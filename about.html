
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>About &#8212; Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="author" title="About these documents" href="#" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Cpu0 Architecture and LLVM Structure" href="llvmstructure.html" />
    <link rel="prev" title="Table of Contents" href="index.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</span></a></h1>
        <h2 class="heading"><span>About</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="index.html">Table of Contents</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="llvmstructure.html">Cpu0 Architecture and LLVM Structure</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="about">
<span id="sec-about"></span><h1>About<a class="headerlink" href="#about" title="Permalink to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#authors" id="id8">Authors</a></p></li>
<li><p><a class="reference internal" href="#contributors" id="id9">Contributors</a></p></li>
<li><p><a class="reference internal" href="#acknowledgments" id="id10">Acknowledgments</a></p></li>
<li><p><a class="reference internal" href="#support" id="id11">Support</a></p></li>
<li><p><a class="reference internal" href="#build-steps" id="id12">Build steps</a></p></li>
<li><p><a class="reference internal" href="#revision-history" id="id13">Revision history</a></p></li>
<li><p><a class="reference internal" href="#licensing" id="id14">Licensing</a></p></li>
<li><p><a class="reference internal" href="#motivation" id="id15">Motivation</a></p></li>
<li><p><a class="reference internal" href="#preface" id="id16">Preface</a></p></li>
<li><p><a class="reference internal" href="#prerequisites" id="id17">Prerequisites</a></p></li>
<li><p><a class="reference internal" href="#outline-of-chapters" id="id18">Outline of Chapters</a></p></li>
</ul>
</nav>
<section id="authors">
<h2><a class="toc-backref" href="#id8" role="doc-backlink">Authors</a><a class="headerlink" href="#authors" title="Permalink to this heading">¶</a></h2>
<figure class="align-right">
<img alt="_images/Author_ChineseName.png" src="_images/Author_ChineseName.png" />
</figure>
<p>Chen Chung-Shu</p>
<blockquote>
<div><p><a class="reference external" href="mailto:gamma_chen&#37;&#52;&#48;yahoo&#46;com&#46;tw">gamma_chen<span>&#64;</span>yahoo<span>&#46;</span>com<span>&#46;</span>tw</a></p>
<p><a class="reference external" href="http://jonathan2251.github.io/ws/en/index.html">http://jonathan2251.github.io/ws/en/index.html</a></p>
</div></blockquote>
</section>
<section id="contributors">
<h2><a class="toc-backref" href="#id9" role="doc-backlink">Contributors</a><a class="headerlink" href="#contributors" title="Permalink to this heading">¶</a></h2>
<p>Anoushe Jamshidi, <a class="reference external" href="mailto:ajamshidi&#37;&#52;&#48;gmail&#46;com">ajamshidi<span>&#64;</span>gmail<span>&#46;</span>com</a>,  Chapters 1, 2, 3 English re-writing and Sphinx tool and format setting.</p>
<p>Chen Wei-Ren, <a class="reference external" href="mailto:chenwj&#37;&#52;&#48;iis&#46;sinica&#46;edu&#46;tw">chenwj<span>&#64;</span>iis<span>&#46;</span>sinica<span>&#46;</span>edu<span>&#46;</span>tw</a>, assisted with text and code formatting.</p>
<p>Chen Zhong-Cheng, who is the author of original cpu0 verilog code.</p>
</section>
<section id="acknowledgments">
<h2><a class="toc-backref" href="#id10" role="doc-backlink">Acknowledgments</a><a class="headerlink" href="#acknowledgments" title="Permalink to this heading">¶</a></h2>
<p>We would like to thank Sean Silva, <a class="reference external" href="mailto:chisophugis&#37;&#52;&#48;gmail&#46;com">chisophugis<span>&#64;</span>gmail<span>&#46;</span>com</a>, for his help,
encouragement, and assistance with the Sphinx document generator.
Without his help, this book would not have been finished and published online.
We also thank those corrections from readers who make the book more accurate.</p>
</section>
<section id="support">
<h2><a class="toc-backref" href="#id11" role="doc-backlink">Support</a><a class="headerlink" href="#support" title="Permalink to this heading">¶</a></h2>
<p>We get the kind help from LLVM development mail list, <a class="reference external" href="mailto:llvmdev&#37;&#52;&#48;cs&#46;uiuc&#46;edu">llvmdev<span>&#64;</span>cs<span>&#46;</span>uiuc<span>&#46;</span>edu</a>,
even we don’t know them. So, our experience is you are not
alone and can get help from the development list members in working with the LLVM
project. Some of them are:</p>
<p>Akira Hatanaka &lt;<a class="reference external" href="mailto:ahatanak&#37;&#52;&#48;gmail&#46;com">ahatanak<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt; in va_arg question answer.</p>
<p>Ulrich Weigand &lt;<a class="reference external" href="mailto:Ulrich&#46;Weigand&#37;&#52;&#48;de&#46;ibm&#46;com">Ulrich<span>&#46;</span>Weigand<span>&#64;</span>de<span>&#46;</span>ibm<span>&#46;</span>com</a>&gt; in AsmParser question answer.</p>
</section>
<section id="build-steps">
<h2><a class="toc-backref" href="#id12" role="doc-backlink">Build steps</a><a class="headerlink" href="#build-steps" title="Permalink to this heading">¶</a></h2>
<p><a class="reference external" href="https://github.com/Jonathan2251/lbd/blob/master/README.md">https://github.com/Jonathan2251/lbd/blob/master/README.md</a></p>
</section>
<section id="revision-history">
<h2><a class="toc-backref" href="#id13" role="doc-backlink">Revision history</a><a class="headerlink" href="#revision-history" title="Permalink to this heading">¶</a></h2>
<p>Version 12.0.18, not released yet.</p>
<dl class="simple">
<dt>Version 12.0.17.3, Released September 26, 2025.</dt><dd><p>gpu.rst: gpu-hw.gv, ogl-pipeline-hw.gv, add subsection
‘Texture Mapping Units (TMUs)’ and add section
‘Unified IR Conversion Flows’.</p>
</dd>
<dt>Version 12.0.17.2, Released September 20, 2025.</dt><dd><p>gpu.rst: add subsection ‘RegLess-style architectures’.</p>
</dd>
<dt>Version 12.0.17.1, Released September 14, 2025.</dt><dd><p>gpu.rst: add ‘SISD, SIMD, and SPMD Pipelines’ in subsection SM (SIMT).
backendstructure.rst: enc.gv.</p>
</dd>
<dt>Version 12.0.17, Released September 7, 2025.</dt><dd><p>c++.rst: Rewrite section ‘C++ Memory Order’.
llvmstructure.rst: Refine the order of sections.
gpu.rst: Refine subsection ‘GPU Hardware Units’.</p>
</dd>
<dt>Version 12.0.16.3, Released Augest 10, 2025.</dt><dd><p>llvmstructure.rst: Modify subsection ‘Why doesn’t the Clang compiler use YACC/LEX tools to parse C++?’.
gpu.rst: Modify subsection ‘SIMT’.</p>
</dd>
<dt>Version 12.0.16.2, Released July 22, 2025.</dt><dd><p>c++.rst: Rewrite section ‘C++ Memory Order’.</p>
</dd>
</dl>
<p>Version 12.0.16.1, Released July 20, 2025.</p>
<blockquote>
<div><p>llvmstructure.rst: add section “BNF Auto-Generated Parsers vs. Handwritten
Parsers”.
c++.rst: Rewrite section ‘C++ Memory Order’.
gpu.rst: section ‘OpenCL, Vulkan and spir-v’, subsections ‘Buffers’.
add ‘Descrete GPU’, ‘Goals’, ‘GLSL vs. C: Feature Overview’ and
‘GLSL Qualifiers by Shader Stage’ in subsection ‘GLSL (GL Shader Language)’.</p>
</div></blockquote>
<p>Version 12.0.16, Released May 24, 2025.</p>
<blockquote>
<div><p>Chatgpt: Refine my English for the input reStructuredText (reST) format I
provide below, and output the corrected version in reST format with each
line no longer than 80 characters.</p>
</div></blockquote>
<p>Version 12.0.15.4, Released September 22, 2024.</p>
<blockquote>
<div><p>backendstructure.rst: Fix Cpu0.td for CH2, Cpu0MCInstLower::Lower() and
printAsm.gv, callFunctions.gv, cpu0-function.gv;
elf.rst: ch3.disas.log, table to explain decodeInstruction();</p>
</div></blockquote>
<p>Version 12.0.15.3, Released September 15, 2024.</p>
<blockquote>
<div><p>gpu.rst: address coalescing, subgroup and trans-steps.png;
backendstructure.rst: printAsm.gv, asm-emit.gv and llvm-data-structure.gv;
elf.rst: disas.gv;
asm.rst: asmFlow.gv;
genobj.rst: getMemEncoding, obj-emit.gv;</p>
</div></blockquote>
<p>Version 12.0.15.2, Released August 18, 2024.</p>
<blockquote>
<div><p>gpu.rst: sm.png, gpu-block-diagram.png, spirv-lang-layers.gv, sycl.png,
subgroup, threadblock.jpg, threads-lanes.png, grid.png.</p>
</div></blockquote>
<p>Version 12.0.15.1, Released May 31, 2024.</p>
<blockquote>
<div><p>gpu.rst: opengl-flow.gv, explanation of Vota, rotation, section Transformation,
graphic-gpu-csf.png.
llvmstructure.rst: DAG for two destination registers.</p>
</div></blockquote>
<p>Version 12.0.15, Released March 16, 2024.</p>
<blockquote>
<div><p>llvmstructure.rst: table: C, llvm-ir and Cpu0.
gpu.rst: glsl-spirv.gv, AMD FreeSync, Fragment definition, comment for
References/01-triangles.cpp, Refine sections and sub-sections.</p>
</div></blockquote>
<p>Version 12.0.14, Released December 30, 2023.</p>
<blockquote>
<div><p>gpu.rst: Table More Desciptive Name and Cuda term in GPU and Desciption,
Table Mapping saxpy code.
gpu.rst: Table More Desciptive Name for Cuda term in Fermi GPU and Desciption.
llvmstructure.rst: table: C, llvm-ir and Cpu0.
lvmstructure.rst: note What and how the ISA of Cpu0 be selected</p>
</div></blockquote>
<p>Version 12.0.13.9, Released November 30, 2023.</p>
<blockquote>
<div><p>gpu.rst: Table More Desciptive Name and Cuda term in GPU and Desciption,
Table Mapping saxpy code.</p>
</div></blockquote>
<p>Version 12.0.13.8, Released November 30, 2023.</p>
<blockquote>
<div><p>gpu.rst: graphic_cpu_gpu.png, additive-colors.</p>
</div></blockquote>
<p>Version 12.0.13.7, Released November 16, 2023.</p>
<blockquote>
<div><p>gpu.rst: 2d-vector-inward, ogl-pointing-outwards and short-rendering-pipeline, Double Buffering and VSync.</p>
</div></blockquote>
<p>Version 12.0.13.6, Released November 13, 2023.</p>
<blockquote>
<div><p>gpu.rst: VAO.</p>
</div></blockquote>
<p>Version 12.0.13.5, Released September 10, 2023.</p>
<blockquote>
<div><p>gpu.rst: Tessellation Shading and clearpage for pdf. llvmstructure.rst:
section CFG and Register Allocation Passes.</p>
</div></blockquote>
<p>Version 12.0.13.4, Released August 26, 2023.</p>
<blockquote>
<div><p>llvm.rst: Sections of Options of llc for debug and Options of opt.</p>
</div></blockquote>
<p>Version 12.0.13.3, Released August 13, 2023.</p>
<blockquote>
<div><p>gpu.rst: animation, graphic-sw-stack.gv and opengl-flow.gv.</p>
</div></blockquote>
<p>Version 12.0.13.2, Released August 7, 2023.</p>
<blockquote>
<div><p>gpu.rst: Subsection of buffers, vao binding.</p>
</div></blockquote>
<p>Version 12.0.13.1, Released July 24, 2023.</p>
<blockquote>
<div><p>gpu.rst: Section of Basic geometry in computer graphics, a x b = -b x a in 2D,
The role of GPU driver. npu.rst: The role of GPU driver.</p>
</div></blockquote>
<p>Version 12.0.13, Released July 15, 2023.</p>
<blockquote>
<div><p>gpu.rst: Section of Basic geometry in computer graphics</p>
</div></blockquote>
<p>Version 12.0.12, Released April 4, 2023.</p>
<blockquote>
<div><p>gpu.rst: refine.</p>
</div></blockquote>
<p>Version 12.0.11, Released Feburary 27, 2023.</p>
<blockquote>
<div><p>README.md.
docs.rst: Note of Sphinx.
c++.rst: Atomic.</p>
</div></blockquote>
<p>Version 12.0.10, Released December 15, 2022.</p>
<blockquote>
<div><p>gpu.rst: Refine Table 43.
ctrl.rst: Refine section “Pipeline architecture”.
Change test_memcpy.ll.
Refine install.rst.</p>
</div></blockquote>
<p>Version 12.0.9, Released November 19, 2022.</p>
<blockquote>
<div><p>gpu.rst: Table 42 Map (Core,Thread) to saxpy and refine section of General purpose GPU.
Move null_pointer.cpp from git/note to lbd/References.</p>
</div></blockquote>
<p>Version 12.0.8, Released November 12, 2022.</p>
<blockquote>
<div><p>install.rst: section Toolchain and Brew install in China.
Section Work flow of genobj.rst.
set-llvm-lit.</p>
</div></blockquote>
<p>Version 12.0.7, Released September 24, 2022.</p>
<blockquote>
<div><p>Atomic, section of Accelerate ML/DL on OpenCL/SYC and refine Makefile and install.rst</p>
</div></blockquote>
<p>Version 12.0.6, Released August 16, 2022.</p>
<blockquote>
<div><p>Fig/backendstructure/class_access_link.puml.
Lock-free of chapter c++ and Vulkan link of gpu.
Install &amp; doc.
Update spirvtoolchain link and grid.png in gpu chapter.</p>
</div></blockquote>
<p>Version 12.0.5, Released February 1, 2022.</p>
<blockquote>
<div><p>Fix regression test.</p>
</div></blockquote>
<p>Version 12.0.4, Released January 22, 2022.</p>
<blockquote>
<div><p>Fix bug: add CMPu, store uses GPROut register to exclude SW registe and
Relocation Record: R_CPU0_HI16/fixup_Cpu0_HI16.</p>
</div></blockquote>
<p>Version 12.0.3, Released January 9, 2022.</p>
<blockquote>
<div><p>Expand memory size of cpu0.v to 0x1000000, 24-bit.
Section LLVM vs GCC in structure.
Add NOR instruction.
Fix bug of SLTu SLTiu, SRA and SRAV in verilog code.</p>
</div></blockquote>
<p>Version 12.0.2, Released December 18, 2021.</p>
<blockquote>
<div><p>Remove regression test cases for large frame of not supporting.</p>
</div></blockquote>
<p>Version 12.0.1, Released December 12, 2021.</p>
<blockquote>
<div><p>Section: More about llvm.
Table: The differences for speedup in architecture of CPU and GPU.
Pipeline diagram and exception handling link.
Update chapter Appendix A.</p>
</div></blockquote>
<p>Version 12.0.0, Released August 11, 2021.</p>
<blockquote>
<div><p>Writing and comment.</p>
</div></blockquote>
<p>Version 3.9.4, Released August 5, 2021.</p>
<blockquote>
<div><p>Writing and comment.</p>
</div></blockquote>
<p>Version 3.9.3, Released March 1, 2020.</p>
<blockquote>
<div><p>Add Appendix C: GPU compiler</p>
</div></blockquote>
<p>Version 3.9.2, Released Feburary 17, 2020.</p>
<blockquote>
<div><p>Add section “Add specific backend intrinsic function”.
Add reasons for regression test.
More phi node explanation.</p>
</div></blockquote>
<p>Version 3.9.1, Released May 11, 2018</p>
<blockquote>
<div><p>Fix tailcall bug.
Fix return-vector.ll run slowly problem, bug from Cpu0ISelLowering.cpp.
Add figure “Tblgen generate files for Cpu0 backend”.
Modify section float and double of Chapter Other data type.
Move storeRegToStack() and loadRegFromStack() from Chapter9_1 to Chapter3_5.
Section DSA of chapter Cpu0 architecture and LLVM structure.</p>
</div></blockquote>
<p>Version 3.9.0, Released November 22, 2016</p>
<blockquote>
<div><p>Porting to llvm 3.9.
Correct writing.</p>
</div></blockquote>
<p>Version 3.7.4, Released December 7, 2016</p>
<blockquote>
<div><p>Change bal instruction from with delay slot to without delay slot.</p>
</div></blockquote>
<p>Version 3.7.3, Released July 20, 2016</p>
<blockquote>
<div><p>Refine code-block according sphinx lexers.
Add search this book.</p>
</div></blockquote>
<p>Version 3.7.2, Released June 29, 2016</p>
<blockquote>
<div><p>Add Verilog delay slot simulation.
Explain “tablegen(” in CMakeLists.txt.
Correct typing.
Add lbdex/install_llvm/*.sh for installation.
Upgrade sphinx to 1.4.4.</p>
</div></blockquote>
<p>Version 3.7.1, Released November 7, 2015</p>
<blockquote>
<div><p>Remove EM_CPU0_EL.
Add subsection Caller and callee saved registers.
Add IR blockaddress and indirectbr support.
Correct tglobaladdr, tblockaddress, tjumptable and tglobaltlsaddr of
Cpu0InstrInfo.td.
Add stacksave and stackrestore support.
Add sub-section frameaddress, returnaddress and eh.return support of chapter
Function call.
Match Mips 3.7 style.
Add bswap in Chapter Function call.
Add section “Vector type (SIMD) support” of Chapter “Other data type”.
Add section “Long branch support” of Chapter “Control flow statements”.
Add sub-section “eh.dwarf intrinsic” of Chapter Function call.
Change display “ret $rx” to “jr $rx” where $rx is not $lr.
Move sub-section Caller and callee saved registers.
Add sub-sections Live in and live out register.
Add Phi node.
Replace ch3-proepilog.ll with ch3_largeframe.cpp.
Remove DecodeCMPInstruction().
Re-organize testing ch4_2_1.cpp, ch4_2_2.cpp and ch9_4.cpp.
Fix dynamic alloca bug.
Move Cpu0AnalyzeImmediate.cpp and related functions from Chapter3_4 to Chapter3_5.
Rename input files.</p>
</div></blockquote>
<p>Version 3.7.0, Released September 24, 2015</p>
<blockquote>
<div><p>Porting to lld 3.7.
Change tricore_llvm.pdf web link.
Add C++ atomic to regression test.</p>
</div></blockquote>
<p>Version 3.6.4, Released July 15, 2015</p>
<blockquote>
<div><p>Add C++ atomic support.</p>
</div></blockquote>
<p>Version 3.6.3, Released May 25, 2015</p>
<blockquote>
<div><p>Correct typing.</p>
</div></blockquote>
<p>Version 3.6.2, Released May 3, 2015</p>
<blockquote>
<div><p>Write Appendix B.
Split chapter Appendix B from Appendix A.
Move some test from lbt to lbd.
Remove warning in build Cpu0 code.</p>
</div></blockquote>
<p>Version 3.6.1, Released March 22, 2015</p>
<blockquote>
<div><p>Add Cpu0 instructions ROLV and RORV.</p>
</div></blockquote>
<p>Version 3.6.0, Released March 9, 2015</p>
<blockquote>
<div><p>Update Appendix A for llvm 3.6.
Replace cpp with ll for appearing in document.
Move chapter lld, optimization, library to
<a class="reference external" href="https://github.com/Jonathan2251/lbt.git">https://github.com/Jonathan2251/lbt.git</a>.</p>
</div></blockquote>
<p>Version 3.5.9, Released February 2, 2015</p>
<blockquote>
<div><p>Fix bug of 64 bits shift.
Fix global address error by replacing addiu with ori.
Change encode of “cmp $sw, $3, $2” from 0x10320000 to 0x10f32000.</p>
</div></blockquote>
<p>Version 3.5.8, Released December 27, 2014</p>
<blockquote>
<div><p>Correct typing.
Fix typing error for update lbdex/src/modify/src/ of install.rst.
Add libsoftfloat/compiler-rt and libc/avr-libc-1.8.1.
Add LLVM-VPO in chapter Optimization.</p>
</div></blockquote>
<p>Version 3.5.7, Released December 1, 2014</p>
<blockquote>
<div><p>Fix over 16-bits frame prologue/epilogue error from 3.5.3.
Call convention ABI S32 is enabled by option.
Change from ADD to ADDu in copyPhysReg() of Cpu0SEInstrInfo.cpp.
Add asm directive .weak back which exists in 3.5.3.</p>
</div></blockquote>
<p>Version 3.5.6, Released November 18, 2014</p>
<blockquote>
<div><p>Remove SWI and IRET instructions.
Add Cpu0SetChapter.h for ex-build-test.sh.
Correct typing.
Fix thread variable error come from version 3.5.3 in static mode.
Add sub-section “Cpu0 backend machine ID and relocation records” of Chapter 2.</p>
</div></blockquote>
<p>Version 3.5.5, Released November 11, 2014</p>
<blockquote>
<div><p>Rename SPR to C0R.
Add ISR simulation.</p>
</div></blockquote>
<p>Version 3.5.4, Released November 6, 2014</p>
<blockquote>
<div><p>Adjust chapter 9 sections.
Fix .cprestore bug.
Re-organize sections.
Add sub-section “Why not using ADD instead of SUB?” in chapter 2.
Add overflow control option to use ADD and SUB instructions.</p>
</div></blockquote>
<p>Version 3.5.3, Released October 29, 2014</p>
<blockquote>
<div><p>Merge Cpu0 example code into one copy and it can be config by Cpu0Config.h.</p>
</div></blockquote>
<p>Version 3.5.2, Released October 3, 2014</p>
<blockquote>
<div><p>Move R_CPU0_32 from type of non-relocation record to type ofrelocation record.
Correct logic error for setgt of BrcondPatsSlt of Cpu0InstrInfo.td.</p>
</div></blockquote>
<p>Version 3.5.1, Released October 1, 2014</p>
<blockquote>
<div><p>Add move alias instruction for addu $reg, $zero.
Add cpu cycles count in verilog.
Fix ISD::SIGN_EXTEND_INREG error in other types beside i1.
Support DAG op br_jt and DAG node JumpTable.</p>
</div></blockquote>
<p>Version 3.5.0, Released September 05, 2014</p>
<blockquote>
<div><p>Issue NOP in delay slot.</p>
</div></blockquote>
<p>Version 3.4.8, Released August 29, 2014</p>
<blockquote>
<div><p>Add reason that set endian swap in memory module.
Add presentation files.</p>
</div></blockquote>
<p>Version 3.4.7, Released August 22, 2014</p>
<blockquote>
<div><p>Fix wrapper_pic for cmov.ll.
Add shift operations 64 bits support.
Fix wrapper_pic for ch8_5.cpp.
Add section thread of chapter 14.
Add section Motivation of chapter about.
Support little endian for cpu0 verilog.
Move ch8_5.cpp test from Chapter Run backend to Chapter lld since it need lld
linker.
Support both big endian and little endian in cpu0 Verilog, elf2hex and lld.
Make branch release_34_7.</p>
</div></blockquote>
<p>Version 3.4.6, Released July 26, 2014</p>
<blockquote>
<div><p>Add Chapter 15, optimization.
Correct typing.
Add Chapter 14, C++.
Fix bug of generating cpu032II instruction in dynamic_linker.cpp.</p>
</div></blockquote>
<p>Version 3.4.5, Released June 30, 2014</p>
<blockquote>
<div><p>Correct typing.</p>
</div></blockquote>
<p>Version 3.4.4, Released June 24, 2014</p>
<blockquote>
<div><p>Correct typing.
Add the reason of use SSA form.
Move sections LLVM Code Generation Sequence, DAG and Instruction Selection
from Chapter 3 to Chapter 2.</p>
</div></blockquote>
<p>Version 3.4.3, Released March 31, 2014</p>
<blockquote>
<div><p>Fix Disassembly bug for GPROut register class.
Adjust Chapters.
Remove hand copy Table of tblgen in AsmParser.</p>
</div></blockquote>
<p>Version 3.4.2, Released February 9, 2014</p>
<blockquote>
<div><p>Add ch12_2.cpp for slt instruction explanation and fix bug in Cpu0InstrInfo.cpp.
Correct typing.
Move Cpu0 Status Register from Number 20 to Number 10.
Fix llc -mcpu option problem.
Update example code build shell script.
Add condition move instruction.
Fix bug of branch pattern match in Cpu0InstrInfo.td.</p>
</div></blockquote>
<p>Version 3.4.1, Released January 18, 2014</p>
<blockquote>
<div><p>Add ch9_4.cpp to lld test.
Fix the wrong reference in lbd/lib/Target/Cpu0 code.
inlineasm.
First instruction jmp X, where X changed from _Z5startv to start.
Correct typing.</p>
</div></blockquote>
<p>Version 3.4.0, Released January 9, 2014</p>
<blockquote>
<div><p>Porting to llvm 3.4 release.</p>
</div></blockquote>
<p>Version 3.3.14, Released January 4, 2014</p>
<blockquote>
<div><p>lld support on iMac.
Correct typing.</p>
</div></blockquote>
<p>Version 3.3.13, Released December 27, 2013</p>
<blockquote>
<div><p>Update section Install sphinx on install.rst.
Add Fig/llvmstructure/cpu0_arch.odp.</p>
</div></blockquote>
<p>Version 3.3.12, Released December 25, 2013</p>
<blockquote>
<div><p>Correct typing error.
Adjust Example Code.
Add section Data operands DAGs of backendstructure.rst.
Fix bug in instructions lb and lh of cpu0.v.
Fix bug in itoa.cpp.
Add ch7_2_2.cpp for othertype.rst.
Add AsmParser reference web.</p>
</div></blockquote>
<p>Version 3.3.11, Released December 11, 2013</p>
<blockquote>
<div><p>Add Figure Code generation and execution flow in about.rst.
Update backendstructure.rst.
Correct otherinst.rst.
Decoration.
Correct typing error.</p>
</div></blockquote>
<p>Version 3.3.10, Released December 5, 2013</p>
<blockquote>
<div><p>Correct typing error.
Dynamic linker in lld.rst.
Correct errors came from old version of example code.
lld.rst.</p>
</div></blockquote>
<p>Version 3.3.9, Released November 22, 2013</p>
<blockquote>
<div><p>Add LLD introduction and Cpu0 static linker document in lld.rst.
Fix the plt bug in elf2hex.h for dynamic linker.</p>
</div></blockquote>
<p>Version 3.3.8, Released November 19, 2013</p>
<blockquote>
<div><p>Fix the reference file missing for make gh-page.</p>
</div></blockquote>
<p>Version 3.3.7, Released November 17, 2013</p>
<blockquote>
<div><p>lld.rst documentation.
Add cpu032I and cpu032II in <cite>llc -mcpu</cite>.
Reference only for Chapter12_2.</p>
</div></blockquote>
<p>Version 3.3.6, Released November 8, 2013</p>
<blockquote>
<div><p>Move example code from github to dropbox since the name is not work for
download example code.</p>
</div></blockquote>
<p>Version 3.3.5, Released November 7, 2013</p>
<blockquote>
<div><p>Split the elf2hex code from modiified llvm-objdump.cpp to elf2hex.h.
Fix bug for tail call setting in LowerCall().
Fix bug for LowerCPLOAD().
Update elf.rst.
Fix typing error.
Add dynamic linker support.
Merge cpu0 Chapter12_1 and Chapter12_2 code into one, and identify each of
them by -mcpu=cpu0I and -mcpu=cpu0II.
cpu0II.
Update lld.rst for static linker.
Change the name of example code from LLVMBackendTutorialExampleCode to lbdex.</p>
</div></blockquote>
<p>Version 3.3.4, Released September 21, 2013</p>
<blockquote>
<div><p>Fix Chapter Global variables error for LUi instructions and the material move
to Chapter Other data type.
Update regression test items.</p>
</div></blockquote>
<p>Version 3.3.3, Released September 20, 2013</p>
<blockquote>
<div><p>Add Chapter othertype</p>
</div></blockquote>
<p>Version 3.3.2, Released September 17, 2013</p>
<blockquote>
<div><p>Update example code.
Fix bug sext_inreg.
Fix llvm-objdump.cpp bug to support global variable of .data.
Update install.rst to run on llvm 3.3.</p>
</div></blockquote>
<p>Version 3.3.1, Released September 14, 2013</p>
<blockquote>
<div><p>Add load bool type in chapter 6.
Fix chapter 4 error.
Add interrupt function in cpu0i.v.
Fix bug in alloc() support of Chapter 8 by adding code of spill $fp register.
Add JSUB texternalsym for memcpy function call of llvm auto reference.
Rename cpu0i.v to cpu0s.v.
Modify itoa.cpp.
Cpu0 of lld.</p>
</div></blockquote>
<p>Version 3.3.0, Released July 13, 2013</p>
<blockquote>
<div><p>Add Table: C operator ! corresponding IR of .bc and IR of DAG and Table: C
operator ! corresponding IR of Type-legalized selection DAG and Cpu0
instructions. Add explanation in section Full support %.
Add Table: Chapter 4 operators.
Add Table: Chapter 3 .bc IR instructions.
Rewrite Chapter 5 Global variables.
Rewrite section Handle $gp register in PIC addressing mode.
Add Large Frame Stack Pointer support.
Add dynamic link section in elf.rst.
Re-oganize Chapter 3.
Re-oganize Chapter 8.
Re-oganize Chapter 10.
Re-oganize Chapter 11.
Re-oganize Chapter 12.
Fix bug that ret not $lr register.
Porting to LLVM 3.3.</p>
</div></blockquote>
<p>Version 3.2.15, Released June 12, 2013</p>
<blockquote>
<div><p>Porting to llvm 3.3.
Rewrite section Support arithmetic instructions of chapter Adding arithmetic
and local pointer support with the table adding.
Add two sentences in Preface.
Add <cite>llc -debug-pass</cite> in section LLVM Code Generation Sequence.
Remove section Adjust cpu0 instructions.
Remove section Use cpu0 official LDI instead of ADDiu of Appendix-C.</p>
</div></blockquote>
<p>Version 3.2.14, Released May 24, 2013</p>
<blockquote>
<div><p>Fix example code disappeared error.</p>
</div></blockquote>
<p>Version 3.2.13, Released May 23, 2013</p>
<blockquote>
<div><p>Add sub-section “Setup llvm-lit on iMac” of Appendix A.
Replace some code-block with literalinclude in *.rst.
Add Fig 9 of chapter Backend structure.
Add section Dynamic stack allocation support of chapter Function call.
Fix bug of Cpu0DelUselessJMP.cpp.
Fix cpu0 instruction table errors.</p>
</div></blockquote>
<p>Version 3.2.12, Released March 9, 2013</p>
<blockquote>
<div><p>Add section “Type of char and short int” of chapter
“Global variables, structs and arrays, other type”.</p>
</div></blockquote>
<p>Version 3.2.11, Released March 8, 2013</p>
<blockquote>
<div><p>Fix bug in generate elf of chapter “Backend Optimization”.</p>
</div></blockquote>
<p>Version 3.2.10, Released February 23, 2013</p>
<blockquote>
<div><p>Add chapter “Backend Optimization”.</p>
</div></blockquote>
<p>Version 3.2.9, Released February 20, 2013</p>
<blockquote>
<div><p>Correct the “Variable number of arguments” such as sum_i(int amount, …)
errors.</p>
</div></blockquote>
<p>Version 3.2.8, Released February 20, 2013</p>
<blockquote>
<div><p>Add section llvm-objdump -t -r.</p>
</div></blockquote>
<p>Version 3.2.7, Released February 14, 2013</p>
<blockquote>
<div><p>Add chapter Run backend.
Add Icarus Verilog tool installation in Appendix A.</p>
</div></blockquote>
<p>Version 3.2.6, Released February 4, 2013</p>
<blockquote>
<div><p>Update CMP instruction implementation.
Add llvm-objdump section.</p>
</div></blockquote>
<p>Version 3.2.5, Released January 27, 2013</p>
<blockquote>
<div><p>Add “LLVMBackendTutorialExampleCode/llvm3.1”.
Add  section “Structure type support”.
Change reference from Figure title to Figure number.</p>
</div></blockquote>
<dl class="simple">
<dt>Version 3.2.4, Released January 17, 2013</dt><dd><p>Update for LLVM 3.2.
Change title (book name) from “Write An LLVM Backend Tutorial For Cpu0” to
“Tutorial: Creating an LLVM Backend for the Cpu0 Architecture”.</p>
</dd>
</dl>
<p>Version 3.2.3, Released January 12, 2013</p>
<blockquote>
<div><p>Add chapter “Porting to LLVM 3.2”.</p>
</div></blockquote>
<p>Version 3.2.2, Released January 10, 2013</p>
<blockquote>
<div><p>Add section “Full support %” and section “Verify DIV for operator %”.</p>
</div></blockquote>
<p>Version 3.2.1, Released January 7, 2013</p>
<blockquote>
<div><p>Add Footnote for references.
Reorganize chapters (Move bottom part of chapter “Global variable” to
chapter “Other instruction”; Move section “Translate into obj file” to
new chapter “Generate obj file”.
Fix errors in Fig/otherinst/2.png and Fig/otherinst/3.png.</p>
</div></blockquote>
<p>Version 3.2.0, Released January 1, 2013</p>
<blockquote>
<div><p>Add chapter Function.
Move Chapter “Installing LLVM and the Cpu0 example code” from beginning to
Appendix A.
Add subsection “Install other tools on Linux”.
Add chapter ELF.</p>
</div></blockquote>
<p>Version 3.1.2, Released December 15, 2012</p>
<blockquote>
<div><p>Fix section 6.1 error by add “def : Pat&lt;(brcond RC:$cond, bb:$dst),
(JNEOp (CMPOp RC:$cond, ZEROReg), bb:$dst)&gt;;” in last pattern.
Modify section 5.5
Fix bug Cpu0InstrInfo.cpp SW to ST.
Correct LW to LD; LB to LDB; SB to STB.</p>
</div></blockquote>
<p>Version 3.1.1, Released November 28, 2012</p>
<blockquote>
<div><p>Add Revision history.
Correct ldi instruction error (replace ldi instruction with addiu from the
beginning and in the all example code).
Move ldi instruction change from section of “Adjust cpu0 instruction and
support type of local variable pointer” to Section ”CPU0
processor architecture”.
Correct some English &amp; typing errors.</p>
</div></blockquote>
</section>
<section id="licensing">
<h2><a class="toc-backref" href="#id14" role="doc-backlink">Licensing</a><a class="headerlink" href="#licensing" title="Permalink to this heading">¶</a></h2>
<p><a class="reference external" href="http://llvm.org/docs/DeveloperPolicy.html#license">http://llvm.org/docs/DeveloperPolicy.html#license</a></p>
</section>
<section id="motivation">
<h2><a class="toc-backref" href="#id15" role="doc-backlink">Motivation</a><a class="headerlink" href="#motivation" title="Permalink to this heading">¶</a></h2>
<p>My intention in writing this book stems from my curiosity about how a simple
and robotic CPU ISA, along with an LLVM-based software toolchain, can be
designed and implemented.</p>
<table class="docutils align-default" id="id6">
<caption><span class="caption-number">Table 1 </span><span class="caption-text">Number of lines in source code (including spaces and comments) for Cpu0</span><a class="headerlink" href="#id6" title="Permalink to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Components</p></th>
<th class="head"><p>Number of lines</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>llvm</p></td>
<td><p>15,000</p></td>
</tr>
<tr class="row-odd"><td><p>llvm-objdump</p></td>
<td><p>8</p></td>
</tr>
<tr class="row-even"><td><p>elf2hex</p></td>
<td><p>765</p></td>
</tr>
<tr class="row-odd"><td><p>verilog</p></td>
<td><p>600</p></td>
</tr>
<tr class="row-even"><td><p>lld</p></td>
<td><p>140</p></td>
</tr>
<tr class="row-odd"><td><p>clang</p></td>
<td><p>500</p></td>
</tr>
<tr class="row-even"><td><p>compiler-rt’s builtin</p></td>
<td><p>5 (abort.c)</p></td>
</tr>
<tr class="row-odd"><td><p>total</p></td>
<td><p>17,018</p></td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><p>Though the LLVM backend’s source code can be ported from another backend, it
still requires a lot of thought and effort to do so, making the process not
entirely easy.</p></li>
</ul>
<p>We all learned computer knowledge in school through conceptual books.
Concepts provide an effective way to understand the big picture.
However, when developing real, complex systems, we often find that the
concepts from school or books are insufficient or lack detail.</p>
<p>A compiler is a highly complex system. Traditionally, students learn about
compilers conceptually and complete homework assignments using yacc/lex tools
to translate parts of C or another high-level language into an intermediate
representation (IR) or assembly. This approach helps them understand parsing
and tool applications.</p>
<p>On the other hand, compiler engineers who graduate from school often face real
market CPUs and complex specifications. Due to market demands, there exist
multiple CPU series and ABIs (Application Binary Interfaces) to handle.
Furthermore, for performance reasons, real compiler backend implementations
are too complex to serve as learning materials, even for a CPU with a single
ABI.</p>
<p>This book develops a compiler backend alongside a simple, educational CPU
called Cpu0. It includes implementations of a compiler backend, linker,
llvm-objdump, elf2hex, and the Verilog source code for Cpu0’s instruction set.
We provide readers with full source code to compile C/C++ programs and observe
how they run on the Cpu0 machine implemented in Verilog. Through this
educational CPU, readers gain insight into compiler backends, linkers, system
tools, and CPU design. In contrast, real-world CPUs and compilers are too
complex for a single person to fully understand or develop alone.</p>
<p>From my observations, LLVM is favored by some software engineers over GCC for
two reasons. The first is political, as LLVM uses the BSD license
<a class="footnote-reference brackets" href="#llvm-license" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#richard" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>. The second is technical, as LLVM follows the
three-tier compiler software structure and leverages C++ object-oriented
programming. GCC was originally written in C and only adopted C++ nearly 20
years later <a class="footnote-reference brackets" href="#wiki-gcc" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>. Some speculate that GCC adopted C++ simply because
LLVM did.</p>
<p>I learned object-oriented programming in C++ during my studies. After reading
books on “Design Patterns,” “C++/STL,” and “Object-Oriented Design,” I
realized that C is easier to trace, whereas C++ enables the creation of
reusable software units, known as objects. If a programmer has a strong
understanding of design patterns, C++ provides better reusability and
modifiability. A book I read on “system languages” defined software quality
based on readability, modifiability, reusability, and performance.
Object-oriented programming was introduced to manage large and complex
software projects.</p>
<p>Given that compilers and operating systems are undeniably complex, why do GCC
and Linux still avoid using C++? <a class="footnote-reference brackets" href="#wiki-cpp" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a> This is one reason I chose to
develop a backend under LLVM rather than GCC.</p>
</section>
<section id="preface">
<h2><a class="toc-backref" href="#id16" role="doc-backlink">Preface</a><a class="headerlink" href="#preface" title="Permalink to this heading">¶</a></h2>
<p>The LLVM Compiler Infrastructure provides a versatile framework for creating
new backends. Once you familiarize yourself with this structure, creating a
new backend should not be too difficult. However, the available backend
documentation is fairly high level and omits many details. This tutorial
provides step-by-step instructions for writing a new backend for a new target
architecture from scratch.</p>
<p>We will use the Cpu0 architecture as an example to build our backend. Cpu0 is
a simple RISC architecture designed for educational purposes. More information
about Cpu0, including its instruction set, is available here <a class="footnote-reference brackets" href="#cpu0-web" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a>. The
Cpu0 example code referenced in this book can be found
<a class="reference external" href="http://jonathan2251.github.io/lbd/lbdex.tar.gz">http://jonathan2251.github.io/lbd/lbdex.tar.gz</a>. As you progress through
each chapter, you will incrementally build the backend’s functionality.</p>
<p>Since Cpu0 is a simple RISC CPU for educational purposes, the LLVM backend code
for it is also simple and easy to learn. Additionally, Cpu0 provides Verilog
source code that can be run on a PC or FPGA platform, as explained in the
chapter “Verify Backend on Verilog Simulator.” To illustrate backend design,
we carefully design C/C++ programs for each newly added function in every
chapter. Through these example codes, readers can understand which LLVM
intermediate representations (IRs) the backend transforms and how these IRs
correspond to the original C/C++ code.</p>
<p>This tutorial initially used the LLVM 3.1 MIPS backend as a reference and was
later synchronized with LLVM 3.5 MIPS at version 3.5.3. Based on our
experience, referencing and synchronizing with an existing backend helps
enhance features and fix bugs. By comparing differences across versions, you
can leverage the LLVM development team’s efforts to improve your backend.</p>
<p>Since Cpu0 is an educational architecture, it lacks key documentation needed
for compiler development, such as an Application Binary Interface (ABI). To
implement our backend, we use the MIPS ABI as a reference. You may find it
helpful to familiarize yourself with relevant parts of the MIPS ABI as you
progress through this tutorial.</p>
<p>This document also serves as a tutorial for toolchain development for a new
CPU architecture. Many programmers graduate with knowledge of compilers and
computer architecture but lack professional experience in compiler or CPU
design. This document introduces these engineers to toolchain programming and
CPU design using the LLVM infrastructure—without requiring the purchase of any
software or hardware. A computer is the only device needed.</p>
<p>Finally, this book is not a conceptual compiler textbook. It is intended for
readers interested in extending a compiler toolchain to support a new CPU
based on LLVM. Programming on Linux does not require understanding every
detail of the operating system. For example, when developing a USB device
driver for Linux, a programmer studies the USB specification, the Linux USB
subsystem, and the common device driver model and APIs. Similarly, this book
focuses on practical implementation rather than compiler theory.</p>
<p>In the same way, when extending functions in a large software project like the
LLVM umbrella project, you should focus on achieving your goal and ignore
irrelevant details.</p>
<p>Trying to understand every line of source code in detail is unrealistic if
your project involves extending a well-defined software structure. It only
makes sense when rewriting the entire software structure.</p>
<p>Of course, if more books or documents about LLVM backend development were
available, readers would have more opportunities to understand LLVM by
studying them.</p>
</section>
<section id="prerequisites">
<h2><a class="toc-backref" href="#id17" role="doc-backlink">Prerequisites</a><a class="headerlink" href="#prerequisites" title="Permalink to this heading">¶</a></h2>
<p>Readers should be comfortable with the C++ language and Object-Oriented
Programming concepts. LLVM is developed in C++ and follows a modular design,
allowing various classes to be adapted and reused efficiently.</p>
<p>Having a conceptual understanding of how compilers work is beneficial. If you
have implemented compilers before, you will likely have no trouble following
this tutorial. Since this tutorial builds an LLVM backend step by step, we will
introduce important concepts as needed.</p>
<p>This tutorial references the following materials. We highly recommend reading
these documents to gain a deeper understanding of the topics covered:</p>
<p><a class="reference external" href="http://www.aosabook.org/en/llvm.html">The Architecture of Open Source Applications Chapter on LLVM</a></p>
<p><a class="reference external" href="http://llvm.org/docs/CodeGenerator.html">LLVM’s Target-Independent Code Generation documentation</a></p>
<p><a class="reference external" href="http://llvm.org/docs/TableGenFundamentals.html">LLVM’s TableGen Fundamentals documentation</a></p>
<p><a class="reference external" href="http://llvm.org/docs/WritingAnLLVMBackend.html">LLVM’s Writing an LLVM Compiler Backend documentation</a></p>
<p><a class="reference external" href="https://opus4.kobv.de/opus4-fau/files/1108/tricore_llvm.pdf">Description of the Tricore LLVM Backend</a></p>
<p><a class="reference external" href="http://www.linux-mips.org/pub/linux/mips/doc/ABI/mipsabi.pdf">Mips ABI document</a></p>
</section>
<section id="outline-of-chapters">
<h2><a class="toc-backref" href="#id18" role="doc-backlink">Outline of Chapters</a><a class="headerlink" href="#outline-of-chapters" title="Permalink to this heading">¶</a></h2>
<figure class="align-center" id="id7">
<span id="about-f1"></span><a class="reference internal image-reference" href="_images/lbd_and_lbt.png"><img alt="_images/lbd_and_lbt.png" src="_images/lbd_and_lbt.png" style="width: 899.0px; height: 261.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 2 </span><span class="caption-text">Code generation and execution flow</span><a class="headerlink" href="#id7" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>The top part of <a class="reference internal" href="#about-f1"><span class="std std-numref">Fig. 2</span></a> represents the workflow and software packages
involved in generating and executing a computer program. IR stands for
Intermediate Representation.</p>
<p>The middle part illustrates this book’s workflow. Except for Clang, the other
components need to be extended for a new backend development. Although the Cpu0
backend extends Clang as well, it uses the MIPS ABI and can utilize MIPS-Clang.
This book implements the sections highlighted in yellow. The green sections,
which include lld and elf2hex for the Cpu0 backend, can be found at:
<a class="reference external" href="http://jonathan2251.github.io/lbt/index.html">http://jonathan2251.github.io/lbt/index.html</a>.</p>
<p>The hex format is an ASCII file representation that uses characters ‘0’ to ‘9’
and ‘a’ to ‘f’ to encode hexadecimal values, as the Verilog machine reads it as
an input file.</p>
<p>This book includes 10,000 lines of source code covering:</p>
<ol class="arabic simple">
<li><p>Step-by-step creation of an LLVM backend for the Cpu0, from Chapters 2 to 11.</p></li>
<li><p>Cpu0 Verilog source code, discussed in Chapter 12.</p></li>
</ol>
<p>With this code, readers can generate Cpu0 machine code through the Cpu0 LLVM
backend compiler and observe how it executes on a computer. However, execution
is only possible for code that does not contain global variables or relocation
records requiring linker handling. The book is also available in PDF and EPUB
formats online.</p>
<p>This tutorial is aimed at LLVM backend developers but is not intended for
experts. It serves as a valuable resource for those familiar with compiler
concepts and computer architecture who wish to learn how to extend the LLVM
toolchain to support a new CPU.</p>
<p><a class="reference internal" href="llvmstructure.html#sec-llvmstructure"><span class="std std-ref">Cpu0 Architecture and LLVM Structure</span></a>:</p>
<p>This chapter introduces the Cpu0 architecture, provides a high-level overview
of LLVM, and explains how Cpu0 will be targeted in an LLVM backend. It guides
you through the initial steps of backend development, including target
description (TD), CMake setup, and target registration. By the end of this
chapter, around 750 lines of source code will be added.</p>
<p><a class="reference internal" href="backendstructure.html#sec-backendstructure"><span class="std std-ref">Backend structure</span></a>:</p>
<p>This chapter outlines the structure of an LLVM backend using UML diagrams. It
continues the development of the Cpu0 backend, adding thousands of lines of
source code. Many of these lines are common across LLVM backends, regardless of
the target architecture.</p>
<p>By the end of this chapter, the Cpu0 LLVM backend will support fewer than ten
instructions and be capable of generating some initial assembly output.</p>
<p><a class="reference internal" href="otherinst.html#sec-addingmoresupport"><span class="std std-ref">Arithmetic and Logic Instructions</span></a>:</p>
<p>Over ten C operators and their corresponding LLVM IR instructions are introduced
in this chapter.</p>
<p>A few hundred lines of source code, mostly in <cite>.td</cite> Target Description files,
are added. With these lines of source code, the backend can now translate the
<strong>+, -, *, /, &amp;, |, ^, &lt;&lt;, &gt;&gt;, !</strong> and <strong>%</strong> C operators into the appropriate
Cpu0 assembly code.</p>
<p>Usage of the <code class="docutils literal notranslate"><span class="pre">llc</span></code> debug option and <strong>Graphviz</strong> as a debug tool are
introduced in this chapter.</p>
<p><a class="reference internal" href="genobj.html#sec-genobjfiles"><span class="std std-ref">Generating object files</span></a>:</p>
<p>Object file generation support for the Cpu0 backend is added in this chapter,
as the Target Registration structure is introduced.</p>
<p>Based on the LLVM structure, the Cpu0 backend can generate big-endian and
little-endian ELF object files with minimal effort.</p>
<p><a class="reference internal" href="globalvar.html#sec-globalvars"><span class="std std-ref">Global Variables</span></a>:</p>
<p>Global variable handling is added in this chapter. Cpu0 supports both PIC and
static addressing modes. Both addressing modes are explained as their
functionalities are implemented.</p>
<p><a class="reference internal" href="othertype.html#sec-othertypesupport"><span class="std std-ref">Other data type</span></a>:</p>
<p>In addition to the <cite>int</cite> type, other data types such as pointers, <cite>char</cite>,
<cite>bool</cite>, <cite>long long</cite>, structures, and arrays are added in this chapter.</p>
<p><a class="reference internal" href="ctrlflow.html#sec-controlflow"><span class="std std-ref">Control flow statements</span></a>:</p>
<p>Support for flow control statements, such as <strong>if, else, while, for, goto,
switch,</strong> and <strong>case</strong>, as well as both a simple optimization software pass and
hardware instructions for control statement optimization, are discussed in this
chapter.</p>
<p><a class="reference internal" href="funccall.html#sec-funccall"><span class="std std-ref">Function call</span></a>:</p>
<p>This chapter details the implementation of function calls in the Cpu0 backend.
The stack frame, handling of incoming and outgoing arguments, and their
corresponding standard LLVM functions are introduced.</p>
<p><a class="reference internal" href="elf.html#sec-elf"><span class="std std-ref">ELF Support</span></a>:</p>
<p>This chapter details Cpu0 support for the well-known ELF object file format.
The ELF format and binutils tools are not part of LLVM but are introduced.
This chapter explains how to use ELF tools to verify and analyze the object
files created by the Cpu0 backend.</p>
<p>The disassembly command <code class="docutils literal notranslate"><span class="pre">llvm-objdump</span> <span class="pre">-d</span></code> support for Cpu0 is added in the
last section of this chapter.</p>
<p><a class="reference internal" href="asm.html#sec-asm"><span class="std std-ref">Assembler</span></a>:</p>
<p>Support for translating hand-written assembly language into object files under
the LLVM infrastructure.</p>
<p><a class="reference internal" href="c%2B%2B.html#sec-c"><span class="std std-ref">C++ support</span></a>:</p>
<p>Support C++ language features. It’s under working.</p>
<p><a class="reference internal" href="verilog.html#sec-verilog"><span class="std std-ref">Verify backend on Verilog simulator</span></a>:</p>
<p>First, create the Cpu0 virtual machine using the Verilog language with the
Icarus tool. Using this tool, feed the hex file generated by <code class="docutils literal notranslate"><span class="pre">llvm-objdump</span></code>
to the Cpu0 virtual machine and observe the execution results on a PC.</p>
<p><a class="reference internal" href="install.html#sec-appendix-installing"><span class="std std-ref">Appendix A: Getting Started: Installing LLVM and the Cpu0 Example Code</span></a>:</p>
<p>This section details how to set up the LLVM source code, development tools,
and environment configuration for macOS and Linux platforms.</p>
<p><a class="reference internal" href="doc.html#sec-appendix-doc"><span class="std std-ref">Appendix B: Cpu0 document and test</span></a>:</p>
<p>This book uses Sphinx to generate PDF and EPUB document formats.
Details on how to install the necessary tools, generate these documents,
and perform regression testing for the Cpu0 backend are included.</p>
<aside class="footnote brackets" id="llvm-license" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://llvm.org/docs/DeveloperPolicy.html#license">http://llvm.org/docs/DeveloperPolicy.html#license</a></p>
</aside>
<aside class="footnote brackets" id="richard" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://www.phoronix.com/scan.php?page=news_item&amp;px=MTU4MjA">http://www.phoronix.com/scan.php?page=news_item&amp;px=MTU4MjA</a></p>
</aside>
<aside class="footnote brackets" id="wiki-gcc" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">3</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://en.wikipedia.org/wiki/GNU_Compiler_Collection">http://en.wikipedia.org/wiki/GNU_Compiler_Collection</a></p>
</aside>
<aside class="footnote brackets" id="wiki-cpp" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">4</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://en.wikipedia.org/wiki/C%2B%2B">http://en.wikipedia.org/wiki/C%2B%2B</a></p>
</aside>
<aside class="footnote brackets" id="cpu0-web" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">5</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://ccckmit.wikidot.com/ocs:cpu0">http://ccckmit.wikidot.com/ocs:cpu0</a></p>
</aside>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="index.html">Table of Contents</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="llvmstructure.html">Cpu0 Architecture and LLVM Structure</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Chen Chung-Shu.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.0.2.
    </div>
  </body>
</html>