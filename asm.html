
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Assembler &#8212; Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="C++ support" href="c%2B%2B.html" />
    <link rel="prev" title="ELF Support" href="elf.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</span></a></h1>
        <h2 class="heading"><span>Assembler</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="elf.html">ELF Support</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="c%2B%2B.html">C++ support</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="assembler">
<span id="sec-asm"></span><h1>Assembler<a class="headerlink" href="#assembler" title="Permalink to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#asmparser-support" id="id12">AsmParser support</a></p>
<ul>
<li><p><a class="reference internal" href="#code-structure-explanation" id="id13">Code structure explanation</a></p></li>
<li><p><a class="reference internal" href="#code-list-and-some-detail-functions-explanation" id="id14">Code list and some detail functions explanation</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#inline-assembly" id="id15">Inline assembly</a></p></li>
</ul>
</nav>
<p>This chapter include the assembly programming support in Cpu0 backend.</p>
<p>When it comes to assembly language programming, there are two type of
writting in C/C++ as follows,</p>
<p class="rubric">ordinary assembly</p>
<div class="highlight-cpp-objdump notranslate"><div class="highlight"><pre><span></span><span class="k">asm</span><span class="p">(</span><span class="s">&quot;ld       $2, 8($sp)&quot;</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">inline assembly</p>
<div class="highlight-cpp-objdump notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">15</span><span class="p">;</span><span class="w"></span>

<span class="n">__asm__</span><span class="w"> </span><span class="nf">__volatile__</span><span class="p">(</span><span class="s">&quot;addu %0,%1,%2&quot;</span><span class="w"></span>
<span class="w">                     </span><span class="o">:</span><span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="w"> </span><span class="c1">// 5</span>
<span class="w">                     </span><span class="o">:</span><span class="s">&quot;r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">(</span><span class="n">bar</span><span class="p">)</span><span class="w"></span>
<span class="w">                     </span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>In llvm, the first is supported by LLVM AsmParser, and the second is inline
assembly handler.
With AsmParser and inline assembly support in Cpu0 backend, we can hand-code
the assembly language in C/C++ file and translate it into obj (elf format).</p>
<section id="asmparser-support">
<h2><a class="toc-backref" href="#id12" role="doc-backlink">AsmParser support</a><a class="headerlink" href="#asmparser-support" title="Permalink to this heading">¶</a></h2>
<p>This section lists all the AsmParser code for Cpu0 backend with only a few
explanation. Please refer here <a class="footnote-reference brackets" href="#id4" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> for more AsmParser explanation.</p>
<p>Run Chapter10_1/ with ch11_1.cpp will get the following error message.</p>
<p class="rubric">lbdex/input/ch11_1.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">asm</span><span class="p">(</span><span class="s2">&quot;ld	$2, 8($sp)&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;st	$0, 4($sp)&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;addiu $3,	$ZERO, 0&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;add $v1, $at, $v0&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;sub $3, $2, $3&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;mul $2, $1, $3&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;div $3, $2&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;divu $2, $3&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;and $2, $1, $3&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;or $3, $1, $2&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;xor $1, $2, $3&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;mult $4, $3&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;multu $3, $2&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;mfhi $3&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;mflo $2&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;mthi $2&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;mtlo $2&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;sra $2, $2, 2&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;rol $2, $1, 3&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;ror $3, $3, 4&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;shl $2, $2, 2&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;shr $2, $3, 5&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;cmp $sw, $2, $3&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;jeq $sw, 20&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;jne $sw, 16&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;jlt $sw, -20&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;jle $sw, -16&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;jgt $sw, -4&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;jge $sw, -12&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;jsub 0x000010000&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;jr $4&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;ret $lr&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;jalr $t9&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;li $3, 0x00700000&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;la $3, 0x00800000($6)&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;la $3, 0x00900000&quot;</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>clang -c ch11_1.cpp -emit-llvm -o
<span class="go">ch11_1.bc</span>
<span class="gp">JonathantekiiMac:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/bin/llc
<span class="go">-march=cpu0 -relocation-model=pic -filetype=obj ch11_1.bc</span>
<span class="go">-o ch11_1.cpu0.o</span>
<span class="go">LLVM ERROR: Inline asm not supported by this streamer because we don&#39;t have</span>
<span class="go">an asm parser for this target</span>
</pre></div>
</div>
<p>Since we havn’t implemented Cpu0 assembler, it has the error message as above.
The Cpu0 can translate LLVM IR into assembly and obj directly, but it cannot
translate hand-code assembly instructions into obj.</p>
<section id="code-structure-explanation">
<h3><a class="toc-backref" href="#id13" role="doc-backlink">Code structure explanation</a><a class="headerlink" href="#code-structure-explanation" title="Permalink to this heading">¶</a></h3>
<p>Directory AsmParser handle the assembly to obj translation.
The assembling Data Flow Diagram (DFD) as <a class="reference internal" href="#asm-f1"><span class="std std-numref">Fig. 45</span></a> and <a class="reference internal" href="#asm-f2"><span class="std std-numref">Fig. 46</span></a>.</p>
<figure class="align-default" id="id7">
<span id="asm-f1"></span><div class="graphviz"><img src="_images/graphviz-83981439aa0a8967cd12b525616450b7fd014f33.png" alt="// Free usage license, author: Chung-Shu Chen 陳鍾樞
// dot -tPng asmDfd.gv -oasmDfd.png

digraph G {
  rankdir=LR;
  subgraph cluster_0 {
    style=filled;
//    label = &quot;Assemble flow&quot;;
    node [style=filled,color=white]; user, asmParser, encoder, elfobj;
    user -&gt; asmParser [ label = &quot;cpu0 assembly&quot; ];
    asmParser -&gt; encoder [ label = &quot;opcode ID &amp; operand IDs&quot; ];
    encoder -&gt; elfobj [ label = &quot;binary&quot; ];
    color=lightgrey
  }
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 45 </span><span class="caption-text">Assemble flow</span><a class="headerlink" href="#id7" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-default" id="id8">
<span id="asm-f2"></span><div class="graphviz"><img src="_images/graphviz-4342827cb3d69f667c4384c52efb234b91270d15.png" alt="// Free usage license, author: Chung-Shu Chen 陳鍾樞
// dot -Tpng asmDfdEx.gv -oasmDfdEx.png

digraph G {
  rankdir=LR;
  subgraph cluster_2 {
    style=filled;
//    label = &quot;Assemble flow, for instance: add $v1, $v0, $at&quot;;
    subgraph clusterA {
      label = &quot;asmParser&quot;;
      node [style=filled,color=white]; ParseInstruction [label=&quot;ParseInstruction()&quot;];
      node [style=filled,color=white]; MatchAndEmitInstruction [label=&quot;MatchAndEmitInstruction()&quot;];
      ParseInstruction -&gt; MatchAndEmitInstruction [ label = &quot;Operands:\n (Cpu0::ADD, Cpu0::V1,\n Cpu0::AT, Cpu0::V0)&quot; ];
    }
    subgraph clusterB {
      label = &quot;encoder: Cpu0MCCodeEmitter.cpp&quot;;
      node [style=filled,color=white]; encodeInstruction [label=&quot;encodeInstruction()&quot;];
    }
    MatchAndEmitInstruction -&gt; encodeInstruction [ label = &quot;Inst.Opcode=\nCpu0::ADD,\nInst.Operand[0] = V1,\nInst.Operand[1] = AT,\nInst.Operand[2] = V0&quot; ];
    color=lightgrey
  }
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 46 </span><span class="caption-text">Assemble flow, for instance: add $v1, $v0, $at</span><a class="headerlink" href="#id8" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>Given an example of assembly instruction “add $v1, $v0, $at”, llvm AsmParser
kernel call backend ParseInstruction() of Cpu0AsmParser.cpp when it
parses and recognises that the first token at the beginning of line is identifier.
ParseInstruction() parses one assembly instruction, creates Operands and
return to llvm AsmParser. Then AsmParser calls backend MatchAndEmitInstruction()
to set Opcode and Operands to MCInst, then encoder can encode binary instruction
from MCInst with the information come from Cpu0InstrInfo.td which includes binary
value for Opcode ID and Operand IDs of the instruction.</p>
<p>List the key functions and data structure of MatchAndEmitInstruction() and
encodeInstruction(), explaining in comments which begin with ///.</p>
<p class="rubric">llvm/build/lib/Target/Cpu0/Cpu0GenAsmMatcher.inc</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="nc">InstructionConversionKind</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">Convert__Reg1_0__Reg1_1__Reg1_2</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">Convert__Reg1_0__Reg1_1__Imm1_2</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="n">CVT_NUM_SIGNATURES</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="p">}</span><span class="w"> </span><span class="c1">// end anonymous namespace</span>

<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">MatchEntry</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">Mnemonic</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">Opcode</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">ConvertFn</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">RequiredFeatures</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">Classes</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">StringRef</span><span class="w"> </span><span class="nf">getMnemonic</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">StringRef</span><span class="p">(</span><span class="n">MnemonicTable</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Mnemonic</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">MnemonicTable</span><span class="p">[</span><span class="n">Mnemonic</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">MatchEntry</span><span class="w"> </span><span class="n">MatchTable0</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="cm">/* add */</span><span class="p">,</span><span class="w"> </span><span class="n">Cpu0</span><span class="o">::</span><span class="n">ADD</span><span class="p">,</span><span class="w"> </span><span class="n">Convert__Reg1_0__Reg1_1__Reg1_2</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">MCK_CPURegs</span><span class="p">,</span><span class="w"> </span><span class="n">MCK_CPURegs</span><span class="p">,</span><span class="w"> </span><span class="n">MCK_CPURegs</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="cm">/* addiu */</span><span class="p">,</span><span class="w"> </span><span class="n">Cpu0</span><span class="o">::</span><span class="n">ADDiu</span><span class="p">,</span><span class="w"> </span><span class="n">Convert__Reg1_0__Reg1_1__Imm1_2</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">MCK_CPURegs</span><span class="p">,</span><span class="w"> </span><span class="n">MCK_CPURegs</span><span class="p">,</span><span class="w"> </span><span class="n">MCK_Imm</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kt">unsigned</span><span class="w"> </span><span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="w"></span>
<span class="nf">MatchInstructionImpl</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">OperandVector</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Operands</span><span class="p">,</span><span class="w"></span>
<span class="w">                     </span><span class="n">MCInst</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ErrorInfo</span><span class="p">,</span><span class="w"></span>
<span class="w">                     </span><span class="kt">bool</span><span class="w"> </span><span class="n">matchingInlineAsm</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">VariantID</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Find the appropriate table for this asm variant.</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">MatchEntry</span><span class="w"> </span><span class="o">*</span><span class="n">Start</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">End</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">VariantID</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">default</span><span class="o">:</span><span class="w"> </span><span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;invalid variant!&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">0</span><span class="p">:</span><span class="w"> </span><span class="n">Start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">MatchTable0</span><span class="p">);</span><span class="w"> </span><span class="n">End</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">MatchTable0</span><span class="p">);</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Search the table.</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">MnemonicRange</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">equal_range</span><span class="p">(</span><span class="n">Start</span><span class="p">,</span><span class="w"> </span><span class="n">End</span><span class="p">,</span><span class="w"> </span><span class="n">Mnemonic</span><span class="p">,</span><span class="w"> </span><span class="n">LessOpcode</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MatchEntry</span><span class="w"> </span><span class="o">*</span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MnemonicRange</span><span class="p">.</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">ie</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MnemonicRange</span><span class="p">.</span><span class="n">second</span><span class="p">;</span><span class="w"></span>
<span class="w">       </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">ie</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="c1">// We have selected a definite instruction, convert the parsed</span>
<span class="w">    </span><span class="c1">// operands into the appropriate MCInst.</span>

<span class="w">    </span><span class="c1">/// For instance ADD , V1, AT, V0</span>
<span class="w">    </span><span class="c1">/// MnemonicRange.first = &amp;MatchTable0[0]</span>
<span class="w">    </span><span class="c1">/// MnemonicRange.second = &amp;MatchTable0[1]</span>
<span class="w">    </span><span class="c1">/// it.ConvertFn = Convert__Reg1_0__Reg1_1__Reg1_2</span>

<span class="w">    </span><span class="n">convertToMCInst</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">ConvertFn</span><span class="p">,</span><span class="w"> </span><span class="n">Inst</span><span class="p">,</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">Opcode</span><span class="p">,</span><span class="w"> </span><span class="n">Operands</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">ConversionTable</span><span class="p">[</span><span class="n">CVT_NUM_SIGNATURES</span><span class="p">][</span><span class="mi">9</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Convert__Reg1_0__Reg1_1__Reg1_2</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">CVT_95_Reg</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">CVT_95_Reg</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">CVT_95_Reg</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">CVT_Done</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Convert__Reg1_0__Reg1_1__Imm1_2</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">CVT_95_Reg</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">CVT_95_Reg</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">CVT_95_addImmOperands</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">CVT_Done</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="c1">/// When kind = Convert__Reg1_0__Reg1_1__Reg1_2, ConversionTable[Kind] is equal to CVT_95_Reg</span>
<span class="c1">/// For Operands[1], Operands[2], Operands[3] do the following:</span>
<span class="c1">///   static_cast&lt;Cpu0Operand&amp;&gt;(*Operands[OpIdx]).addRegOperands(Inst, 1);</span>
<span class="c1">/// Since p = 0, 2, 4, then OpIdx = 1, 2, 3 when OpIdx=*(p+1).</span>
<span class="c1">/// Since, Operands[1] = V1, Operands[2] = AT, Operands[3] = V0,</span>
<span class="c1">///   for &quot;ADD , V1, AT, V0&quot; which created by ParseInstruction().</span>
<span class="c1">/// Inst.Opcode = ADD, Inst.Operand[0] = V1, Inst.Operand[1] = AT,</span>
<span class="c1">///   Inst.Operand[2] = V0.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="w"></span>
<span class="nf">convertToMCInst</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">Kind</span><span class="p">,</span><span class="w"> </span><span class="n">MCInst</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">Opcode</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="n">OperandVector</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Operands</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">Kind</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">CVT_NUM_SIGNATURES</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="s">&quot;Invalid signature!&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">Converter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ConversionTable</span><span class="p">[</span><span class="n">Kind</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">OpIdx</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">Inst</span><span class="p">.</span><span class="n">setOpcode</span><span class="p">(</span><span class="n">Opcode</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Converter</span><span class="p">;</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span><span class="w"> </span><span class="n">p</span><span class="o">+=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">OpIdx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">default</span><span class="o">:</span><span class="w"> </span><span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;invalid conversion entry!&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">CVT_Reg</span><span class="p">:</span><span class="w"></span>
<span class="w">      </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Cpu0Operand</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">Operands</span><span class="p">[</span><span class="n">OpIdx</span><span class="p">]).</span><span class="n">addRegOperands</span><span class="p">(</span><span class="n">Inst</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_1/AsmParser/Cpu0AsmParser.cpp</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// For &quot;ADD , V1, AT, V0&quot;, ParseInstruction() set Operands[1].Reg.RegNum = V1,</span>
<span class="c1">///   Operands[2].Reg.RegNum = AT, ..., by Cpu0Operand::CreateReg(RegNo, S,</span>
<span class="c1">///   Parser.getTok().getLoc()) in calling ParseOperand().</span>
<span class="c1">/// So, after (*Operands[1..3]).addRegOperands(Inst, 1),</span>
<span class="c1">///   Inst.Opcode = ADD, Inst.Operand[0] = V1, Inst.Operand[1] = AT,</span>
<span class="c1">///   Inst.Operand[2] = V0.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Cpu0Operand</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">MCParsedAsmOperand</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">addRegOperands</span><span class="p">(</span><span class="n">MCInst</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">N</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="s">&quot;Invalid number of operands!&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">Inst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">createReg</span><span class="p">(</span><span class="n">getReg</span><span class="p">()));</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">getReg</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="p">((</span><span class="n">Kind</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">k_Register</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="s">&quot;Invalid access!&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Reg</span><span class="p">.</span><span class="n">RegNum</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_1/MCTargetDesc/Cpu0MCCodeEmitter.cpp</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="n">Cpu0MCCodeEmitter</span><span class="o">::</span><span class="w"></span>
<span class="nf">encodeInstruction</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MCInst</span><span class="w"> </span><span class="o">&amp;</span><span class="n">MI</span><span class="p">,</span><span class="w"> </span><span class="n">raw_ostream</span><span class="w"> </span><span class="o">&amp;</span><span class="n">OS</span><span class="p">,</span><span class="w"></span>
<span class="w">                  </span><span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCFixup</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Fixups</span><span class="p">,</span><span class="w"></span>
<span class="w">                  </span><span class="k">const</span><span class="w"> </span><span class="n">MCSubtargetInfo</span><span class="w"> </span><span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">Binary</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getBinaryCodeForInstr</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span><span class="w"> </span><span class="n">Fixups</span><span class="p">,</span><span class="w"> </span><span class="n">STI</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="n">EmitInstruction</span><span class="p">(</span><span class="n">Binary</span><span class="p">,</span><span class="w"> </span><span class="n">Size</span><span class="p">,</span><span class="w"> </span><span class="n">OS</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">llvm/build/lib/Target/Cpu0/Cpu0GenMCCodeEmitter.inc</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">uint64_t</span><span class="w"> </span><span class="nf">Cpu0MCCodeEmitter::getBinaryCodeForInstr</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MCInst</span><span class="w"> </span><span class="o">&amp;</span><span class="n">MI</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCFixup</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Fixups</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">MCSubtargetInfo</span><span class="w"> </span><span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">InstBits</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="n">UINT64_C</span><span class="p">(</span><span class="mi">318767104</span><span class="p">),</span><span class="w">      </span><span class="c1">// ADD  /// 318767104=0x13000000</span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">opcode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MI</span><span class="p">.</span><span class="n">getOpcode</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">opcode</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">Cpu0</span><span class="o">::</span><span class="no">ADD</span><span class="p">:</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">      </span><span class="c1">// op: ra</span>
<span class="w">      </span><span class="n">op</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getMachineOpValue</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span><span class="w"> </span><span class="n">MI</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">Fixups</span><span class="p">,</span><span class="w"> </span><span class="n">STI</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">Value</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="p">(</span><span class="n">op</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">UINT64_C</span><span class="p">(</span><span class="mi">15</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="c1">// op: rb</span>
<span class="w">      </span><span class="n">op</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getMachineOpValue</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span><span class="w"> </span><span class="n">MI</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">Fixups</span><span class="p">,</span><span class="w"> </span><span class="n">STI</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">Value</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="p">(</span><span class="n">op</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">UINT64_C</span><span class="p">(</span><span class="mi">15</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="c1">// op: rc</span>
<span class="w">      </span><span class="n">op</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getMachineOpValue</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span><span class="w"> </span><span class="n">MI</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="n">Fixups</span><span class="p">,</span><span class="w"> </span><span class="n">STI</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">Value</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="p">(</span><span class="n">op</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">UINT64_C</span><span class="p">(</span><span class="mi">15</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">12</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">Value</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<figure class="align-default" id="id9">
<span id="asm-f3"></span><div class="graphviz"><img src="_images/graphviz-b8e184fba6bf28f4ebe4fd9c01b3b07dc4dc548d.png" alt="// Free usage license, author: Chung-Shu Chen 陳鍾樞
// dot -Tpng asmDfdEx2.gv -oasmDfdEx2.png

digraph G {
  rankdir=LR;
  subgraph cluster_2 {
    style=filled;
//    label = &quot;Data flow in MatchAndEmitInstruction(), for instance: add $v1, $v0, $at&quot;;
    subgraph clusterA {
      label = &quot;MatchAndEmitInstruction()&quot;;
      node [style=filled,color=white]; MatchTable0 [label=&quot;Start = std::\nbegin(MatchTable0);\nEnd = std::end\n(MatchTable0);&quot;];
      node [style=filled,color=white]; equal_range [label=&quot;std::equal_range(Start, End, \nMnemonic, LessOpcode());&quot;];
      node [style=filled,color=white]; convertToMCInst [label=&quot;convertToMCInst\n(Kind, ...)&quot;];
      MatchTable0 -&gt; equal_range [ label = &quot;Start,\nEnd&quot; ];
      equal_range -&gt; convertToMCInst [ label = &quot;Kind=\nConvert__Reg1_0__\nReg1_1__Reg1_2&quot; ];
    }
    color=lightgrey
  }
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 47 </span><span class="caption-text">Data flow in MatchAndEmitInstruction(), for instance: add $v1, $v0, $at”</span><a class="headerlink" href="#id9" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-default" id="id10">
<span id="asm-f4"></span><div class="graphviz"><img src="_images/graphviz-3f9ce164f96f1d09a1c4d5fe60e50c87dc9a85ad.png" alt="// Free usage license, author: Chung-Shu Chen 陳鍾樞
// dot -Tpng asmDfdEx3.gv -oasmDfdEx3.png

digraph G {
  rankdir=LR;
  subgraph cluster_2 {
    style=filled;
//    label = &quot;Data flow in and between MatchAndEmitInstruction() and encodeInstruction(), for instance: add $v1, $v0, $at&quot;;
    subgraph clusterA {
      label = &quot;MatchAndEmitInstruction()&quot;;
      node [style=filled,color=white]; convertToMCInst [label=&quot;convertToMCInst()&quot;];
    }
    subgraph clusterB {
      label = &quot;encodeInstruction()&quot;;
      node [style=filled,color=white]; getBinaryCodeForInstr [label=&quot;getBinaryCodeForInstr()&quot;];
      node [style=filled,color=white]; EmitInstruction [label=&quot;EmitInstruction()&quot;];
      getBinaryCodeForInstr -&gt; EmitInstruction [ label = &quot;Binary&quot; ];
    }
    convertToMCInst -&gt; getBinaryCodeForInstr [ label = &quot;Inst.Opcode = ADD,\nInst.Operand[0] = V1,\nInst.Operand[1] = AT,\nInst.Operand[2] = V0&quot; ];
    color=lightgrey
  }
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 48 </span><span class="caption-text">Data flow in and between MatchAndEmitInstruction() and encodeInstruction(), for instance: add $v1, $v0, $at</span><a class="headerlink" href="#id10" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>MatchTable0 include all the possibile combinations of opcode and operands type.
Even the assembly instruction of user input may pass Cpu0AsmParser in syntax
check, the MatchAndEmitInstruction() still can be fail. For example, instruction
“asm(“move $3, $2);” can pass but “asm(“move $3, $2, $1”);” will fail.</p>
</section>
<section id="code-list-and-some-detail-functions-explanation">
<h3><a class="toc-backref" href="#id14" role="doc-backlink">Code list and some detail functions explanation</a><a class="headerlink" href="#code-list-and-some-detail-functions-explanation" title="Permalink to this heading">¶</a></h3>
<p>The Chapter11_1/ include AsmParser implementation as follows,</p>
<p class="rubric">lbdex/chapters/Chapter11_1/AsmParser/Cpu0AsmParser.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>//===-- Cpu0AsmParser.cpp - Parse Cpu0 assembly to MCInst instructions ----===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#include &quot;Cpu0.h&quot;
#if CH &gt;= CH11_1

#include &quot;MCTargetDesc/Cpu0MCExpr.h&quot;
#include &quot;MCTargetDesc/Cpu0MCTargetDesc.h&quot;
#include &quot;Cpu0RegisterInfo.h&quot;
#include &quot;llvm/ADT/APInt.h&quot;
#include &quot;llvm/ADT/StringSwitch.h&quot;
#include &quot;llvm/MC/MCContext.h&quot;
#include &quot;llvm/MC/MCExpr.h&quot;
#include &quot;llvm/MC/MCInst.h&quot;
#include &quot;llvm/MC/MCInstBuilder.h&quot;
#include &quot;llvm/MC/MCParser/MCAsmLexer.h&quot;
#include &quot;llvm/MC/MCParser/MCParsedAsmOperand.h&quot;
#include &quot;llvm/MC/MCParser/MCTargetAsmParser.h&quot;
#include &quot;llvm/MC/MCStreamer.h&quot;
#include &quot;llvm/MC/MCSubtargetInfo.h&quot;
#include &quot;llvm/MC/MCSymbol.h&quot;
#include &quot;llvm/MC/MCParser/MCAsmLexer.h&quot;
#include &quot;llvm/MC/MCParser/MCParsedAsmOperand.h&quot;
#include &quot;llvm/MC/MCValue.h&quot;
#include &quot;llvm/Support/Debug.h&quot;
#include &quot;llvm/Support/MathExtras.h&quot;
#include &quot;llvm/Support/TargetRegistry.h&quot;

using namespace llvm;

#define DEBUG_TYPE &quot;cpu0-asm-parser&quot;

namespace {
class Cpu0AssemblerOptions {
public:
  Cpu0AssemblerOptions():
    reorder(true), macro(true) {
  }

  bool isReorder() {return reorder;}
  void setReorder() {reorder = true;}
  void setNoreorder() {reorder = false;}

  bool isMacro() {return macro;}
  void setMacro() {macro = true;}
  void setNomacro() {macro = false;}

private:
  bool reorder;
  bool macro;
};
}

namespace {
class Cpu0AsmParser : public MCTargetAsmParser {
  MCAsmParser &amp;Parser;
  Cpu0AssemblerOptions Options;


#define GET_ASSEMBLER_HEADER
#include &quot;Cpu0GenAsmMatcher.inc&quot;

  bool MatchAndEmitInstruction(SMLoc IDLoc, unsigned &amp;Opcode,
                               OperandVector &amp;Operands, MCStreamer &amp;Out,
                               uint64_t &amp;ErrorInfo,
                               bool MatchingInlineAsm) override;

  bool ParseRegister(unsigned &amp;RegNo, SMLoc &amp;StartLoc, SMLoc &amp;EndLoc) override;

  OperandMatchResultTy tryParseRegister(unsigned &amp;RegNo, SMLoc &amp;StartLoc,
                                        SMLoc &amp;EndLoc) override;

  bool ParseInstruction(ParseInstructionInfo &amp;Info, StringRef Name,
                        SMLoc NameLoc, OperandVector &amp;Operands) override;

  bool ParseDirective(AsmToken DirectiveID) override;

  OperandMatchResultTy parseMemOperand(OperandVector &amp;);

  bool ParseOperand(OperandVector &amp;Operands, StringRef Mnemonic);

  int tryParseRegister(StringRef Mnemonic);

  bool tryParseRegisterOperand(OperandVector &amp;Operands,
                               StringRef Mnemonic);

  bool needsExpansion(MCInst &amp;Inst);

  void expandInstruction(MCInst &amp;Inst, SMLoc IDLoc,
                         SmallVectorImpl&lt;MCInst&gt; &amp;Instructions);
  void expandLoadImm(MCInst &amp;Inst, SMLoc IDLoc,
                     SmallVectorImpl&lt;MCInst&gt; &amp;Instructions);
  void expandLoadAddressImm(MCInst &amp;Inst, SMLoc IDLoc,
                            SmallVectorImpl&lt;MCInst&gt; &amp;Instructions);
  void expandLoadAddressReg(MCInst &amp;Inst, SMLoc IDLoc,
                            SmallVectorImpl&lt;MCInst&gt; &amp;Instructions);
  bool reportParseError(StringRef ErrorMsg);

  bool parseMemOffset(const MCExpr *&amp;Res);
  bool parseRelocOperand(const MCExpr *&amp;Res);

  const MCExpr *evaluateRelocExpr(const MCExpr *Expr, StringRef RelocStr);

  bool parseDirectiveSet();

  bool parseSetAtDirective();
  bool parseSetNoAtDirective();
  bool parseSetMacroDirective();
  bool parseSetNoMacroDirective();
  bool parseSetReorderDirective();
  bool parseSetNoReorderDirective();

  int matchRegisterName(StringRef Symbol);

  int matchRegisterByNumber(unsigned RegNum, StringRef Mnemonic);

  unsigned getReg(int RC,int RegNo);

public:
  Cpu0AsmParser(const MCSubtargetInfo &amp;sti, MCAsmParser &amp;parser,
                const MCInstrInfo &amp;MII, const MCTargetOptions &amp;Options)
    : MCTargetAsmParser(Options, sti, MII), Parser(parser) {
    // Initialize the set of available features.
    setAvailableFeatures(ComputeAvailableFeatures(getSTI().getFeatureBits()));
  }

  MCAsmParser &amp;getParser() const { return Parser; }
  MCAsmLexer &amp;getLexer() const { return Parser.getLexer(); }

};
}

namespace {

/// Cpu0Operand - Instances of this class represent a parsed Cpu0 machine
/// instruction.
class Cpu0Operand : public MCParsedAsmOperand {

  enum KindTy {
    k_Immediate,
    k_Memory,
    k_Register,
    k_Token
  } Kind;

public:
  Cpu0Operand(KindTy K) : MCParsedAsmOperand(), Kind(K) {}

  struct Token {
    const char *Data;
    unsigned Length;
  };
  struct PhysRegOp {
    unsigned RegNum; /// Register Number
  };
  struct ImmOp {
    const MCExpr *Val;
  };
  struct MemOp {
    unsigned Base;
    const MCExpr *Off;
  };

  union {
    struct Token Tok;
    struct PhysRegOp Reg;
    struct ImmOp Imm;
    struct MemOp Mem;
  };

  SMLoc StartLoc, EndLoc;

public:
  void addRegOperands(MCInst &amp;Inst, unsigned N) const {
    assert(N == 1 &amp;&amp; &quot;Invalid number of operands!&quot;);
    Inst.addOperand(MCOperand::createReg(getReg()));
  }

  void addExpr(MCInst &amp;Inst, const MCExpr *Expr) const{
    // Add as immediate when possible.  Null MCExpr = 0.
    if (Expr == 0)
      Inst.addOperand(MCOperand::createImm(0));
    else if (const MCConstantExpr *CE = dyn_cast&lt;MCConstantExpr&gt;(Expr))
      Inst.addOperand(MCOperand::createImm(CE-&gt;getValue()));
    else
      Inst.addOperand(MCOperand::createExpr(Expr));
  }

  void addImmOperands(MCInst &amp;Inst, unsigned N) const {
    assert(N == 1 &amp;&amp; &quot;Invalid number of operands!&quot;);
    const MCExpr *Expr = getImm();
    addExpr(Inst,Expr);
  }

  void addMemOperands(MCInst &amp;Inst, unsigned N) const {
    assert(N == 2 &amp;&amp; &quot;Invalid number of operands!&quot;);

    Inst.addOperand(MCOperand::createReg(getMemBase()));

    const MCExpr *Expr = getMemOff();
    addExpr(Inst,Expr);
  }

  bool isReg() const override { return Kind == k_Register; }
  bool isImm() const override { return Kind == k_Immediate; }
  bool isToken() const override { return Kind == k_Token; }
  bool isMem() const override { return Kind == k_Memory; }

  StringRef getToken() const {
    assert(Kind == k_Token &amp;&amp; &quot;Invalid access!&quot;);
    return StringRef(Tok.Data, Tok.Length);
  }

  unsigned getReg() const override {
    assert((Kind == k_Register) &amp;&amp; &quot;Invalid access!&quot;);
    return Reg.RegNum;
  }

  const MCExpr *getImm() const {
    assert((Kind == k_Immediate) &amp;&amp; &quot;Invalid access!&quot;);
    return Imm.Val;
  }

  unsigned getMemBase() const {
    assert((Kind == k_Memory) &amp;&amp; &quot;Invalid access!&quot;);
    return Mem.Base;
  }

  const MCExpr *getMemOff() const {
    assert((Kind == k_Memory) &amp;&amp; &quot;Invalid access!&quot;);
    return Mem.Off;
  }

  static std::unique_ptr&lt;Cpu0Operand&gt; CreateToken(StringRef Str, SMLoc S) {
    auto Op = std::make_unique&lt;Cpu0Operand&gt;(k_Token);
    Op-&gt;Tok.Data = Str.data();
    Op-&gt;Tok.Length = Str.size();
    Op-&gt;StartLoc = S;
    Op-&gt;EndLoc = S;
    return Op;
  }

  /// Internal constructor for register kinds
  static std::unique_ptr&lt;Cpu0Operand&gt; CreateReg(unsigned RegNum, SMLoc S, 
                                                SMLoc E) {
    auto Op = std::make_unique&lt;Cpu0Operand&gt;(k_Register);
    Op-&gt;Reg.RegNum = RegNum;
    Op-&gt;StartLoc = S;
    Op-&gt;EndLoc = E;
    return Op;
  }

  static std::unique_ptr&lt;Cpu0Operand&gt; CreateImm(const MCExpr *Val, SMLoc S, SMLoc E) {
    auto Op = std::make_unique&lt;Cpu0Operand&gt;(k_Immediate);
    Op-&gt;Imm.Val = Val;
    Op-&gt;StartLoc = S;
    Op-&gt;EndLoc = E;
    return Op;
  }

  static std::unique_ptr&lt;Cpu0Operand&gt; CreateMem(unsigned Base, const MCExpr *Off,
                                 SMLoc S, SMLoc E) {
    auto Op = std::make_unique&lt;Cpu0Operand&gt;(k_Memory);
    Op-&gt;Mem.Base = Base;
    Op-&gt;Mem.Off = Off;
    Op-&gt;StartLoc = S;
    Op-&gt;EndLoc = E;
    return Op;
  }

  /// getStartLoc - Get the location of the first token of this operand.
  SMLoc getStartLoc() const override { return StartLoc; }
  /// getEndLoc - Get the location of the last token of this operand.
  SMLoc getEndLoc() const override { return EndLoc; }

  void print(raw_ostream &amp;OS) const override {
    switch (Kind) {
    case k_Immediate:
      OS &lt;&lt; &quot;Imm&lt;&quot;;
      OS &lt;&lt; *Imm.Val;
      OS &lt;&lt; &quot;&gt;&quot;;
      break;
    case k_Memory:
      OS &lt;&lt; &quot;Mem&lt;&quot;;
      OS &lt;&lt; Mem.Base;
      OS &lt;&lt; &quot;, &quot;;
      OS &lt;&lt; *Mem.Off;
      OS &lt;&lt; &quot;&gt;&quot;;
      break;
    case k_Register:
      OS &lt;&lt; &quot;Register&lt;&quot; &lt;&lt; Reg.RegNum &lt;&lt; &quot;&gt;&quot;;
      break;
    case k_Token:
      OS &lt;&lt; Tok.Data;
      break;
    }
  }
};
}

void printCpu0Operands(OperandVector &amp;Operands) {
  for (size_t i = 0; i &lt; Operands.size(); i++) {
    Cpu0Operand* op = static_cast&lt;Cpu0Operand*&gt;(&amp;*Operands[i]);
    assert(op != nullptr);
    LLVM_DEBUG(dbgs() &lt;&lt; &quot;&lt;&quot; &lt;&lt; *op &lt;&lt; &quot;&gt;&quot;);
  }
  LLVM_DEBUG(dbgs() &lt;&lt; &quot;\n&quot;);
}

//@1 {
bool Cpu0AsmParser::needsExpansion(MCInst &amp;Inst) {

  switch(Inst.getOpcode()) {
    case Cpu0::LoadImm32Reg:
    case Cpu0::LoadAddr32Imm:
    case Cpu0::LoadAddr32Reg:
      return true;
    default:
      return false;
  }
}

void Cpu0AsmParser::expandInstruction(MCInst &amp;Inst, SMLoc IDLoc,
                        SmallVectorImpl&lt;MCInst&gt; &amp;Instructions){
  switch(Inst.getOpcode()) {
    case Cpu0::LoadImm32Reg:
      return expandLoadImm(Inst, IDLoc, Instructions);
    case Cpu0::LoadAddr32Imm:
      return expandLoadAddressImm(Inst,IDLoc,Instructions);
    case Cpu0::LoadAddr32Reg:
      return expandLoadAddressReg(Inst,IDLoc,Instructions);
    }
}
//@1 }

void Cpu0AsmParser::expandLoadImm(MCInst &amp;Inst, SMLoc IDLoc,
                                  SmallVectorImpl&lt;MCInst&gt; &amp;Instructions){
  MCInst tmpInst;
  const MCOperand &amp;ImmOp = Inst.getOperand(1);
  assert(ImmOp.isImm() &amp;&amp; &quot;expected immediate operand kind&quot;);
  const MCOperand &amp;RegOp = Inst.getOperand(0);
  assert(RegOp.isReg() &amp;&amp; &quot;expected register operand kind&quot;);

  int ImmValue = ImmOp.getImm();
  tmpInst.setLoc(IDLoc);
  if ( 0 &lt;= ImmValue &amp;&amp; ImmValue &lt;= 65535) {
    // for 0 &lt;= j &lt;= 65535.
    // li d,j =&gt; ori d,$zero,j
    tmpInst.setOpcode(Cpu0::ORi);
    tmpInst.addOperand(MCOperand::createReg(RegOp.getReg()));
    tmpInst.addOperand(
              MCOperand::createReg(Cpu0::ZERO));
    tmpInst.addOperand(MCOperand::createImm(ImmValue));
    Instructions.push_back(tmpInst);
  } else if ( ImmValue &lt; 0 &amp;&amp; ImmValue &gt;= -32768) {
    // for -32768 &lt;= j &lt; 0.
    // li d,j =&gt; addiu d,$zero,j
    tmpInst.setOpcode(Cpu0::ADDiu); //TODO:no ADDiu64 in td files?
    tmpInst.addOperand(MCOperand::createReg(RegOp.getReg()));
    tmpInst.addOperand(
              MCOperand::createReg(Cpu0::ZERO));
    tmpInst.addOperand(MCOperand::createImm(ImmValue));
    Instructions.push_back(tmpInst);
  } else {
    // for any other value of j that is representable as a 32-bit integer.
    // li d,j =&gt; lui d,hi16(j)
    //           ori d,d,lo16(j)
    tmpInst.setOpcode(Cpu0::LUi);
    tmpInst.addOperand(MCOperand::createReg(RegOp.getReg()));
    tmpInst.addOperand(MCOperand::createImm((ImmValue &amp; 0xffff0000) &gt;&gt; 16));
    Instructions.push_back(tmpInst);
    tmpInst.clear();
    tmpInst.setOpcode(Cpu0::ORi);
    tmpInst.addOperand(MCOperand::createReg(RegOp.getReg()));
    tmpInst.addOperand(MCOperand::createReg(RegOp.getReg()));
    tmpInst.addOperand(MCOperand::createImm(ImmValue &amp; 0xffff));
    tmpInst.setLoc(IDLoc);
    Instructions.push_back(tmpInst);
  }
}

void Cpu0AsmParser::expandLoadAddressReg(MCInst &amp;Inst, SMLoc IDLoc,
                                         SmallVectorImpl&lt;MCInst&gt; &amp;Instructions){
  MCInst tmpInst;
  const MCOperand &amp;ImmOp = Inst.getOperand(2);
  assert(ImmOp.isImm() &amp;&amp; &quot;expected immediate operand kind&quot;);
  const MCOperand &amp;SrcRegOp = Inst.getOperand(1);
  assert(SrcRegOp.isReg() &amp;&amp; &quot;expected register operand kind&quot;);
  const MCOperand &amp;DstRegOp = Inst.getOperand(0);
  assert(DstRegOp.isReg() &amp;&amp; &quot;expected register operand kind&quot;);
  int ImmValue = ImmOp.getImm();
  if ( -32768 &lt;= ImmValue &amp;&amp; ImmValue &lt;= 32767) {
    // for -32768 &lt;= j &lt; 32767.
    //la d,j(s) =&gt; addiu d,s,j
    tmpInst.setOpcode(Cpu0::ADDiu); //TODO:no ADDiu64 in td files?
    tmpInst.addOperand(MCOperand::createReg(DstRegOp.getReg()));
    tmpInst.addOperand(MCOperand::createReg(SrcRegOp.getReg()));
    tmpInst.addOperand(MCOperand::createImm(ImmValue));
    Instructions.push_back(tmpInst);
  } else {
    // for any other value of j that is representable as a 32-bit integer.
    // la d,j(s) =&gt; lui d,hi16(j)
    //              ori d,d,lo16(j)
    //              add d,d,s
    tmpInst.setOpcode(Cpu0::LUi);
    tmpInst.addOperand(MCOperand::createReg(DstRegOp.getReg()));
    tmpInst.addOperand(MCOperand::createImm((ImmValue &amp; 0xffff0000) &gt;&gt; 16));
    Instructions.push_back(tmpInst);
    tmpInst.clear();
    tmpInst.setOpcode(Cpu0::ORi);
    tmpInst.addOperand(MCOperand::createReg(DstRegOp.getReg()));
    tmpInst.addOperand(MCOperand::createReg(DstRegOp.getReg()));
    tmpInst.addOperand(MCOperand::createImm(ImmValue &amp; 0xffff));
    Instructions.push_back(tmpInst);
    tmpInst.clear();
    tmpInst.setOpcode(Cpu0::ADD);
    tmpInst.addOperand(MCOperand::createReg(DstRegOp.getReg()));
    tmpInst.addOperand(MCOperand::createReg(DstRegOp.getReg()));
    tmpInst.addOperand(MCOperand::createReg(SrcRegOp.getReg()));
    Instructions.push_back(tmpInst);
  }
}

void Cpu0AsmParser::expandLoadAddressImm(MCInst &amp;Inst, SMLoc IDLoc,
                                         SmallVectorImpl&lt;MCInst&gt; &amp;Instructions){
  MCInst tmpInst;
  const MCOperand &amp;ImmOp = Inst.getOperand(1);
  assert(ImmOp.isImm() &amp;&amp; &quot;expected immediate operand kind&quot;);
  const MCOperand &amp;RegOp = Inst.getOperand(0);
  assert(RegOp.isReg() &amp;&amp; &quot;expected register operand kind&quot;);
  int ImmValue = ImmOp.getImm();
  if ( -32768 &lt;= ImmValue &amp;&amp; ImmValue &lt;= 32767) {
    // for -32768 &lt;= j &lt; 32767.
    //la d,j =&gt; addiu d,$zero,j
    tmpInst.setOpcode(Cpu0::ADDiu);
    tmpInst.addOperand(MCOperand::createReg(RegOp.getReg()));
    tmpInst.addOperand(
              MCOperand::createReg(Cpu0::ZERO));
    tmpInst.addOperand(MCOperand::createImm(ImmValue));
    Instructions.push_back(tmpInst);
  } else {
    // for any other value of j that is representable as a 32-bit integer.
    // la d,j =&gt; lui d,hi16(j)
    //           ori d,d,lo16(j)
    tmpInst.setOpcode(Cpu0::LUi);
    tmpInst.addOperand(MCOperand::createReg(RegOp.getReg()));
    tmpInst.addOperand(MCOperand::createImm((ImmValue &amp; 0xffff0000) &gt;&gt; 16));
    Instructions.push_back(tmpInst);
    tmpInst.clear();
    tmpInst.setOpcode(Cpu0::ORi);
    tmpInst.addOperand(MCOperand::createReg(RegOp.getReg()));
    tmpInst.addOperand(MCOperand::createReg(RegOp.getReg()));
    tmpInst.addOperand(MCOperand::createImm(ImmValue &amp; 0xffff));
    Instructions.push_back(tmpInst);
  }
}

//@2 {
bool Cpu0AsmParser::MatchAndEmitInstruction(SMLoc IDLoc, unsigned &amp;Opcode,
                                            OperandVector &amp;Operands,
                                            MCStreamer &amp;Out,
                                            uint64_t &amp;ErrorInfo,
                                            bool MatchingInlineAsm) {
  printCpu0Operands(Operands);
  MCInst Inst;
  unsigned MatchResult = MatchInstructionImpl(Operands, Inst, ErrorInfo,
                                              MatchingInlineAsm);
  switch (MatchResult) {
  default: break;
  case Match_Success: {
    if (needsExpansion(Inst)) {
      SmallVector&lt;MCInst, 4&gt; Instructions;
      expandInstruction(Inst, IDLoc, Instructions);
      for(unsigned i =0; i &lt; Instructions.size(); i++){
        Out.emitInstruction(Instructions[i], getSTI());
      }
    } else {
        Inst.setLoc(IDLoc);
        Out.emitInstruction(Inst, getSTI());
      }
    return false;
  }
//@2 }
  case Match_MissingFeature:
    Error(IDLoc, &quot;instruction requires a CPU feature not currently enabled&quot;);
    return true;
  case Match_InvalidOperand: {
    SMLoc ErrorLoc = IDLoc;
    if (ErrorInfo != ~0U) {
      if (ErrorInfo &gt;= Operands.size())
        return Error(IDLoc, &quot;too few operands for instruction&quot;);

      ErrorLoc = ((Cpu0Operand &amp;)*Operands[ErrorInfo]).getStartLoc();
      if (ErrorLoc == SMLoc()) ErrorLoc = IDLoc;
    }

    return Error(ErrorLoc, &quot;invalid operand for instruction&quot;);
  }
  case Match_MnemonicFail:
    return Error(IDLoc, &quot;invalid instruction&quot;);
  }
  return true;
}

int Cpu0AsmParser::matchRegisterName(StringRef Name) {

   int CC;
    CC = StringSwitch&lt;unsigned&gt;(Name)
      .Case(&quot;zero&quot;,  Cpu0::ZERO)
      .Case(&quot;at&quot;,  Cpu0::AT)
      .Case(&quot;v0&quot;,  Cpu0::V0)
      .Case(&quot;v1&quot;,  Cpu0::V1)
      .Case(&quot;a0&quot;,  Cpu0::A0)
      .Case(&quot;a1&quot;,  Cpu0::A1)
      .Case(&quot;t9&quot;,  Cpu0::T9)
      .Case(&quot;t0&quot;,  Cpu0::T0)
      .Case(&quot;t1&quot;,  Cpu0::T1)
      .Case(&quot;s0&quot;,  Cpu0::S0)
      .Case(&quot;s1&quot;,  Cpu0::S1)
      .Case(&quot;sw&quot;,  Cpu0::SW)
      .Case(&quot;gp&quot;,  Cpu0::GP)
      .Case(&quot;fp&quot;,  Cpu0::FP)
      .Case(&quot;sp&quot;,  Cpu0::SP)
      .Case(&quot;lr&quot;,  Cpu0::LR)
      .Case(&quot;pc&quot;,  Cpu0::PC)
      .Case(&quot;hi&quot;,  Cpu0::HI)
      .Case(&quot;lo&quot;,  Cpu0::LO)
      .Case(&quot;epc&quot;, Cpu0::EPC)
      .Default(-1);

  if (CC != -1)
    return CC;

  return -1;
}

unsigned Cpu0AsmParser::getReg(int RC,int RegNo) {
  return *(getContext().getRegisterInfo()-&gt;getRegClass(RC).begin() + RegNo);
}

int Cpu0AsmParser::matchRegisterByNumber(unsigned RegNum, StringRef Mnemonic) {
  if (RegNum &gt; 15)
    return -1;

  return getReg(Cpu0::CPURegsRegClassID, RegNum);
}

int Cpu0AsmParser::tryParseRegister(StringRef Mnemonic) {
  const AsmToken &amp;Tok = Parser.getTok();
  int RegNum = -1;

  if (Tok.is(AsmToken::Identifier)) {
    std::string lowerCase = Tok.getString().lower();
    RegNum = matchRegisterName(lowerCase);
  } else if (Tok.is(AsmToken::Integer))
    RegNum = matchRegisterByNumber(static_cast&lt;unsigned&gt;(Tok.getIntVal()),
                                   Mnemonic.lower());
    else
      return RegNum;  //error
  return RegNum;
}

bool Cpu0AsmParser::
  tryParseRegisterOperand(OperandVector &amp;Operands,
                          StringRef Mnemonic){

  SMLoc S = Parser.getTok().getLoc();
  int RegNo = -1;

    RegNo = tryParseRegister(Mnemonic);
  if (RegNo == -1)
    return true;

  Operands.push_back(Cpu0Operand::CreateReg(RegNo, S,
      Parser.getTok().getLoc()));
  Parser.Lex(); // Eat register token.
  return false;
}

bool Cpu0AsmParser::ParseOperand(OperandVector &amp;Operands,
                                 StringRef Mnemonic) {
  LLVM_DEBUG(dbgs() &lt;&lt; &quot;ParseOperand\n&quot;);
  // Check if the current operand has a custom associated parser, if so, try to
  // custom parse the operand, or fallback to the general approach.
  OperandMatchResultTy ResTy = MatchOperandParserImpl(Operands, Mnemonic);
  if (ResTy == MatchOperand_Success)
    return false;
  // If there wasn&#39;t a custom match, try the generic matcher below. Otherwise,
  // there was a match, but an error occurred, in which case, just return that
  // the operand parsing failed.
  if (ResTy == MatchOperand_ParseFail)
    return true;

  LLVM_DEBUG(dbgs() &lt;&lt; &quot;.. Generic Parser\n&quot;);

  switch (getLexer().getKind()) {
  default:
    Error(Parser.getTok().getLoc(), &quot;unexpected token in operand&quot;);
    return true;
  case AsmToken::Dollar: {
    // parse register
    SMLoc S = Parser.getTok().getLoc();
    Parser.Lex(); // Eat dollar token.
    // parse register operand
    if (!tryParseRegisterOperand(Operands, Mnemonic)) {
      if (getLexer().is(AsmToken::LParen)) {
        // check if it is indexed addressing operand
        Operands.push_back(Cpu0Operand::CreateToken(&quot;(&quot;, S));
        Parser.Lex(); // eat parenthesis
        if (getLexer().isNot(AsmToken::Dollar))
          return true;

        Parser.Lex(); // eat dollar
        if (tryParseRegisterOperand(Operands, Mnemonic))
          return true;

        if (!getLexer().is(AsmToken::RParen))
          return true;

        S = Parser.getTok().getLoc();
        Operands.push_back(Cpu0Operand::CreateToken(&quot;)&quot;, S));
        Parser.Lex();
      }
      return false;
    }
    // maybe it is a symbol reference
    StringRef Identifier;
    if (Parser.parseIdentifier(Identifier))
      return true;

    SMLoc E = SMLoc::getFromPointer(Parser.getTok().getLoc().getPointer() - 1);

    MCSymbol *Sym = getContext().getOrCreateSymbol(&quot;$&quot; + Identifier);

    // Otherwise create a symbol ref.
    const MCExpr *Res = MCSymbolRefExpr::create(Sym, MCSymbolRefExpr::VK_None,
                                                getContext());

    Operands.push_back(Cpu0Operand::CreateImm(Res, S, E));
    return false;
  }
  case AsmToken::Identifier:
  case AsmToken::LParen:
  case AsmToken::Minus:
  case AsmToken::Plus:
  case AsmToken::Integer:
  case AsmToken::String: {
     // quoted label names
    const MCExpr *IdVal;
    SMLoc S = Parser.getTok().getLoc();
    if (getParser().parseExpression(IdVal))
      return true;
    SMLoc E = SMLoc::getFromPointer(Parser.getTok().getLoc().getPointer() - 1);
    Operands.push_back(Cpu0Operand::CreateImm(IdVal, S, E));
    return false;
  }
  case AsmToken::Percent: {
    // it is a symbol reference or constant expression
    const MCExpr *IdVal;
    SMLoc S = Parser.getTok().getLoc(); // start location of the operand
    if (parseRelocOperand(IdVal))
      return true;

    SMLoc E = SMLoc::getFromPointer(Parser.getTok().getLoc().getPointer() - 1);

    Operands.push_back(Cpu0Operand::CreateImm(IdVal, S, E));
    return false;
  } // case AsmToken::Percent
  } // switch(getLexer().getKind())
  return true;
}

const MCExpr *Cpu0AsmParser::evaluateRelocExpr(const MCExpr *Expr,
                                               StringRef RelocStr) {
  Cpu0MCExpr::Cpu0ExprKind Kind =
      StringSwitch&lt;Cpu0MCExpr::Cpu0ExprKind&gt;(RelocStr)
          .Case(&quot;call16&quot;, Cpu0MCExpr::CEK_GOT_CALL)
          .Case(&quot;call_hi&quot;, Cpu0MCExpr::CEK_CALL_HI16)
          .Case(&quot;call_lo&quot;, Cpu0MCExpr::CEK_CALL_LO16)
          .Case(&quot;dtp_hi&quot;, Cpu0MCExpr::CEK_DTP_HI)
          .Case(&quot;dtp_lo&quot;, Cpu0MCExpr::CEK_DTP_LO)
          .Case(&quot;got&quot;, Cpu0MCExpr::CEK_GOT)
          .Case(&quot;got_hi&quot;, Cpu0MCExpr::CEK_GOT_HI16)
          .Case(&quot;got_lo&quot;, Cpu0MCExpr::CEK_GOT_LO16)
          .Case(&quot;gottprel&quot;, Cpu0MCExpr::CEK_GOTTPREL)
          .Case(&quot;gp_rel&quot;, Cpu0MCExpr::CEK_GPREL)
          .Case(&quot;hi&quot;, Cpu0MCExpr::CEK_ABS_HI)
          .Case(&quot;lo&quot;, Cpu0MCExpr::CEK_ABS_LO)
          .Case(&quot;tlsgd&quot;, Cpu0MCExpr::CEK_TLSGD)
          .Case(&quot;tlsldm&quot;, Cpu0MCExpr::CEK_TLSLDM)
          .Case(&quot;tp_hi&quot;, Cpu0MCExpr::CEK_TP_HI)
          .Case(&quot;tp_lo&quot;, Cpu0MCExpr::CEK_TP_LO)
          .Default(Cpu0MCExpr::CEK_None);

  assert(Kind != Cpu0MCExpr::CEK_None);
  return Cpu0MCExpr::create(Kind, Expr, getContext());
}

bool Cpu0AsmParser::parseRelocOperand(const MCExpr *&amp;Res) {

  Parser.Lex(); // eat % token
  const AsmToken &amp;Tok = Parser.getTok(); // get next token, operation
  if (Tok.isNot(AsmToken::Identifier))
    return true;

  std::string Str = Tok.getIdentifier().str();

  Parser.Lex(); // eat identifier
  // now make expression from the rest of the operand
  const MCExpr *IdVal;
  SMLoc EndLoc;

  if (getLexer().getKind() == AsmToken::LParen) {
    while (1) {
      Parser.Lex(); // eat &#39;(&#39; token
      if (getLexer().getKind() == AsmToken::Percent) {
        Parser.Lex(); // eat % token
        const AsmToken &amp;nextTok = Parser.getTok();
        if (nextTok.isNot(AsmToken::Identifier))
          return true;
        Str += &quot;(%&quot;;
        Str += nextTok.getIdentifier();
        Parser.Lex(); // eat identifier
        if (getLexer().getKind() != AsmToken::LParen)
          return true;
      } else
        break;
    }
    if (getParser().parseParenExpression(IdVal,EndLoc))
      return true;

    while (getLexer().getKind() == AsmToken::RParen)
      Parser.Lex(); // eat &#39;)&#39; token

  } else
    return true; // parenthesis must follow reloc operand

  Res = evaluateRelocExpr(IdVal, Str);
  return false;
}

bool Cpu0AsmParser::ParseRegister(unsigned &amp;RegNo, SMLoc &amp;StartLoc,
                                  SMLoc &amp;EndLoc) {

  StartLoc = Parser.getTok().getLoc();
  RegNo = tryParseRegister(&quot;&quot;);
  EndLoc = Parser.getTok().getLoc();
  return (RegNo == (unsigned)-1);
}

OperandMatchResultTy Cpu0AsmParser::tryParseRegister(unsigned &amp;RegNo,
                                                     SMLoc &amp;StartLoc,
                                                     SMLoc &amp;EndLoc) {
  StartLoc = Parser.getTok().getLoc();
  RegNo = tryParseRegister(&quot;&quot;);
  EndLoc = Parser.getTok().getLoc();
  return (RegNo == (unsigned)-1) ? MatchOperand_NoMatch
                                 : MatchOperand_Success;
}

bool Cpu0AsmParser::parseMemOffset(const MCExpr *&amp;Res) {
  switch(getLexer().getKind()) {
  default:
    return true;
  case AsmToken::Integer:
  case AsmToken::Minus:
  case AsmToken::Plus:
    return (getParser().parseExpression(Res));
  case AsmToken::Percent:
    return parseRelocOperand(Res);
  case AsmToken::LParen:
    return false;  // it&#39;s probably assuming 0
  }
  return true;
}

// eg, 12($sp) or 12(la)
OperandMatchResultTy Cpu0AsmParser::parseMemOperand(
               OperandVector &amp;Operands) {

  const MCExpr *IdVal = 0;
  SMLoc S;
  // first operand is the offset
  S = Parser.getTok().getLoc();

  if (parseMemOffset(IdVal))
    return MatchOperand_ParseFail;

  const AsmToken &amp;Tok = Parser.getTok(); // get next token
  if (Tok.isNot(AsmToken::LParen)) {
    Cpu0Operand &amp;Mnemonic = static_cast&lt;Cpu0Operand &amp;&gt;(*Operands[0]);
    if (Mnemonic.getToken() == &quot;la&quot;) {
      SMLoc E = SMLoc::getFromPointer(Parser.getTok().getLoc().getPointer()-1);
      Operands.push_back(Cpu0Operand::CreateImm(IdVal, S, E));
      return MatchOperand_Success;
    }
    Error(Parser.getTok().getLoc(), &quot;&#39;(&#39; expected&quot;);
    return MatchOperand_ParseFail;
  }

  Parser.Lex(); // Eat &#39;(&#39; token.

  const AsmToken &amp;Tok1 = Parser.getTok(); // get next token
  if (Tok1.is(AsmToken::Dollar)) {
    Parser.Lex(); // Eat &#39;$&#39; token.
    if (tryParseRegisterOperand(Operands,&quot;&quot;)) {
      Error(Parser.getTok().getLoc(), &quot;unexpected token in operand&quot;);
      return MatchOperand_ParseFail;
    }

  } else {
    Error(Parser.getTok().getLoc(), &quot;unexpected token in operand&quot;);
    return MatchOperand_ParseFail;
  }

  const AsmToken &amp;Tok2 = Parser.getTok(); // get next token
  if (Tok2.isNot(AsmToken::RParen)) {
    Error(Parser.getTok().getLoc(), &quot;&#39;)&#39; expected&quot;);
    return MatchOperand_ParseFail;
  }

  SMLoc E = SMLoc::getFromPointer(Parser.getTok().getLoc().getPointer() - 1);

  Parser.Lex(); // Eat &#39;)&#39; token.

  if (!IdVal)
    IdVal = MCConstantExpr::create(0, getContext());

  // Replace the register operand with the memory operand.
  std::unique_ptr&lt;Cpu0Operand&gt; op(
      static_cast&lt;Cpu0Operand *&gt;(Operands.back().release()));
  int RegNo = op-&gt;getReg();
  // remove register from operands
  Operands.pop_back();
  // and add memory operand
  Operands.push_back(Cpu0Operand::CreateMem(RegNo, IdVal, S, E));
  return MatchOperand_Success;
}

bool Cpu0AsmParser::
ParseInstruction(ParseInstructionInfo &amp;Info, StringRef Name, SMLoc NameLoc,
                 OperandVector &amp;Operands) {

  // Create the leading tokens for the mnemonic, split by &#39;.&#39; characters.
  size_t Start = 0, Next = Name.find(&#39;.&#39;);
  StringRef Mnemonic = Name.slice(Start, Next);
  // Refer to the explanation in source code of function DecodeJumpFR(...) in 
  // Cpu0Disassembler.cpp
  if (Mnemonic == &quot;ret&quot;)
    Mnemonic = &quot;jr&quot;;

  Operands.push_back(Cpu0Operand::CreateToken(Mnemonic, NameLoc));

  // Read the remaining operands.
  if (getLexer().isNot(AsmToken::EndOfStatement)) {
    // Read the first operand.
    if (ParseOperand(Operands, Name)) {
      SMLoc Loc = getLexer().getLoc();
      Parser.eatToEndOfStatement();
      return Error(Loc, &quot;unexpected token in argument list&quot;);
    }

    while (getLexer().is(AsmToken::Comma) ) {
      Parser.Lex();  // Eat the comma.

      // Parse and remember the operand.
      if (ParseOperand(Operands, Name)) {
        SMLoc Loc = getLexer().getLoc();
        Parser.eatToEndOfStatement();
        return Error(Loc, &quot;unexpected token in argument list&quot;);
      }
    }
  }

  if (getLexer().isNot(AsmToken::EndOfStatement)) {
    SMLoc Loc = getLexer().getLoc();
    Parser.eatToEndOfStatement();
    return Error(Loc, &quot;unexpected token in argument list&quot;);
  }

  Parser.Lex(); // Consume the EndOfStatement
  return false;
}

bool Cpu0AsmParser::reportParseError(StringRef ErrorMsg) {
   SMLoc Loc = getLexer().getLoc();
   Parser.eatToEndOfStatement();
   return Error(Loc, ErrorMsg);
}

bool Cpu0AsmParser::parseSetReorderDirective() {
  Parser.Lex();
  // if this is not the end of the statement, report error
  if (getLexer().isNot(AsmToken::EndOfStatement)) {
    reportParseError(&quot;unexpected token in statement&quot;);
    return false;
  }
  Options.setReorder();
  Parser.Lex(); // Consume the EndOfStatement
  return false;
}

bool Cpu0AsmParser::parseSetNoReorderDirective() {
    Parser.Lex();
    // if this is not the end of the statement, report error
    if (getLexer().isNot(AsmToken::EndOfStatement)) {
      reportParseError(&quot;unexpected token in statement&quot;);
      return false;
    }
    Options.setNoreorder();
    Parser.Lex(); // Consume the EndOfStatement
    return false;
}

bool Cpu0AsmParser::parseSetMacroDirective() {
  Parser.Lex();
  // if this is not the end of the statement, report error
  if (getLexer().isNot(AsmToken::EndOfStatement)) {
    reportParseError(&quot;unexpected token in statement&quot;);
    return false;
  }
  Options.setMacro();
  Parser.Lex(); // Consume the EndOfStatement
  return false;
}

bool Cpu0AsmParser::parseSetNoMacroDirective() {
  Parser.Lex();
  // if this is not the end of the statement, report error
  if (getLexer().isNot(AsmToken::EndOfStatement)) {
    reportParseError(&quot;`noreorder&#39; must be set before `nomacro&#39;&quot;);
    return false;
  }
  if (Options.isReorder()) {
    reportParseError(&quot;`noreorder&#39; must be set before `nomacro&#39;&quot;);
    return false;
  }
  Options.setNomacro();
  Parser.Lex(); // Consume the EndOfStatement
  return false;
}
bool Cpu0AsmParser::parseDirectiveSet() {

  // get next token
  const AsmToken &amp;Tok = Parser.getTok();

  if (Tok.getString() == &quot;reorder&quot;) {
    return parseSetReorderDirective();
  } else if (Tok.getString() == &quot;noreorder&quot;) {
    return parseSetNoReorderDirective();
  } else if (Tok.getString() == &quot;macro&quot;) {
    return parseSetMacroDirective();
  } else if (Tok.getString() == &quot;nomacro&quot;) {
    return parseSetNoMacroDirective();
  }
  return true;
}

bool Cpu0AsmParser::ParseDirective(AsmToken DirectiveID) {

  if (DirectiveID.getString() == &quot;.ent&quot;) {
    // ignore this directive for now
    Parser.Lex();
    return false;
  }

  if (DirectiveID.getString() == &quot;.end&quot;) {
    // ignore this directive for now
    Parser.Lex();
    return false;
  }

  if (DirectiveID.getString() == &quot;.frame&quot;) {
    // ignore this directive for now
    Parser.eatToEndOfStatement();
    return false;
  }

  if (DirectiveID.getString() == &quot;.set&quot;) {
    return parseDirectiveSet();
  }

  if (DirectiveID.getString() == &quot;.fmask&quot;) {
    // ignore this directive for now
    Parser.eatToEndOfStatement();
    return false;
  }

  if (DirectiveID.getString() == &quot;.mask&quot;) {
    // ignore this directive for now
    Parser.eatToEndOfStatement();
    return false;
  }

  if (DirectiveID.getString() == &quot;.gpword&quot;) {
    // ignore this directive for now
    Parser.eatToEndOfStatement();
    return false;
  }

  return true;
}

extern &quot;C&quot; void LLVMInitializeCpu0AsmParser() {
  RegisterMCAsmParser&lt;Cpu0AsmParser&gt; X(TheCpu0Target);
  RegisterMCAsmParser&lt;Cpu0AsmParser&gt; Y(TheCpu0elTarget);
}

#define GET_REGISTER_MATCHER
#define GET_MATCHER_IMPLEMENTATION
#include &quot;Cpu0GenAsmMatcher.inc&quot;

#else // #if CH &gt;= CH11_1
extern &quot;C&quot; void LLVMInitializeCpu0AsmParser() {}
#endif
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_1/AsmParser/CMakeLists.txt</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">add_llvm_component_library</span><span class="p">(</span><span class="n">LLVMCpu0AsmParser</span>
  <span class="n">Cpu0AsmParser</span><span class="o">.</span><span class="n">cpp</span>

  <span class="n">LINK_COMPONENTS</span>
  <span class="n">MC</span>
  <span class="n">MCParser</span>
  <span class="n">Cpu0Desc</span>
  <span class="n">Cpu0Info</span>
  <span class="n">Support</span>

  <span class="n">ADD_TO_COMPONENT</span>
  <span class="n">Cpu0</span>
  <span class="p">)</span>
</pre></div>
</div>
<p>The Cpu0AsmParser.cpp contains one thousand lines of code which do the assembly
language parsing. You can understand it with a little patience only.
To let files in directory of AsmParser be built, modify CMakeLists.txt as follows,</p>
<p class="rubric">lbdex/chapters/Chapter11_1/CMakeLists.txt</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">set</span><span class="p">(</span><span class="n">LLVM_TARGET_DEFINITIONS</span> <span class="n">Cpu0Asm</span><span class="o">.</span><span class="n">td</span><span class="p">)</span>
<span class="n">tablegen</span><span class="p">(</span><span class="n">LLVM</span> <span class="n">Cpu0GenAsmMatcher</span><span class="o">.</span><span class="n">inc</span> <span class="o">-</span><span class="n">gen</span><span class="o">-</span><span class="n">asm</span><span class="o">-</span><span class="n">matcher</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">Cpu0AsmParser</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">add_subdirectory</span><span class="p">(</span><span class="n">AsmParser</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_1/Cpu0Asm.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//===--</span> <span class="n">Cpu0Asm</span><span class="o">.</span><span class="n">td</span> <span class="o">-</span> <span class="n">Describe</span> <span class="n">the</span> <span class="n">Cpu0</span> <span class="n">Target</span> <span class="n">Machine</span> <span class="o">------*-</span> <span class="n">tablegen</span> <span class="o">-*-===//</span>
<span class="o">//</span>
<span class="o">//</span>                     <span class="n">The</span> <span class="n">LLVM</span> <span class="n">Compiler</span> <span class="n">Infrastructure</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">This</span> <span class="n">file</span> <span class="ow">is</span> <span class="n">distributed</span> <span class="n">under</span> <span class="n">the</span> <span class="n">University</span> <span class="n">of</span> <span class="n">Illinois</span> <span class="n">Open</span> <span class="n">Source</span>
<span class="o">//</span> <span class="n">License</span><span class="o">.</span> <span class="n">See</span> <span class="n">LICENSE</span><span class="o">.</span><span class="n">TXT</span> <span class="k">for</span> <span class="n">details</span><span class="o">.</span>
<span class="o">//</span>
<span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">//</span> <span class="n">This</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">top</span> <span class="n">level</span> <span class="n">entry</span> <span class="n">point</span> <span class="k">for</span> <span class="n">the</span> <span class="n">Cpu0</span> <span class="n">target</span><span class="o">.</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">//</span> <span class="n">Target</span><span class="o">-</span><span class="n">independent</span> <span class="n">interfaces</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="n">include</span> <span class="s2">&quot;llvm/Target/Target.td&quot;</span>

<span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">//</span> <span class="n">Target</span><span class="o">-</span><span class="n">dependent</span> <span class="n">interfaces</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="n">include</span> <span class="s2">&quot;Cpu0RegisterInfo.td&quot;</span>
<span class="n">include</span> <span class="s2">&quot;Cpu0RegisterInfoGPROutForAsm.td&quot;</span>
<span class="n">include</span> <span class="s2">&quot;Cpu0.td&quot;</span>

</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_1/Cpu0RegisterInfoGPROutForAsm.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">//</span> <span class="n">Register</span> <span class="n">Classes</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="k">def</span> <span class="nf">GPROut</span> <span class="p">:</span> <span class="n">RegisterClass</span><span class="o">&lt;</span><span class="s2">&quot;Cpu0&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">i32</span><span class="p">],</span> <span class="mi">32</span><span class="p">,</span> <span class="p">(</span><span class="n">add</span> <span class="n">CPURegs</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>

</pre></div>
</div>
<p>The CMakeLists.txt adds code as above to generate Cpu0GenAsmMatcher.inc
used by Cpu0AsmParser.cpp.
Cpu0Asm.td include Cpu0RegisterInfoGPROutForAsm.td which define GPROut to
CPURegs while Cpu0Other.td include Cpu0RegisterInfoGPROutForOther.td which
define GPROut to CPURegs exclude SW.
Cpu0Other.td is used when translating llvm IR to Cpu0 instruction.
In latter case, the register SW is reserved for keeping the CPU status and not
allowed to be allocated as a general purpose register.
For example, if setting GPROut to include SW, when compile with C statement
“a = (b &amp; c);”, it may generate instruction “and $sw, $1, $2”, as a result that
interrupt status in $sw will be destroyed.
When programming in assembly, instruction “andi $sw, $sw, 0xffdf” is allowed.
This assembly program is accepted and Cpu0 backend treats it safe since
assembler programmer can disable trace debug message by
“andi $sw, $sw, 0xffdf” and enable debug message by “ori $sw, $sw, 0x0020”.
In addition, the interrupt bits can also be enabled or disabled by “ori” and
“andi” instructions.</p>
<p>The EPC must set to CPURegs as follows, otherwise, MatchInstructionImpl() of
MatchAndEmitInstruction() will return fail for “asm(“mfc0 $pc, $epc”);”.</p>
<p class="rubric">lbdex/chapters/Chapter2/Cpu0RegisterInfo.td</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">def</span><span class="w"> </span><span class="n">CPURegs</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">RegisterClass</span><span class="o">&lt;</span><span class="s">&quot;Cpu0&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">i32</span><span class="p">],</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">add</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">PC</span><span class="p">,</span><span class="w"> </span><span class="n">EPC</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_1/Cpu0.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">Cpu0AsmParser</span> <span class="p">:</span> <span class="n">AsmParser</span> <span class="p">{</span>
  <span class="n">let</span> <span class="n">ShouldEmitMatchRegisterName</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">def</span> <span class="nf">Cpu0AsmParserVariant</span> <span class="p">:</span> <span class="n">AsmParserVariant</span> <span class="p">{</span>
  <span class="nb">int</span> <span class="n">Variant</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="o">//</span> <span class="n">Recognize</span> <span class="n">hard</span> <span class="n">coded</span> <span class="n">registers</span><span class="o">.</span>
  <span class="n">string</span> <span class="n">RegisterPrefix</span> <span class="o">=</span> <span class="s2">&quot;$&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">def</span><span class="w"> </span><span class="n">Cpu0</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Target</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">let</span> <span class="n">AssemblyParsers</span> <span class="o">=</span> <span class="p">[</span><span class="n">Cpu0AsmParser</span><span class="p">];</span>
  <span class="n">let</span> <span class="n">AssemblyParserVariants</span> <span class="o">=</span> <span class="p">[</span><span class="n">Cpu0AsmParserVariant</span><span class="p">];</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_1/Cpu0InstrFormats.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Pseudo</span><span class="o">-</span><span class="n">instructions</span> <span class="k">for</span> <span class="n">alternate</span> <span class="n">assembly</span> <span class="n">syntax</span> <span class="p">(</span><span class="n">never</span> <span class="n">used</span> <span class="n">by</span> <span class="n">codegen</span><span class="p">)</span><span class="o">.</span>
<span class="o">//</span> <span class="n">These</span> <span class="n">are</span> <span class="n">aliases</span> <span class="n">that</span> <span class="n">require</span> <span class="n">C</span><span class="o">++</span> <span class="n">handling</span> <span class="n">to</span> <span class="n">convert</span> <span class="n">to</span> <span class="n">the</span> <span class="n">target</span>
<span class="o">//</span> <span class="n">instruction</span><span class="p">,</span> <span class="k">while</span> <span class="n">InstAliases</span> <span class="n">can</span> <span class="n">be</span> <span class="n">handled</span> <span class="n">directly</span> <span class="n">by</span> <span class="n">tblgen</span><span class="o">.</span>
<span class="k">class</span> <span class="nc">Cpu0AsmPseudoInst</span><span class="o">&lt;</span><span class="n">dag</span> <span class="n">outs</span><span class="p">,</span> <span class="n">dag</span> <span class="n">ins</span><span class="p">,</span> <span class="n">string</span> <span class="n">asmstr</span><span class="o">&gt;</span><span class="p">:</span>
  <span class="n">Cpu0Inst</span><span class="o">&lt;</span><span class="n">outs</span><span class="p">,</span> <span class="n">ins</span><span class="p">,</span> <span class="n">asmstr</span><span class="p">,</span> <span class="p">[],</span> <span class="n">IIPseudo</span><span class="p">,</span> <span class="n">Pseudo</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">let</span> <span class="n">isPseudo</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">let</span> <span class="n">Pattern</span> <span class="o">=</span> <span class="p">[];</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_1/Cpu0InstrInfo.td</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">def</span><span class="w"> </span><span class="n">Cpu0MemAsmOperand</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">AsmOperandClass</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">let</span><span class="w"> </span><span class="n">Name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Mem&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">let</span><span class="w"> </span><span class="n">ParserMethod</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;parseMemOperand&quot;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Address operand</span>
<span class="n">def</span><span class="w"> </span><span class="n">mem</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Operand</span><span class="o">&lt;</span><span class="n">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="n">let</span><span class="w"> </span><span class="n">ParserMatchClass</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Cpu0MemAsmOperand</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>//===----------------------------------------------------------------------===//
// Pseudo Instruction definition
//===----------------------------------------------------------------------===//

let Predicates = [Ch11_1] in {
class LoadImm32&lt; string instr_asm, Operand Od, RegisterClass RC&gt; :
  Cpu0AsmPseudoInst&lt;(outs RC:$ra), (ins Od:$imm32),
                     !strconcat(instr_asm, &quot;\t$ra, $imm32&quot;)&gt; ;
def LoadImm32Reg : LoadImm32&lt;&quot;li&quot;, shamt, GPROut&gt;;

class LoadAddress&lt;string instr_asm, Operand MemOpnd, RegisterClass RC&gt; :
  Cpu0AsmPseudoInst&lt;(outs RC:$ra), (ins MemOpnd:$addr),
                     !strconcat(instr_asm, &quot;\t$ra, $addr&quot;)&gt; ;
def LoadAddr32Reg : LoadAddress&lt;&quot;la&quot;, mem, GPROut&gt;;

class LoadAddressImm&lt;string instr_asm, Operand Od, RegisterClass RC&gt; :
  Cpu0AsmPseudoInst&lt;(outs RC:$ra), (ins Od:$imm32),
                     !strconcat(instr_asm, &quot;\t$ra, $imm32&quot;)&gt; ;
def LoadAddr32Imm : LoadAddressImm&lt;&quot;la&quot;, shamt, GPROut&gt;;
}
</pre></div>
</div>
<p>Above Cpu0InstrInfo.td declare the <strong>let ParserMethod = “parseMemOperand”</strong> and
implement the
parseMemOperand() in Cpu0AsmParser.cpp to handle the <strong>“mem”</strong> operand which
used in Cpu0 instructions ld and st.
For example, ld $2, 4($sp), the <strong>mem</strong> operand is 4($sp).
Accompany with <strong>“let ParserMatchClass = Cpu0MemAsmOperand;”</strong>,
LLVM will call parseMemOperand() of Cpu0AsmParser.cpp when it meets the assembly
<strong>mem</strong> operand 4($sp). With above <strong>“let”</strong> assignment, TableGen will generate
the following structure and functions in Cpu0GenAsmMatcher.inc.</p>
<p class="rubric">build/lib/Target/Cpu0/Cpu0GenAsmMatcher.inc</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="k">enum</span><span class="w"> </span><span class="nc">OperandMatchResultTy</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">MatchOperand_Success</span><span class="p">,</span><span class="w">    </span><span class="c1">// operand matched successfully</span>
<span class="w">    </span><span class="n">MatchOperand_NoMatch</span><span class="p">,</span><span class="w">    </span><span class="c1">// operand did not match</span>
<span class="w">    </span><span class="n">MatchOperand_ParseFail</span><span class="w">   </span><span class="c1">// operand matched but had errors</span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="n">OperandMatchResultTy</span><span class="w"> </span><span class="nf">MatchOperandParserImpl</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">OperandVector</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Operands</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">StringRef</span><span class="w"> </span><span class="n">Mnemonic</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">OperandMatchResultTy</span><span class="w"> </span><span class="nf">tryCustomParseOperand</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">OperandVector</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Operands</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">MCK</span><span class="p">);</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">OperandMatchResultTy</span><span class="w"> </span><span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="w"></span>
<span class="n">tryCustomParseOperand</span><span class="p">(</span><span class="n">OperandVector</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Operands</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">MCK</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="k">switch</span><span class="p">(</span><span class="n">MCK</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">MCK_Mem</span><span class="p">:</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">parseMemOperand</span><span class="p">(</span><span class="n">Operands</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">default</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">MatchOperand_NoMatch</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">MatchOperand_NoMatch</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">OperandMatchResultTy</span><span class="w"> </span><span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="w"></span>
<span class="n">MatchOperandParserImpl</span><span class="p">(</span><span class="n">OperandVector</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Operands</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="n">StringRef</span><span class="w"> </span><span class="n">Mnemonic</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">/// MatchClassKind - The kinds of classes which participate in</span>
<span class="c1">/// instruction matching.</span>
<span class="k">enum</span><span class="w"> </span><span class="nc">MatchClassKind</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="n">MCK_Mem</span><span class="p">,</span><span class="w"> </span><span class="c1">// user defined class &#39;Cpu0MemAsmOperand&#39;</span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>Above three Pseudo Instruction definitions in Cpu0InstrInfo.td, such as
LoadImm32Reg, are handled by Cpu0AsmParser.cpp as follows,</p>
<p class="rubric">lbdex/chapters/Chapter11_1/AsmParser/Cpu0AsmParser.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">bool</span> <span class="n">Cpu0AsmParser</span><span class="p">::</span><span class="n">needsExpansion</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">)</span> <span class="p">{</span>

  <span class="n">switch</span><span class="p">(</span><span class="n">Inst</span><span class="o">.</span><span class="n">getOpcode</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">LoadImm32Reg</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">LoadAddr32Imm</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">LoadAddr32Reg</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">true</span><span class="p">;</span>
    <span class="n">default</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">false</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">Cpu0AsmParser</span><span class="p">::</span><span class="n">expandInstruction</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="n">IDLoc</span><span class="p">,</span>
                        <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCInst</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Instructions</span><span class="p">){</span>
  <span class="n">switch</span><span class="p">(</span><span class="n">Inst</span><span class="o">.</span><span class="n">getOpcode</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">LoadImm32Reg</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">expandLoadImm</span><span class="p">(</span><span class="n">Inst</span><span class="p">,</span> <span class="n">IDLoc</span><span class="p">,</span> <span class="n">Instructions</span><span class="p">);</span>
    <span class="k">case</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">LoadAddr32Imm</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">expandLoadAddressImm</span><span class="p">(</span><span class="n">Inst</span><span class="p">,</span><span class="n">IDLoc</span><span class="p">,</span><span class="n">Instructions</span><span class="p">);</span>
    <span class="k">case</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">LoadAddr32Reg</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">expandLoadAddressReg</span><span class="p">(</span><span class="n">Inst</span><span class="p">,</span><span class="n">IDLoc</span><span class="p">,</span><span class="n">Instructions</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">bool</span> <span class="n">Cpu0AsmParser</span><span class="p">::</span><span class="n">MatchAndEmitInstruction</span><span class="p">(</span><span class="n">SMLoc</span> <span class="n">IDLoc</span><span class="p">,</span> <span class="n">unsigned</span> <span class="o">&amp;</span><span class="n">Opcode</span><span class="p">,</span>
                                            <span class="n">OperandVector</span> <span class="o">&amp;</span><span class="n">Operands</span><span class="p">,</span>
                                            <span class="n">MCStreamer</span> <span class="o">&amp;</span><span class="n">Out</span><span class="p">,</span>
                                            <span class="n">uint64_t</span> <span class="o">&amp;</span><span class="n">ErrorInfo</span><span class="p">,</span>
                                            <span class="nb">bool</span> <span class="n">MatchingInlineAsm</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printCpu0Operands</span><span class="p">(</span><span class="n">Operands</span><span class="p">);</span>
  <span class="n">MCInst</span> <span class="n">Inst</span><span class="p">;</span>
  <span class="n">unsigned</span> <span class="n">MatchResult</span> <span class="o">=</span> <span class="n">MatchInstructionImpl</span><span class="p">(</span><span class="n">Operands</span><span class="p">,</span> <span class="n">Inst</span><span class="p">,</span> <span class="n">ErrorInfo</span><span class="p">,</span>
                                              <span class="n">MatchingInlineAsm</span><span class="p">);</span>
  <span class="n">switch</span> <span class="p">(</span><span class="n">MatchResult</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">default</span><span class="p">:</span> <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Match_Success</span><span class="p">:</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">needsExpansion</span><span class="p">(</span><span class="n">Inst</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">MCInst</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">Instructions</span><span class="p">;</span>
      <span class="n">expandInstruction</span><span class="p">(</span><span class="n">Inst</span><span class="p">,</span> <span class="n">IDLoc</span><span class="p">,</span> <span class="n">Instructions</span><span class="p">);</span>
      <span class="k">for</span><span class="p">(</span><span class="n">unsigned</span> <span class="n">i</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Instructions</span><span class="o">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">Out</span><span class="o">.</span><span class="n">emitInstruction</span><span class="p">(</span><span class="n">Instructions</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">getSTI</span><span class="p">());</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">Inst</span><span class="o">.</span><span class="n">setLoc</span><span class="p">(</span><span class="n">IDLoc</span><span class="p">);</span>
        <span class="n">Out</span><span class="o">.</span><span class="n">emitInstruction</span><span class="p">(</span><span class="n">Inst</span><span class="p">,</span> <span class="n">getSTI</span><span class="p">());</span>
      <span class="p">}</span>
    <span class="k">return</span> <span class="n">false</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Finally, remind that the CPURegs as below must follow the order of register
number because AsmParser uses them when do register number encoding.</p>
<p class="rubric">lbdex/chapters/Chapter11_1/Cpu0RegisterInfo.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">//</span> <span class="n">The</span> <span class="n">register</span> <span class="n">string</span><span class="p">,</span> <span class="n">such</span> <span class="k">as</span> <span class="s2">&quot;9&quot;</span> <span class="ow">or</span> <span class="s2">&quot;gp&quot;</span> <span class="n">will</span> <span class="n">show</span> <span class="n">on</span> <span class="s2">&quot;llvm-objdump -d&quot;</span>
<span class="o">//@</span> <span class="n">All</span> <span class="n">registers</span> <span class="n">definition</span>
<span class="n">let</span> <span class="n">Namespace</span> <span class="o">=</span> <span class="s2">&quot;Cpu0&quot;</span> <span class="ow">in</span> <span class="p">{</span>
  <span class="o">//@</span> <span class="n">General</span> <span class="n">Purpose</span> <span class="n">Registers</span>
  <span class="k">def</span> <span class="nf">ZERO</span> <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span>  <span class="s2">&quot;zero&quot;</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">AT</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span>  <span class="s2">&quot;1&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">V0</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span>  <span class="s2">&quot;2&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">V1</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span>  <span class="s2">&quot;3&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">A0</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">,</span>  <span class="s2">&quot;4&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">A1</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">,</span>  <span class="s2">&quot;5&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">T9</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">,</span>  <span class="s2">&quot;t9&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">T0</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">7</span><span class="p">,</span>  <span class="s2">&quot;7&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">T1</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span>  <span class="s2">&quot;8&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">S0</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">9</span><span class="p">,</span>  <span class="s2">&quot;9&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">S1</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">GP</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">11</span><span class="p">,</span> <span class="s2">&quot;gp&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">FP</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">12</span><span class="p">,</span> <span class="s2">&quot;fp&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">SP</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">13</span><span class="p">,</span> <span class="s2">&quot;sp&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">LR</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">14</span><span class="p">,</span> <span class="s2">&quot;lr&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">SW</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">15</span><span class="p">,</span> <span class="s2">&quot;sw&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="o">//</span>  <span class="k">def</span> <span class="nf">MAR</span>  <span class="p">:</span> <span class="n">Register</span><span class="o">&lt;</span> <span class="mi">16</span><span class="p">,</span> <span class="s2">&quot;mar&quot;</span><span class="o">&gt;</span><span class="p">,</span>  <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="o">//</span>  <span class="k">def</span> <span class="nf">MDR</span>  <span class="p">:</span> <span class="n">Register</span><span class="o">&lt;</span> <span class="mi">17</span><span class="p">,</span> <span class="s2">&quot;mdr&quot;</span><span class="o">&gt;</span><span class="p">,</span>  <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>

<span class="o">//</span><span class="c1">#if CH &gt;= CH4_1 1</span>
  <span class="o">//</span> <span class="n">Hi</span><span class="o">/</span><span class="n">Lo</span> <span class="n">registers</span> <span class="n">number</span> <span class="ow">and</span> <span class="n">name</span>
  <span class="k">def</span> <span class="nf">HI</span>   <span class="p">:</span> <span class="n">Cpu0Reg</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;ac0&quot;</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">18</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">LO</span>   <span class="p">:</span> <span class="n">Cpu0Reg</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;ac0&quot;</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="o">//</span><span class="c1">#endif</span>
  <span class="k">def</span> <span class="nf">PC</span>   <span class="p">:</span> <span class="n">Cpu0C0Reg</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;pc&quot;</span><span class="o">&gt;</span><span class="p">,</span>  <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">EPC</span>  <span class="p">:</span> <span class="n">Cpu0C0Reg</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;epc&quot;</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">21</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">//</span><span class="nd">@Register</span> <span class="n">Classes</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="k">def</span> <span class="nf">CPURegs</span> <span class="p">:</span> <span class="n">RegisterClass</span><span class="o">&lt;</span><span class="s2">&quot;Cpu0&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">i32</span><span class="p">],</span> <span class="mi">32</span><span class="p">,</span> <span class="p">(</span><span class="n">add</span>
  <span class="o">//</span> <span class="n">Reserved</span>
  <span class="n">ZERO</span><span class="p">,</span> <span class="n">AT</span><span class="p">,</span> 
  <span class="o">//</span> <span class="n">Return</span> <span class="n">Values</span> <span class="ow">and</span> <span class="n">Arguments</span>
  <span class="n">V0</span><span class="p">,</span> <span class="n">V1</span><span class="p">,</span> <span class="n">A0</span><span class="p">,</span> <span class="n">A1</span><span class="p">,</span> 
  <span class="o">//</span> <span class="n">Not</span> <span class="n">preserved</span> <span class="n">across</span> <span class="n">procedure</span> <span class="n">calls</span>
  <span class="n">T9</span><span class="p">,</span> <span class="n">T0</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span>
  <span class="o">//</span> <span class="n">Callee</span> <span class="n">save</span>
  <span class="n">S0</span><span class="p">,</span> <span class="n">S1</span><span class="p">,</span>
  <span class="o">//</span> <span class="n">Reserved</span>
  <span class="n">GP</span><span class="p">,</span> <span class="n">FP</span><span class="p">,</span> 
  <span class="n">SP</span><span class="p">,</span> <span class="n">LR</span><span class="p">,</span> <span class="n">SW</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>

</pre></div>
</div>
<p>Run Chapter11_1/ with ch11_1.cpp to get the correct result as follows,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/bin/llc
<span class="go">-march=cpu0 -relocation-model=pic -filetype=obj ch11_1.bc -o</span>
<span class="go">ch11_1.cpu0.o</span>
<span class="gp">JonathantekiiMac:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/bin/
<span class="go">llvm-objdump -d ch11_1.cpu0.o</span>

<span class="go">ch11_1.cpu0.o:  file format ELF32-unknown</span>

<span class="go">Disassembly of section .text:</span>
<span class="go">.text:</span>
<span class="go">       0:     01 2d 00 08                                     ld      $2, 8($sp)</span>
<span class="go">       4:     02 0d 00 04                                     st      $zero, 4($sp)</span>
<span class="go">       8:     09 30 00 00                                     addiu   $3, $zero, 0</span>
<span class="go">       c:     13 31 20 00                                     add     $3, $1, $2</span>
<span class="go">      10:     14 32 30 00                                     sub     $3, $2, $3</span>
<span class="go">      ...</span>
</pre></div>
</div>
<p>The instructions cmp and jeg printed with explicit $sw displayed in assembly
and disassembly. You can change the code in AsmParser and Dissassembly (the last
chapter) to hide the $sw printed in these instructions (such as “jeq 20”
rather than “jeq $sw, 20”).</p>
<p>Both AsmParser and Cpu0AsmParser inherited from MCAsmParser as follows,</p>
<p class="rubric">llvm/lib/MC/MCParser/AsmParser.cpp</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">AsmParser</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">MCAsmParser</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
</pre></div>
</div>
<p>AsmParser will call functions ParseInstruction() and MatchAndEmitInstruction()
of Cpu0AsmParser as follows,</p>
<p class="rubric">llvm/lib/MC/MCParser/AsmParser.cpp</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">AsmParser::parseStatement</span><span class="p">(</span><span class="n">ParseStatementInfo</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Info</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Directives start with &quot;.&quot;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IDVal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;.&#39;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">IDVal</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="s">&quot;.&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// First query the target-specific parser. It will return &#39;true&#39; if it</span>
<span class="w">    </span><span class="c1">// isn&#39;t interested in this directive.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">getTargetParser</span><span class="p">().</span><span class="n">ParseDirective</span><span class="p">(</span><span class="n">ID</span><span class="p">))</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">HadError</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getTargetParser</span><span class="p">().</span><span class="n">ParseInstruction</span><span class="p">(</span><span class="n">IInfo</span><span class="p">,</span><span class="w"> </span><span class="n">OpcodeStr</span><span class="p">,</span><span class="w"> </span><span class="n">IDLoc</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                     </span><span class="n">Info</span><span class="p">.</span><span class="n">ParsedOperands</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="c1">// If parsing succeeded, match the instruction.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">HadError</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">ErrorInfo</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">getTargetParser</span><span class="p">().</span><span class="n">MatchAndEmitInstruction</span><span class="p">(</span><span class="n">IDLoc</span><span class="p">,</span><span class="w"> </span><span class="n">Info</span><span class="p">.</span><span class="n">Opcode</span><span class="p">,</span><span class="w"></span>
<span class="w">                                              </span><span class="n">Info</span><span class="p">.</span><span class="n">ParsedOperands</span><span class="p">,</span><span class="w"> </span><span class="n">Out</span><span class="p">,</span><span class="w"></span>
<span class="w">                                              </span><span class="n">ErrorInfo</span><span class="p">,</span><span class="w"> </span><span class="n">ParsingInlineAsm</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The other functions in Cpu0AsmParser called as follows,</p>
<ul class="simple">
<li><p>ParseDirective() -&gt; parseDirectiveSet() -&gt; parseSetReorderDirective(), parseSetNoReorderDirective(), parseSetMacroDirective(), parseSetNoMacroDirective() -&gt; reportParseError()</p></li>
<li><p>ParseInstruction() -&gt; ParseOperand() -&gt; MatchOperandParserImpl() of Cpu0GenAsmMatcher.inc -&gt; tryCustomParseOperand() of Cpu0GenAsmMatcher.inc -&gt; parseMemOperand() -&gt; parseMemOffset(), tryParseRegisterOperand()</p></li>
<li><p>MatchAndEmitInstruction() -&gt; MatchInstructionImpl() of Cpu0GenAsmMatcher.inc, needsExpansion(), expandInstruction()</p></li>
<li><p>parseMemOffset() -&gt; parseRelocOperand() -&gt; getVariantKind()</p></li>
<li><p>tryParseRegisterOperand() -&gt; tryParseRegister() -&gt; matchRegisterName() -&gt; getReg()), matchRegisterByNumber()</p></li>
<li><p>expandInstruction() -&gt; expandLoadImm(), expandLoadAddressImm(), expandLoadAddressReg() -&gt; EmitInstruction() of Cpu0AsmPrint.cpp</p></li>
</ul>
</section>
</section>
<section id="inline-assembly">
<h2><a class="toc-backref" href="#id15" role="doc-backlink">Inline assembly</a><a class="headerlink" href="#inline-assembly" title="Permalink to this heading">¶</a></h2>
<p>Run Chapter11_1 with ch11_2 will get the following error.</p>
<p class="rubric">lbdex/input/ch11_2.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="s2">&quot;C&quot;</span> <span class="nb">int</span> <span class="n">printf</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="nb">format</span><span class="p">,</span> <span class="o">...</span><span class="p">);</span>
<span class="nb">int</span> <span class="n">inlineasm_addu</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">foo</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="n">const</span> <span class="nb">int</span> <span class="n">bar</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>

<span class="o">//</span>  <span class="n">call</span> <span class="n">i32</span> <span class="n">asm</span> <span class="n">sideeffect</span> <span class="s2">&quot;addu $0,$1,$2&quot;</span><span class="p">,</span> <span class="s2">&quot;=r,r,r&quot;</span><span class="p">(</span><span class="n">i32</span> <span class="o">%</span><span class="mi">1</span><span class="p">,</span> <span class="n">i32</span> <span class="o">%</span><span class="mi">2</span><span class="p">)</span> <span class="c1">#1, !srcloc !1</span>
  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s2">&quot;addu %0,%1,%2&quot;</span>
                       <span class="p">:</span><span class="s2">&quot;=r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="o">//</span> <span class="mi">5</span>
                       <span class="p">:</span><span class="s2">&quot;r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span> <span class="s2">&quot;r&quot;</span><span class="p">(</span><span class="n">bar</span><span class="p">)</span>
                       <span class="p">);</span>

  <span class="k">return</span> <span class="n">foo</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">inlineasm_longlong</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">long</span> <span class="n">long</span> <span class="n">bar</span> <span class="o">=</span> <span class="mh">0x0000000500000006</span><span class="p">;</span>
  <span class="nb">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">bar</span><span class="p">;</span>
<span class="o">//</span>  <span class="nb">int</span><span class="o">*</span> <span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="o">//</span> <span class="n">Do</span> <span class="ow">not</span> <span class="nb">set</span> <span class="n">q</span> <span class="n">here</span><span class="o">.</span>

<span class="o">//</span>  <span class="n">call</span> <span class="n">i32</span> <span class="n">asm</span> <span class="n">sideeffect</span> <span class="s2">&quot;ld $0,$1&quot;</span><span class="p">,</span> <span class="s2">&quot;=r,*m&quot;</span><span class="p">(</span><span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="mi">2</span><span class="p">)</span> <span class="c1">#2, !srcloc !2</span>
  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s2">&quot;ld %0,%1&quot;</span>
                       <span class="p">:</span><span class="s2">&quot;=r&quot;</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">//</span> <span class="mh">0x700070007000700b</span>
                       <span class="p">:</span><span class="s2">&quot;m&quot;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span>
                       <span class="p">);</span>
  <span class="nb">int</span><span class="o">*</span> <span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="o">//</span> <span class="n">Set</span> <span class="n">q</span> <span class="n">just</span> <span class="n">before</span> <span class="n">inline</span> <span class="n">asm</span> <span class="n">refer</span> <span class="n">to</span> <span class="n">avoid</span> <span class="n">register</span> <span class="n">clobbered</span><span class="o">.</span> 
<span class="o">//</span>  <span class="n">call</span> <span class="n">i32</span> <span class="n">asm</span> <span class="n">sideeffect</span> <span class="s2">&quot;ld $0,$1&quot;</span><span class="p">,</span> <span class="s2">&quot;=r,*m&quot;</span><span class="p">(</span><span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="mi">6</span><span class="p">)</span> <span class="c1">#2, !srcloc !3</span>
  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s2">&quot;ld %0,%1&quot;</span>
                       <span class="p">:</span><span class="s2">&quot;=r&quot;</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">//</span> <span class="mi">11</span>
                       <span class="p">:</span><span class="s2">&quot;m&quot;</span><span class="p">(</span><span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="o">//</span>              <span class="n">Or</span> <span class="n">use</span> <span class="p">:</span><span class="s2">&quot;m&quot;</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="n">to</span> <span class="n">avoid</span> <span class="n">register</span> <span class="n">clobbered</span><span class="o">.</span> 
                       <span class="p">);</span>

  <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">inlineasm_constraint</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">foo</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="n">const</span> <span class="nb">int</span> <span class="n">n_5</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span><span class="p">;</span>
  <span class="n">const</span> <span class="nb">int</span> <span class="n">n5</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="n">const</span> <span class="nb">int</span> <span class="n">n0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">un5</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="n">const</span> <span class="nb">int</span> <span class="n">n65536</span> <span class="o">=</span> <span class="mh">0x10000</span><span class="p">;</span>
  <span class="n">const</span> <span class="nb">int</span> <span class="n">n_65531</span> <span class="o">=</span> <span class="o">-</span><span class="mi">65531</span><span class="p">;</span>

<span class="o">//</span>   <span class="n">call</span> <span class="n">i32</span> <span class="n">asm</span> <span class="n">sideeffect</span> <span class="s2">&quot;addiu $0,$1,$2&quot;</span><span class="p">,</span> <span class="s2">&quot;=r,r,I&quot;</span><span class="p">(</span><span class="n">i32</span> <span class="o">%</span><span class="mi">1</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">15</span><span class="p">)</span> <span class="c1">#1, !srcloc !2</span>
  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s2">&quot;addiu %0,%1,%2&quot;</span>
                       <span class="p">:</span><span class="s2">&quot;=r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="o">//</span> <span class="mi">15</span>
                       <span class="p">:</span><span class="s2">&quot;r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span> <span class="s2">&quot;I&quot;</span><span class="p">(</span><span class="n">n_5</span><span class="p">)</span>
                       <span class="p">);</span>

  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s2">&quot;addiu %0,%1,%2&quot;</span>
                       <span class="p">:</span><span class="s2">&quot;=r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="o">//</span> <span class="mi">15</span>
                       <span class="p">:</span><span class="s2">&quot;r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span> <span class="s2">&quot;J&quot;</span><span class="p">(</span><span class="n">n0</span><span class="p">)</span>
                       <span class="p">);</span>

  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s2">&quot;addiu %0,%1,%2&quot;</span>
                       <span class="p">:</span><span class="s2">&quot;=r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="o">//</span> <span class="mi">10</span>
                       <span class="p">:</span><span class="s2">&quot;r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span> <span class="s2">&quot;K&quot;</span><span class="p">(</span><span class="n">n5</span><span class="p">)</span>
                       <span class="p">);</span>

  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s2">&quot;ori %0,%1,%2&quot;</span>
                       <span class="p">:</span><span class="s2">&quot;=r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="o">//</span> <span class="mi">10</span>
                       <span class="p">:</span><span class="s2">&quot;r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span> <span class="s2">&quot;L&quot;</span><span class="p">(</span><span class="n">n65536</span><span class="p">)</span> <span class="o">//</span> <span class="mh">0x10000</span> <span class="o">=</span> <span class="mi">65536</span>
                       <span class="p">);</span>

  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s2">&quot;addiu %0,%1,%2&quot;</span>
                       <span class="p">:</span><span class="s2">&quot;=r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="o">//</span> <span class="mi">15</span>
                       <span class="p">:</span><span class="s2">&quot;r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span> <span class="s2">&quot;N&quot;</span><span class="p">(</span><span class="n">n_65531</span><span class="p">)</span>
                       <span class="p">);</span>

  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s2">&quot;addiu %0,%1,%2&quot;</span>
                       <span class="p">:</span><span class="s2">&quot;=r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="o">//</span> <span class="mi">10</span>
                       <span class="p">:</span><span class="s2">&quot;r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span> <span class="s2">&quot;O&quot;</span><span class="p">(</span><span class="n">n_5</span><span class="p">)</span>
                       <span class="p">);</span>

  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s2">&quot;addiu %0,%1,%2&quot;</span>
                       <span class="p">:</span><span class="s2">&quot;=r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="o">//</span> <span class="mi">15</span>
                       <span class="p">:</span><span class="s2">&quot;r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span> <span class="s2">&quot;P&quot;</span><span class="p">(</span><span class="n">un5</span><span class="p">)</span>
                       <span class="p">);</span>

  <span class="k">return</span> <span class="n">foo</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">inlineasm_arg</span><span class="p">(</span><span class="nb">int</span> <span class="n">u</span><span class="p">,</span> <span class="nb">int</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">w</span><span class="p">;</span>

  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s2">&quot;subu %0,%1,%2&quot;</span>
                       <span class="p">:</span><span class="s2">&quot;=r&quot;</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                       <span class="p">:</span><span class="s2">&quot;r&quot;</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="s2">&quot;r&quot;</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                       <span class="p">);</span>

  <span class="k">return</span> <span class="n">w</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">g</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span>

<span class="nb">int</span> <span class="n">inlineasm_global</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">;</span>
  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s2">&quot;ld %0,%1&quot;</span>
                       <span class="p">:</span><span class="s2">&quot;=r&quot;</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">//</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span>
                       <span class="p">:</span><span class="s2">&quot;m&quot;</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                       <span class="p">);</span>

  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s2">&quot;addiu %0,%1,1&quot;</span>
                       <span class="p">:</span><span class="s2">&quot;=r&quot;</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">//</span> <span class="n">d</span><span class="o">=</span><span class="mi">4</span>
                       <span class="p">:</span><span class="s2">&quot;r&quot;</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                       <span class="p">);</span>

  <span class="k">return</span> <span class="n">d</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">#ifdef TESTSOFTFLOATLIB</span>
<span class="o">//</span> <span class="n">test_float</span><span class="p">()</span> <span class="n">will</span> <span class="n">call</span> <span class="n">soft</span> <span class="nb">float</span> <span class="n">library</span>
<span class="nb">int</span> <span class="n">inlineasm_float</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">float</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">2.2</span><span class="p">;</span>
  <span class="nb">float</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">3.3</span><span class="p">;</span>
  
  <span class="nb">int</span> <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">);</span>

  <span class="nb">int</span> <span class="n">d</span><span class="p">;</span>
  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s2">&quot;addiu %0,%1,1&quot;</span>
                       <span class="p">:</span><span class="s2">&quot;=r&quot;</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                       <span class="p">:</span><span class="s2">&quot;r&quot;</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                       <span class="p">);</span>

  <span class="k">return</span> <span class="n">d</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">#endif</span>

<span class="nb">int</span> <span class="n">test_inlineasm</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">;</span>

  <span class="n">a</span> <span class="o">=</span> <span class="n">inlineasm_addu</span><span class="p">();</span> <span class="o">//</span> <span class="mi">25</span>
  <span class="n">b</span> <span class="o">=</span> <span class="n">inlineasm_longlong</span><span class="p">();</span> <span class="o">//</span> <span class="mi">11</span>
  <span class="n">c</span> <span class="o">=</span> <span class="n">inlineasm_constraint</span><span class="p">();</span> <span class="o">//</span> <span class="mi">15</span>
  <span class="n">d</span> <span class="o">=</span> <span class="n">inlineasm_arg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span> <span class="o">//</span> <span class="o">-</span><span class="mi">9</span>
  <span class="n">e</span> <span class="o">=</span> <span class="n">inlineasm_arg</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="o">//</span> <span class="mi">3</span>
  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s2">&quot;addiu %0,%1,1&quot;</span>
                       <span class="p">:</span><span class="s2">&quot;=r&quot;</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">//</span> <span class="n">e</span><span class="o">=</span><span class="mi">4</span>
                       <span class="p">:</span><span class="s2">&quot;r&quot;</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                       <span class="p">);</span>

  <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="n">c</span><span class="o">+</span><span class="n">d</span><span class="o">+</span><span class="n">e</span><span class="o">+</span><span class="n">f</span><span class="p">);</span> <span class="o">//</span> <span class="mi">25</span><span class="o">+</span><span class="mi">11</span><span class="o">+</span><span class="mi">15</span><span class="o">-</span><span class="mi">9</span><span class="o">+</span><span class="mi">3</span><span class="o">+</span><span class="mi">4</span><span class="o">=</span><span class="mi">49</span>
<span class="p">}</span>

</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">1-160-129-73:input Jonathan$ </span>~/llvm/test/build/bin/llc
<span class="go">-march=cpu0 -relocation-model=static -filetype=asm ch11_2.bc -o -</span>
<span class="go">  .section .mdebug.abi32</span>
<span class="go">  .previous</span>
<span class="go">  .file &quot;ch11_2.bc&quot;</span>
<span class="go">error: couldn&#39;t allocate output register for constraint &#39;r&#39;</span>
</pre></div>
</div>
<p>The ch11_2.cpp is a inline assembly example. The clang supports inline
assembly like gcc.
The inline assembly used in C/C++ when program need to access the
specific allocated register or memory for the C/C++ variable. For example, the
variable foo of ch11_2.cpp may be allocated by compiler to register $2, $3
or any other register.
The inline assembly fills the gap between high level language and
assembly language. Reference here <a class="footnote-reference brackets" href="#id5" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>. Chapter11_2 supports inline assembly
as follows,</p>
<p class="rubric">lbdex/chapters/Chapter11_2/Cpu0AsmPrinter.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="nb">bool</span> <span class="n">PrintAsmOperand</span><span class="p">(</span><span class="n">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">OpNo</span><span class="p">,</span>
                       <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">ExtraCode</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">)</span> <span class="n">override</span><span class="p">;</span>
  <span class="nb">bool</span> <span class="n">PrintAsmMemoryOperand</span><span class="p">(</span><span class="n">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">OpNum</span><span class="p">,</span>
                             <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">ExtraCode</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">)</span> <span class="n">override</span><span class="p">;</span>
  <span class="n">void</span> <span class="n">printOperand</span><span class="p">(</span><span class="n">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="nb">int</span> <span class="n">opNum</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_2/Cpu0AsmPrinter.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// Print out an operand for an inline asm expression.
bool Cpu0AsmPrinter::PrintAsmOperand(const MachineInstr *MI, unsigned OpNum,
                                     const char *ExtraCode, raw_ostream &amp;O) {
  // Does this asm operand have a single letter operand modifier?
  if (ExtraCode &amp;&amp; ExtraCode[0]) {
    if (ExtraCode[1] != 0) return true; // Unknown modifier.

    const MachineOperand &amp;MO = MI-&gt;getOperand(OpNum);
    switch (ExtraCode[0]) {
    default:
      // See if this is a generic print operand
      return AsmPrinter::PrintAsmOperand(MI,OpNum, ExtraCode,O);
    case &#39;X&#39;: // hex const int
      if ((MO.getType()) != MachineOperand::MO_Immediate)
        return true;
      O &lt;&lt; &quot;0x&quot; &lt;&lt; StringRef(utohexstr(MO.getImm())).lower();
      return false;
    case &#39;x&#39;: // hex const int (low 16 bits)
      if ((MO.getType()) != MachineOperand::MO_Immediate)
        return true;
      O &lt;&lt; &quot;0x&quot; &lt;&lt; StringRef(utohexstr(MO.getImm() &amp; 0xffff)).lower();
      return false;
    case &#39;d&#39;: // decimal const int
      if ((MO.getType()) != MachineOperand::MO_Immediate)
        return true;
      O &lt;&lt; MO.getImm();
      return false;
    case &#39;m&#39;: // decimal const int minus 1
      if ((MO.getType()) != MachineOperand::MO_Immediate)
        return true;
      O &lt;&lt; MO.getImm() - 1;
      return false;
    case &#39;z&#39;: {
      // $0 if zero, regular printing otherwise
      if (MO.getType() != MachineOperand::MO_Immediate)
        return true;
      int64_t Val = MO.getImm();
      if (Val)
        O &lt;&lt; Val;
      else
        O &lt;&lt; &quot;$0&quot;;
      return false;
    }
    }
  }

  printOperand(MI, OpNum, O);
  return false;
}

bool Cpu0AsmPrinter::PrintAsmMemoryOperand(const MachineInstr *MI,
                                           unsigned OpNum,
                                           const char *ExtraCode,
                                           raw_ostream &amp;O) {
  int Offset = 0;
  // Currently we are expecting either no ExtraCode or &#39;D&#39;
  if (ExtraCode) {
    return true; // Unknown modifier.
  }

  const MachineOperand &amp;MO = MI-&gt;getOperand(OpNum);
  assert(MO.isReg() &amp;&amp; &quot;unexpected inline asm memory operand&quot;);
  O &lt;&lt; Offset &lt;&lt; &quot;($&quot; &lt;&lt; Cpu0InstPrinter::getRegisterName(MO.getReg()) &lt;&lt; &quot;)&quot;;

  return false;
}

void Cpu0AsmPrinter::printOperand(const MachineInstr *MI, int opNum,
                                  raw_ostream &amp;O) {
  const MachineOperand &amp;MO = MI-&gt;getOperand(opNum);
  bool closeP = false;

  if (MO.getTargetFlags())
    closeP = true;

  switch(MO.getTargetFlags()) {
  case Cpu0II::MO_GPREL:    O &lt;&lt; &quot;%gp_rel(&quot;; break;
  case Cpu0II::MO_GOT_CALL: O &lt;&lt; &quot;%call16(&quot;; break;
  case Cpu0II::MO_GOT:      O &lt;&lt; &quot;%got(&quot;;    break;
  case Cpu0II::MO_ABS_HI:   O &lt;&lt; &quot;%hi(&quot;;     break;
  case Cpu0II::MO_ABS_LO:   O &lt;&lt; &quot;%lo(&quot;;     break;
  case Cpu0II::MO_GOT_HI16: O &lt;&lt; &quot;%got_hi16(&quot;; break;
  case Cpu0II::MO_GOT_LO16: O &lt;&lt; &quot;%got_lo16(&quot;; break;
  }

  switch (MO.getType()) {
    case MachineOperand::MO_Register:
      O &lt;&lt; &#39;$&#39;
        &lt;&lt; StringRef(Cpu0InstPrinter::getRegisterName(MO.getReg())).lower();
      break;

    case MachineOperand::MO_Immediate:
      O &lt;&lt; MO.getImm();
      break;

    case MachineOperand::MO_MachineBasicBlock:
      O &lt;&lt; *MO.getMBB()-&gt;getSymbol();
      return;

    case MachineOperand::MO_GlobalAddress:
      O &lt;&lt; *getSymbol(MO.getGlobal());
      break;

    case MachineOperand::MO_BlockAddress: {
      MCSymbol *BA = GetBlockAddressSymbol(MO.getBlockAddress());
      O &lt;&lt; BA-&gt;getName();
      break;
    }

    case MachineOperand::MO_ExternalSymbol:
      O &lt;&lt; *GetExternalSymbolSymbol(MO.getSymbolName());
      break;

    case MachineOperand::MO_JumpTableIndex:
      O &lt;&lt; MAI-&gt;getPrivateGlobalPrefix() &lt;&lt; &quot;JTI&quot; &lt;&lt; getFunctionNumber()
        &lt;&lt; &#39;_&#39; &lt;&lt; MO.getIndex();
      break;

    case MachineOperand::MO_ConstantPoolIndex:
      O &lt;&lt; MAI-&gt;getPrivateGlobalPrefix() &lt;&lt; &quot;CPI&quot;
        &lt;&lt; getFunctionNumber() &lt;&lt; &quot;_&quot; &lt;&lt; MO.getIndex();
      if (MO.getOffset())
        O &lt;&lt; &quot;+&quot; &lt;&lt; MO.getOffset();
      break;

    default:
      llvm_unreachable(&quot;&lt;unknown operand type&gt;&quot;);
  }

  if (closeP) O &lt;&lt; &quot;)&quot;;
}
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_2/Cpu0InstrInfo.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">///</span> <span class="n">Return</span> <span class="n">the</span> <span class="n">number</span> <span class="n">of</span> <span class="nb">bytes</span> <span class="n">of</span> <span class="n">code</span> <span class="n">the</span> <span class="n">specified</span> <span class="n">instruction</span> <span class="n">may</span> <span class="n">be</span><span class="o">.</span>
<span class="n">unsigned</span> <span class="n">Cpu0InstrInfo</span><span class="p">::</span><span class="n">GetInstSizeInBytes</span><span class="p">(</span><span class="n">const</span> <span class="n">MachineInstr</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">case</span>  <span class="n">TargetOpcode</span><span class="p">::</span><span class="n">INLINEASM</span><span class="p">:</span> <span class="p">{</span>       <span class="o">//</span> <span class="n">Inline</span> <span class="n">Asm</span><span class="p">:</span> <span class="n">Variable</span> <span class="n">size</span><span class="o">.</span>
    <span class="n">const</span> <span class="n">MachineFunction</span> <span class="o">*</span><span class="n">MF</span> <span class="o">=</span> <span class="n">MI</span><span class="o">.</span><span class="n">getParent</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">();</span>
    <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">AsmStr</span> <span class="o">=</span> <span class="n">MI</span><span class="o">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">getSymbolName</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">getInlineAsmLength</span><span class="p">(</span><span class="n">AsmStr</span><span class="p">,</span> <span class="o">*</span><span class="n">MF</span><span class="o">-&gt;</span><span class="n">getTarget</span><span class="p">()</span><span class="o">.</span><span class="n">getMCAsmInfo</span><span class="p">());</span>
  <span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_2/Cpu0ISelDAGToDAG.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="nb">bool</span> <span class="n">SelectInlineAsmMemoryOperand</span><span class="p">(</span><span class="n">const</span> <span class="n">SDValue</span> <span class="o">&amp;</span><span class="n">Op</span><span class="p">,</span>
                                    <span class="n">unsigned</span> <span class="n">ConstraintID</span><span class="p">,</span>
                                    <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">OutOps</span><span class="p">)</span> <span class="n">override</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_2/Cpu0ISelDAGToDAG.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">inlineasm</span> <span class="n">begin</span>
<span class="nb">bool</span> <span class="n">Cpu0DAGToDAGISel</span><span class="p">::</span>
<span class="n">SelectInlineAsmMemoryOperand</span><span class="p">(</span><span class="n">const</span> <span class="n">SDValue</span> <span class="o">&amp;</span><span class="n">Op</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">ConstraintID</span><span class="p">,</span>
                             <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">OutOps</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">//</span> <span class="n">All</span> <span class="n">memory</span> <span class="n">constraints</span> <span class="n">can</span> <span class="n">at</span> <span class="n">least</span> <span class="n">accept</span> <span class="n">raw</span> <span class="n">pointers</span><span class="o">.</span>
  <span class="n">switch</span><span class="p">(</span><span class="n">ConstraintID</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">default</span><span class="p">:</span>
    <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s2">&quot;Unexpected asm memory constraint&quot;</span><span class="p">);</span>
  <span class="k">case</span> <span class="n">InlineAsm</span><span class="p">::</span><span class="n">Constraint_m</span><span class="p">:</span>
    <span class="n">OutOps</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Op</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="o">//</span> <span class="n">inlineasm</span> <span class="n">end</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_2/Cpu0ISelLowering.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="o">//</span> <span class="n">Inline</span> <span class="n">asm</span> <span class="n">support</span>
    <span class="n">ConstraintType</span> <span class="n">getConstraintType</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">Constraint</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span><span class="p">;</span>

    <span class="o">///</span> <span class="n">Examine</span> <span class="n">constraint</span> <span class="n">string</span> <span class="ow">and</span> <span class="n">operand</span> <span class="nb">type</span> <span class="ow">and</span> <span class="n">determine</span> <span class="n">a</span> <span class="n">weight</span> <span class="n">value</span><span class="o">.</span>
    <span class="o">///</span> <span class="n">The</span> <span class="n">operand</span> <span class="nb">object</span> <span class="n">must</span> <span class="n">already</span> <span class="n">have</span> <span class="n">been</span> <span class="nb">set</span> <span class="n">up</span> <span class="k">with</span> <span class="n">the</span> <span class="n">operand</span> <span class="nb">type</span><span class="o">.</span>
    <span class="n">ConstraintWeight</span> <span class="n">getSingleConstraintMatchWeight</span><span class="p">(</span>
      <span class="n">AsmOperandInfo</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">constraint</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span><span class="p">;</span>

    <span class="o">///</span> <span class="n">This</span> <span class="n">function</span> <span class="n">parses</span> <span class="n">registers</span> <span class="n">that</span> <span class="n">appear</span> <span class="ow">in</span> <span class="n">inline</span><span class="o">-</span><span class="n">asm</span> <span class="n">constraints</span><span class="o">.</span>
    <span class="o">///</span> <span class="n">It</span> <span class="n">returns</span> <span class="n">pair</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="n">on</span> <span class="n">failure</span><span class="o">.</span>
    <span class="n">std</span><span class="p">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">unsigned</span><span class="p">,</span> <span class="n">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*&gt;</span>
    <span class="n">parseRegForInlineAsmConstraint</span><span class="p">(</span><span class="n">const</span> <span class="n">StringRef</span> <span class="o">&amp;</span><span class="n">C</span><span class="p">,</span> <span class="n">MVT</span> <span class="n">VT</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>

    <span class="n">std</span><span class="p">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">unsigned</span><span class="p">,</span> <span class="n">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*&gt;</span>
    <span class="n">getRegForInlineAsmConstraint</span><span class="p">(</span><span class="n">const</span> <span class="n">TargetRegisterInfo</span> <span class="o">*</span><span class="n">TRI</span><span class="p">,</span>
                                 <span class="n">StringRef</span> <span class="n">Constraint</span><span class="p">,</span> <span class="n">MVT</span> <span class="n">VT</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span><span class="p">;</span>

    <span class="o">///</span> <span class="n">LowerAsmOperandForConstraint</span> <span class="o">-</span> <span class="n">Lower</span> <span class="n">the</span> <span class="n">specified</span> <span class="n">operand</span> <span class="n">into</span> <span class="n">the</span> <span class="n">Ops</span>
    <span class="o">///</span> <span class="n">vector</span><span class="o">.</span>  <span class="n">If</span> <span class="n">it</span> <span class="ow">is</span> <span class="n">invalid</span><span class="p">,</span> <span class="n">don</span><span class="s1">&#39;t add anything to Ops. If hasMemory is</span>
    <span class="o">///</span> <span class="n">true</span> <span class="n">it</span> <span class="n">means</span> <span class="n">one</span> <span class="n">of</span> <span class="n">the</span> <span class="n">asm</span> <span class="n">constraint</span> <span class="n">of</span> <span class="n">the</span> <span class="n">inline</span> <span class="n">asm</span> <span class="n">instruction</span>
    <span class="o">///</span> <span class="n">being</span> <span class="n">processed</span> <span class="ow">is</span> <span class="s1">&#39;m&#39;</span><span class="o">.</span>
    <span class="n">void</span> <span class="n">LowerAsmOperandForConstraint</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span>
                                      <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">Constraint</span><span class="p">,</span>
                                      <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ops</span><span class="p">,</span>
                                      <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span><span class="p">;</span>

    <span class="nb">bool</span> <span class="n">isLegalAddressingMode</span><span class="p">(</span><span class="n">const</span> <span class="n">DataLayout</span> <span class="o">&amp;</span><span class="n">DL</span><span class="p">,</span> <span class="n">const</span> <span class="n">AddrMode</span> <span class="o">&amp;</span><span class="n">AM</span><span class="p">,</span>
                               <span class="n">Type</span> <span class="o">*</span><span class="n">Ty</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">AS</span><span class="p">,</span>
                               <span class="n">Instruction</span> <span class="o">*</span><span class="n">I</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_2/Cpu0ISelLowering.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>//===----------------------------------------------------------------------===//
//                           Cpu0 Inline Assembly Support
//===----------------------------------------------------------------------===//

/// getConstraintType - Given a constraint letter, return the type of
/// constraint it is for this target.
Cpu0TargetLowering::ConstraintType 
Cpu0TargetLowering::getConstraintType(StringRef Constraint) const
{
  // Cpu0 specific constraints
  // GCC config/mips/constraints.md
  // &#39;c&#39; : A register suitable for use in an indirect
  //       jump. This will always be $t9 for -mabicalls.
  if (Constraint.size() == 1) {
    switch (Constraint[0]) {
      default : break;
      case &#39;c&#39;:
        return C_RegisterClass;
      case &#39;R&#39;:
        return C_Memory;
    }
  }
  return TargetLowering::getConstraintType(Constraint);
}

/// Examine constraint type and operand type and determine a weight value.
/// This object must already have been set up with the operand type
/// and the current alternative constraint selected.
TargetLowering::ConstraintWeight
Cpu0TargetLowering::getSingleConstraintMatchWeight(
    AsmOperandInfo &amp;info, const char *constraint) const {
  ConstraintWeight weight = CW_Invalid;
  Value *CallOperandVal = info.CallOperandVal;
    // If we don&#39;t have a value, we can&#39;t do a match,
    // but allow it at the lowest weight.
  if (!CallOperandVal)
    return CW_Default;
  Type *type = CallOperandVal-&gt;getType();
  // Look at the constraint type.
  switch (*constraint) {
  default:
    weight = TargetLowering::getSingleConstraintMatchWeight(info, constraint);
    break;
  case &#39;c&#39;: // $t9 for indirect jumps
    if (type-&gt;isIntegerTy())
      weight = CW_SpecificReg;
    break;
  case &#39;I&#39;: // signed 16 bit immediate
  case &#39;J&#39;: // integer zero
  case &#39;K&#39;: // unsigned 16 bit immediate
  case &#39;L&#39;: // signed 32 bit immediate where lower 16 bits are 0
  case &#39;N&#39;: // immediate in the range of -65535 to -1 (inclusive)
  case &#39;O&#39;: // signed 15 bit immediate (+- 16383)
  case &#39;P&#39;: // immediate in the range of 65535 to 1 (inclusive)
    if (isa&lt;ConstantInt&gt;(CallOperandVal))
      weight = CW_Constant;
    break;
  case &#39;R&#39;:
    weight = CW_Memory;
    break;
  }
  return weight;
}

/// This is a helper function to parse a physical register string and split it
/// into non-numeric and numeric parts (Prefix and Reg). The first boolean flag
/// that is returned indicates whether parsing was successful. The second flag
/// is true if the numeric part exists.
static std::pair&lt;bool, bool&gt;
parsePhysicalReg(const StringRef &amp;C, std::string &amp;Prefix,
                 unsigned long long &amp;Reg) {
  if (C.front() != &#39;{&#39; || C.back() != &#39;}&#39;)
    return std::make_pair(false, false);

  // Search for the first numeric character.
  StringRef::const_iterator I, B = C.begin() + 1, E = C.end() - 1;
  I = std::find_if(B, E, isdigit);

  Prefix.assign(B, I - B);

  // The second flag is set to false if no numeric characters were found.
  if (I == E)
    return std::make_pair(true, false);

  // Parse the numeric characters.
  return std::make_pair(!getAsUnsignedInteger(StringRef(I, E - I), 10, Reg),
                        true);
}

std::pair&lt;unsigned, const TargetRegisterClass *&gt; Cpu0TargetLowering::
parseRegForInlineAsmConstraint(const StringRef &amp;C, MVT VT) const {
  const TargetRegisterClass *RC;
  std::string Prefix;
  unsigned long long Reg;

  std::pair&lt;bool, bool&gt; R = parsePhysicalReg(C, Prefix, Reg);

  if (!R.first)
    return std::make_pair(0U, nullptr);
  if (!R.second)
    return std::make_pair(0U, nullptr);

 // Parse $0-$15.
  assert(Prefix == &quot;$&quot;);
  RC = getRegClassFor((VT == MVT::Other) ? MVT::i32 : VT);

  assert(Reg &lt; RC-&gt;getNumRegs());
  return std::make_pair(*(RC-&gt;begin() + Reg), RC);
}

/// Given a register class constraint, like &#39;r&#39;, if this corresponds directly
/// to an LLVM register class, return a register of 0 and the register class
/// pointer.
std::pair&lt;unsigned, const TargetRegisterClass *&gt;
Cpu0TargetLowering::getRegForInlineAsmConstraint(const TargetRegisterInfo *TRI,
                                                 StringRef Constraint,
                                                 MVT VT) const
{
  if (Constraint.size() == 1) {
    switch (Constraint[0]) {
    case &#39;r&#39;:
      if (VT == MVT::i32 || VT == MVT::i16 || VT == MVT::i8) {
        return std::make_pair(0U, &amp;Cpu0::CPURegsRegClass);
      }
      if (VT == MVT::i64)
        return std::make_pair(0U, &amp;Cpu0::CPURegsRegClass);
      // This will generate an error message
      return std::make_pair(0u, static_cast&lt;const TargetRegisterClass*&gt;(0));
    case &#39;c&#39;: // register suitable for indirect jump
      if (VT == MVT::i32)
        return std::make_pair((unsigned)Cpu0::T9, &amp;Cpu0::CPURegsRegClass);
      assert(0 &amp;&amp; &quot;Unexpected type.&quot;);
    }
  }

  std::pair&lt;unsigned, const TargetRegisterClass *&gt; R;
  R = parseRegForInlineAsmConstraint(Constraint, VT);

  if (R.second)
    return R;

  return TargetLowering::getRegForInlineAsmConstraint(TRI, Constraint, VT);
}

/// LowerAsmOperandForConstraint - Lower the specified operand into the Ops
/// vector.  If it is invalid, don&#39;t add anything to Ops.
void Cpu0TargetLowering::LowerAsmOperandForConstraint(SDValue Op,
                                                     std::string &amp;Constraint,
                                                     std::vector&lt;SDValue&gt;&amp;Ops,
                                                     SelectionDAG &amp;DAG) const {
  SDLoc DL(Op);
  SDValue Result;

  // Only support length 1 constraints for now.
  if (Constraint.length() &gt; 1) return;

  char ConstraintLetter = Constraint[0];
  switch (ConstraintLetter) {
  default: break; // This will fall through to the generic implementation
  case &#39;I&#39;: // Signed 16 bit constant
    // If this fails, the parent routine will give an error
    if (ConstantSDNode *C = dyn_cast&lt;ConstantSDNode&gt;(Op)) {
      EVT Type = Op.getValueType();
      int64_t Val = C-&gt;getSExtValue();
      if (isInt&lt;16&gt;(Val)) {
        Result = DAG.getTargetConstant(Val, DL, Type);
        break;
      }
    }
    return;
  case &#39;J&#39;: // integer zero
    if (ConstantSDNode *C = dyn_cast&lt;ConstantSDNode&gt;(Op)) {
      EVT Type = Op.getValueType();
      int64_t Val = C-&gt;getZExtValue();
      if (Val == 0) {
        Result = DAG.getTargetConstant(0, DL, Type);
        break;
      }
    }
    return;
  case &#39;K&#39;: // unsigned 16 bit immediate
    if (ConstantSDNode *C = dyn_cast&lt;ConstantSDNode&gt;(Op)) {
      EVT Type = Op.getValueType();
      uint64_t Val = (uint64_t)C-&gt;getZExtValue();
      if (isUInt&lt;16&gt;(Val)) {
        Result = DAG.getTargetConstant(Val, DL, Type);
        break;
      }
    }
    return;
  case &#39;L&#39;: // signed 32 bit immediate where lower 16 bits are 0
    if (ConstantSDNode *C = dyn_cast&lt;ConstantSDNode&gt;(Op)) {
      EVT Type = Op.getValueType();
      int64_t Val = C-&gt;getSExtValue();
      if ((isInt&lt;32&gt;(Val)) &amp;&amp; ((Val &amp; 0xffff) == 0)){
        Result = DAG.getTargetConstant(Val, DL, Type);
        break;
      }
    }
    return;
  case &#39;N&#39;: // immediate in the range of -65535 to -1 (inclusive)
    if (ConstantSDNode *C = dyn_cast&lt;ConstantSDNode&gt;(Op)) {
      EVT Type = Op.getValueType();
      int64_t Val = C-&gt;getSExtValue();
      if ((Val &gt;= -65535) &amp;&amp; (Val &lt;= -1)) {
        Result = DAG.getTargetConstant(Val, DL, Type);
        break;
      }
    }
    return;
  case &#39;O&#39;: // signed 15 bit immediate
    if (ConstantSDNode *C = dyn_cast&lt;ConstantSDNode&gt;(Op)) {
      EVT Type = Op.getValueType();
      int64_t Val = C-&gt;getSExtValue();
      if ((isInt&lt;15&gt;(Val))) {
        Result = DAG.getTargetConstant(Val, DL, Type);
        break;
      }
    }
    return;
  case &#39;P&#39;: // immediate in the range of 1 to 65535 (inclusive)
    if (ConstantSDNode *C = dyn_cast&lt;ConstantSDNode&gt;(Op)) {
      EVT Type = Op.getValueType();
      int64_t Val = C-&gt;getSExtValue();
      if ((Val &lt;= 65535) &amp;&amp; (Val &gt;= 1)) {
        Result = DAG.getTargetConstant(Val, DL, Type);
        break;
      }
    }
    return;
  }

  if (Result.getNode()) {
    Ops.push_back(Result);
    return;
  }

  TargetLowering::LowerAsmOperandForConstraint(Op, Constraint, Ops, DAG);
}

bool Cpu0TargetLowering::isLegalAddressingMode(const DataLayout &amp;DL,
                                               const AddrMode &amp;AM, Type *Ty,
                                               unsigned AS, Instruction *I) const {
  // No global is ever allowed as a base.
  if (AM.BaseGV)
    return false;

  switch (AM.Scale) {
  case 0: // &quot;r+i&quot; or just &quot;i&quot;, depending on HasBaseReg.
    break;
  case 1:
    if (!AM.HasBaseReg) // allow &quot;r+i&quot;.
      break;
    return false; // disallow &quot;r+r&quot; or &quot;r+r+i&quot;.
  default:
    return false;
  }

  return true;
}
</pre></div>
</div>
<p>Same with backend structure, the structure of inline assembly can be divided by
file name as Table: the structure of inline assembly.</p>
<table class="docutils align-default" id="id11">
<caption><span class="caption-number">Table 37 </span><span class="caption-text">inline assembly functions</span><a class="headerlink" href="#id11" title="Permalink to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>File</p></th>
<th class="head"><p>Function</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Cpu0ISelLowering.cpp</p></td>
<td><p>inline asm DAG node create</p></td>
</tr>
<tr class="row-odd"><td><p>Cpu0ISelDAGToDAG.cpp</p></td>
<td><p>save OP code</p></td>
</tr>
<tr class="row-even"><td><p>Cpu0AsmPrinter.cpp,</p></td>
<td><p>inline asm instructions printing</p></td>
</tr>
<tr class="row-odd"><td><p>Cpu0InstrInfo.cpp</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Except Cpu0ISelDAGToDAG.cpp, the other functions are same with backend’s compile
code.
The Cpu0ISelLowering.cpp inline asm is explained after the result of running
with ch11_2.cpp.
Cpu0ISelDAGToDAG.cpp just save OP code in SelectInlineAsmMemoryOperand().
Since the the OP code is Cpu0 inline assembly instruction,
no llvm IR DAG translation needed further, just save OP
directly and return false to notify llvm system that Cpu0 backend has finished
processing this inline assembly instruction.</p>
<p>Run Chapter11_2 with ch11_2.cpp will get the following result.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">1-160-129-73:input Jonathan$ </span>clang -target mips-unknown-linux-gnu -c
<span class="go">ch11_2.cpp -emit-llvm -o ch11_2.bc</span>

<span class="gp">1-160-129-73:input Jonathan$ </span>~/llvm/test/build/bin/
<span class="go">llvm-dis ch11_2.bc -o -</span>
<span class="go">...</span>
<span class="go">target triple = &quot;mips-unknown-linux-gnu&quot;</span>

<span class="go">@g = global [3 x i32] [i32 1, i32 2, i32 3], align 4</span>

<span class="go">; Function Attrs: nounwind</span>
<span class="go">define i32 @_Z14inlineasm_adduv() #0 {</span>
<span class="gp">  %</span><span class="nv">foo</span> <span class="o">=</span> alloca i32, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">bar</span> <span class="o">=</span> alloca i32, align <span class="m">4</span>
<span class="go">  store i32 10, i32* %foo, align 4</span>
<span class="go">  store i32 15, i32* %bar, align 4</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> load i32* %foo, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">2</span> <span class="o">=</span> call i32 asm sideeffect <span class="s2">&quot;addu </span><span class="nv">$0</span><span class="s2">,</span><span class="nv">$1</span><span class="s2">,</span><span class="nv">$2</span><span class="s2">&quot;</span>, <span class="s2">&quot;=r,r,r&quot;</span><span class="o">(</span>i32 %1, i32 <span class="m">15</span><span class="o">)</span> <span class="c1">#1,</span>
<span class="go">  !srcloc !1</span>
<span class="go">  store i32 %2, i32* %foo, align 4</span>
<span class="gp">  %</span><span class="nv">3</span> <span class="o">=</span> load i32* %foo, align <span class="m">4</span>
<span class="go">  ret i32 %3</span>
<span class="go">}</span>

<span class="go">; Function Attrs: nounwind</span>
<span class="go">define i32 @_Z18inlineasm_longlongv() #0 {</span>
<span class="gp">  %</span><span class="nv">a</span> <span class="o">=</span> alloca i32, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">b</span> <span class="o">=</span> alloca i32, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">bar</span> <span class="o">=</span> alloca i64, align <span class="m">8</span>
<span class="gp">  %</span><span class="nv">p</span> <span class="o">=</span> alloca i32*, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">q</span> <span class="o">=</span> alloca i32*, align <span class="m">4</span>
<span class="go">  store i64 21474836486, i64* %bar, align 8</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> bitcast i64* %bar to i32*
<span class="go">  store i32* %1, i32** %p, align 4</span>
<span class="gp">  %</span><span class="nv">2</span> <span class="o">=</span> load i32** %p, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">3</span> <span class="o">=</span> call i32 asm sideeffect <span class="s2">&quot;ld </span><span class="nv">$0</span><span class="s2">,</span><span class="nv">$1</span><span class="s2">&quot;</span>, <span class="s2">&quot;=r,*m&quot;</span><span class="o">(</span>i32* %2<span class="o">)</span> <span class="c1">#1, !srcloc !2</span>
<span class="go">  store i32 %3, i32* %a, align 4</span>
<span class="gp">  %</span><span class="nv">4</span> <span class="o">=</span> load i32** %p, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">5</span> <span class="o">=</span> getelementptr inbounds i32* %4, i32 <span class="m">1</span>
<span class="go">  store i32* %5, i32** %q, align 4</span>
<span class="gp">  %</span><span class="nv">6</span> <span class="o">=</span> load i32** %q, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">7</span> <span class="o">=</span> call i32 asm sideeffect <span class="s2">&quot;ld </span><span class="nv">$0</span><span class="s2">,</span><span class="nv">$1</span><span class="s2">&quot;</span>, <span class="s2">&quot;=r,*m&quot;</span><span class="o">(</span>i32* %6<span class="o">)</span> <span class="c1">#1, !srcloc !3</span>
<span class="go">  store i32 %7, i32* %b, align 4</span>
<span class="gp">  %</span><span class="nv">8</span> <span class="o">=</span> load i32* %a, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">9</span> <span class="o">=</span> load i32* %b, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">10</span> <span class="o">=</span> add nsw i32 %8, %9
<span class="go">  ret i32 %10</span>
<span class="go">}</span>

<span class="go">; Function Attrs: nounwind</span>
<span class="go">define i32 @_Z20inlineasm_constraintv() #0 {</span>
<span class="gp">  %</span><span class="nv">foo</span> <span class="o">=</span> alloca i32, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">n_5</span> <span class="o">=</span> alloca i32, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">n5</span> <span class="o">=</span> alloca i32, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">n0</span> <span class="o">=</span> alloca i32, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">un5</span> <span class="o">=</span> alloca i32, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">n65536</span> <span class="o">=</span> alloca i32, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">n_65531</span> <span class="o">=</span> alloca i32, align <span class="m">4</span>
<span class="go">  store i32 10, i32* %foo, align 4</span>
<span class="go">  store i32 -5, i32* %n_5, align 4</span>
<span class="go">  store i32 5, i32* %n5, align 4</span>
<span class="go">  store i32 0, i32* %n0, align 4</span>
<span class="go">  store i32 5, i32* %un5, align 4</span>
<span class="go">  store i32 65536, i32* %n65536, align 4</span>
<span class="go">  store i32 -65531, i32* %n_65531, align 4</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> load i32* %foo, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">2</span> <span class="o">=</span> call i32 asm sideeffect <span class="s2">&quot;addiu </span><span class="nv">$0</span><span class="s2">,</span><span class="nv">$1</span><span class="s2">,</span><span class="nv">$2</span><span class="s2">&quot;</span>, <span class="s2">&quot;=r,r,I&quot;</span><span class="o">(</span>i32 %1, i32 -5<span class="o">)</span> <span class="c1">#1,</span>
<span class="go">  !srcloc !4</span>
<span class="go">  store i32 %2, i32* %foo, align 4</span>
<span class="gp">  %</span><span class="nv">3</span> <span class="o">=</span> load i32* %foo, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">4</span> <span class="o">=</span> call i32 asm sideeffect <span class="s2">&quot;addiu </span><span class="nv">$0</span><span class="s2">,</span><span class="nv">$1</span><span class="s2">,</span><span class="nv">$2</span><span class="s2">&quot;</span>, <span class="s2">&quot;=r,r,J&quot;</span><span class="o">(</span>i32 %3, i32 <span class="m">0</span><span class="o">)</span> <span class="c1">#1,</span>
<span class="go">  !srcloc !5</span>
<span class="go">  store i32 %4, i32* %foo, align 4</span>
<span class="gp">  %</span><span class="nv">5</span> <span class="o">=</span> load i32* %foo, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">6</span> <span class="o">=</span> call i32 asm sideeffect <span class="s2">&quot;addiu </span><span class="nv">$0</span><span class="s2">,</span><span class="nv">$1</span><span class="s2">,</span><span class="nv">$2</span><span class="s2">&quot;</span>, <span class="s2">&quot;=r,r,K&quot;</span><span class="o">(</span>i32 %5, i32 <span class="m">5</span><span class="o">)</span> <span class="c1">#1,</span>
<span class="go">  !srcloc !6</span>
<span class="go">  store i32 %6, i32* %foo, align 4</span>
<span class="gp">  %</span><span class="nv">7</span> <span class="o">=</span> load i32* %foo, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">8</span> <span class="o">=</span> call i32 asm sideeffect <span class="s2">&quot;ori </span><span class="nv">$0</span><span class="s2">,</span><span class="nv">$1</span><span class="s2">,</span><span class="nv">$2</span><span class="s2">&quot;</span>, <span class="s2">&quot;=r,r,L&quot;</span><span class="o">(</span>i32 %7, i32 <span class="m">65536</span><span class="o">)</span> <span class="c1">#1,</span>
<span class="go">  !srcloc !7</span>
<span class="go">  store i32 %8, i32* %foo, align 4</span>
<span class="gp">  %</span><span class="nv">9</span> <span class="o">=</span> load i32* %foo, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">10</span> <span class="o">=</span> call i32 asm sideeffect <span class="s2">&quot;addiu </span><span class="nv">$0</span><span class="s2">,</span><span class="nv">$1</span><span class="s2">,</span><span class="nv">$2</span><span class="s2">&quot;</span>, <span class="s2">&quot;=r,r,N&quot;</span><span class="o">(</span>i32 %9, i32 -65531<span class="o">)</span>
<span class="gp">  #</span><span class="m">1</span>, !srcloc !8
<span class="go">  store i32 %10, i32* %foo, align 4</span>
<span class="gp">  %</span><span class="nv">11</span> <span class="o">=</span> load i32* %foo, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">12</span> <span class="o">=</span> call i32 asm sideeffect <span class="s2">&quot;addiu </span><span class="nv">$0</span><span class="s2">,</span><span class="nv">$1</span><span class="s2">,</span><span class="nv">$2</span><span class="s2">&quot;</span>, <span class="s2">&quot;=r,r,O&quot;</span><span class="o">(</span>i32 %11, i32 -5<span class="o">)</span> <span class="c1">#1,</span>
<span class="go">  !srcloc !9</span>
<span class="go">  store i32 %12, i32* %foo, align 4</span>
<span class="gp">  %</span><span class="nv">13</span> <span class="o">=</span> load i32* %foo, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">14</span> <span class="o">=</span> call i32 asm sideeffect <span class="s2">&quot;addiu </span><span class="nv">$0</span><span class="s2">,</span><span class="nv">$1</span><span class="s2">,</span><span class="nv">$2</span><span class="s2">&quot;</span>, <span class="s2">&quot;=r,r,P&quot;</span><span class="o">(</span>i32 %13, i32 <span class="m">5</span><span class="o">)</span> <span class="c1">#1,</span>
<span class="go">  !srcloc !10</span>
<span class="go">  store i32 %14, i32* %foo, align 4</span>
<span class="gp">  %</span><span class="nv">15</span> <span class="o">=</span> load i32* %foo, align <span class="m">4</span>
<span class="go">  ret i32 %15</span>
<span class="go">}</span>

<span class="go">; Function Attrs: nounwind</span>
<span class="go">define i32 @_Z13inlineasm_argii(i32 %u, i32 %v) #0 {</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> alloca i32, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">2</span> <span class="o">=</span> alloca i32, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">w</span> <span class="o">=</span> alloca i32, align <span class="m">4</span>
<span class="go">  store i32 %u, i32* %1, align 4</span>
<span class="go">  store i32 %v, i32* %2, align 4</span>
<span class="gp">  %</span><span class="nv">3</span> <span class="o">=</span> load i32* %1, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">4</span> <span class="o">=</span> load i32* %2, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">5</span> <span class="o">=</span> call i32 asm sideeffect <span class="s2">&quot;subu </span><span class="nv">$0</span><span class="s2">,</span><span class="nv">$1</span><span class="s2">,</span><span class="nv">$2</span><span class="s2">&quot;</span>, <span class="s2">&quot;=r,r,r&quot;</span><span class="o">(</span>i32 %3, i32 %4<span class="o">)</span> <span class="c1">#1,</span>
<span class="go">  !srcloc !11</span>
<span class="go">  store i32 %5, i32* %w, align 4</span>
<span class="gp">  %</span><span class="nv">6</span> <span class="o">=</span> load i32* %w, align <span class="m">4</span>
<span class="go">  ret i32 %6</span>
<span class="go">}</span>

<span class="go">; Function Attrs: nounwind</span>
<span class="go">define i32 @_Z16inlineasm_globalv() #0 {</span>
<span class="gp">  %</span><span class="nv">c</span> <span class="o">=</span> alloca i32, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">d</span> <span class="o">=</span> alloca i32, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> call i32 asm sideeffect <span class="s2">&quot;ld </span><span class="nv">$0</span><span class="s2">,</span><span class="nv">$1</span><span class="s2">&quot;</span>, <span class="s2">&quot;=r,*m&quot;</span><span class="o">(</span>i32* getelementptr inbounds
<span class="go">  ([3 x i32]* @g, i32 0, i32 2)) #1, !srcloc !12</span>
<span class="go">  store i32 %1, i32* %c, align 4</span>
<span class="gp">  %</span><span class="nv">2</span> <span class="o">=</span> load i32* %c, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">3</span> <span class="o">=</span> call i32 asm sideeffect <span class="s2">&quot;addiu </span><span class="nv">$0</span><span class="s2">,</span><span class="nv">$1</span><span class="s2">,1&quot;</span>, <span class="s2">&quot;=r,r&quot;</span><span class="o">(</span>i32 %2<span class="o">)</span> <span class="c1">#1, !srcloc !13</span>
<span class="go">  store i32 %3, i32* %d, align 4</span>
<span class="gp">  %</span><span class="nv">4</span> <span class="o">=</span> load i32* %d, align <span class="m">4</span>
<span class="go">  ret i32 %4</span>
<span class="go">}</span>

<span class="go">; Function Attrs: nounwind</span>
<span class="go">define i32 @_Z14test_inlineasmv() #0 {</span>
<span class="gp">  %</span><span class="nv">a</span> <span class="o">=</span> alloca i32, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">b</span> <span class="o">=</span> alloca i32, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">c</span> <span class="o">=</span> alloca i32, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">d</span> <span class="o">=</span> alloca i32, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">e</span> <span class="o">=</span> alloca i32, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">f</span> <span class="o">=</span> alloca i32, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">g</span> <span class="o">=</span> alloca i32, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> call i32 @_Z14inlineasm_adduv<span class="o">()</span>
<span class="go">  store i32 %1, i32* %a, align 4</span>
<span class="gp">  %</span><span class="nv">2</span> <span class="o">=</span> call i32 @_Z18inlineasm_longlongv<span class="o">()</span>
<span class="go">  store i32 %2, i32* %b, align 4</span>
<span class="gp">  %</span><span class="nv">3</span> <span class="o">=</span> call i32 @_Z20inlineasm_constraintv<span class="o">()</span>
<span class="go">  store i32 %3, i32* %c, align 4</span>
<span class="gp">  %</span><span class="nv">4</span> <span class="o">=</span> call i32 @_Z13inlineasm_argii<span class="o">(</span>i32 <span class="m">1</span>, i32 <span class="m">10</span><span class="o">)</span>
<span class="go">  store i32 %4, i32* %d, align 4</span>
<span class="gp">  %</span><span class="nv">5</span> <span class="o">=</span> call i32 @_Z13inlineasm_argii<span class="o">(</span>i32 <span class="m">6</span>, i32 <span class="m">3</span><span class="o">)</span>
<span class="go">  store i32 %5, i32* %e, align 4</span>
<span class="gp">  %</span><span class="nv">6</span> <span class="o">=</span> load i32* %e, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">7</span> <span class="o">=</span> call i32 asm sideeffect <span class="s2">&quot;addiu </span><span class="nv">$0</span><span class="s2">,</span><span class="nv">$1</span><span class="s2">,1&quot;</span>, <span class="s2">&quot;=r,r&quot;</span><span class="o">(</span>i32 %6<span class="o">)</span> <span class="c1">#1, !srcloc !14</span>
<span class="go">  store i32 %7, i32* %f, align 4</span>
<span class="gp">  %</span><span class="nv">8</span> <span class="o">=</span> call i32 @_Z16inlineasm_globalv<span class="o">()</span>
<span class="go">  store i32 %8, i32* %g, align 4</span>
<span class="gp">  %</span><span class="nv">9</span> <span class="o">=</span> load i32* %a, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">10</span> <span class="o">=</span> load i32* %b, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">11</span> <span class="o">=</span> add nsw i32 %9, %10
<span class="gp">  %</span><span class="nv">12</span> <span class="o">=</span> load i32* %c, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">13</span> <span class="o">=</span> add nsw i32 %11, %12
<span class="gp">  %</span><span class="nv">14</span> <span class="o">=</span> load i32* %d, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">15</span> <span class="o">=</span> add nsw i32 %13, %14
<span class="gp">  %</span><span class="nv">16</span> <span class="o">=</span> load i32* %e, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">17</span> <span class="o">=</span> add nsw i32 %15, %16
<span class="gp">  %</span><span class="nv">18</span> <span class="o">=</span> load i32* %f, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">19</span> <span class="o">=</span> add nsw i32 %17, %18
<span class="gp">  %</span><span class="nv">20</span> <span class="o">=</span> load i32* %g, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">21</span> <span class="o">=</span> add nsw i32 %19, %20
<span class="go">  ret i32 %21</span>
<span class="go">}</span>
<span class="go">...</span>
<span class="gp">1-160-129-73:input Jonathan$ </span>~/llvm/test/build/bin/llc
<span class="go">  -march=cpu0 -relocation-model=static -filetype=asm ch11_2.bc -o -</span>
<span class="go">  .section .mdebug.abi32</span>
<span class="go">  .previous</span>
<span class="go">  .file &quot;ch11_2.bc&quot;</span>
<span class="go">  .text</span>
<span class="go">  .globl  _Z14inlineasm_adduv</span>
<span class="go">  .align  2</span>
<span class="go">  .type _Z14inlineasm_adduv,@function</span>
<span class="go">  .ent  _Z14inlineasm_adduv     # @_Z14inlineasm_adduv</span>
<span class="go">_Z14inlineasm_adduv:</span>
<span class="go">  .frame  $fp,16,$lr</span>
<span class="go">  .mask   0x00001000,-4</span>
<span class="go">  .set  noreorder</span>
<span class="go">  .set  nomacro</span>
<span class="gp"># </span>BB#0:
<span class="go">  addiu $sp, $sp, -16</span>
<span class="go">  st  $fp, 12($sp)            # 4-byte Folded Spill</span>
<span class="go">  addu  $fp, $sp, $zero</span>
<span class="go">  addiu $2, $zero, 10</span>
<span class="go">  st  $2, 8($fp)</span>
<span class="go">  addiu $2, $zero, 15</span>
<span class="go">  st  $2, 4($fp)</span>
<span class="go">  ld  $3, 8($fp)</span>
<span class="gp">  #</span>APP
<span class="go">  addu $2,$3,$2</span>
<span class="gp">  #</span>NO_APP
<span class="go">  st  $2, 8($fp)</span>
<span class="go">  addu  $sp, $fp, $zero</span>
<span class="go">  ld  $fp, 12($sp)            # 4-byte Folded Reload</span>
<span class="go">  addiu $sp, $sp, 16</span>
<span class="go">  ret $lr</span>
<span class="go">  nop</span>
<span class="go">  .set  macro</span>
<span class="go">  .set  reorder</span>
<span class="go">  .end  _Z14inlineasm_adduv</span>
<span class="gp">$</span>tmp3:
<span class="go">  .size _Z14inlineasm_adduv, ($tmp3)-_Z14inlineasm_adduv</span>

<span class="go">  .globl  _Z18inlineasm_longlongv</span>
<span class="go">  .align  2</span>
<span class="go">  .type _Z18inlineasm_longlongv,@function</span>
<span class="go">  .ent  _Z18inlineasm_longlongv # @_Z18inlineasm_longlongv</span>
<span class="go">_Z18inlineasm_longlongv:</span>
<span class="go">  .frame  $fp,32,$lr</span>
<span class="go">  .mask   0x00001000,-4</span>
<span class="go">  .set  noreorder</span>
<span class="go">  .set  nomacro</span>
<span class="gp"># </span>BB#0:
<span class="go">  addiu $sp, $sp, -32</span>
<span class="go">  st  $fp, 28($sp)            # 4-byte Folded Spill</span>
<span class="go">  addu  $fp, $sp, $zero</span>
<span class="go">  addiu $2, $zero, 6</span>
<span class="go">  st  $2, 12($fp)</span>
<span class="go">  addiu $2, $zero, 5</span>
<span class="go">  st  $2, 8($fp)</span>
<span class="go">  addiu $2, $fp, 8</span>
<span class="go">  st  $2, 4($fp)</span>
<span class="gp">  #</span>APP
<span class="go">  ld $2,0($2)</span>
<span class="gp">  #</span>NO_APP
<span class="go">  st  $2, 24($fp)</span>
<span class="go">  ld  $2, 4($fp)</span>
<span class="go">  addiu $2, $2, 4</span>
<span class="go">  st  $2, 0($fp)</span>
<span class="gp">  #</span>APP
<span class="go">  ld $2,0($2)</span>
<span class="gp">  #</span>NO_APP
<span class="go">  st  $2, 20($fp)</span>
<span class="go">  ld  $3, 24($fp)</span>
<span class="go">  addu  $2, $3, $2</span>
<span class="go">  addu  $sp, $fp, $zero</span>
<span class="go">  ld  $fp, 28($sp)            # 4-byte Folded Reload</span>
<span class="go">  addiu $sp, $sp, 32</span>
<span class="go">  ret $lr</span>
<span class="go">  .set  macro</span>
<span class="go">  .set  reorder</span>
<span class="go">  .end  _Z18inlineasm_longlongv</span>
<span class="gp">$</span>tmp7:
<span class="go">  .size _Z18inlineasm_longlongv, ($tmp7)-_Z18inlineasm_longlongv</span>

<span class="go">  .globl  _Z20inlineasm_constraintv</span>
<span class="go">  .align  2</span>
<span class="go">  .type _Z20inlineasm_constraintv,@function</span>
<span class="go">  .ent  _Z20inlineasm_constraintv # @_Z20inlineasm_constraintv</span>
<span class="go">_Z20inlineasm_constraintv:</span>
<span class="go">  .frame  $fp,32,$lr</span>
<span class="go">  .mask   0x00001000,-4</span>
<span class="go">  .set  noreorder</span>
<span class="go">  .set  nomacro</span>
<span class="gp"># </span>BB#0:
<span class="go">  addiu $sp, $sp, -32</span>
<span class="go">  st  $fp, 28($sp)            # 4-byte Folded Spill</span>
<span class="go">  addu  $fp, $sp, $zero</span>
<span class="go">  addiu $2, $zero, 10</span>
<span class="go">  st  $2, 24($fp)</span>
<span class="go">  addiu $2, $zero, -5</span>
<span class="go">  st  $2, 20($fp)</span>
<span class="go">  addiu $2, $zero, 5</span>
<span class="go">  st  $2, 16($fp)</span>
<span class="go">  addiu $3, $zero, 0</span>
<span class="go">  st  $3, 12($fp)</span>
<span class="go">  st  $2, 8($fp)</span>
<span class="go">  lui $2, 1</span>
<span class="go">  st  $2, 4($fp)</span>
<span class="go">  lui $2, 65535</span>
<span class="go">  ori $2, $2, 5</span>
<span class="go">  st  $2, 0($fp)</span>
<span class="go">  ld  $2, 24($fp)</span>
<span class="gp">  #</span>APP
<span class="go">  addiu $2,$2,-5</span>
<span class="gp">  #</span>NO_APP
<span class="go">  st  $2, 24($fp)</span>
<span class="gp">  #</span>APP
<span class="go">  addiu $2,$2,0</span>
<span class="gp">  #</span>NO_APP
<span class="go">  st  $2, 24($fp)</span>
<span class="gp">  #</span>APP
<span class="go">  addiu $2,$2,5</span>
<span class="gp">  #</span>NO_APP
<span class="go">  st  $2, 24($fp)</span>
<span class="gp">  #</span>APP
<span class="go">  ori $2,$2,65536</span>
<span class="gp">  #</span>NO_APP
<span class="go">  st  $2, 24($fp)</span>
<span class="gp">  #</span>APP
<span class="go">  addiu $2,$2,-65531</span>
<span class="gp">  #</span>NO_APP
<span class="go">  st  $2, 24($fp)</span>
<span class="gp">  #</span>APP
<span class="go">  addiu $2,$2,-5</span>
<span class="gp">  #</span>NO_APP
<span class="go">  st  $2, 24($fp)</span>
<span class="gp">  #</span>APP
<span class="go">  addiu $2,$2,5</span>
<span class="gp">  #</span>NO_APP
<span class="go">  st  $2, 24($fp)</span>
<span class="go">  addu  $sp, $fp, $zero</span>
<span class="go">  ld  $fp, 28($sp)            # 4-byte Folded Reload</span>
<span class="go">  addiu $sp, $sp, 32</span>
<span class="go">  ret $lr</span>
<span class="go">  nop</span>
<span class="go">  .set  macro</span>
<span class="go">  .set  reorder</span>
<span class="go">  .end  _Z20inlineasm_constraintv</span>
<span class="gp">$</span>tmp11:
<span class="go">  .size _Z20inlineasm_constraintv, ($tmp11)-_Z20inlineasm_constraintv</span>

<span class="go">  .globl  _Z13inlineasm_argii</span>
<span class="go">  .align  2</span>
<span class="go">  .type _Z13inlineasm_argii,@function</span>
<span class="go">  .ent  _Z13inlineasm_argii     # @_Z13inlineasm_argii</span>
<span class="go">_Z13inlineasm_argii:</span>
<span class="go">  .frame  $fp,16,$lr</span>
<span class="go">  .mask   0x00001000,-4</span>
<span class="go">  .set  noreorder</span>
<span class="go">  .set  nomacro</span>
<span class="gp"># </span>BB#0:
<span class="go">  addiu $sp, $sp, -16</span>
<span class="go">  st  $fp, 12($sp)            # 4-byte Folded Spill</span>
<span class="go">  addu  $fp, $sp, $zero</span>
<span class="go">  ld  $2, 16($fp)</span>
<span class="go">  st  $2, 8($fp)</span>
<span class="go">  ld  $2, 20($fp)</span>
<span class="go">  st  $2, 4($fp)</span>
<span class="go">  ld  $3, 8($fp)</span>
<span class="gp">  #</span>APP
<span class="go">  subu $2,$3,$2</span>
<span class="gp">  #</span>NO_APP
<span class="go">  st  $2, 0($fp)</span>
<span class="go">  addu  $sp, $fp, $zero</span>
<span class="go">  ld  $fp, 12($sp)            # 4-byte Folded Reload</span>
<span class="go">  addiu $sp, $sp, 16</span>
<span class="go">  ret $lr</span>
<span class="go">  nop</span>
<span class="go">  .set  macro</span>
<span class="go">  .set  reorder</span>
<span class="go">  .end  _Z13inlineasm_argii</span>
<span class="gp">$</span>tmp15:
<span class="go">  .size _Z13inlineasm_argii, ($tmp15)-_Z13inlineasm_argii</span>

<span class="go">  .globl  _Z16inlineasm_globalv</span>
<span class="go">  .align  2</span>
<span class="go">  .type _Z16inlineasm_globalv,@function</span>
<span class="go">  .ent  _Z16inlineasm_globalv   # @_Z16inlineasm_globalv</span>
<span class="go">_Z16inlineasm_globalv:</span>
<span class="go">  .frame  $fp,16,$lr</span>
<span class="go">  .mask   0x00001000,-4</span>
<span class="go">  .set  noreorder</span>
<span class="go">  .set  nomacro</span>
<span class="gp"># </span>BB#0:
<span class="go">  addiu $sp, $sp, -16</span>
<span class="go">  st  $fp, 12($sp)            # 4-byte Folded Spill</span>
<span class="go">  addu  $fp, $sp, $zero</span>
<span class="go">  lui $2, %hi(g)</span>
<span class="go">  ori $2, $2, %lo(g)</span>
<span class="go">  addiu $2, $2, 8</span>
<span class="gp">  #</span>APP
<span class="go">  ld $2,0($2)</span>
<span class="gp">  #</span>NO_APP
<span class="go">  st  $2, 8($fp)</span>
<span class="gp">  #</span>APP
<span class="go">  addiu $2,$2,1</span>
<span class="gp">  #</span>NO_APP
<span class="go">  st  $2, 4($fp)</span>
<span class="go">  addu  $sp, $fp, $zero</span>
<span class="go">  ld  $fp, 12($sp)            # 4-byte Folded Reload</span>
<span class="go">  addiu $sp, $sp, 16</span>
<span class="go">  ret $lr</span>
<span class="go">  nop</span>
<span class="go">  .set  macro</span>
<span class="go">  .set  reorder</span>
<span class="go">  .end  _Z16inlineasm_globalv</span>
<span class="gp">$</span>tmp19:
<span class="go">  .size _Z16inlineasm_globalv, ($tmp19)-_Z16inlineasm_globalv</span>

<span class="go">  .globl  _Z14test_inlineasmv</span>
<span class="go">  .align  2</span>
<span class="go">  .type _Z14test_inlineasmv,@function</span>
<span class="go">  .ent  _Z14test_inlineasmv     # @_Z14test_inlineasmv</span>
<span class="go">_Z14test_inlineasmv:</span>
<span class="go">  .frame  $fp,48,$lr</span>
<span class="go">  .mask   0x00005000,-4</span>
<span class="go">  .set  noreorder</span>
<span class="go">  .set  nomacro</span>
<span class="gp"># </span>BB#0:
<span class="go">  addiu $sp, $sp, -48</span>
<span class="go">  st  $lr, 44($sp)            # 4-byte Folded Spill</span>
<span class="go">  st  $fp, 40($sp)            # 4-byte Folded Spill</span>
<span class="go">  addu  $fp, $sp, $zero</span>
<span class="go">  jsub  _Z14inlineasm_adduv</span>
<span class="go">  nop</span>
<span class="go">  st  $2, 36($fp)</span>
<span class="go">  jsub  _Z18inlineasm_longlongv</span>
<span class="go">  nop</span>
<span class="go">  st  $2, 32($fp)</span>
<span class="go">  jsub  _Z20inlineasm_constraintv</span>
<span class="go">  nop</span>
<span class="go">  st  $2, 28($fp)</span>
<span class="go">  addiu $2, $zero, 10</span>
<span class="go">  st  $2, 4($sp)</span>
<span class="go">  addiu $2, $zero, 1</span>
<span class="go">  st  $2, 0($sp)</span>
<span class="go">  jsub  _Z13inlineasm_argii</span>
<span class="go">  nop</span>
<span class="go">  st  $2, 24($fp)</span>
<span class="go">  addiu $2, $zero, 3</span>
<span class="go">  st  $2, 4($sp)</span>
<span class="go">  addiu $2, $zero, 6</span>
<span class="go">  st  $2, 0($sp)</span>
<span class="go">  jsub  _Z13inlineasm_argii</span>
<span class="go">  nop</span>
<span class="go">  st  $2, 20($fp)</span>
<span class="gp">  #</span>APP
<span class="go">  addiu $2,$2,1</span>
<span class="gp">  #</span>NO_APP
<span class="go">  st  $2, 16($fp)</span>
<span class="go">  jsub  _Z16inlineasm_globalv</span>
<span class="go">  nop</span>
<span class="go">  st  $2, 12($fp)</span>
<span class="go">  ld  $3, 32($fp)</span>
<span class="go">  ld  $4, 36($fp)</span>
<span class="go">  addu  $3, $4, $3</span>
<span class="go">  ld  $4, 28($fp)</span>
<span class="go">  addu  $3, $3, $4</span>
<span class="go">  ld  $4, 24($fp)</span>
<span class="go">  addu  $3, $3, $4</span>
<span class="go">  ld  $4, 20($fp)</span>
<span class="go">  addu  $3, $3, $4</span>
<span class="go">  ld  $4, 16($fp)</span>
<span class="go">  addu  $3, $3, $4</span>
<span class="go">  addu  $2, $3, $2</span>
<span class="go">  addu  $sp, $fp, $zero</span>
<span class="go">  ld  $fp, 40($sp)            # 4-byte Folded Reload</span>
<span class="go">  ld  $lr, 44($sp)            # 4-byte Folded Reload</span>
<span class="go">  addiu $sp, $sp, 48</span>
<span class="go">  ret $lr</span>
<span class="go">  nop</span>
<span class="go">  .set  macro</span>
<span class="go">  .set  reorder</span>
<span class="go">  .end  _Z14test_inlineasmv</span>
<span class="gp">$</span>tmp23:
<span class="go">  .size _Z14test_inlineasmv, ($tmp23)-_Z14test_inlineasmv</span>

<span class="go">  .type g,@object               # @g</span>
<span class="go">  .data</span>
<span class="go">  .globl  g</span>
<span class="go">  .align  2</span>
<span class="go">g:</span>
<span class="go">  .4byte  1                       # 0x1</span>
<span class="go">  .4byte  2                       # 0x2</span>
<span class="go">  .4byte  3                       # 0x3</span>
<span class="go">  .size g, 12</span>
</pre></div>
</div>
<p>Clang translates gcc style inline assembly __asm__  into llvm IR Inline
Assembler Expressions first <a class="footnote-reference brackets" href="#id6" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>, then replace the variable registers of SSA
form to physical registers during llc register allocation stage.
From above example,
functions LowerAsmOperandForConstraint() and getSingleConstraintMatchWeight()
of Cpu0ISelLowering.cpp will create different range of const operand by I, J,
K, L, N, O, or P, and register operand by r . For instance, the following
__asm__ will create the llvm asm immediately after it.</p>
<div class="highlight-cpp-objdump notranslate"><div class="highlight"><pre><span></span><span class="n">__asm__</span><span class="w"> </span><span class="nf">__volatile__</span><span class="p">(</span><span class="s">&quot;addiu %0,%1,%2&quot;</span><span class="w"></span>
<span class="w">                     </span><span class="o">:</span><span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="w"> </span><span class="c1">// 15</span>
<span class="w">                     </span><span class="o">:</span><span class="s">&quot;r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;I&quot;</span><span class="p">(</span><span class="n">n_5</span><span class="p">)</span><span class="w"></span>
<span class="w">                     </span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">%2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="k">asm</span><span class="w"> </span><span class="k">sideeffect</span><span class="w"> </span><span class="s">&quot;addiu $0,$1,$2&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;=r,r,I&quot;</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv nv-Anonymous">%1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">-5</span><span class="p">)</span><span class="w"> </span><span class="vg">#0</span><span class="p">,</span><span class="w"> </span><span class="nv">!srcloc</span><span class="w"> </span><span class="nv nv-Anonymous">!1</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-cpp-objdump notranslate"><div class="highlight"><pre><span></span><span class="n">__asm__</span><span class="w"> </span><span class="nf">__volatile__</span><span class="p">(</span><span class="s">&quot;addiu %0,%1,%2&quot;</span><span class="w"></span>
<span class="w">                     </span><span class="o">:</span><span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="w"> </span><span class="c1">// 15</span>
<span class="w">                     </span><span class="o">:</span><span class="s">&quot;r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;N&quot;</span><span class="p">(</span><span class="n">n_65531</span><span class="p">)</span><span class="w"></span>
<span class="w">                     </span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">%10</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="k">asm</span><span class="w"> </span><span class="k">sideeffect</span><span class="w"> </span><span class="s">&quot;addiu $0,$1,$2&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;=r,r,N&quot;</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv nv-Anonymous">%9</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">-65531</span><span class="p">)</span><span class="w"> </span><span class="vg">#0</span><span class="p">,</span><span class="w"> </span><span class="nv">!srcloc</span><span class="w"> </span><span class="nv nv-Anonymous">!5</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-cpp-objdump notranslate"><div class="highlight"><pre><span></span><span class="n">__asm__</span><span class="w"> </span><span class="nf">__volatile__</span><span class="p">(</span><span class="s">&quot;addiu %0,%1,%2&quot;</span><span class="w"></span>
<span class="w">                     </span><span class="o">:</span><span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="w"> </span><span class="c1">// 15</span>
<span class="w">                     </span><span class="o">:</span><span class="s">&quot;r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;P&quot;</span><span class="p">(</span><span class="n">un5</span><span class="p">)</span><span class="w"></span>
<span class="w">                     </span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">%14</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="k">asm</span><span class="w"> </span><span class="k">sideeffect</span><span class="w"> </span><span class="s">&quot;addiu $0,$1,$2&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;=r,r,P&quot;</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv nv-Anonymous">%13</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">5</span><span class="p">)</span><span class="w"> </span><span class="vg">#0</span><span class="p">,</span><span class="w"> </span><span class="nv">!srcloc</span><span class="w"> </span><span class="nv nv-Anonymous">!7</span><span class="w"></span>
</pre></div>
</div>
<p>The r in __asm__ will generate register, %1, in llvm IR asm while I
in __asm__ will generate const operand, -5, in llvm IR asm. Remind,
the LowerAsmOperandForConstraint() limit the range of positive or negative const
operand value to 16 bits since FL type immediate operand is 16 bits in Cpu0
instruction. So, the range of N is -65535 to -1 and the range of P is 65535 to 1.
For any value out of
the range, the code in LowerAsmOperandForConstraint() will treat it as error
since FL instruction format has limitation of 16 bits.</p>
<aside class="footnote brackets" id="id4" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://www.embecosm.com/appnotes/ean10/ean10-howto-llvmas-1.0.html">http://www.embecosm.com/appnotes/ean10/ean10-howto-llvmas-1.0.html</a></p>
</aside>
<aside class="footnote brackets" id="id5" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html">http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html</a></p>
</aside>
<aside class="footnote brackets" id="id6" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">3</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://llvm.org/docs/LangRef.html#inline-assembler-expressions">http://llvm.org/docs/LangRef.html#inline-assembler-expressions</a></p>
</aside>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="elf.html">ELF Support</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="c%2B%2B.html">C++ support</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Chen Chung-Shu.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.0.2.
    </div>
  </body>
</html>