<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Assembler &mdash; Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '3.7.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="top" title="Tutorial: Creating an LLVM Backend for the Cpu0 Architecture" href="index.html" />
    <link rel="next" title="C++ support" href="c++.html" />
    <link rel="prev" title="ELF Support" href="elf.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="index.html">
          <span>Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</span></a></h1>
        <h2 class="heading"><span>Assembler</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="elf.html">ELF Support</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="c++.html">C++ support</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="assembler">
<span id="sec-asm"></span><h1>Assembler<a class="headerlink" href="#assembler" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#asmparser-support" id="id7">AsmParser support</a></li>
<li><a class="reference internal" href="#inline-assembly" id="id8">Inline assembly</a></li>
</ul>
</div>
<p>This chapter will add LLVM AsmParser support first and introduce inline
assembly handler next.
With AsmParser and inline assembly support, we can hand code the assembly
language in C/C++ file and translate it into obj (elf format).</p>
<div class="section" id="asmparser-support">
<h2><a class="toc-backref" href="#id7">AsmParser support</a><a class="headerlink" href="#asmparser-support" title="Permalink to this headline">¶</a></h2>
<p>This section lists all the AsmParser code for cpu0 backend with only a few
explanation. Please refer here <a class="footnote-reference" href="#id4" id="id1">[1]</a> for more AsmParser explanation.</p>
<p>Run Chapter10_1/ with ch11_1.cpp will get the following error message.</p>
<p class="rubric">lbdex/input/ch11_1.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">asm</span><span class="p">(</span><span class="s">&quot;ld	$2, 8($sp)&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;st	$0, 4($sp)&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;addiu $3,	$ZERO, 0&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;add $3, $1, $2&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;sub $3, $2, $3&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;mul $2, $1, $3&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;div $3, $2&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;divu $2, $3&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;and $2, $1, $3&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;or $3, $1, $2&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;xor $1, $2, $3&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;mult $4, $3&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;multu $3, $2&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;mfhi $3&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;mflo $2&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;mthi $2&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;mtlo $2&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;sra $2, $2, 2&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;rol $2, $1, 3&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;ror $3, $3, 4&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;shl $2, $2, 2&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;shr $2, $3, 5&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;cmp $sw, $2, $3&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;jeq $sw, 20&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;jne $sw, 16&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;jlt $sw, -20&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;jle $sw, -16&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;jgt $sw, -4&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;jge $sw, -12&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;jsub 0x000010000&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;ret $lr&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;jalr $t9&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;li $3, 0x00700000&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;la $3, 0x00800000($6)&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;la $3, 0x00900000&quot;</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>JonathantekiiMac:input Jonathan$ clang -c ch11_1.cpp -emit-llvm -o
ch11_1.bc
JonathantekiiMac:input Jonathan$ /Users/Jonathan/llvm/test/cmake_debug_
build/Debug/bin/llc -march=cpu0 -relocation-model=pic -filetype=obj ch11_1.bc
-o ch11_1.cpu0.o
LLVM ERROR: Inline asm not supported by this streamer because we don&#39;t have
an asm parser for this target
</pre></div>
</div>
<p>Since we don&#8217;t implement cpu0 assembler, it has the error message as above.
The cpu0 can translate LLVM IR into assembly and obj directly, but it cannot
translate hand code assembly instructions into obj.
Directory AsmParser handle the assembly to obj translation.
The Chapter11_1/ include AsmParser implementation as follows,</p>
<p class="rubric">lbdex/chapters/Chapter11_1/AsmParser/Cpu0AsmParser.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0AsmParser.cpp - Parse Cpu0 assembly to MCInst instructions ----===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include &quot;Cpu0.h&quot;</span>
<span class="cp">#if CH &gt;= CH11_1</span>

<span class="cp">#include &quot;MCTargetDesc/Cpu0MCTargetDesc.h&quot;</span>
<span class="cp">#include &quot;Cpu0RegisterInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/ADT/APInt.h&quot;</span>
<span class="cp">#include &quot;llvm/ADT/StringSwitch.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCContext.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCExpr.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCInst.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCInstBuilder.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCParser/MCAsmLexer.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCParser/MCParsedAsmOperand.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCStreamer.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCSubtargetInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCSymbol.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCParser/MCAsmLexer.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCParser/MCParsedAsmOperand.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCTargetAsmParser.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCValue.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/Debug.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/MathExtras.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/TargetRegistry.h&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="cp">#define DEBUG_TYPE &quot;cpu0-asm-parser&quot;</span>

<span class="k">namespace</span> <span class="p">{</span>
<span class="k">class</span> <span class="nc">Cpu0AssemblerOptions</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Cpu0AssemblerOptions</span><span class="p">()</span><span class="o">:</span>
    <span class="n">reorder</span><span class="p">(</span><span class="nb">true</span><span class="p">),</span> <span class="n">macro</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="n">isReorder</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span> <span class="n">reorder</span><span class="p">;}</span>
  <span class="kt">void</span> <span class="n">setReorder</span><span class="p">()</span> <span class="p">{</span><span class="n">reorder</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;}</span>
  <span class="kt">void</span> <span class="n">setNoreorder</span><span class="p">()</span> <span class="p">{</span><span class="n">reorder</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;}</span>

  <span class="kt">bool</span> <span class="n">isMacro</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span> <span class="n">macro</span><span class="p">;}</span>
  <span class="kt">void</span> <span class="n">setMacro</span><span class="p">()</span> <span class="p">{</span><span class="n">macro</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;}</span>
  <span class="kt">void</span> <span class="n">setNomacro</span><span class="p">()</span> <span class="p">{</span><span class="n">macro</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;}</span>

<span class="nl">private:</span>
  <span class="kt">bool</span> <span class="n">reorder</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">macro</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="p">{</span>
<span class="k">class</span> <span class="nc">Cpu0AsmParser</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MCTargetAsmParser</span> <span class="p">{</span>
  <span class="n">MCSubtargetInfo</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">;</span>
  <span class="n">MCAsmParser</span> <span class="o">&amp;</span><span class="n">Parser</span><span class="p">;</span>
  <span class="n">Cpu0AssemblerOptions</span> <span class="n">Options</span><span class="p">;</span>


<span class="cp">#define GET_ASSEMBLER_HEADER</span>
<span class="cp">#include &quot;Cpu0GenAsmMatcher.inc&quot;</span>

  <span class="kt">bool</span> <span class="n">MatchAndEmitInstruction</span><span class="p">(</span><span class="n">SMLoc</span> <span class="n">IDLoc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="o">&amp;</span><span class="n">Opcode</span><span class="p">,</span>
                               <span class="n">OperandVector</span> <span class="o">&amp;</span><span class="n">Operands</span><span class="p">,</span> <span class="n">MCStreamer</span> <span class="o">&amp;</span><span class="n">Out</span><span class="p">,</span>
                               <span class="kt">uint64_t</span> <span class="o">&amp;</span><span class="n">ErrorInfo</span><span class="p">,</span>
                               <span class="kt">bool</span> <span class="n">MatchingInlineAsm</span><span class="p">)</span> <span class="n">override</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="n">ParseRegister</span><span class="p">(</span><span class="kt">unsigned</span> <span class="o">&amp;</span><span class="n">RegNo</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="o">&amp;</span><span class="n">StartLoc</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="o">&amp;</span><span class="n">EndLoc</span><span class="p">)</span> <span class="n">override</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="n">ParseInstruction</span><span class="p">(</span><span class="n">ParseInstructionInfo</span> <span class="o">&amp;</span><span class="n">Info</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">Name</span><span class="p">,</span>
                        <span class="n">SMLoc</span> <span class="n">NameLoc</span><span class="p">,</span> <span class="n">OperandVector</span> <span class="o">&amp;</span><span class="n">Operands</span><span class="p">)</span> <span class="n">override</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="nf">parseMathOperation</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">Name</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="n">NameLoc</span><span class="p">,</span>
                        <span class="n">OperandVector</span> <span class="o">&amp;</span><span class="n">Operands</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="n">ParseDirective</span><span class="p">(</span><span class="n">AsmToken</span> <span class="n">DirectiveID</span><span class="p">)</span> <span class="n">override</span><span class="p">;</span>

  <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">OperandMatchResultTy</span> <span class="n">parseMemOperand</span><span class="p">(</span><span class="n">OperandVector</span> <span class="o">&amp;</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">ParseOperand</span><span class="p">(</span><span class="n">OperandVector</span> <span class="o">&amp;</span><span class="n">Operands</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">Mnemonic</span><span class="p">);</span>

  <span class="kt">int</span> <span class="nf">tryParseRegister</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">Mnemonic</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">tryParseRegisterOperand</span><span class="p">(</span><span class="n">OperandVector</span> <span class="o">&amp;</span><span class="n">Operands</span><span class="p">,</span>
                               <span class="n">StringRef</span> <span class="n">Mnemonic</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">needsExpansion</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">);</span>

  <span class="kt">void</span> <span class="nf">expandInstruction</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="n">IDLoc</span><span class="p">,</span>
                         <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCInst</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Instructions</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">expandLoadImm</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="n">IDLoc</span><span class="p">,</span>
                     <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCInst</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Instructions</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">expandLoadAddressImm</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="n">IDLoc</span><span class="p">,</span>
                            <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCInst</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Instructions</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">expandLoadAddressReg</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="n">IDLoc</span><span class="p">,</span>
                            <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCInst</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Instructions</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">reportParseError</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">ErrorMsg</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">parseMemOffset</span><span class="p">(</span><span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*&amp;</span><span class="n">Res</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">parseRelocOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*&amp;</span><span class="n">Res</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">parseDirectiveSet</span><span class="p">();</span>

  <span class="kt">bool</span> <span class="nf">parseSetAtDirective</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="nf">parseSetNoAtDirective</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="nf">parseSetMacroDirective</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="nf">parseSetNoMacroDirective</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="nf">parseSetReorderDirective</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="nf">parseSetNoReorderDirective</span><span class="p">();</span>

  <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VariantKind</span> <span class="n">getVariantKind</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">Symbol</span><span class="p">);</span>

  <span class="kt">int</span> <span class="nf">matchRegisterName</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">Symbol</span><span class="p">);</span>

  <span class="kt">int</span> <span class="nf">matchRegisterByNumber</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">RegNum</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">Mnemonic</span><span class="p">);</span>

  <span class="kt">unsigned</span> <span class="nf">getReg</span><span class="p">(</span><span class="kt">int</span> <span class="n">RC</span><span class="p">,</span><span class="kt">int</span> <span class="n">RegNo</span><span class="p">);</span>

<span class="nl">public:</span>
  <span class="n">Cpu0AsmParser</span><span class="p">(</span><span class="n">MCSubtargetInfo</span> <span class="o">&amp;</span><span class="n">sti</span><span class="p">,</span> <span class="n">MCAsmParser</span> <span class="o">&amp;</span><span class="n">parser</span><span class="p">,</span>
                <span class="k">const</span> <span class="n">MCInstrInfo</span> <span class="o">&amp;</span><span class="n">MII</span><span class="p">,</span> <span class="k">const</span> <span class="n">MCTargetOptions</span> <span class="o">&amp;</span><span class="n">Options</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">MCTargetAsmParser</span><span class="p">(),</span> <span class="n">STI</span><span class="p">(</span><span class="n">sti</span><span class="p">),</span> <span class="n">Parser</span><span class="p">(</span><span class="n">parser</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Initialize the set of available features.</span>
    <span class="n">setAvailableFeatures</span><span class="p">(</span><span class="n">ComputeAvailableFeatures</span><span class="p">(</span><span class="n">STI</span><span class="p">.</span><span class="n">getFeatureBits</span><span class="p">()));</span>
  <span class="p">}</span>

  <span class="n">MCAsmParser</span> <span class="o">&amp;</span><span class="n">getParser</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Parser</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">MCAsmLexer</span> <span class="o">&amp;</span><span class="n">getLexer</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Parser</span><span class="p">.</span><span class="n">getLexer</span><span class="p">();</span> <span class="p">}</span>

<span class="p">};</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="p">{</span>

<span class="c1">/// Cpu0Operand - Instances of this class represent a parsed Cpu0 machine</span>
<span class="c1">/// instruction.</span>
<span class="k">class</span> <span class="nc">Cpu0Operand</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MCParsedAsmOperand</span> <span class="p">{</span>

  <span class="k">enum</span> <span class="n">KindTy</span> <span class="p">{</span>
    <span class="n">k_CondCode</span><span class="p">,</span>
    <span class="n">k_CoprocNum</span><span class="p">,</span>
    <span class="n">k_Immediate</span><span class="p">,</span>
    <span class="n">k_Memory</span><span class="p">,</span>
    <span class="n">k_PostIndexRegister</span><span class="p">,</span>
    <span class="n">k_Register</span><span class="p">,</span>
    <span class="n">k_Token</span>
  <span class="p">}</span> <span class="n">Kind</span><span class="p">;</span>

<span class="nl">public:</span>
  <span class="n">Cpu0Operand</span><span class="p">(</span><span class="n">KindTy</span> <span class="n">K</span><span class="p">)</span> <span class="o">:</span> <span class="n">MCParsedAsmOperand</span><span class="p">(),</span> <span class="n">Kind</span><span class="p">(</span><span class="n">K</span><span class="p">)</span> <span class="p">{}</span>

  <span class="k">struct</span> <span class="n">Token</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">Data</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="n">Length</span><span class="p">;</span>
  <span class="p">};</span>
  <span class="k">struct</span> <span class="n">PhysRegOp</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">RegNum</span><span class="p">;</span> <span class="c1">/// Register Number</span>
  <span class="p">};</span>
  <span class="k">struct</span> <span class="n">ImmOp</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">Val</span><span class="p">;</span>
  <span class="p">};</span>
  <span class="k">struct</span> <span class="n">MemOp</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">Base</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">Off</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="k">union</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Token</span> <span class="n">Tok</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">PhysRegOp</span> <span class="n">Reg</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">ImmOp</span> <span class="n">Imm</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">MemOp</span> <span class="n">Mem</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="n">SMLoc</span> <span class="n">StartLoc</span><span class="p">,</span> <span class="n">EndLoc</span><span class="p">;</span>

<span class="nl">public:</span>
  <span class="kt">void</span> <span class="nf">addRegOperands</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">N</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">N</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Invalid number of operands!&quot;</span><span class="p">);</span>
    <span class="n">Inst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">createReg</span><span class="p">(</span><span class="n">getReg</span><span class="p">()));</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">addExpr</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span> <span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">Expr</span><span class="p">)</span> <span class="k">const</span><span class="p">{</span>
    <span class="c1">// Add as immediate when possible.  Null MCExpr = 0.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Expr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">Inst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">createImm</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="k">const</span> <span class="n">MCConstantExpr</span> <span class="o">*</span><span class="n">CE</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">MCConstantExpr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Expr</span><span class="p">))</span>
      <span class="n">Inst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">createImm</span><span class="p">(</span><span class="n">CE</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">()));</span>
    <span class="k">else</span>
      <span class="n">Inst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">createExpr</span><span class="p">(</span><span class="n">Expr</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">addImmOperands</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">N</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">N</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Invalid number of operands!&quot;</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">Expr</span> <span class="o">=</span> <span class="n">getImm</span><span class="p">();</span>
    <span class="n">addExpr</span><span class="p">(</span><span class="n">Inst</span><span class="p">,</span><span class="n">Expr</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">addMemOperands</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">N</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">N</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Invalid number of operands!&quot;</span><span class="p">);</span>

    <span class="n">Inst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">createReg</span><span class="p">(</span><span class="n">getMemBase</span><span class="p">()));</span>

    <span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">Expr</span> <span class="o">=</span> <span class="n">getMemOff</span><span class="p">();</span>
    <span class="n">addExpr</span><span class="p">(</span><span class="n">Inst</span><span class="p">,</span><span class="n">Expr</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="n">isReg</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Kind</span> <span class="o">==</span> <span class="n">k_Register</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">bool</span> <span class="n">isImm</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Kind</span> <span class="o">==</span> <span class="n">k_Immediate</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">bool</span> <span class="n">isToken</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Kind</span> <span class="o">==</span> <span class="n">k_Token</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">bool</span> <span class="n">isMem</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Kind</span> <span class="o">==</span> <span class="n">k_Memory</span><span class="p">;</span> <span class="p">}</span>

  <span class="n">StringRef</span> <span class="n">getToken</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">Kind</span> <span class="o">==</span> <span class="n">k_Token</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Invalid access!&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="nf">StringRef</span><span class="p">(</span><span class="n">Tok</span><span class="p">.</span><span class="n">Data</span><span class="p">,</span> <span class="n">Tok</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">unsigned</span> <span class="n">getReg</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">((</span><span class="n">Kind</span> <span class="o">==</span> <span class="n">k_Register</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Invalid access!&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Reg</span><span class="p">.</span><span class="n">RegNum</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">getImm</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">((</span><span class="n">Kind</span> <span class="o">==</span> <span class="n">k_Immediate</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Invalid access!&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Imm</span><span class="p">.</span><span class="n">Val</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">unsigned</span> <span class="n">getMemBase</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">((</span><span class="n">Kind</span> <span class="o">==</span> <span class="n">k_Memory</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Invalid access!&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Mem</span><span class="p">.</span><span class="n">Base</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">getMemOff</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">((</span><span class="n">Kind</span> <span class="o">==</span> <span class="n">k_Memory</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Invalid access!&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Mem</span><span class="p">.</span><span class="n">Off</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Cpu0Operand</span><span class="o">&gt;</span> <span class="n">CreateToken</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">Str</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="n">S</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">Op</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Cpu0Operand</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k_Token</span><span class="p">);</span>
    <span class="n">Op</span><span class="o">-&gt;</span><span class="n">Tok</span><span class="p">.</span><span class="n">Data</span> <span class="o">=</span> <span class="n">Str</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
    <span class="n">Op</span><span class="o">-&gt;</span><span class="n">Tok</span><span class="p">.</span><span class="n">Length</span> <span class="o">=</span> <span class="n">Str</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="n">Op</span><span class="o">-&gt;</span><span class="n">StartLoc</span> <span class="o">=</span> <span class="n">S</span><span class="p">;</span>
    <span class="n">Op</span><span class="o">-&gt;</span><span class="n">EndLoc</span> <span class="o">=</span> <span class="n">S</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">Op</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">/// Internal constructor for register kinds</span>
  <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Cpu0Operand</span><span class="o">&gt;</span> <span class="n">CreateReg</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">RegNum</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="n">S</span><span class="p">,</span> 
                                                <span class="n">SMLoc</span> <span class="n">E</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">Op</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Cpu0Operand</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k_Register</span><span class="p">);</span>
    <span class="n">Op</span><span class="o">-&gt;</span><span class="n">Reg</span><span class="p">.</span><span class="n">RegNum</span> <span class="o">=</span> <span class="n">RegNum</span><span class="p">;</span>
    <span class="n">Op</span><span class="o">-&gt;</span><span class="n">StartLoc</span> <span class="o">=</span> <span class="n">S</span><span class="p">;</span>
    <span class="n">Op</span><span class="o">-&gt;</span><span class="n">EndLoc</span> <span class="o">=</span> <span class="n">E</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">Op</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Cpu0Operand</span><span class="o">&gt;</span> <span class="n">CreateImm</span><span class="p">(</span><span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">Val</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="n">S</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="n">E</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">Op</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Cpu0Operand</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k_Immediate</span><span class="p">);</span>
    <span class="n">Op</span><span class="o">-&gt;</span><span class="n">Imm</span><span class="p">.</span><span class="n">Val</span> <span class="o">=</span> <span class="n">Val</span><span class="p">;</span>
    <span class="n">Op</span><span class="o">-&gt;</span><span class="n">StartLoc</span> <span class="o">=</span> <span class="n">S</span><span class="p">;</span>
    <span class="n">Op</span><span class="o">-&gt;</span><span class="n">EndLoc</span> <span class="o">=</span> <span class="n">E</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">Op</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Cpu0Operand</span><span class="o">&gt;</span> <span class="n">CreateMem</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">Base</span><span class="p">,</span> <span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">Off</span><span class="p">,</span>
                                 <span class="n">SMLoc</span> <span class="n">S</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="n">E</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">Op</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Cpu0Operand</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k_Memory</span><span class="p">);</span>
    <span class="n">Op</span><span class="o">-&gt;</span><span class="n">Mem</span><span class="p">.</span><span class="n">Base</span> <span class="o">=</span> <span class="n">Base</span><span class="p">;</span>
    <span class="n">Op</span><span class="o">-&gt;</span><span class="n">Mem</span><span class="p">.</span><span class="n">Off</span> <span class="o">=</span> <span class="n">Off</span><span class="p">;</span>
    <span class="n">Op</span><span class="o">-&gt;</span><span class="n">StartLoc</span> <span class="o">=</span> <span class="n">S</span><span class="p">;</span>
    <span class="n">Op</span><span class="o">-&gt;</span><span class="n">EndLoc</span> <span class="o">=</span> <span class="n">E</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">Op</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">/// getStartLoc - Get the location of the first token of this operand.</span>
  <span class="n">SMLoc</span> <span class="n">getStartLoc</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">StartLoc</span><span class="p">;</span> <span class="p">}</span>
  <span class="c1">/// getEndLoc - Get the location of the last token of this operand.</span>
  <span class="n">SMLoc</span> <span class="n">getEndLoc</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">EndLoc</span><span class="p">;</span> <span class="p">}</span>

  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">OS</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;unimplemented!&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="p">}</span>

<span class="c1">//@1 {</span>
<span class="kt">bool</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">needsExpansion</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">)</span> <span class="p">{</span>

  <span class="k">switch</span><span class="p">(</span><span class="n">Inst</span><span class="p">.</span><span class="n">getOpcode</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">LoadImm32Reg</span><span class="o">:</span>
    <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">LoadAddr32Imm</span><span class="o">:</span>
    <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">LoadAddr32Reg</span><span class="o">:</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="nl">default:</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">expandInstruction</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="n">IDLoc</span><span class="p">,</span>
                        <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCInst</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Instructions</span><span class="p">){</span>
  <span class="k">switch</span><span class="p">(</span><span class="n">Inst</span><span class="p">.</span><span class="n">getOpcode</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">LoadImm32Reg</span><span class="o">:</span>
      <span class="k">return</span> <span class="n">expandLoadImm</span><span class="p">(</span><span class="n">Inst</span><span class="p">,</span> <span class="n">IDLoc</span><span class="p">,</span> <span class="n">Instructions</span><span class="p">);</span>
    <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">LoadAddr32Imm</span><span class="o">:</span>
      <span class="k">return</span> <span class="n">expandLoadAddressImm</span><span class="p">(</span><span class="n">Inst</span><span class="p">,</span><span class="n">IDLoc</span><span class="p">,</span><span class="n">Instructions</span><span class="p">);</span>
    <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">LoadAddr32Reg</span><span class="o">:</span>
      <span class="k">return</span> <span class="n">expandLoadAddressReg</span><span class="p">(</span><span class="n">Inst</span><span class="p">,</span><span class="n">IDLoc</span><span class="p">,</span><span class="n">Instructions</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//@1 }</span>

<span class="kt">void</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">expandLoadImm</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="n">IDLoc</span><span class="p">,</span>
                                  <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCInst</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Instructions</span><span class="p">){</span>
  <span class="n">MCInst</span> <span class="n">tmpInst</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">MCOperand</span> <span class="o">&amp;</span><span class="n">ImmOp</span> <span class="o">=</span> <span class="n">Inst</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">ImmOp</span><span class="p">.</span><span class="n">isImm</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;expected immediate operand kind&quot;</span><span class="p">);</span>
  <span class="k">const</span> <span class="n">MCOperand</span> <span class="o">&amp;</span><span class="n">RegOp</span> <span class="o">=</span> <span class="n">Inst</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">RegOp</span><span class="p">.</span><span class="n">isReg</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;expected register operand kind&quot;</span><span class="p">);</span>

  <span class="kt">int</span> <span class="n">ImmValue</span> <span class="o">=</span> <span class="n">ImmOp</span><span class="p">.</span><span class="n">getImm</span><span class="p">();</span>
  <span class="n">tmpInst</span><span class="p">.</span><span class="n">setLoc</span><span class="p">(</span><span class="n">IDLoc</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ImmValue</span> <span class="o">&amp;&amp;</span> <span class="n">ImmValue</span> <span class="o">&lt;=</span> <span class="mi">65535</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// for 0 &lt;= j &lt;= 65535.</span>
    <span class="c1">// li d,j =&gt; ori d,$zero,j</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">setOpcode</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">ORi</span><span class="p">);</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">createReg</span><span class="p">(</span><span class="n">RegOp</span><span class="p">.</span><span class="n">getReg</span><span class="p">()));</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span>
              <span class="n">MCOperand</span><span class="o">::</span><span class="n">createReg</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">ZERO</span><span class="p">));</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">createImm</span><span class="p">(</span><span class="n">ImmValue</span><span class="p">));</span>
    <span class="n">Instructions</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmpInst</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">ImmValue</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ImmValue</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">32768</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// for -32768 &lt;= j &lt; 0.</span>
    <span class="c1">// li d,j =&gt; addiu d,$zero,j</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">setOpcode</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">ADDiu</span><span class="p">);</span> <span class="c1">//TODO:no ADDiu64 in td files?</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">createReg</span><span class="p">(</span><span class="n">RegOp</span><span class="p">.</span><span class="n">getReg</span><span class="p">()));</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span>
              <span class="n">MCOperand</span><span class="o">::</span><span class="n">createReg</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">ZERO</span><span class="p">));</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">createImm</span><span class="p">(</span><span class="n">ImmValue</span><span class="p">));</span>
    <span class="n">Instructions</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmpInst</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// for any other value of j that is representable as a 32-bit integer.</span>
    <span class="c1">// li d,j =&gt; lui d,hi16(j)</span>
    <span class="c1">//           ori d,d,lo16(j)</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">setOpcode</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">LUi</span><span class="p">);</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">createReg</span><span class="p">(</span><span class="n">RegOp</span><span class="p">.</span><span class="n">getReg</span><span class="p">()));</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">createImm</span><span class="p">((</span><span class="n">ImmValue</span> <span class="o">&amp;</span> <span class="mh">0xffff0000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">));</span>
    <span class="n">Instructions</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmpInst</span><span class="p">);</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">setOpcode</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">ORi</span><span class="p">);</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">createReg</span><span class="p">(</span><span class="n">RegOp</span><span class="p">.</span><span class="n">getReg</span><span class="p">()));</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">createReg</span><span class="p">(</span><span class="n">RegOp</span><span class="p">.</span><span class="n">getReg</span><span class="p">()));</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">createImm</span><span class="p">(</span><span class="n">ImmValue</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">));</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">setLoc</span><span class="p">(</span><span class="n">IDLoc</span><span class="p">);</span>
    <span class="n">Instructions</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmpInst</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">expandLoadAddressReg</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="n">IDLoc</span><span class="p">,</span>
                                         <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCInst</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Instructions</span><span class="p">){</span>
  <span class="n">MCInst</span> <span class="n">tmpInst</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">MCOperand</span> <span class="o">&amp;</span><span class="n">ImmOp</span> <span class="o">=</span> <span class="n">Inst</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">ImmOp</span><span class="p">.</span><span class="n">isImm</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;expected immediate operand kind&quot;</span><span class="p">);</span>
  <span class="k">const</span> <span class="n">MCOperand</span> <span class="o">&amp;</span><span class="n">SrcRegOp</span> <span class="o">=</span> <span class="n">Inst</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">SrcRegOp</span><span class="p">.</span><span class="n">isReg</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;expected register operand kind&quot;</span><span class="p">);</span>
  <span class="k">const</span> <span class="n">MCOperand</span> <span class="o">&amp;</span><span class="n">DstRegOp</span> <span class="o">=</span> <span class="n">Inst</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">DstRegOp</span><span class="p">.</span><span class="n">isReg</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;expected register operand kind&quot;</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">ImmValue</span> <span class="o">=</span> <span class="n">ImmOp</span><span class="p">.</span><span class="n">getImm</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span> <span class="o">-</span><span class="mi">32768</span> <span class="o">&lt;=</span> <span class="n">ImmValue</span> <span class="o">&amp;&amp;</span> <span class="n">ImmValue</span> <span class="o">&lt;=</span> <span class="mi">32767</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// for -32768 &lt;= j &lt; 32767.</span>
    <span class="c1">//la d,j(s) =&gt; addiu d,s,j</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">setOpcode</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">ADDiu</span><span class="p">);</span> <span class="c1">//TODO:no ADDiu64 in td files?</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">createReg</span><span class="p">(</span><span class="n">DstRegOp</span><span class="p">.</span><span class="n">getReg</span><span class="p">()));</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">createReg</span><span class="p">(</span><span class="n">SrcRegOp</span><span class="p">.</span><span class="n">getReg</span><span class="p">()));</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">createImm</span><span class="p">(</span><span class="n">ImmValue</span><span class="p">));</span>
    <span class="n">Instructions</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmpInst</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// for any other value of j that is representable as a 32-bit integer.</span>
    <span class="c1">// la d,j(s) =&gt; lui d,hi16(j)</span>
    <span class="c1">//              ori d,d,lo16(j)</span>
    <span class="c1">//              add d,d,s</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">setOpcode</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">LUi</span><span class="p">);</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">createReg</span><span class="p">(</span><span class="n">DstRegOp</span><span class="p">.</span><span class="n">getReg</span><span class="p">()));</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">createImm</span><span class="p">((</span><span class="n">ImmValue</span> <span class="o">&amp;</span> <span class="mh">0xffff0000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">));</span>
    <span class="n">Instructions</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmpInst</span><span class="p">);</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">setOpcode</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">ORi</span><span class="p">);</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">createReg</span><span class="p">(</span><span class="n">DstRegOp</span><span class="p">.</span><span class="n">getReg</span><span class="p">()));</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">createReg</span><span class="p">(</span><span class="n">DstRegOp</span><span class="p">.</span><span class="n">getReg</span><span class="p">()));</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">createImm</span><span class="p">(</span><span class="n">ImmValue</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">));</span>
    <span class="n">Instructions</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmpInst</span><span class="p">);</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">setOpcode</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">ADD</span><span class="p">);</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">createReg</span><span class="p">(</span><span class="n">DstRegOp</span><span class="p">.</span><span class="n">getReg</span><span class="p">()));</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">createReg</span><span class="p">(</span><span class="n">DstRegOp</span><span class="p">.</span><span class="n">getReg</span><span class="p">()));</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">createReg</span><span class="p">(</span><span class="n">SrcRegOp</span><span class="p">.</span><span class="n">getReg</span><span class="p">()));</span>
    <span class="n">Instructions</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmpInst</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">expandLoadAddressImm</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="n">IDLoc</span><span class="p">,</span>
                                         <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCInst</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Instructions</span><span class="p">){</span>
  <span class="n">MCInst</span> <span class="n">tmpInst</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">MCOperand</span> <span class="o">&amp;</span><span class="n">ImmOp</span> <span class="o">=</span> <span class="n">Inst</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">ImmOp</span><span class="p">.</span><span class="n">isImm</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;expected immediate operand kind&quot;</span><span class="p">);</span>
  <span class="k">const</span> <span class="n">MCOperand</span> <span class="o">&amp;</span><span class="n">RegOp</span> <span class="o">=</span> <span class="n">Inst</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">RegOp</span><span class="p">.</span><span class="n">isReg</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;expected register operand kind&quot;</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">ImmValue</span> <span class="o">=</span> <span class="n">ImmOp</span><span class="p">.</span><span class="n">getImm</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span> <span class="o">-</span><span class="mi">32768</span> <span class="o">&lt;=</span> <span class="n">ImmValue</span> <span class="o">&amp;&amp;</span> <span class="n">ImmValue</span> <span class="o">&lt;=</span> <span class="mi">32767</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// for -32768 &lt;= j &lt; 32767.</span>
    <span class="c1">//la d,j =&gt; addiu d,$zero,j</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">setOpcode</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">ADDiu</span><span class="p">);</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">createReg</span><span class="p">(</span><span class="n">RegOp</span><span class="p">.</span><span class="n">getReg</span><span class="p">()));</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span>
              <span class="n">MCOperand</span><span class="o">::</span><span class="n">createReg</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">ZERO</span><span class="p">));</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">createImm</span><span class="p">(</span><span class="n">ImmValue</span><span class="p">));</span>
    <span class="n">Instructions</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmpInst</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// for any other value of j that is representable as a 32-bit integer.</span>
    <span class="c1">// la d,j =&gt; lui d,hi16(j)</span>
    <span class="c1">//           ori d,d,lo16(j)</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">setOpcode</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">LUi</span><span class="p">);</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">createReg</span><span class="p">(</span><span class="n">RegOp</span><span class="p">.</span><span class="n">getReg</span><span class="p">()));</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">createImm</span><span class="p">((</span><span class="n">ImmValue</span> <span class="o">&amp;</span> <span class="mh">0xffff0000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">));</span>
    <span class="n">Instructions</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmpInst</span><span class="p">);</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">setOpcode</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">ORi</span><span class="p">);</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">createReg</span><span class="p">(</span><span class="n">RegOp</span><span class="p">.</span><span class="n">getReg</span><span class="p">()));</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">createReg</span><span class="p">(</span><span class="n">RegOp</span><span class="p">.</span><span class="n">getReg</span><span class="p">()));</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">createImm</span><span class="p">(</span><span class="n">ImmValue</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">));</span>
    <span class="n">Instructions</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmpInst</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//@2 {</span>
<span class="kt">bool</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">MatchAndEmitInstruction</span><span class="p">(</span><span class="n">SMLoc</span> <span class="n">IDLoc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="o">&amp;</span><span class="n">Opcode</span><span class="p">,</span>
                                            <span class="n">OperandVector</span> <span class="o">&amp;</span><span class="n">Operands</span><span class="p">,</span>
                                            <span class="n">MCStreamer</span> <span class="o">&amp;</span><span class="n">Out</span><span class="p">,</span>
                                            <span class="kt">uint64_t</span> <span class="o">&amp;</span><span class="n">ErrorInfo</span><span class="p">,</span>
                                            <span class="kt">bool</span> <span class="n">MatchingInlineAsm</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MCInst</span> <span class="n">Inst</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">MatchResult</span> <span class="o">=</span> <span class="n">MatchInstructionImpl</span><span class="p">(</span><span class="n">Operands</span><span class="p">,</span> <span class="n">Inst</span><span class="p">,</span> <span class="n">ErrorInfo</span><span class="p">,</span>
                                              <span class="n">MatchingInlineAsm</span><span class="p">);</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">MatchResult</span><span class="p">)</span> <span class="p">{</span>
  <span class="nl">default:</span> <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Match_Success</span>: <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">needsExpansion</span><span class="p">(</span><span class="n">Inst</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">MCInst</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">Instructions</span><span class="p">;</span>
      <span class="n">expandInstruction</span><span class="p">(</span><span class="n">Inst</span><span class="p">,</span> <span class="n">IDLoc</span><span class="p">,</span> <span class="n">Instructions</span><span class="p">);</span>
      <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Instructions</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">Out</span><span class="p">.</span><span class="n">EmitInstruction</span><span class="p">(</span><span class="n">Instructions</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">STI</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">Inst</span><span class="p">.</span><span class="n">setLoc</span><span class="p">(</span><span class="n">IDLoc</span><span class="p">);</span>
        <span class="n">Out</span><span class="p">.</span><span class="n">EmitInstruction</span><span class="p">(</span><span class="n">Inst</span><span class="p">,</span> <span class="n">STI</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
<span class="c1">//@2 }</span>
  <span class="k">case</span> <span class="n">Match_MissingFeature</span>:
    <span class="n">Error</span><span class="p">(</span><span class="n">IDLoc</span><span class="p">,</span> <span class="s">&quot;instruction requires a CPU feature not currently enabled&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Match_InvalidOperand</span>: <span class="p">{</span>
    <span class="n">SMLoc</span> <span class="n">ErrorLoc</span> <span class="o">=</span> <span class="n">IDLoc</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ErrorInfo</span> <span class="o">!=</span> <span class="o">~</span><span class="mi">0U</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">ErrorInfo</span> <span class="o">&gt;=</span> <span class="n">Operands</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">Error</span><span class="p">(</span><span class="n">IDLoc</span><span class="p">,</span> <span class="s">&quot;too few operands for instruction&quot;</span><span class="p">);</span>

      <span class="n">ErrorLoc</span> <span class="o">=</span> <span class="p">((</span><span class="n">Cpu0Operand</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">*</span><span class="n">Operands</span><span class="p">[</span><span class="n">ErrorInfo</span><span class="p">]).</span><span class="n">getStartLoc</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">ErrorLoc</span> <span class="o">==</span> <span class="n">SMLoc</span><span class="p">())</span> <span class="n">ErrorLoc</span> <span class="o">=</span> <span class="n">IDLoc</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">Error</span><span class="p">(</span><span class="n">ErrorLoc</span><span class="p">,</span> <span class="s">&quot;invalid operand for instruction&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">case</span> <span class="n">Match_MnemonicFail</span>:
    <span class="k">return</span> <span class="n">Error</span><span class="p">(</span><span class="n">IDLoc</span><span class="p">,</span> <span class="s">&quot;invalid instruction&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">matchRegisterName</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">Name</span><span class="p">)</span> <span class="p">{</span>

   <span class="kt">int</span> <span class="n">CC</span><span class="p">;</span>
    <span class="n">CC</span> <span class="o">=</span> <span class="n">StringSwitch</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Name</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;zero&quot;</span><span class="p">,</span>  <span class="n">Cpu0</span><span class="o">::</span><span class="n">ZERO</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;at&quot;</span><span class="p">,</span>  <span class="n">Cpu0</span><span class="o">::</span><span class="n">AT</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;v0&quot;</span><span class="p">,</span>  <span class="n">Cpu0</span><span class="o">::</span><span class="n">V0</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;v1&quot;</span><span class="p">,</span>  <span class="n">Cpu0</span><span class="o">::</span><span class="n">V1</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;a0&quot;</span><span class="p">,</span>  <span class="n">Cpu0</span><span class="o">::</span><span class="n">A0</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;a1&quot;</span><span class="p">,</span>  <span class="n">Cpu0</span><span class="o">::</span><span class="n">A1</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;t9&quot;</span><span class="p">,</span>  <span class="n">Cpu0</span><span class="o">::</span><span class="n">T9</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;t0&quot;</span><span class="p">,</span>  <span class="n">Cpu0</span><span class="o">::</span><span class="n">T0</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;t1&quot;</span><span class="p">,</span>  <span class="n">Cpu0</span><span class="o">::</span><span class="n">T1</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;s0&quot;</span><span class="p">,</span>  <span class="n">Cpu0</span><span class="o">::</span><span class="n">S0</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;s1&quot;</span><span class="p">,</span>  <span class="n">Cpu0</span><span class="o">::</span><span class="n">S1</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;sw&quot;</span><span class="p">,</span>  <span class="n">Cpu0</span><span class="o">::</span><span class="n">SW</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;gp&quot;</span><span class="p">,</span>  <span class="n">Cpu0</span><span class="o">::</span><span class="n">GP</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;fp&quot;</span><span class="p">,</span>  <span class="n">Cpu0</span><span class="o">::</span><span class="n">FP</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;sp&quot;</span><span class="p">,</span>  <span class="n">Cpu0</span><span class="o">::</span><span class="n">SP</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;lr&quot;</span><span class="p">,</span>  <span class="n">Cpu0</span><span class="o">::</span><span class="n">LR</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;pc&quot;</span><span class="p">,</span>  <span class="n">Cpu0</span><span class="o">::</span><span class="n">PC</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;hi&quot;</span><span class="p">,</span>  <span class="n">Cpu0</span><span class="o">::</span><span class="n">HI</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;lo&quot;</span><span class="p">,</span>  <span class="n">Cpu0</span><span class="o">::</span><span class="n">LO</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;epc&quot;</span><span class="p">,</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">EPC</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Default</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">CC</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">CC</span><span class="p">;</span>

  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">getReg</span><span class="p">(</span><span class="kt">int</span> <span class="n">RC</span><span class="p">,</span><span class="kt">int</span> <span class="n">RegNo</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="n">getContext</span><span class="p">().</span><span class="n">getRegisterInfo</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getRegClass</span><span class="p">(</span><span class="n">RC</span><span class="p">).</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">RegNo</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">matchRegisterByNumber</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">RegNum</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">Mnemonic</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">RegNum</span> <span class="o">&gt;</span> <span class="mi">15</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

  <span class="k">return</span> <span class="nf">getReg</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">CPURegsRegClassID</span><span class="p">,</span> <span class="n">RegNum</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">tryParseRegister</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">Mnemonic</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">AsmToken</span> <span class="o">&amp;</span><span class="n">Tok</span> <span class="o">=</span> <span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">RegNum</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">Tok</span><span class="p">.</span><span class="n">is</span><span class="p">(</span><span class="n">AsmToken</span><span class="o">::</span><span class="n">Identifier</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">lowerCase</span> <span class="o">=</span> <span class="n">Tok</span><span class="p">.</span><span class="n">getString</span><span class="p">().</span><span class="n">lower</span><span class="p">();</span>
    <span class="n">RegNum</span> <span class="o">=</span> <span class="n">matchRegisterName</span><span class="p">(</span><span class="n">lowerCase</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Tok</span><span class="p">.</span><span class="n">is</span><span class="p">(</span><span class="n">AsmToken</span><span class="o">::</span><span class="n">Integer</span><span class="p">))</span>
    <span class="n">RegNum</span> <span class="o">=</span> <span class="n">matchRegisterByNumber</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Tok</span><span class="p">.</span><span class="n">getIntVal</span><span class="p">()),</span>
                                   <span class="n">Mnemonic</span><span class="p">.</span><span class="n">lower</span><span class="p">());</span>
    <span class="k">else</span>
      <span class="k">return</span> <span class="n">RegNum</span><span class="p">;</span>  <span class="c1">//error</span>
  <span class="k">return</span> <span class="n">RegNum</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span>
  <span class="n">tryParseRegisterOperand</span><span class="p">(</span><span class="n">OperandVector</span> <span class="o">&amp;</span><span class="n">Operands</span><span class="p">,</span>
                          <span class="n">StringRef</span> <span class="n">Mnemonic</span><span class="p">){</span>

  <span class="n">SMLoc</span> <span class="n">S</span> <span class="o">=</span> <span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">().</span><span class="n">getLoc</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">RegNo</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="n">RegNo</span> <span class="o">=</span> <span class="n">tryParseRegister</span><span class="p">(</span><span class="n">Mnemonic</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">RegNo</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

  <span class="n">Operands</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Cpu0Operand</span><span class="o">::</span><span class="n">CreateReg</span><span class="p">(</span><span class="n">RegNo</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span>
      <span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">().</span><span class="n">getLoc</span><span class="p">()));</span>
  <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span> <span class="c1">// Eat register token.</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">ParseOperand</span><span class="p">(</span><span class="n">OperandVector</span> <span class="o">&amp;</span><span class="n">Operands</span><span class="p">,</span>
                                 <span class="n">StringRef</span> <span class="n">Mnemonic</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">DEBUG</span><span class="p">(</span><span class="n">dbgs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;ParseOperand</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="c1">// Check if the current operand has a custom associated parser, if so, try to</span>
  <span class="c1">// custom parse the operand, or fallback to the general approach.</span>
  <span class="n">OperandMatchResultTy</span> <span class="n">ResTy</span> <span class="o">=</span> <span class="n">MatchOperandParserImpl</span><span class="p">(</span><span class="n">Operands</span><span class="p">,</span> <span class="n">Mnemonic</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ResTy</span> <span class="o">==</span> <span class="n">MatchOperand_Success</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="c1">// If there wasn&#39;t a custom match, try the generic matcher below. Otherwise,</span>
  <span class="c1">// there was a match, but an error occurred, in which case, just return that</span>
  <span class="c1">// the operand parsing failed.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ResTy</span> <span class="o">==</span> <span class="n">MatchOperand_ParseFail</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

  <span class="n">DEBUG</span><span class="p">(</span><span class="n">dbgs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;.. Generic Parser</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">getLexer</span><span class="p">().</span><span class="n">getKind</span><span class="p">())</span> <span class="p">{</span>
  <span class="nl">default:</span>
    <span class="n">Error</span><span class="p">(</span><span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">().</span><span class="n">getLoc</span><span class="p">(),</span> <span class="s">&quot;unexpected token in operand&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">AsmToken</span>:<span class="o">:</span><span class="n">Dollar</span><span class="o">:</span> <span class="p">{</span>
    <span class="c1">// parse register</span>
    <span class="n">SMLoc</span> <span class="n">S</span> <span class="o">=</span> <span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">().</span><span class="n">getLoc</span><span class="p">();</span>
    <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span> <span class="c1">// Eat dollar token.</span>
    <span class="c1">// parse register operand</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tryParseRegisterOperand</span><span class="p">(</span><span class="n">Operands</span><span class="p">,</span> <span class="n">Mnemonic</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">getLexer</span><span class="p">().</span><span class="n">is</span><span class="p">(</span><span class="n">AsmToken</span><span class="o">::</span><span class="n">LParen</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// check if it is indexed addressing operand</span>
        <span class="n">Operands</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Cpu0Operand</span><span class="o">::</span><span class="n">CreateToken</span><span class="p">(</span><span class="s">&quot;(&quot;</span><span class="p">,</span> <span class="n">S</span><span class="p">));</span>
        <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span> <span class="c1">// eat parenthesis</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">getLexer</span><span class="p">().</span><span class="n">isNot</span><span class="p">(</span><span class="n">AsmToken</span><span class="o">::</span><span class="n">Dollar</span><span class="p">))</span>
          <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

        <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span> <span class="c1">// eat dollar</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tryParseRegisterOperand</span><span class="p">(</span><span class="n">Operands</span><span class="p">,</span> <span class="n">Mnemonic</span><span class="p">))</span>
          <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">getLexer</span><span class="p">().</span><span class="n">is</span><span class="p">(</span><span class="n">AsmToken</span><span class="o">::</span><span class="n">RParen</span><span class="p">))</span>
          <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

        <span class="n">S</span> <span class="o">=</span> <span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">().</span><span class="n">getLoc</span><span class="p">();</span>
        <span class="n">Operands</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Cpu0Operand</span><span class="o">::</span><span class="n">CreateToken</span><span class="p">(</span><span class="s">&quot;)&quot;</span><span class="p">,</span> <span class="n">S</span><span class="p">));</span>
        <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// maybe it is a symbol reference</span>
    <span class="n">StringRef</span> <span class="n">Identifier</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Parser</span><span class="p">.</span><span class="n">parseIdentifier</span><span class="p">(</span><span class="n">Identifier</span><span class="p">))</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

    <span class="n">SMLoc</span> <span class="n">E</span> <span class="o">=</span> <span class="n">SMLoc</span><span class="o">::</span><span class="n">getFromPointer</span><span class="p">(</span><span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">().</span><span class="n">getLoc</span><span class="p">().</span><span class="n">getPointer</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

    <span class="n">MCSymbol</span> <span class="o">*</span><span class="n">Sym</span> <span class="o">=</span> <span class="n">getContext</span><span class="p">().</span><span class="n">getOrCreateSymbol</span><span class="p">(</span><span class="s">&quot;$&quot;</span> <span class="o">+</span> <span class="n">Identifier</span><span class="p">);</span>

    <span class="c1">// Otherwise create a symbol ref.</span>
    <span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">Res</span> <span class="o">=</span> <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">Sym</span><span class="p">,</span> <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_None</span><span class="p">,</span>
                                                <span class="n">getContext</span><span class="p">());</span>

    <span class="n">Operands</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Cpu0Operand</span><span class="o">::</span><span class="n">CreateImm</span><span class="p">(</span><span class="n">Res</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">E</span><span class="p">));</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">case</span> <span class="n">AsmToken</span>:<span class="o">:</span><span class="n">Identifier</span><span class="o">:</span>
  <span class="k">case</span> <span class="n">AsmToken</span>:<span class="o">:</span><span class="n">LParen</span><span class="o">:</span>
  <span class="k">case</span> <span class="n">AsmToken</span>:<span class="o">:</span><span class="n">Minus</span><span class="o">:</span>
  <span class="k">case</span> <span class="n">AsmToken</span>:<span class="o">:</span><span class="n">Plus</span><span class="o">:</span>
  <span class="k">case</span> <span class="n">AsmToken</span>:<span class="o">:</span><span class="n">Integer</span><span class="o">:</span>
  <span class="k">case</span> <span class="n">AsmToken</span>:<span class="o">:</span><span class="n">String</span><span class="o">:</span> <span class="p">{</span>
     <span class="c1">// quoted label names</span>
    <span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">IdVal</span><span class="p">;</span>
    <span class="n">SMLoc</span> <span class="n">S</span> <span class="o">=</span> <span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">().</span><span class="n">getLoc</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">getParser</span><span class="p">().</span><span class="n">parseExpression</span><span class="p">(</span><span class="n">IdVal</span><span class="p">))</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">SMLoc</span> <span class="n">E</span> <span class="o">=</span> <span class="n">SMLoc</span><span class="o">::</span><span class="n">getFromPointer</span><span class="p">(</span><span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">().</span><span class="n">getLoc</span><span class="p">().</span><span class="n">getPointer</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">Operands</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Cpu0Operand</span><span class="o">::</span><span class="n">CreateImm</span><span class="p">(</span><span class="n">IdVal</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">E</span><span class="p">));</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">case</span> <span class="n">AsmToken</span>:<span class="o">:</span><span class="n">Percent</span><span class="o">:</span> <span class="p">{</span>
    <span class="c1">// it is a symbol reference or constant expression</span>
    <span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">IdVal</span><span class="p">;</span>
    <span class="n">SMLoc</span> <span class="n">S</span> <span class="o">=</span> <span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">().</span><span class="n">getLoc</span><span class="p">();</span> <span class="c1">// start location of the operand</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">parseRelocOperand</span><span class="p">(</span><span class="n">IdVal</span><span class="p">))</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

    <span class="n">SMLoc</span> <span class="n">E</span> <span class="o">=</span> <span class="n">SMLoc</span><span class="o">::</span><span class="n">getFromPointer</span><span class="p">(</span><span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">().</span><span class="n">getLoc</span><span class="p">().</span><span class="n">getPointer</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

    <span class="n">Operands</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Cpu0Operand</span><span class="o">::</span><span class="n">CreateImm</span><span class="p">(</span><span class="n">IdVal</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">E</span><span class="p">));</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span> <span class="c1">// case AsmToken::Percent</span>
  <span class="p">}</span> <span class="c1">// switch(getLexer().getKind())</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">parseRelocOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*&amp;</span><span class="n">Res</span><span class="p">)</span> <span class="p">{</span>

  <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span> <span class="c1">// eat % token</span>
  <span class="k">const</span> <span class="n">AsmToken</span> <span class="o">&amp;</span><span class="n">Tok</span> <span class="o">=</span> <span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">();</span> <span class="c1">// get next token, operation</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Tok</span><span class="p">.</span><span class="n">isNot</span><span class="p">(</span><span class="n">AsmToken</span><span class="o">::</span><span class="n">Identifier</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Str</span> <span class="o">=</span> <span class="n">Tok</span><span class="p">.</span><span class="n">getIdentifier</span><span class="p">().</span><span class="n">str</span><span class="p">();</span>

  <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span> <span class="c1">// eat identifier</span>
  <span class="c1">// now make expression from the rest of the operand</span>
  <span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">IdVal</span><span class="p">;</span>
  <span class="n">SMLoc</span> <span class="n">EndLoc</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">getLexer</span><span class="p">().</span><span class="n">getKind</span><span class="p">()</span> <span class="o">==</span> <span class="n">AsmToken</span><span class="o">::</span><span class="n">LParen</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span> <span class="c1">// eat &#39;(&#39; token</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">getLexer</span><span class="p">().</span><span class="n">getKind</span><span class="p">()</span> <span class="o">==</span> <span class="n">AsmToken</span><span class="o">::</span><span class="n">Percent</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span> <span class="c1">// eat % token</span>
        <span class="k">const</span> <span class="n">AsmToken</span> <span class="o">&amp;</span><span class="n">nextTok</span> <span class="o">=</span> <span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nextTok</span><span class="p">.</span><span class="n">isNot</span><span class="p">(</span><span class="n">AsmToken</span><span class="o">::</span><span class="n">Identifier</span><span class="p">))</span>
          <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="n">Str</span> <span class="o">+=</span> <span class="s">&quot;(%&quot;</span><span class="p">;</span>
        <span class="n">Str</span> <span class="o">+=</span> <span class="n">nextTok</span><span class="p">.</span><span class="n">getIdentifier</span><span class="p">();</span>
        <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span> <span class="c1">// eat identifier</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">getLexer</span><span class="p">().</span><span class="n">getKind</span><span class="p">()</span> <span class="o">!=</span> <span class="n">AsmToken</span><span class="o">::</span><span class="n">LParen</span><span class="p">)</span>
          <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">getParser</span><span class="p">().</span><span class="n">parseParenExpression</span><span class="p">(</span><span class="n">IdVal</span><span class="p">,</span><span class="n">EndLoc</span><span class="p">))</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">getLexer</span><span class="p">().</span><span class="n">getKind</span><span class="p">()</span> <span class="o">==</span> <span class="n">AsmToken</span><span class="o">::</span><span class="n">RParen</span><span class="p">)</span>
      <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span> <span class="c1">// eat &#39;)&#39; token</span>

  <span class="p">}</span> <span class="k">else</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// parenthesis must follow reloc operand</span>

  <span class="c1">// Check the type of the expression</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">const</span> <span class="n">MCConstantExpr</span> <span class="o">*</span><span class="n">MCE</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">MCConstantExpr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">IdVal</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// it&#39;s a constant, evaluate lo or hi value</span>
    <span class="kt">int</span> <span class="n">Val</span> <span class="o">=</span> <span class="n">MCE</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Str</span> <span class="o">==</span> <span class="s">&quot;lo&quot;</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Val</span> <span class="o">=</span> <span class="n">Val</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Str</span> <span class="o">==</span> <span class="s">&quot;hi&quot;</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Val</span> <span class="o">=</span> <span class="p">(</span><span class="n">Val</span> <span class="o">&amp;</span> <span class="mh">0xffff0000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">Res</span> <span class="o">=</span> <span class="n">MCConstantExpr</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">Val</span><span class="p">,</span> <span class="n">getContext</span><span class="p">());</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="k">const</span> <span class="n">MCSymbolRefExpr</span> <span class="o">*</span><span class="n">MSRE</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">MCSymbolRefExpr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">IdVal</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// it&#39;s a symbol, create symbolic expression from symbol</span>
    <span class="n">StringRef</span> <span class="n">Symbol</span> <span class="o">=</span> <span class="n">MSRE</span><span class="o">-&gt;</span><span class="n">getSymbol</span><span class="p">().</span><span class="n">getName</span><span class="p">();</span>
    <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VariantKind</span> <span class="n">VK</span> <span class="o">=</span> <span class="n">getVariantKind</span><span class="p">(</span><span class="n">Str</span><span class="p">);</span>
    <span class="n">Res</span> <span class="o">=</span> <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">Symbol</span><span class="p">,</span><span class="n">VK</span><span class="p">,</span><span class="n">getContext</span><span class="p">());</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">ParseRegister</span><span class="p">(</span><span class="kt">unsigned</span> <span class="o">&amp;</span><span class="n">RegNo</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="o">&amp;</span><span class="n">StartLoc</span><span class="p">,</span>
                                  <span class="n">SMLoc</span> <span class="o">&amp;</span><span class="n">EndLoc</span><span class="p">)</span> <span class="p">{</span>

  <span class="n">StartLoc</span> <span class="o">=</span> <span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">().</span><span class="n">getLoc</span><span class="p">();</span>
  <span class="n">RegNo</span> <span class="o">=</span> <span class="n">tryParseRegister</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
  <span class="n">EndLoc</span> <span class="o">=</span> <span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">().</span><span class="n">getLoc</span><span class="p">();</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">RegNo</span> <span class="o">==</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">parseMemOffset</span><span class="p">(</span><span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*&amp;</span><span class="n">Res</span><span class="p">)</span> <span class="p">{</span>

  <span class="n">SMLoc</span> <span class="n">S</span><span class="p">;</span>

  <span class="k">switch</span><span class="p">(</span><span class="n">getLexer</span><span class="p">().</span><span class="n">getKind</span><span class="p">())</span> <span class="p">{</span>
  <span class="nl">default:</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">AsmToken</span>:<span class="o">:</span><span class="n">Integer</span><span class="o">:</span>
  <span class="k">case</span> <span class="n">AsmToken</span>:<span class="o">:</span><span class="n">Minus</span><span class="o">:</span>
  <span class="k">case</span> <span class="n">AsmToken</span>:<span class="o">:</span><span class="n">Plus</span><span class="o">:</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">getParser</span><span class="p">().</span><span class="n">parseExpression</span><span class="p">(</span><span class="n">Res</span><span class="p">));</span>
  <span class="k">case</span> <span class="n">AsmToken</span>:<span class="o">:</span><span class="n">Percent</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">parseRelocOperand</span><span class="p">(</span><span class="n">Res</span><span class="p">);</span>
  <span class="k">case</span> <span class="n">AsmToken</span>:<span class="o">:</span><span class="n">LParen</span><span class="o">:</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>  <span class="c1">// it&#39;s probably assuming 0</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// eg, 12($sp) or 12(la)</span>
<span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">OperandMatchResultTy</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">parseMemOperand</span><span class="p">(</span>
               <span class="n">OperandVector</span> <span class="o">&amp;</span><span class="n">Operands</span><span class="p">)</span> <span class="p">{</span>

  <span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">IdVal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">SMLoc</span> <span class="n">S</span><span class="p">;</span>
  <span class="c1">// first operand is the offset</span>
  <span class="n">S</span> <span class="o">=</span> <span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">().</span><span class="n">getLoc</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">parseMemOffset</span><span class="p">(</span><span class="n">IdVal</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">MatchOperand_ParseFail</span><span class="p">;</span>

  <span class="k">const</span> <span class="n">AsmToken</span> <span class="o">&amp;</span><span class="n">Tok</span> <span class="o">=</span> <span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">();</span> <span class="c1">// get next token</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Tok</span><span class="p">.</span><span class="n">isNot</span><span class="p">(</span><span class="n">AsmToken</span><span class="o">::</span><span class="n">LParen</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">Cpu0Operand</span> <span class="o">&amp;</span><span class="n">Mnemonic</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Cpu0Operand</span> <span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">Operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Mnemonic</span><span class="p">.</span><span class="n">getToken</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;la&quot;</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">SMLoc</span> <span class="n">E</span> <span class="o">=</span> <span class="n">SMLoc</span><span class="o">::</span><span class="n">getFromPointer</span><span class="p">(</span><span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">().</span><span class="n">getLoc</span><span class="p">().</span><span class="n">getPointer</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
      <span class="n">Operands</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Cpu0Operand</span><span class="o">::</span><span class="n">CreateImm</span><span class="p">(</span><span class="n">IdVal</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">E</span><span class="p">));</span>
      <span class="k">return</span> <span class="n">MatchOperand_Success</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">Error</span><span class="p">(</span><span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">().</span><span class="n">getLoc</span><span class="p">(),</span> <span class="s">&quot;&#39;(&#39; expected&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">MatchOperand_ParseFail</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span> <span class="c1">// Eat &#39;(&#39; token.</span>

  <span class="k">const</span> <span class="n">AsmToken</span> <span class="o">&amp;</span><span class="n">Tok1</span> <span class="o">=</span> <span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">();</span> <span class="c1">// get next token</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Tok1</span><span class="p">.</span><span class="n">is</span><span class="p">(</span><span class="n">AsmToken</span><span class="o">::</span><span class="n">Dollar</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span> <span class="c1">// Eat &#39;$&#39; token.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tryParseRegisterOperand</span><span class="p">(</span><span class="n">Operands</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">Error</span><span class="p">(</span><span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">().</span><span class="n">getLoc</span><span class="p">(),</span> <span class="s">&quot;unexpected token in operand&quot;</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">MatchOperand_ParseFail</span><span class="p">;</span>
    <span class="p">}</span>

  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">Error</span><span class="p">(</span><span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">().</span><span class="n">getLoc</span><span class="p">(),</span> <span class="s">&quot;unexpected token in operand&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">MatchOperand_ParseFail</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="n">AsmToken</span> <span class="o">&amp;</span><span class="n">Tok2</span> <span class="o">=</span> <span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">();</span> <span class="c1">// get next token</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Tok2</span><span class="p">.</span><span class="n">isNot</span><span class="p">(</span><span class="n">AsmToken</span><span class="o">::</span><span class="n">RParen</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">Error</span><span class="p">(</span><span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">().</span><span class="n">getLoc</span><span class="p">(),</span> <span class="s">&quot;&#39;)&#39; expected&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">MatchOperand_ParseFail</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">SMLoc</span> <span class="n">E</span> <span class="o">=</span> <span class="n">SMLoc</span><span class="o">::</span><span class="n">getFromPointer</span><span class="p">(</span><span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">().</span><span class="n">getLoc</span><span class="p">().</span><span class="n">getPointer</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

  <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span> <span class="c1">// Eat &#39;)&#39; token.</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IdVal</span><span class="p">)</span>
    <span class="n">IdVal</span> <span class="o">=</span> <span class="n">MCConstantExpr</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">getContext</span><span class="p">());</span>

  <span class="c1">// Replace the register operand with the memory operand.</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Cpu0Operand</span><span class="o">&gt;</span> <span class="n">op</span><span class="p">(</span>
      <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Cpu0Operand</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">Operands</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">release</span><span class="p">()));</span>
  <span class="kt">int</span> <span class="n">RegNo</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">getReg</span><span class="p">();</span>
  <span class="c1">// remove register from operands</span>
  <span class="n">Operands</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
  <span class="c1">// and add memory operand</span>
  <span class="n">Operands</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Cpu0Operand</span><span class="o">::</span><span class="n">CreateMem</span><span class="p">(</span><span class="n">RegNo</span><span class="p">,</span> <span class="n">IdVal</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">E</span><span class="p">));</span>
  <span class="k">return</span> <span class="n">MatchOperand_Success</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//@getVariantKind {</span>
<span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VariantKind</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">getVariantKind</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">Symbol</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">//@getVariantKind body {</span>
  <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VariantKind</span> <span class="n">VK</span>
                   <span class="o">=</span> <span class="n">StringSwitch</span><span class="o">&lt;</span><span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VariantKind</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;hi&quot;</span><span class="p">,</span>          <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_ABS_HI</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;lo&quot;</span><span class="p">,</span>          <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_ABS_LO</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;gp_rel&quot;</span><span class="p">,</span>      <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_GPREL</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;call16&quot;</span><span class="p">,</span>      <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_GOT_CALL</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;got&quot;</span><span class="p">,</span>         <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_GOT</span><span class="p">)</span>
<span class="cp">#if CH &gt;= CH12_1</span>
    <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;tlsgd&quot;</span><span class="p">,</span>       <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_TLSGD</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;tlsldm&quot;</span><span class="p">,</span>      <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_TLSLDM</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;dtp_hi&quot;</span><span class="p">,</span>      <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_DTP_HI</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;dtp_lo&quot;</span><span class="p">,</span>      <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_DTP_LO</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;gottp&quot;</span><span class="p">,</span>       <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_GOTTPREL</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;tp_hi&quot;</span><span class="p">,</span>       <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_TP_HI</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;tp_lo&quot;</span><span class="p">,</span>       <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_TP_LO</span><span class="p">)</span>
<span class="cp">#endif</span>
    <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;got_disp&quot;</span><span class="p">,</span>    <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_GOT_DISP</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;got_page&quot;</span><span class="p">,</span>    <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_GOT_PAGE</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;got_ofst&quot;</span><span class="p">,</span>    <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_GOT_OFST</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;hi(%neg(%gp_rel&quot;</span><span class="p">,</span>    <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_GPOFF_HI</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;lo(%neg(%gp_rel&quot;</span><span class="p">,</span>    <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_GPOFF_LO</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Default</span><span class="p">(</span><span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_None</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">VK</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span>
<span class="n">parseMathOperation</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">Name</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="n">NameLoc</span><span class="p">,</span>
                   <span class="n">OperandVector</span> <span class="o">&amp;</span><span class="n">Operands</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// split the format</span>
  <span class="kt">size_t</span> <span class="n">Start</span> <span class="o">=</span> <span class="n">Name</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="sc">&#39;.&#39;</span><span class="p">),</span> <span class="n">Next</span> <span class="o">=</span> <span class="n">Name</span><span class="p">.</span><span class="n">rfind</span><span class="p">(</span><span class="sc">&#39;.&#39;</span><span class="p">);</span>
  <span class="n">StringRef</span> <span class="n">Format1</span> <span class="o">=</span> <span class="n">Name</span><span class="p">.</span><span class="n">slice</span><span class="p">(</span><span class="n">Start</span><span class="p">,</span> <span class="n">Next</span><span class="p">);</span>
  <span class="c1">// and add the first format to the operands</span>
  <span class="n">Operands</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Cpu0Operand</span><span class="o">::</span><span class="n">CreateToken</span><span class="p">(</span><span class="n">Format1</span><span class="p">,</span> <span class="n">NameLoc</span><span class="p">));</span>
  <span class="c1">// now for the second format</span>
  <span class="n">StringRef</span> <span class="n">Format2</span> <span class="o">=</span> <span class="n">Name</span><span class="p">.</span><span class="n">slice</span><span class="p">(</span><span class="n">Next</span><span class="p">,</span> <span class="n">StringRef</span><span class="o">::</span><span class="n">npos</span><span class="p">);</span>
  <span class="n">Operands</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Cpu0Operand</span><span class="o">::</span><span class="n">CreateToken</span><span class="p">(</span><span class="n">Format2</span><span class="p">,</span> <span class="n">NameLoc</span><span class="p">));</span>

  <span class="c1">// set the format for the first register</span>
<span class="c1">//  setFpFormat(Format1);</span>

  <span class="c1">// Read the remaining operands.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">getLexer</span><span class="p">().</span><span class="n">isNot</span><span class="p">(</span><span class="n">AsmToken</span><span class="o">::</span><span class="n">EndOfStatement</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// Read the first operand.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ParseOperand</span><span class="p">(</span><span class="n">Operands</span><span class="p">,</span> <span class="n">Name</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">SMLoc</span> <span class="n">Loc</span> <span class="o">=</span> <span class="n">getLexer</span><span class="p">().</span><span class="n">getLoc</span><span class="p">();</span>
      <span class="n">Parser</span><span class="p">.</span><span class="n">eatToEndOfStatement</span><span class="p">();</span>
      <span class="k">return</span> <span class="nf">Error</span><span class="p">(</span><span class="n">Loc</span><span class="p">,</span> <span class="s">&quot;unexpected token in argument list&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">getLexer</span><span class="p">().</span><span class="n">isNot</span><span class="p">(</span><span class="n">AsmToken</span><span class="o">::</span><span class="n">Comma</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">SMLoc</span> <span class="n">Loc</span> <span class="o">=</span> <span class="n">getLexer</span><span class="p">().</span><span class="n">getLoc</span><span class="p">();</span>
      <span class="n">Parser</span><span class="p">.</span><span class="n">eatToEndOfStatement</span><span class="p">();</span>
      <span class="k">return</span> <span class="nf">Error</span><span class="p">(</span><span class="n">Loc</span><span class="p">,</span> <span class="s">&quot;unexpected token in argument list&quot;</span><span class="p">);</span>

    <span class="p">}</span>
    <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span>  <span class="c1">// Eat the comma.</span>

    <span class="c1">// Parse and remember the operand.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ParseOperand</span><span class="p">(</span><span class="n">Operands</span><span class="p">,</span> <span class="n">Name</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">SMLoc</span> <span class="n">Loc</span> <span class="o">=</span> <span class="n">getLexer</span><span class="p">().</span><span class="n">getLoc</span><span class="p">();</span>
      <span class="n">Parser</span><span class="p">.</span><span class="n">eatToEndOfStatement</span><span class="p">();</span>
      <span class="k">return</span> <span class="nf">Error</span><span class="p">(</span><span class="n">Loc</span><span class="p">,</span> <span class="s">&quot;unexpected token in argument list&quot;</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">getLexer</span><span class="p">().</span><span class="n">isNot</span><span class="p">(</span><span class="n">AsmToken</span><span class="o">::</span><span class="n">EndOfStatement</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">SMLoc</span> <span class="n">Loc</span> <span class="o">=</span> <span class="n">getLexer</span><span class="p">().</span><span class="n">getLoc</span><span class="p">();</span>
    <span class="n">Parser</span><span class="p">.</span><span class="n">eatToEndOfStatement</span><span class="p">();</span>
    <span class="k">return</span> <span class="nf">Error</span><span class="p">(</span><span class="n">Loc</span><span class="p">,</span> <span class="s">&quot;unexpected token in argument list&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span> <span class="c1">// Consume the EndOfStatement</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span>
<span class="n">ParseInstruction</span><span class="p">(</span><span class="n">ParseInstructionInfo</span> <span class="o">&amp;</span><span class="n">Info</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">Name</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="n">NameLoc</span><span class="p">,</span>
                 <span class="n">OperandVector</span> <span class="o">&amp;</span><span class="n">Operands</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">// Create the leading tokens for the mnemonic, split by &#39;.&#39; characters.</span>
  <span class="kt">size_t</span> <span class="n">Start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Next</span> <span class="o">=</span> <span class="n">Name</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="sc">&#39;.&#39;</span><span class="p">);</span>
  <span class="n">StringRef</span> <span class="n">Mnemonic</span> <span class="o">=</span> <span class="n">Name</span><span class="p">.</span><span class="n">slice</span><span class="p">(</span><span class="n">Start</span><span class="p">,</span> <span class="n">Next</span><span class="p">);</span>

  <span class="n">Operands</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Cpu0Operand</span><span class="o">::</span><span class="n">CreateToken</span><span class="p">(</span><span class="n">Mnemonic</span><span class="p">,</span> <span class="n">NameLoc</span><span class="p">));</span>

  <span class="c1">// Read the remaining operands.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">getLexer</span><span class="p">().</span><span class="n">isNot</span><span class="p">(</span><span class="n">AsmToken</span><span class="o">::</span><span class="n">EndOfStatement</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// Read the first operand.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ParseOperand</span><span class="p">(</span><span class="n">Operands</span><span class="p">,</span> <span class="n">Name</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">SMLoc</span> <span class="n">Loc</span> <span class="o">=</span> <span class="n">getLexer</span><span class="p">().</span><span class="n">getLoc</span><span class="p">();</span>
      <span class="n">Parser</span><span class="p">.</span><span class="n">eatToEndOfStatement</span><span class="p">();</span>
      <span class="k">return</span> <span class="nf">Error</span><span class="p">(</span><span class="n">Loc</span><span class="p">,</span> <span class="s">&quot;unexpected token in argument list&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">getLexer</span><span class="p">().</span><span class="n">is</span><span class="p">(</span><span class="n">AsmToken</span><span class="o">::</span><span class="n">Comma</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span>  <span class="c1">// Eat the comma.</span>

      <span class="c1">// Parse and remember the operand.</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">ParseOperand</span><span class="p">(</span><span class="n">Operands</span><span class="p">,</span> <span class="n">Name</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">SMLoc</span> <span class="n">Loc</span> <span class="o">=</span> <span class="n">getLexer</span><span class="p">().</span><span class="n">getLoc</span><span class="p">();</span>
        <span class="n">Parser</span><span class="p">.</span><span class="n">eatToEndOfStatement</span><span class="p">();</span>
        <span class="k">return</span> <span class="nf">Error</span><span class="p">(</span><span class="n">Loc</span><span class="p">,</span> <span class="s">&quot;unexpected token in argument list&quot;</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">getLexer</span><span class="p">().</span><span class="n">isNot</span><span class="p">(</span><span class="n">AsmToken</span><span class="o">::</span><span class="n">EndOfStatement</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">SMLoc</span> <span class="n">Loc</span> <span class="o">=</span> <span class="n">getLexer</span><span class="p">().</span><span class="n">getLoc</span><span class="p">();</span>
    <span class="n">Parser</span><span class="p">.</span><span class="n">eatToEndOfStatement</span><span class="p">();</span>
    <span class="k">return</span> <span class="nf">Error</span><span class="p">(</span><span class="n">Loc</span><span class="p">,</span> <span class="s">&quot;unexpected token in argument list&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span> <span class="c1">// Consume the EndOfStatement</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">reportParseError</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">ErrorMsg</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">SMLoc</span> <span class="n">Loc</span> <span class="o">=</span> <span class="n">getLexer</span><span class="p">().</span><span class="n">getLoc</span><span class="p">();</span>
   <span class="n">Parser</span><span class="p">.</span><span class="n">eatToEndOfStatement</span><span class="p">();</span>
   <span class="k">return</span> <span class="nf">Error</span><span class="p">(</span><span class="n">Loc</span><span class="p">,</span> <span class="n">ErrorMsg</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">parseSetReorderDirective</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span>
  <span class="c1">// if this is not the end of the statement, report error</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">getLexer</span><span class="p">().</span><span class="n">isNot</span><span class="p">(</span><span class="n">AsmToken</span><span class="o">::</span><span class="n">EndOfStatement</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">reportParseError</span><span class="p">(</span><span class="s">&quot;unexpected token in statement&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">Options</span><span class="p">.</span><span class="n">setReorder</span><span class="p">();</span>
  <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span> <span class="c1">// Consume the EndOfStatement</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">parseSetNoReorderDirective</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span>
    <span class="c1">// if this is not the end of the statement, report error</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">getLexer</span><span class="p">().</span><span class="n">isNot</span><span class="p">(</span><span class="n">AsmToken</span><span class="o">::</span><span class="n">EndOfStatement</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">reportParseError</span><span class="p">(</span><span class="s">&quot;unexpected token in statement&quot;</span><span class="p">);</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">Options</span><span class="p">.</span><span class="n">setNoreorder</span><span class="p">();</span>
    <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span> <span class="c1">// Consume the EndOfStatement</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">parseSetMacroDirective</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span>
  <span class="c1">// if this is not the end of the statement, report error</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">getLexer</span><span class="p">().</span><span class="n">isNot</span><span class="p">(</span><span class="n">AsmToken</span><span class="o">::</span><span class="n">EndOfStatement</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">reportParseError</span><span class="p">(</span><span class="s">&quot;unexpected token in statement&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">Options</span><span class="p">.</span><span class="n">setMacro</span><span class="p">();</span>
  <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span> <span class="c1">// Consume the EndOfStatement</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">parseSetNoMacroDirective</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span>
  <span class="c1">// if this is not the end of the statement, report error</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">getLexer</span><span class="p">().</span><span class="n">isNot</span><span class="p">(</span><span class="n">AsmToken</span><span class="o">::</span><span class="n">EndOfStatement</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">reportParseError</span><span class="p">(</span><span class="s">&quot;`noreorder&#39; must be set before `nomacro&#39;&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Options</span><span class="p">.</span><span class="n">isReorder</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">reportParseError</span><span class="p">(</span><span class="s">&quot;`noreorder&#39; must be set before `nomacro&#39;&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">Options</span><span class="p">.</span><span class="n">setNomacro</span><span class="p">();</span>
  <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span> <span class="c1">// Consume the EndOfStatement</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">bool</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">parseDirectiveSet</span><span class="p">()</span> <span class="p">{</span>

  <span class="c1">// get next token</span>
  <span class="k">const</span> <span class="n">AsmToken</span> <span class="o">&amp;</span><span class="n">Tok</span> <span class="o">=</span> <span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">Tok</span><span class="p">.</span><span class="n">getString</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;reorder&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">parseSetReorderDirective</span><span class="p">();</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Tok</span><span class="p">.</span><span class="n">getString</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;noreorder&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">parseSetNoReorderDirective</span><span class="p">();</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Tok</span><span class="p">.</span><span class="n">getString</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;macro&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">parseSetMacroDirective</span><span class="p">();</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Tok</span><span class="p">.</span><span class="n">getString</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;nomacro&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">parseSetNoMacroDirective</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">ParseDirective</span><span class="p">(</span><span class="n">AsmToken</span> <span class="n">DirectiveID</span><span class="p">)</span> <span class="p">{</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">DirectiveID</span><span class="p">.</span><span class="n">getString</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;.ent&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ignore this directive for now</span>
    <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">DirectiveID</span><span class="p">.</span><span class="n">getString</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;.end&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ignore this directive for now</span>
    <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">DirectiveID</span><span class="p">.</span><span class="n">getString</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;.frame&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ignore this directive for now</span>
    <span class="n">Parser</span><span class="p">.</span><span class="n">eatToEndOfStatement</span><span class="p">();</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">DirectiveID</span><span class="p">.</span><span class="n">getString</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;.set&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">parseDirectiveSet</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">DirectiveID</span><span class="p">.</span><span class="n">getString</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;.fmask&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ignore this directive for now</span>
    <span class="n">Parser</span><span class="p">.</span><span class="n">eatToEndOfStatement</span><span class="p">();</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">DirectiveID</span><span class="p">.</span><span class="n">getString</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;.mask&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ignore this directive for now</span>
    <span class="n">Parser</span><span class="p">.</span><span class="n">eatToEndOfStatement</span><span class="p">();</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">DirectiveID</span><span class="p">.</span><span class="n">getString</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;.gpword&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ignore this directive for now</span>
    <span class="n">Parser</span><span class="p">.</span><span class="n">eatToEndOfStatement</span><span class="p">();</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">void</span> <span class="n">LLVMInitializeCpu0AsmParser</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">RegisterMCAsmParser</span><span class="o">&lt;</span><span class="n">Cpu0AsmParser</span><span class="o">&gt;</span> <span class="n">X</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">);</span>
  <span class="n">RegisterMCAsmParser</span><span class="o">&lt;</span><span class="n">Cpu0AsmParser</span><span class="o">&gt;</span> <span class="n">Y</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define GET_REGISTER_MATCHER</span>
<span class="cp">#define GET_MATCHER_IMPLEMENTATION</span>
<span class="cp">#include &quot;Cpu0GenAsmMatcher.inc&quot;</span>

<span class="cp">#else </span><span class="c1">// #if CH &gt;= CH11_1</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">void</span> <span class="n">LLVMInitializeCpu0AsmParser</span><span class="p">()</span> <span class="p">{}</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_1/AsmParser/CMakeLists.txt</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">add_llvm_library</span><span class="p">(</span><span class="n">LLVMCpu0AsmParser</span>
  <span class="n">Cpu0AsmParser</span><span class="p">.</span><span class="n">cpp</span>
  <span class="p">)</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_1/AsmParser/LLVMBuild.txt</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">;</span><span class="o">===-</span> <span class="p">.</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">Target</span><span class="o">/</span><span class="n">Cpu0</span><span class="o">/</span><span class="n">AsmParser</span><span class="o">/</span><span class="n">LLVMBuild</span><span class="p">.</span><span class="n">txt</span> <span class="o">----------------*-</span> <span class="n">Conf</span> <span class="o">-*--===</span><span class="p">;</span>
<span class="p">;</span>
<span class="p">;</span>                     <span class="n">The</span> <span class="n">LLVM</span> <span class="n">Compiler</span> <span class="n">Infrastructure</span>
<span class="p">;</span>
<span class="p">;</span> <span class="n">This</span> <span class="n">file</span> <span class="n">is</span> <span class="n">distributed</span> <span class="n">under</span> <span class="n">the</span> <span class="n">University</span> <span class="n">of</span> <span class="n">Illinois</span> <span class="n">Open</span> <span class="n">Source</span>
<span class="p">;</span> <span class="n">License</span><span class="p">.</span> <span class="n">See</span> <span class="n">LICENSE</span><span class="p">.</span><span class="n">TXT</span> <span class="k">for</span> <span class="n">details</span><span class="p">.</span>
<span class="p">;</span>
<span class="p">;</span><span class="o">===------------------------------------------------------------------------===</span><span class="p">;</span>
<span class="p">;</span>
<span class="p">;</span> <span class="n">This</span> <span class="n">is</span> <span class="n">an</span> <span class="n">LLVMBuild</span> <span class="n">description</span> <span class="n">file</span> <span class="k">for</span> <span class="n">the</span> <span class="n">components</span> <span class="n">in</span> <span class="k">this</span> <span class="n">subdirectory</span><span class="p">.</span>
<span class="p">;</span>
<span class="p">;</span> <span class="n">For</span> <span class="n">more</span> <span class="n">information</span> <span class="n">on</span> <span class="n">the</span> <span class="n">LLVMBuild</span> <span class="n">system</span><span class="p">,</span> <span class="n">please</span> <span class="n">see</span><span class="o">:</span>
<span class="p">;</span>
<span class="p">;</span>   <span class="n">http</span><span class="o">:</span><span class="c1">//llvm.org/docs/LLVMBuild.html</span>
<span class="p">;</span>
<span class="p">;</span><span class="o">===------------------------------------------------------------------------===</span><span class="p">;</span>

<span class="p">[</span><span class="n">component_0</span><span class="p">]</span>
<span class="n">type</span> <span class="o">=</span> <span class="n">Library</span>
<span class="n">name</span> <span class="o">=</span> <span class="n">Cpu0AsmParser</span>
<span class="n">parent</span> <span class="o">=</span> <span class="n">Cpu0</span>
<span class="n">required_libraries</span> <span class="o">=</span> <span class="n">Cpu0Desc</span> <span class="n">Cpu0Info</span> <span class="n">MC</span> <span class="n">MCParser</span> <span class="n">Support</span> 
<span class="n">add_to_library_groups</span> <span class="o">=</span> <span class="n">Cpu0</span>
</pre></div>
</div>
<p>The Cpu0AsmParser.cpp contains one thousand lines of code which do the assembly
language parsing. You can understand it with a little patient only.
To let file directory of AsmParser be built, modify CMakeLists.txt and
LLVMBuild.txt as follows,</p>
<p class="rubric">lbdex/chapters/Chapter11_1/CMakeLists.txt</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">set</span><span class="p">(</span><span class="n">LLVM_TARGET_DEFINITIONS</span> <span class="n">Cpu0Asm</span><span class="p">.</span><span class="n">td</span><span class="p">)</span>
<span class="n">tablegen</span><span class="p">(</span><span class="n">LLVM</span> <span class="n">Cpu0GenAsmMatcher</span><span class="p">.</span><span class="n">inc</span> <span class="o">-</span><span class="n">gen</span><span class="o">-</span><span class="k">asm</span><span class="o">-</span><span class="n">matcher</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_1/LLVMBuild.txt</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">subdirectories</span> <span class="o">=</span> 
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="n">AsmParser</span> 
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">has_asmparser</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_1/Cpu0Asm.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0Asm.td - Describe the Cpu0 Target Machine ------*- tablegen -*-===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// This is the top level entry point for the Cpu0 target.</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Target-independent interfaces</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="n">include</span> <span class="s">&quot;llvm/Target/Target.td&quot;</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Target-dependent interfaces</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="n">include</span> <span class="s">&quot;Cpu0RegisterInfo.td&quot;</span>
<span class="n">include</span> <span class="s">&quot;Cpu0RegisterInfoGPROutForAsm.td&quot;</span>
<span class="n">include</span> <span class="s">&quot;Cpu0.td&quot;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_1/Cpu0RegisterInfoGPROutForAsm.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Register Classes</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="n">def</span> <span class="n">GPROut</span> <span class="o">:</span> <span class="n">RegisterClass</span><span class="o">&lt;</span><span class="s">&quot;Cpu0&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">i32</span><span class="p">],</span> <span class="mi">32</span><span class="p">,</span> <span class="p">(</span><span class="n">add</span> <span class="n">CPURegs</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>The CMakeLists.txt add code as above to generate Cpu0GenAsmMatcher.inc
used by Cpu0AsmParser.cpp.
Cpu0Asm.td include Cpu0RegisterInfoGPROutForAsm.td which define GPROut to
CPURegs while Cpu0Other.td include Cpu0RegisterInfoGPROutForOther.td which
define GPROut to CPURegs but SW.
Cpu0Other.td is used when translating llvm IR to Cpu0 instruction.
In this case, the register SW is reserved for keeping the CPU status and not
allowed to be allocated as a general purpose register.
For example, if compile with C statement &#8220;a = (b &amp; c);&#8221; and generate
&#8220;and $sw, $1, $2&#8221; instruction, then the $sw of interrupt status will be
destroyed.
When do assembling, instruction &#8220;andi $sw, $sw, 0xffdf&#8221; is allowed.
This assembly program is accepted and Cpu0 backend treats it is safe.
For instance, assembler programmer can disable trace debug message by
&#8220;andi $sw, $sw, 0xffdf&#8221; and enable debug message by &#8220;ori $sw, $sw, 0x0020&#8221; as
the dynamic linker example code using them in later chapter.
Beside this, the interrupt bits can also be enabled or disabled by &#8220;ori&#8221; and
&#8220;andi&#8221; instructions.</p>
<p>The EPC must set to CPURegs as follows, otherwise, MatchInstructionImpl() of
MatchAndEmitInstruction() will return fail for &#8220;asm(&#8220;mfc0 $pc, $epc&#8221;);&#8221;.</p>
<p class="rubric">lbdex/chapters/Chapter2/Cpu0RegisterInfo.td</p>
<dl class="docutils">
<dt>def CPURegs <span class="classifier-delimiter">:</span> <span class="classifier">RegisterClass&lt;&#8221;Cpu0&#8221;, [i32], 32, (add</span></dt>
<dd>...
, PC, EPC)&gt;;</dd>
</dl>
<p class="rubric">lbdex/chapters/Chapter11_1/Cpu0.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">def</span> <span class="n">Cpu0AsmParser</span> <span class="o">:</span> <span class="n">AsmParser</span> <span class="p">{</span>
  <span class="n">let</span> <span class="n">ShouldEmitMatchRegisterName</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">def</span> <span class="n">Cpu0AsmParserVariant</span> <span class="o">:</span> <span class="n">AsmParserVariant</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">Variant</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// Recognize hard coded registers.</span>
  <span class="n">string</span> <span class="n">RegisterPrefix</span> <span class="o">=</span> <span class="s">&quot;$&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">def</span> <span class="n">Cpu0</span> <span class="o">:</span> <span class="n">Target</span> <span class="p">{</span>
  <span class="p">...</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="n">let</span> <span class="n">AssemblyParsers</span> <span class="o">=</span> <span class="p">[</span><span class="n">Cpu0AsmParser</span><span class="p">];</span>
  <span class="n">let</span> <span class="n">AssemblyParserVariants</span> <span class="o">=</span> <span class="p">[</span><span class="n">Cpu0AsmParserVariant</span><span class="p">];</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_1/Cpu0InstrFormats.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Pseudo-instructions for alternate assembly syntax (never used by codegen).</span>
<span class="c1">// These are aliases that require C++ handling to convert to the target</span>
<span class="c1">// instruction, while InstAliases can be handled directly by tblgen.</span>
<span class="k">class</span> <span class="nc">Cpu0AsmPseudoInst</span><span class="o">&lt;</span><span class="n">dag</span> <span class="n">outs</span><span class="p">,</span> <span class="n">dag</span> <span class="n">ins</span><span class="p">,</span> <span class="n">string</span> <span class="n">asmstr</span><span class="o">&gt;:</span>
  <span class="n">Cpu0Inst</span><span class="o">&lt;</span><span class="n">outs</span><span class="p">,</span> <span class="n">ins</span><span class="p">,</span> <span class="n">asmstr</span><span class="p">,</span> <span class="p">[],</span> <span class="n">IIPseudo</span><span class="p">,</span> <span class="n">Pseudo</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">let</span> <span class="n">isPseudo</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">let</span> <span class="n">Pattern</span> <span class="o">=</span> <span class="p">[];</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_1/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">def</span> <span class="n">Cpu0MemAsmOperand</span> <span class="o">:</span> <span class="n">AsmOperandClass</span> <span class="p">{</span>
  <span class="n">let</span> <span class="n">Name</span> <span class="o">=</span> <span class="s">&quot;Mem&quot;</span><span class="p">;</span>
  <span class="n">let</span> <span class="n">ParserMethod</span> <span class="o">=</span> <span class="s">&quot;parseMemOperand&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Address operand</span>
<span class="n">def</span> <span class="n">mem</span> <span class="o">:</span> <span class="n">Operand</span><span class="o">&lt;</span><span class="n">i32</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="n">let</span> <span class="n">ParserMatchClass</span> <span class="o">=</span> <span class="n">Cpu0MemAsmOperand</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">...</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>//===----------------------------------------------------------------------===//
// Pseudo Instruction definition
//===----------------------------------------------------------------------===//

let Predicates = [Ch11_1] in {
class LoadImm32&lt; string instr_asm, Operand Od, RegisterClass RC&gt; :
  Cpu0AsmPseudoInst&lt;(outs RC:$ra), (ins Od:$imm32),
                     !strconcat(instr_asm, &quot;\t$ra, $imm32&quot;)&gt; ;
def LoadImm32Reg : LoadImm32&lt;&quot;li&quot;, shamt, GPROut&gt;;

class LoadAddress&lt;string instr_asm, Operand MemOpnd, RegisterClass RC&gt; :
  Cpu0AsmPseudoInst&lt;(outs RC:$ra), (ins MemOpnd:$addr),
                     !strconcat(instr_asm, &quot;\t$ra, $addr&quot;)&gt; ;
def LoadAddr32Reg : LoadAddress&lt;&quot;la&quot;, mem, GPROut&gt;;

class LoadAddressImm&lt;string instr_asm, Operand Od, RegisterClass RC&gt; :
  Cpu0AsmPseudoInst&lt;(outs RC:$ra), (ins Od:$imm32),
                     !strconcat(instr_asm, &quot;\t$ra, $imm32&quot;)&gt; ;
def LoadAddr32Imm : LoadAddressImm&lt;&quot;la&quot;, shamt, GPROut&gt;;
}
</pre></div>
</div>
<p>Above declare the <strong>ParserMethod = &#8220;parseMemOperand&#8221;</strong> and implement the
parseMemOperand() in Cpu0AsmParser.cpp to handle the <strong>&#8220;mem&#8221;</strong> operand which
used in Cpu0 instructions ld and st.
For example, ld $2, 4($sp), the <strong>mem</strong> operand is 4($sp).
Accompany with <strong>&#8220;let ParserMatchClass = Cpu0MemAsmOperand;&#8221;</strong>,
LLVM will call parseMemOperand() of Cpu0AsmParser.cpp when it meets the assembly
<strong>mem</strong> operand 4($sp). With above <strong>&#8220;let&#8221;</strong> assignment, TableGen will generate
the following structure and functions in Cpu0GenAsmMatcher.inc.</p>
<p class="rubric">cmake_debug_build/lib/Target/Cpu0/Cpu0GenAsmMatcher.inc</p>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">enum</span> <span class="n">OperandMatchResultTy</span> <span class="p">{</span>
    <span class="n">MatchOperand_Success</span><span class="p">,</span>    <span class="c1">// operand matched successfully</span>
    <span class="n">MatchOperand_NoMatch</span><span class="p">,</span>    <span class="c1">// operand did not match</span>
    <span class="n">MatchOperand_ParseFail</span>   <span class="c1">// operand matched but had errors</span>
  <span class="p">};</span>
  <span class="n">OperandMatchResultTy</span> <span class="nf">MatchOperandParserImpl</span><span class="p">(</span>
    <span class="n">OperandVector</span> <span class="o">&amp;</span><span class="n">Operands</span><span class="p">,</span>
    <span class="n">StringRef</span> <span class="n">Mnemonic</span><span class="p">);</span>
  <span class="n">OperandMatchResultTy</span> <span class="nf">tryCustomParseOperand</span><span class="p">(</span>
    <span class="n">OperandVector</span> <span class="o">&amp;</span><span class="n">Operands</span><span class="p">,</span>
    <span class="kt">unsigned</span> <span class="n">MCK</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">OperandMatchResultTy</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span>
<span class="n">tryCustomParseOperand</span><span class="p">(</span><span class="n">OperandVector</span> <span class="o">&amp;</span><span class="n">Operands</span><span class="p">,</span>
            <span class="kt">unsigned</span> <span class="n">MCK</span><span class="p">)</span> <span class="p">{</span>

  <span class="k">switch</span><span class="p">(</span><span class="n">MCK</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">MCK_Mem</span>:
    <span class="k">return</span> <span class="n">parseMemOperand</span><span class="p">(</span><span class="n">Operands</span><span class="p">);</span>
  <span class="nl">default:</span>
    <span class="k">return</span> <span class="n">MatchOperand_NoMatch</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">MatchOperand_NoMatch</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">OperandMatchResultTy</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span>
<span class="n">MatchOperandParserImpl</span><span class="p">(</span><span class="n">OperandVector</span> <span class="o">&amp;</span><span class="n">Operands</span><span class="p">,</span>
             <span class="n">StringRef</span> <span class="n">Mnemonic</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>

<span class="c1">/// MatchClassKind - The kinds of classes which participate in</span>
<span class="c1">/// instruction matching.</span>
<span class="k">enum</span> <span class="n">MatchClassKind</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="n">MCK_Mem</span><span class="p">,</span> <span class="c1">// user defined class &#39;Cpu0MemAsmOperand&#39;</span>
  <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Above three Pseudo Instruction definitions in Cpu0InstrInfo.td, such as
LoadImm32Reg, are handled by Cpu0AsmParser.cpp as follows,</p>
<p class="rubric">lbdex/chapters/Chapter11_1/AsmParser/Cpu0AsmParser.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">needsExpansion</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">)</span> <span class="p">{</span>

  <span class="k">switch</span><span class="p">(</span><span class="n">Inst</span><span class="p">.</span><span class="n">getOpcode</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">LoadImm32Reg</span><span class="o">:</span>
    <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">LoadAddr32Imm</span><span class="o">:</span>
    <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">LoadAddr32Reg</span><span class="o">:</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="nl">default:</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">expandInstruction</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="n">IDLoc</span><span class="p">,</span>
                        <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCInst</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Instructions</span><span class="p">){</span>
  <span class="k">switch</span><span class="p">(</span><span class="n">Inst</span><span class="p">.</span><span class="n">getOpcode</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">LoadImm32Reg</span><span class="o">:</span>
      <span class="k">return</span> <span class="n">expandLoadImm</span><span class="p">(</span><span class="n">Inst</span><span class="p">,</span> <span class="n">IDLoc</span><span class="p">,</span> <span class="n">Instructions</span><span class="p">);</span>
    <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">LoadAddr32Imm</span><span class="o">:</span>
      <span class="k">return</span> <span class="n">expandLoadAddressImm</span><span class="p">(</span><span class="n">Inst</span><span class="p">,</span><span class="n">IDLoc</span><span class="p">,</span><span class="n">Instructions</span><span class="p">);</span>
    <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">LoadAddr32Reg</span><span class="o">:</span>
      <span class="k">return</span> <span class="n">expandLoadAddressReg</span><span class="p">(</span><span class="n">Inst</span><span class="p">,</span><span class="n">IDLoc</span><span class="p">,</span><span class="n">Instructions</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">MatchAndEmitInstruction</span><span class="p">(</span><span class="n">SMLoc</span> <span class="n">IDLoc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="o">&amp;</span><span class="n">Opcode</span><span class="p">,</span>
                                            <span class="n">OperandVector</span> <span class="o">&amp;</span><span class="n">Operands</span><span class="p">,</span>
                                            <span class="n">MCStreamer</span> <span class="o">&amp;</span><span class="n">Out</span><span class="p">,</span>
                                            <span class="kt">uint64_t</span> <span class="o">&amp;</span><span class="n">ErrorInfo</span><span class="p">,</span>
                                            <span class="kt">bool</span> <span class="n">MatchingInlineAsm</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MCInst</span> <span class="n">Inst</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">MatchResult</span> <span class="o">=</span> <span class="n">MatchInstructionImpl</span><span class="p">(</span><span class="n">Operands</span><span class="p">,</span> <span class="n">Inst</span><span class="p">,</span> <span class="n">ErrorInfo</span><span class="p">,</span>
                                              <span class="n">MatchingInlineAsm</span><span class="p">);</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">MatchResult</span><span class="p">)</span> <span class="p">{</span>
  <span class="nl">default:</span> <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Match_Success</span>: <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">needsExpansion</span><span class="p">(</span><span class="n">Inst</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">MCInst</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">Instructions</span><span class="p">;</span>
      <span class="n">expandInstruction</span><span class="p">(</span><span class="n">Inst</span><span class="p">,</span> <span class="n">IDLoc</span><span class="p">,</span> <span class="n">Instructions</span><span class="p">);</span>
      <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Instructions</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">Out</span><span class="p">.</span><span class="n">EmitInstruction</span><span class="p">(</span><span class="n">Instructions</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">STI</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">Inst</span><span class="p">.</span><span class="n">setLoc</span><span class="p">(</span><span class="n">IDLoc</span><span class="p">);</span>
        <span class="n">Out</span><span class="p">.</span><span class="n">EmitInstruction</span><span class="p">(</span><span class="n">Inst</span><span class="p">,</span> <span class="n">STI</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Finally, remind the CPURegs as below must follow the order of register number
because AsmParser uses them when do register number encode.</p>
<p class="rubric">lbdex/chapters/Chapter11_1/Cpu0RegisterInfo.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// The register string, such as &quot;9&quot; or &quot;gp&quot; will show on &quot;llvm-objdump -d&quot;</span>
<span class="c1">//@ All registers definition</span>
<span class="n">let</span> <span class="n">Namespace</span> <span class="o">=</span> <span class="s">&quot;Cpu0&quot;</span> <span class="n">in</span> <span class="p">{</span>
  <span class="c1">//@ General Purpose Registers</span>
  <span class="n">def</span> <span class="n">ZERO</span> <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span>  <span class="s">&quot;zero&quot;</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">def</span> <span class="n">AT</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span>  <span class="s">&quot;1&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">def</span> <span class="n">V0</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span>  <span class="s">&quot;2&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">def</span> <span class="n">V1</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span>  <span class="s">&quot;3&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">def</span> <span class="n">A0</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">,</span>  <span class="s">&quot;4&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">def</span> <span class="n">A1</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">,</span>  <span class="s">&quot;5&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">def</span> <span class="n">T9</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">,</span>  <span class="s">&quot;t9&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">def</span> <span class="n">T0</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">7</span><span class="p">,</span>  <span class="s">&quot;7&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">def</span> <span class="n">T1</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span>  <span class="s">&quot;8&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">def</span> <span class="n">S0</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">9</span><span class="p">,</span>  <span class="s">&quot;9&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">def</span> <span class="n">S1</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">,</span> <span class="s">&quot;10&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">def</span> <span class="n">GP</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">11</span><span class="p">,</span> <span class="s">&quot;gp&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">def</span> <span class="n">FP</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">12</span><span class="p">,</span> <span class="s">&quot;fp&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">def</span> <span class="n">SP</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">13</span><span class="p">,</span> <span class="s">&quot;sp&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">def</span> <span class="n">LR</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">14</span><span class="p">,</span> <span class="s">&quot;lr&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">def</span> <span class="n">SW</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">15</span><span class="p">,</span> <span class="s">&quot;sw&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="c1">//  def MAR  : Register&lt; 16, &quot;mar&quot;&gt;,  DwarfRegNum&lt;[16]&gt;;</span>
<span class="c1">//  def MDR  : Register&lt; 17, &quot;mdr&quot;&gt;,  DwarfRegNum&lt;[17]&gt;;</span>

<span class="c1">//#if CH &gt;= CH4_1 1</span>
  <span class="c1">// Hi/Lo registers number and name</span>
  <span class="n">def</span> <span class="n">HI</span>   <span class="o">:</span> <span class="n">Register</span><span class="o">&lt;</span><span class="s">&quot;hi&quot;</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">18</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">def</span> <span class="n">LO</span>   <span class="o">:</span> <span class="n">Register</span><span class="o">&lt;</span><span class="s">&quot;lo&quot;</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="c1">//#endif</span>
  <span class="n">def</span> <span class="n">PC</span>   <span class="o">:</span> <span class="n">Cpu0C0Reg</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;pc&quot;</span><span class="o">&gt;</span><span class="p">,</span>  <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">def</span> <span class="n">EPC</span>  <span class="o">:</span> <span class="n">Cpu0C0Reg</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;epc&quot;</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">21</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//@Register Classes</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="n">def</span> <span class="n">CPURegs</span> <span class="o">:</span> <span class="n">RegisterClass</span><span class="o">&lt;</span><span class="s">&quot;Cpu0&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">i32</span><span class="p">],</span> <span class="mi">32</span><span class="p">,</span> <span class="p">(</span><span class="n">add</span>
  <span class="c1">// Reserved</span>
  <span class="n">ZERO</span><span class="p">,</span> <span class="n">AT</span><span class="p">,</span> 
  <span class="c1">// Return Values and Arguments</span>
  <span class="n">V0</span><span class="p">,</span> <span class="n">V1</span><span class="p">,</span> <span class="n">A0</span><span class="p">,</span> <span class="n">A1</span><span class="p">,</span> 
  <span class="c1">// Not preserved across procedure calls</span>
  <span class="n">T9</span><span class="p">,</span> <span class="n">T0</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span>
  <span class="c1">// Callee save</span>
  <span class="n">S0</span><span class="p">,</span> <span class="n">S1</span><span class="p">,</span>
  <span class="c1">// Reserved</span>
  <span class="n">GP</span><span class="p">,</span> <span class="n">FP</span><span class="p">,</span> 
  <span class="n">SP</span><span class="p">,</span> <span class="n">LR</span><span class="p">,</span> <span class="n">SW</span><span class="p">,</span> <span class="n">PC</span><span class="p">,</span> <span class="n">EPC</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>Run Chapter11_1/ with ch11_1.cpp to get the correct result as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>JonathantekiiMac:input Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_
build/Debug/bin/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>obj ch11_1.bc -o
ch11_1.cpu0.o
JonathantekiiMac:input Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_
build/Debug/bin/llvm-objdump -d ch11_1.cpu0.o

ch11_1.cpu0.o:  file format ELF32-unknown

Disassembly of section .text:
.text:
       0:     01 2d 00 08                                     ld      <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
       4:     02 0d 00 04                                     st      <span class="nv">$zero</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
       8:     09 30 00 00                                     addiu   <span class="nv">$3</span>, <span class="nv">$zero</span>, 0
       c:     13 31 20 00                                     add     <span class="nv">$3</span>, <span class="nv">$1</span>, <span class="nv">$2</span>
      10:     14 32 30 00                                     sub     <span class="nv">$3</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
      ...
</pre></div>
</div>
<p>The instructions cmp and jeg printed with explicit $sw displayed in assembly
and disassembly. You can change code in AsmParser and Dissassembly (the last
chapter) to hide the $sw printed in these instructions (such as &#8220;jeq 20&#8221;
rather than &#8220;jeq $sw, 20&#8221;).</p>
<p>Both AsmParser and Cpu0AsmParser inherited from MCAsmParser as follows,</p>
<p class="rubric">src/lib/MC/MCParser/AsmParser.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">AsmParser</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MCAsmParser</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
<span class="p">...</span>
</pre></div>
</div>
<p>AsmParser will call functions ParseInstruction() and MatchAndEmitInstruction()
of Cpu0AsmParser as follows,</p>
<p class="rubric">src/lib/MC/MCParser/AsmParser.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="n">AsmParser</span><span class="o">::</span><span class="n">parseStatement</span><span class="p">(</span><span class="n">ParseStatementInfo</span> <span class="o">&amp;</span><span class="n">Info</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="c1">// Directives start with &quot;.&quot;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">IDVal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">IDVal</span> <span class="o">!=</span> <span class="s">&quot;.&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// First query the target-specific parser. It will return &#39;true&#39; if it</span>
    <span class="c1">// isn&#39;t interested in this directive.</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">getTargetParser</span><span class="p">().</span><span class="n">ParseDirective</span><span class="p">(</span><span class="n">ID</span><span class="p">))</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">...</span>
  <span class="p">}</span>
  <span class="p">...</span>
  <span class="kt">bool</span> <span class="n">HadError</span> <span class="o">=</span> <span class="n">getTargetParser</span><span class="p">().</span><span class="n">ParseInstruction</span><span class="p">(</span><span class="n">IInfo</span><span class="p">,</span> <span class="n">OpcodeStr</span><span class="p">,</span> <span class="n">IDLoc</span><span class="p">,</span>
                                                     <span class="n">Info</span><span class="p">.</span><span class="n">ParsedOperands</span><span class="p">);</span>
  <span class="p">...</span>
  <span class="c1">// If parsing succeeded, match the instruction.</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">HadError</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">ErrorInfo</span><span class="p">;</span>
    <span class="n">getTargetParser</span><span class="p">().</span><span class="n">MatchAndEmitInstruction</span><span class="p">(</span><span class="n">IDLoc</span><span class="p">,</span> <span class="n">Info</span><span class="p">.</span><span class="n">Opcode</span><span class="p">,</span>
                                              <span class="n">Info</span><span class="p">.</span><span class="n">ParsedOperands</span><span class="p">,</span> <span class="n">Out</span><span class="p">,</span>
                                              <span class="n">ErrorInfo</span><span class="p">,</span> <span class="n">ParsingInlineAsm</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The other functions in Cpu0AsmParser called as follows,</p>
<ul class="simple">
<li>ParseDirective() -&gt; parseDirectiveSet() -&gt; parseSetReorderDirective(), parseSetNoReorderDirective(), parseSetMacroDirective(), parseSetNoMacroDirective() -&gt; reportParseError()</li>
<li>ParseInstruction() -&gt; ParseOperand() -&gt; MatchOperandParserImpl() of Cpu0GenAsmMatcher.inc -&gt; tryCustomParseOperand() of Cpu0GenAsmMatcher.inc -&gt; parseMemOperand() -&gt; parseMemOffset(), tryParseRegisterOperand()</li>
<li>MatchAndEmitInstruction() -&gt; MatchInstructionImpl() of Cpu0GenAsmMatcher.inc, needsExpansion(), expandInstruction()</li>
<li>parseMemOffset() -&gt; parseRelocOperand() -&gt; getVariantKind()</li>
<li>tryParseRegisterOperand() -&gt; tryParseRegister() -&gt; matchRegisterName() -&gt; getReg()), matchRegisterByNumber()</li>
<li>expandInstruction() -&gt; expandLoadImm(), expandLoadAddressImm(), expandLoadAddressReg() -&gt; EmitInstruction() of Cpu0AsmPrint.cpp</li>
</ul>
</div>
<div class="section" id="inline-assembly">
<h2><a class="toc-backref" href="#id8">Inline assembly</a><a class="headerlink" href="#inline-assembly" title="Permalink to this headline">¶</a></h2>
<p>Run Chapter11_1 with ch11_2 will get the following error.</p>
<p class="rubric">lbdex/input/ch11_2.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">int</span> <span class="n">printf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...);</span>
<span class="kt">int</span> <span class="nf">inlineasm_addu</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">foo</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">bar</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>

<span class="c1">//  call i32 asm sideeffect &quot;addu $0,$1,$2&quot;, &quot;=r,r,r&quot;(i32 %1, i32 %2) #1, !srcloc !1</span>
  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;addu %0,%1,%2&quot;</span>
                       <span class="o">:</span><span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="c1">// 5</span>
                       <span class="o">:</span><span class="s">&quot;r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span> <span class="s">&quot;r&quot;</span><span class="p">(</span><span class="n">bar</span><span class="p">)</span>
                       <span class="p">);</span>

  <span class="k">return</span> <span class="n">foo</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">inlineasm_longlong</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">bar</span> <span class="o">=</span> <span class="mh">0x0000000500000006</span><span class="p">;</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">bar</span><span class="p">;</span>
<span class="c1">//  int* q = (p+1); // Do not set q here.</span>

<span class="c1">//  call i32 asm sideeffect &quot;ld $0,$1&quot;, &quot;=r,*m&quot;(i32* %2) #2, !srcloc !2</span>
  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;ld %0,%1&quot;</span>
                       <span class="o">:</span><span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c1">// 0x700070007000700b</span>
                       <span class="o">:</span><span class="s">&quot;m&quot;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span>
                       <span class="p">);</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// Set q just before inline asm refer to avoid register clobbered. </span>
<span class="c1">//  call i32 asm sideeffect &quot;ld $0,$1&quot;, &quot;=r,*m&quot;(i32* %6) #2, !srcloc !3</span>
  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;ld %0,%1&quot;</span>
                       <span class="o">:</span><span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="c1">// 11</span>
                       <span class="o">:</span><span class="s">&quot;m&quot;</span><span class="p">(</span><span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="c1">//              Or use :&quot;m&quot;(*(p+1)) to avoid register clobbered. </span>
                       <span class="p">);</span>

  <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">inlineasm_constraint</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">foo</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">n_5</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">n5</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">n0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">un5</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">n65536</span> <span class="o">=</span> <span class="mh">0x10000</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">n_65531</span> <span class="o">=</span> <span class="o">-</span><span class="mi">65531</span><span class="p">;</span>

<span class="c1">//   call i32 asm sideeffect &quot;addiu $0,$1,$2&quot;, &quot;=r,r,I&quot;(i32 %1, i32 15) #1, !srcloc !2</span>
  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;addiu %0,%1,%2&quot;</span>
                       <span class="o">:</span><span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="c1">// 15</span>
                       <span class="o">:</span><span class="s">&quot;r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span> <span class="s">&quot;I&quot;</span><span class="p">(</span><span class="n">n_5</span><span class="p">)</span>
                       <span class="p">);</span>

  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;addiu %0,%1,%2&quot;</span>
                       <span class="o">:</span><span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="c1">// 15</span>
                       <span class="o">:</span><span class="s">&quot;r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span> <span class="s">&quot;J&quot;</span><span class="p">(</span><span class="n">n0</span><span class="p">)</span>
                       <span class="p">);</span>

  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;addiu %0,%1,%2&quot;</span>
                       <span class="o">:</span><span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="c1">// 10</span>
                       <span class="o">:</span><span class="s">&quot;r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span> <span class="s">&quot;K&quot;</span><span class="p">(</span><span class="n">n5</span><span class="p">)</span>
                       <span class="p">);</span>

  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;ori %0,%1,%2&quot;</span>
                       <span class="o">:</span><span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="c1">// 10</span>
                       <span class="o">:</span><span class="s">&quot;r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span> <span class="s">&quot;L&quot;</span><span class="p">(</span><span class="n">n65536</span><span class="p">)</span> <span class="c1">// 0x10000 = 65536</span>
                       <span class="p">);</span>

  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;addiu %0,%1,%2&quot;</span>
                       <span class="o">:</span><span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="c1">// 15</span>
                       <span class="o">:</span><span class="s">&quot;r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span> <span class="s">&quot;N&quot;</span><span class="p">(</span><span class="n">n_65531</span><span class="p">)</span>
                       <span class="p">);</span>

  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;addiu %0,%1,%2&quot;</span>
                       <span class="o">:</span><span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="c1">// 10</span>
                       <span class="o">:</span><span class="s">&quot;r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span> <span class="s">&quot;O&quot;</span><span class="p">(</span><span class="n">n_5</span><span class="p">)</span>
                       <span class="p">);</span>

  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;addiu %0,%1,%2&quot;</span>
                       <span class="o">:</span><span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="c1">// 15</span>
                       <span class="o">:</span><span class="s">&quot;r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span> <span class="s">&quot;P&quot;</span><span class="p">(</span><span class="n">un5</span><span class="p">)</span>
                       <span class="p">);</span>

  <span class="k">return</span> <span class="n">foo</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">inlineasm_arg</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">w</span><span class="p">;</span>

  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;subu %0,%1,%2&quot;</span>
                       <span class="o">:</span><span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                       <span class="o">:</span><span class="s">&quot;r&quot;</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="s">&quot;r&quot;</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                       <span class="p">);</span>

  <span class="k">return</span> <span class="n">w</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">g</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span>

<span class="kt">int</span> <span class="nf">inlineasm_global</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">;</span>
  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;ld %0,%1&quot;</span>
                       <span class="o">:</span><span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="c1">// c=3</span>
                       <span class="o">:</span><span class="s">&quot;m&quot;</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                       <span class="p">);</span>

  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;addiu %0,%1,1&quot;</span>
                       <span class="o">:</span><span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="c1">// d=4</span>
                       <span class="o">:</span><span class="s">&quot;r&quot;</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                       <span class="p">);</span>

  <span class="k">return</span> <span class="n">d</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef TESTSOFTFLOATLIB</span>
<span class="c1">// test_float() will call soft float library</span>
<span class="kt">int</span> <span class="nf">inlineasm_float</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">float</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">2.2</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">3.3</span><span class="p">;</span>
  
  <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">);</span>

  <span class="kt">int</span> <span class="n">d</span><span class="p">;</span>
  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;addiu %0,%1,1&quot;</span>
                       <span class="o">:</span><span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                       <span class="o">:</span><span class="s">&quot;r&quot;</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                       <span class="p">);</span>

  <span class="k">return</span> <span class="n">d</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">int</span> <span class="nf">test_inlineasm</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">;</span>

  <span class="n">a</span> <span class="o">=</span> <span class="n">inlineasm_addu</span><span class="p">();</span> <span class="c1">// 25</span>
  <span class="n">b</span> <span class="o">=</span> <span class="n">inlineasm_longlong</span><span class="p">();</span> <span class="c1">// 11</span>
  <span class="n">c</span> <span class="o">=</span> <span class="n">inlineasm_constraint</span><span class="p">();</span> <span class="c1">// 15</span>
  <span class="n">d</span> <span class="o">=</span> <span class="n">inlineasm_arg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span> <span class="c1">// -9</span>
  <span class="n">e</span> <span class="o">=</span> <span class="n">inlineasm_arg</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// 3</span>
  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;addiu %0,%1,1&quot;</span>
                       <span class="o">:</span><span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="c1">// e=4</span>
                       <span class="o">:</span><span class="s">&quot;r&quot;</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                       <span class="p">);</span>

  <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="n">c</span><span class="o">+</span><span class="n">d</span><span class="o">+</span><span class="n">e</span><span class="o">+</span><span class="n">f</span><span class="p">);</span> <span class="c1">// 25+11+15-9+3+4=49</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>1-160-129-73:input Jonathan$ ~/llvm/test/cmake_debug_build/Debug/bin/llc
-march=cpu0 -relocation-model=static -filetype=asm ch11_2.bc -o -
  .section .mdebug.abi32
  .previous
  .file &quot;ch11_2.bc&quot;
error: couldn&#39;t allocate output register for constraint &#39;r&#39;
</pre></div>
</div>
<p>The ch11_2.cpp is a inline assembly example. The clang supports inline
assembly like gcc.
The inline assembly used in C/C++ when program need to access the
specific allocated register or memory for the C/C++ variable. For example, the
variable foo of ch11_2.cpp can be allocated by compiler to register $2, $3
or other. The inline assembly fills the gap between high level language and
assembly language. Reference here <a class="footnote-reference" href="#id5" id="id2">[2]</a>. Chapter11_2 support inline assembly
as follows,</p>
<p class="rubric">lbdex/chapters/Chapter11_2/Cpu0AsmPrinter.h</p>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="kt">bool</span> <span class="n">PrintAsmOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">OpNo</span><span class="p">,</span>
                       <span class="kt">unsigned</span> <span class="n">AsmVariant</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ExtraCode</span><span class="p">,</span>
                       <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">)</span> <span class="n">override</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">PrintAsmMemoryOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">OpNum</span><span class="p">,</span>
                             <span class="kt">unsigned</span> <span class="n">AsmVariant</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ExtraCode</span><span class="p">,</span>
                             <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">)</span> <span class="n">override</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">printOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opNum</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_2/Cpu0AsmPrinter.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Print out an operand for an inline asm expression.</span>
<span class="kt">bool</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">PrintAsmOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">OpNum</span><span class="p">,</span>
                                     <span class="kt">unsigned</span> <span class="n">AsmVariant</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ExtraCode</span><span class="p">,</span>
                                     <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Does this asm operand have a single letter operand modifier?</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ExtraCode</span> <span class="o">&amp;&amp;</span> <span class="n">ExtraCode</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ExtraCode</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// Unknown modifier.</span>

    <span class="k">const</span> <span class="n">MachineOperand</span> <span class="o">&amp;</span><span class="n">MO</span> <span class="o">=</span> <span class="n">MI</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="n">OpNum</span><span class="p">);</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">ExtraCode</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
    <span class="nl">default:</span>
      <span class="c1">// See if this is a generic print operand</span>
      <span class="k">return</span> <span class="n">AsmPrinter</span><span class="o">::</span><span class="n">PrintAsmOperand</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span><span class="n">OpNum</span><span class="p">,</span><span class="n">AsmVariant</span><span class="p">,</span><span class="n">ExtraCode</span><span class="p">,</span><span class="n">O</span><span class="p">);</span>
    <span class="k">case</span> <span class="sc">&#39;X&#39;</span>: <span class="c1">// hex const int</span>
      <span class="k">if</span> <span class="p">((</span><span class="n">MO</span><span class="p">.</span><span class="n">getType</span><span class="p">())</span> <span class="o">!=</span> <span class="n">MachineOperand</span><span class="o">::</span><span class="n">MO_Immediate</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
      <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;0x&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">StringRef</span><span class="p">(</span><span class="n">utohexstr</span><span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getImm</span><span class="p">())).</span><span class="n">lower</span><span class="p">();</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">&#39;x&#39;</span>: <span class="c1">// hex const int (low 16 bits)</span>
      <span class="k">if</span> <span class="p">((</span><span class="n">MO</span><span class="p">.</span><span class="n">getType</span><span class="p">())</span> <span class="o">!=</span> <span class="n">MachineOperand</span><span class="o">::</span><span class="n">MO_Immediate</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
      <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;0x&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">StringRef</span><span class="p">(</span><span class="n">utohexstr</span><span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getImm</span><span class="p">()</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)).</span><span class="n">lower</span><span class="p">();</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">&#39;d&#39;</span>: <span class="c1">// decimal const int</span>
      <span class="k">if</span> <span class="p">((</span><span class="n">MO</span><span class="p">.</span><span class="n">getType</span><span class="p">())</span> <span class="o">!=</span> <span class="n">MachineOperand</span><span class="o">::</span><span class="n">MO_Immediate</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
      <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="n">MO</span><span class="p">.</span><span class="n">getImm</span><span class="p">();</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">&#39;m&#39;</span>: <span class="c1">// decimal const int minus 1</span>
      <span class="k">if</span> <span class="p">((</span><span class="n">MO</span><span class="p">.</span><span class="n">getType</span><span class="p">())</span> <span class="o">!=</span> <span class="n">MachineOperand</span><span class="o">::</span><span class="n">MO_Immediate</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
      <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="n">MO</span><span class="p">.</span><span class="n">getImm</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">&#39;z&#39;</span>: <span class="p">{</span>
      <span class="c1">// $0 if zero, regular printing otherwise</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getType</span><span class="p">()</span> <span class="o">!=</span> <span class="n">MachineOperand</span><span class="o">::</span><span class="n">MO_Immediate</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
      <span class="kt">int64_t</span> <span class="n">Val</span> <span class="o">=</span> <span class="n">MO</span><span class="p">.</span><span class="n">getImm</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">Val</span><span class="p">)</span>
        <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="n">Val</span><span class="p">;</span>
      <span class="k">else</span>
        <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;$0&quot;</span><span class="p">;</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">printOperand</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span> <span class="n">OpNum</span><span class="p">,</span> <span class="n">O</span><span class="p">);</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">PrintAsmMemoryOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span>
                                           <span class="kt">unsigned</span> <span class="n">OpNum</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">AsmVariant</span><span class="p">,</span>
                                           <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ExtraCode</span><span class="p">,</span>
                                           <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">Offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// Currently we are expecting either no ExtraCode or &#39;D&#39;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ExtraCode</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// Unknown modifier.</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="n">MachineOperand</span> <span class="o">&amp;</span><span class="n">MO</span> <span class="o">=</span> <span class="n">MI</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="n">OpNum</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">isReg</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;unexpected inline asm memory operand&quot;</span><span class="p">);</span>
  <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="n">Offset</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;($&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">Cpu0InstPrinter</span><span class="o">::</span><span class="n">getRegisterName</span><span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getReg</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;)&quot;</span><span class="p">;</span>

  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">printOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opNum</span><span class="p">,</span>
                                  <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">MachineOperand</span> <span class="o">&amp;</span><span class="n">MO</span> <span class="o">=</span> <span class="n">MI</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="n">opNum</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="n">closeP</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getTargetFlags</span><span class="p">())</span>
    <span class="n">closeP</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

  <span class="k">switch</span><span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getTargetFlags</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">Cpu0II</span>:<span class="o">:</span><span class="n">MO_GPREL</span><span class="o">:</span>    <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;%gp_rel(&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0II</span>:<span class="o">:</span><span class="n">MO_GOT_CALL</span><span class="o">:</span> <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;%call16(&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0II</span>:<span class="o">:</span><span class="n">MO_GOT16</span><span class="o">:</span>    <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;%got16(&quot;</span><span class="p">;</span>  <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0II</span>:<span class="o">:</span><span class="n">MO_GOT</span><span class="o">:</span>      <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;%got(&quot;</span><span class="p">;</span>    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0II</span>:<span class="o">:</span><span class="n">MO_ABS_HI</span><span class="o">:</span>   <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;%hi(&quot;</span><span class="p">;</span>     <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0II</span>:<span class="o">:</span><span class="n">MO_ABS_LO</span><span class="o">:</span>   <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;%lo(&quot;</span><span class="p">;</span>     <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0II</span>:<span class="o">:</span><span class="n">MO_GOT_HI16</span><span class="o">:</span> <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;%got_hi16(&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0II</span>:<span class="o">:</span><span class="n">MO_GOT_LO16</span><span class="o">:</span> <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;%got_lo16(&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getType</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">MachineOperand</span>:<span class="o">:</span><span class="n">MO_Register</span><span class="o">:</span>
      <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;$&#39;</span>
        <span class="o">&lt;&lt;</span> <span class="n">StringRef</span><span class="p">(</span><span class="n">Cpu0InstPrinter</span><span class="o">::</span><span class="n">getRegisterName</span><span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getReg</span><span class="p">())).</span><span class="n">lower</span><span class="p">();</span>
      <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">MachineOperand</span>:<span class="o">:</span><span class="n">MO_Immediate</span><span class="o">:</span>
      <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="n">MO</span><span class="p">.</span><span class="n">getImm</span><span class="p">();</span>
      <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">MachineOperand</span>:<span class="o">:</span><span class="n">MO_MachineBasicBlock</span><span class="o">:</span>
      <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">MO</span><span class="p">.</span><span class="n">getMBB</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getSymbol</span><span class="p">();</span>
      <span class="k">return</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">MachineOperand</span>:<span class="o">:</span><span class="n">MO_GlobalAddress</span><span class="o">:</span>
      <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">getSymbol</span><span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getGlobal</span><span class="p">());</span>
      <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">MachineOperand</span>:<span class="o">:</span><span class="n">MO_BlockAddress</span><span class="o">:</span> <span class="p">{</span>
      <span class="n">MCSymbol</span> <span class="o">*</span><span class="n">BA</span> <span class="o">=</span> <span class="n">GetBlockAddressSymbol</span><span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getBlockAddress</span><span class="p">());</span>
      <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="n">BA</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">();</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">case</span> <span class="n">MachineOperand</span>:<span class="o">:</span><span class="n">MO_ExternalSymbol</span><span class="o">:</span>
      <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">GetExternalSymbolSymbol</span><span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getSymbolName</span><span class="p">());</span>
      <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">MachineOperand</span>:<span class="o">:</span><span class="n">MO_JumpTableIndex</span><span class="o">:</span>
      <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="n">MAI</span><span class="o">-&gt;</span><span class="n">getPrivateGlobalPrefix</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;JTI&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">getFunctionNumber</span><span class="p">()</span>
        <span class="o">&lt;&lt;</span> <span class="sc">&#39;_&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">MO</span><span class="p">.</span><span class="n">getIndex</span><span class="p">();</span>
      <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">MachineOperand</span>:<span class="o">:</span><span class="n">MO_ConstantPoolIndex</span><span class="o">:</span>
      <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="n">MAI</span><span class="o">-&gt;</span><span class="n">getPrivateGlobalPrefix</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;CPI&quot;</span>
        <span class="o">&lt;&lt;</span> <span class="n">getFunctionNumber</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;_&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">MO</span><span class="p">.</span><span class="n">getIndex</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getOffset</span><span class="p">())</span>
        <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;+&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">MO</span><span class="p">.</span><span class="n">getOffset</span><span class="p">();</span>
      <span class="k">break</span><span class="p">;</span>

    <span class="nl">default:</span>
      <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;&lt;unknown operand type&gt;&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">closeP</span><span class="p">)</span> <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;)&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_2/Cpu0InstrInfo.h</p>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="c1">/// Return the number of bytes of code the specified instruction may be.</span>
  <span class="kt">unsigned</span> <span class="n">GetInstSizeInBytes</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_2/Cpu0InstrInfo.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">/// Return the number of bytes of code the specified instruction may be.</span>
<span class="kt">unsigned</span> <span class="n">Cpu0InstrInfo</span><span class="o">::</span><span class="n">GetInstSizeInBytes</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">MI</span><span class="o">-&gt;</span><span class="n">getOpcode</span><span class="p">())</span> <span class="p">{</span>
  <span class="nl">default:</span>
    <span class="k">return</span> <span class="n">MI</span><span class="o">-&gt;</span><span class="n">getDesc</span><span class="p">().</span><span class="n">getSize</span><span class="p">();</span>
  <span class="k">case</span>  <span class="n">TargetOpcode</span>:<span class="o">:</span><span class="n">INLINEASM</span><span class="o">:</span> <span class="p">{</span>       <span class="c1">// Inline Asm: Variable size.</span>
    <span class="k">const</span> <span class="n">MachineFunction</span> <span class="o">*</span><span class="n">MF</span> <span class="o">=</span> <span class="n">MI</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">();</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">AsmStr</span> <span class="o">=</span> <span class="n">MI</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">getSymbolName</span><span class="p">();</span>
    <span class="k">return</span> <span class="nf">getInlineAsmLength</span><span class="p">(</span><span class="n">AsmStr</span><span class="p">,</span> <span class="o">*</span><span class="n">MF</span><span class="o">-&gt;</span><span class="n">getTarget</span><span class="p">().</span><span class="n">getMCAsmInfo</span><span class="p">());</span>
  <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_2/Cpu0ISelDAGToDAG.h</p>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="kt">bool</span> <span class="n">SelectInlineAsmMemoryOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">SDValue</span> <span class="o">&amp;</span><span class="n">Op</span><span class="p">,</span>
                                    <span class="kt">unsigned</span> <span class="n">ConstraintID</span><span class="p">,</span>
                                    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">OutOps</span><span class="p">)</span> <span class="n">override</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_2/Cpu0ISelDAGToDAG.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// inlineasm begin</span>
<span class="kt">bool</span> <span class="n">Cpu0DAGToDAGISel</span><span class="o">::</span>
<span class="n">SelectInlineAsmMemoryOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">SDValue</span> <span class="o">&amp;</span><span class="n">Op</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">ConstraintID</span><span class="p">,</span>
                             <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">OutOps</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// All memory constraints can at least accept raw pointers.</span>
  <span class="k">switch</span><span class="p">(</span><span class="n">ConstraintID</span><span class="p">)</span> <span class="p">{</span>
  <span class="nl">default:</span>
    <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;Unexpected asm memory constraint&quot;</span><span class="p">);</span>
  <span class="k">case</span> <span class="n">InlineAsm</span>:<span class="o">:</span><span class="n">Constraint_m</span><span class="o">:</span>
    <span class="n">OutOps</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Op</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// inlineasm end</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_2/Cpu0ISelLowering.h</p>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="c1">// Inline asm support</span>
    <span class="n">ConstraintType</span> <span class="n">getConstraintType</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">Constraint</span><span class="p">)</span> <span class="k">const</span> <span class="n">override</span><span class="p">;</span>

    <span class="c1">/// Examine constraint string and operand type and determine a weight value.</span>
    <span class="c1">/// The operand object must already have been set up with the operand type.</span>
    <span class="n">ConstraintWeight</span> <span class="n">getSingleConstraintMatchWeight</span><span class="p">(</span>
      <span class="n">AsmOperandInfo</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">constraint</span><span class="p">)</span> <span class="k">const</span> <span class="n">override</span><span class="p">;</span>

    <span class="c1">/// This function parses registers that appear in inline-asm constraints.</span>
    <span class="c1">/// It returns pair (0, 0) on failure.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*&gt;</span>
    <span class="n">parseRegForInlineAsmConstraint</span><span class="p">(</span><span class="k">const</span> <span class="n">StringRef</span> <span class="o">&amp;</span><span class="n">C</span><span class="p">,</span> <span class="n">MVT</span> <span class="n">VT</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*&gt;</span>
    <span class="n">getRegForInlineAsmConstraint</span><span class="p">(</span><span class="k">const</span> <span class="n">TargetRegisterInfo</span> <span class="o">*</span><span class="n">TRI</span><span class="p">,</span>
                                 <span class="n">StringRef</span> <span class="n">Constraint</span><span class="p">,</span> <span class="n">MVT</span> <span class="n">VT</span><span class="p">)</span> <span class="k">const</span> <span class="n">override</span><span class="p">;</span>

    <span class="c1">/// LowerAsmOperandForConstraint - Lower the specified operand into the Ops</span>
    <span class="c1">/// vector.  If it is invalid, don&#39;t add anything to Ops. If hasMemory is</span>
    <span class="c1">/// true it means one of the asm constraint of the inline asm instruction</span>
    <span class="c1">/// being processed is &#39;m&#39;.</span>
    <span class="kt">void</span> <span class="n">LowerAsmOperandForConstraint</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span>
                                      <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">Constraint</span><span class="p">,</span>
                                      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ops</span><span class="p">,</span>
                                      <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="k">const</span> <span class="n">override</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="n">isLegalAddressingMode</span><span class="p">(</span><span class="k">const</span> <span class="n">DataLayout</span> <span class="o">&amp;</span><span class="n">DL</span><span class="p">,</span> <span class="k">const</span> <span class="n">AddrMode</span> <span class="o">&amp;</span><span class="n">AM</span><span class="p">,</span>
                               <span class="n">Type</span> <span class="o">*</span><span class="n">Ty</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">AS</span><span class="p">)</span> <span class="k">const</span> <span class="n">override</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_2/Cpu0ISelLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//                           Cpu0 Inline Assembly Support</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="c1">/// getConstraintType - Given a constraint letter, return the type of</span>
<span class="c1">/// constraint it is for this target.</span>
<span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">ConstraintType</span> 
<span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">getConstraintType</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">Constraint</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
  <span class="c1">// Cpu0 specific constraints</span>
  <span class="c1">// GCC config/mips/constraints.md</span>
  <span class="c1">// &#39;c&#39; : A register suitable for use in an indirect</span>
  <span class="c1">//       jump. This will always be $t9 for -mabicalls.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Constraint</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">Constraint</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
      <span class="k">default</span> <span class="o">:</span> <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="sc">&#39;c&#39;</span>:
        <span class="k">return</span> <span class="n">C_RegisterClass</span><span class="p">;</span>
      <span class="k">case</span> <span class="sc">&#39;R&#39;</span>:
        <span class="k">return</span> <span class="n">C_Memory</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">TargetLowering</span><span class="o">::</span><span class="n">getConstraintType</span><span class="p">(</span><span class="n">Constraint</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// Examine constraint type and operand type and determine a weight value.</span>
<span class="c1">/// This object must already have been set up with the operand type</span>
<span class="c1">/// and the current alternative constraint selected.</span>
<span class="n">TargetLowering</span><span class="o">::</span><span class="n">ConstraintWeight</span>
<span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">getSingleConstraintMatchWeight</span><span class="p">(</span>
    <span class="n">AsmOperandInfo</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">constraint</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">ConstraintWeight</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">CW_Invalid</span><span class="p">;</span>
  <span class="n">Value</span> <span class="o">*</span><span class="n">CallOperandVal</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">CallOperandVal</span><span class="p">;</span>
    <span class="c1">// If we don&#39;t have a value, we can&#39;t do a match,</span>
    <span class="c1">// but allow it at the lowest weight.</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CallOperandVal</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">CW_Default</span><span class="p">;</span>
  <span class="n">Type</span> <span class="o">*</span><span class="n">type</span> <span class="o">=</span> <span class="n">CallOperandVal</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">();</span>
  <span class="c1">// Look at the constraint type.</span>
  <span class="k">switch</span> <span class="p">(</span><span class="o">*</span><span class="n">constraint</span><span class="p">)</span> <span class="p">{</span>
  <span class="nl">default:</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="n">TargetLowering</span><span class="o">::</span><span class="n">getSingleConstraintMatchWeight</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">constraint</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="sc">&#39;c&#39;</span>: <span class="c1">// $t9 for indirect jumps</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">isIntegerTy</span><span class="p">())</span>
      <span class="n">weight</span> <span class="o">=</span> <span class="n">CW_SpecificReg</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="sc">&#39;I&#39;</span>: <span class="c1">// signed 16 bit immediate</span>
  <span class="k">case</span> <span class="sc">&#39;J&#39;</span>: <span class="c1">// integer zero</span>
  <span class="k">case</span> <span class="sc">&#39;K&#39;</span>: <span class="c1">// unsigned 16 bit immediate</span>
  <span class="k">case</span> <span class="sc">&#39;L&#39;</span>: <span class="c1">// signed 32 bit immediate where lower 16 bits are 0</span>
  <span class="k">case</span> <span class="sc">&#39;N&#39;</span>: <span class="c1">// immediate in the range of -65535 to -1 (inclusive)</span>
  <span class="k">case</span> <span class="sc">&#39;O&#39;</span>: <span class="c1">// signed 15 bit immediate (+- 16383)</span>
  <span class="k">case</span> <span class="sc">&#39;P&#39;</span>: <span class="c1">// immediate in the range of 65535 to 1 (inclusive)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">ConstantInt</span><span class="o">&gt;</span><span class="p">(</span><span class="n">CallOperandVal</span><span class="p">))</span>
      <span class="n">weight</span> <span class="o">=</span> <span class="n">CW_Constant</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="sc">&#39;R&#39;</span>:
    <span class="n">weight</span> <span class="o">=</span> <span class="n">CW_Memory</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">weight</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// This is a helper function to parse a physical register string and split it</span>
<span class="c1">/// into non-numeric and numeric parts (Prefix and Reg). The first boolean flag</span>
<span class="c1">/// that is returned indicates whether parsing was successful. The second flag</span>
<span class="c1">/// is true if the numeric part exists.</span>
<span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span>
<span class="n">parsePhysicalReg</span><span class="p">(</span><span class="k">const</span> <span class="n">StringRef</span> <span class="o">&amp;</span><span class="n">C</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">Prefix</span><span class="p">,</span>
                 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">&amp;</span><span class="n">Reg</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">C</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">!=</span> <span class="sc">&#39;{&#39;</span> <span class="o">||</span> <span class="n">C</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">!=</span> <span class="sc">&#39;}&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

  <span class="c1">// Search for the first numeric character.</span>
  <span class="n">StringRef</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">I</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="n">C</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">E</span> <span class="o">=</span> <span class="n">C</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">I</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ptr_fun</span><span class="p">(</span><span class="n">isdigit</span><span class="p">));</span>

  <span class="n">Prefix</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">I</span> <span class="o">-</span> <span class="n">B</span><span class="p">);</span>

  <span class="c1">// The second flag is set to false if no numeric characters were found.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">I</span> <span class="o">==</span> <span class="n">E</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

  <span class="c1">// Parse the numeric characters.</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="o">!</span><span class="n">getAsUnsignedInteger</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">E</span> <span class="o">-</span> <span class="n">I</span><span class="p">),</span> <span class="mi">10</span><span class="p">,</span> <span class="n">Reg</span><span class="p">),</span>
                        <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*&gt;</span> <span class="n">Cpu0TargetLowering</span><span class="o">::</span>
<span class="n">parseRegForInlineAsmConstraint</span><span class="p">(</span><span class="k">const</span> <span class="n">StringRef</span> <span class="o">&amp;</span><span class="n">C</span><span class="p">,</span> <span class="n">MVT</span> <span class="n">VT</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span><span class="n">RC</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Prefix</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">Reg</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">R</span> <span class="o">=</span> <span class="n">parsePhysicalReg</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">Prefix</span><span class="p">,</span> <span class="n">Reg</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">R</span><span class="p">.</span><span class="n">first</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">0U</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">R</span><span class="p">.</span><span class="n">second</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">0U</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">);</span>

 <span class="c1">// Parse $0-$15.</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">Prefix</span> <span class="o">==</span> <span class="s">&quot;$&quot;</span><span class="p">);</span>
  <span class="n">RC</span> <span class="o">=</span> <span class="n">getRegClassFor</span><span class="p">((</span><span class="n">VT</span> <span class="o">==</span> <span class="n">MVT</span><span class="o">::</span><span class="n">Other</span><span class="p">)</span> <span class="o">?</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span> <span class="o">:</span> <span class="n">VT</span><span class="p">);</span>

  <span class="n">assert</span><span class="p">(</span><span class="n">Reg</span> <span class="o">&lt;</span> <span class="n">RC</span><span class="o">-&gt;</span><span class="n">getNumRegs</span><span class="p">());</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">RC</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">Reg</span><span class="p">),</span> <span class="n">RC</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// Given a register class constraint, like &#39;r&#39;, if this corresponds directly</span>
<span class="c1">/// to an LLVM register class, return a register of 0 and the register class</span>
<span class="c1">/// pointer.</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*&gt;</span>
<span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">getRegForInlineAsmConstraint</span><span class="p">(</span><span class="k">const</span> <span class="n">TargetRegisterInfo</span> <span class="o">*</span><span class="n">TRI</span><span class="p">,</span>
                                                 <span class="n">StringRef</span> <span class="n">Constraint</span><span class="p">,</span>
                                                 <span class="n">MVT</span> <span class="n">VT</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Constraint</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">Constraint</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">case</span> <span class="sc">&#39;r&#39;</span>:
      <span class="k">if</span> <span class="p">(</span><span class="n">VT</span> <span class="o">==</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span> <span class="o">||</span> <span class="n">VT</span> <span class="o">==</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i16</span> <span class="o">||</span> <span class="n">VT</span> <span class="o">==</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i8</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">0U</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">CPURegsRegClass</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">VT</span> <span class="o">==</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i64</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">0U</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">CPURegsRegClass</span><span class="p">);</span>
      <span class="c1">// This will generate an error message</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">0u</span><span class="p">,</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">TargetRegisterClass</span><span class="o">*&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
    <span class="k">case</span> <span class="sc">&#39;c&#39;</span>: <span class="c1">// register suitable for indirect jump</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">VT</span> <span class="o">==</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">((</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">T9</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">CPURegsRegClass</span><span class="p">);</span>
      <span class="n">assert</span><span class="p">(</span><span class="s">&quot;Unexpected type.&quot;</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*&gt;</span> <span class="n">R</span><span class="p">;</span>
  <span class="n">R</span> <span class="o">=</span> <span class="n">parseRegForInlineAsmConstraint</span><span class="p">(</span><span class="n">Constraint</span><span class="p">,</span> <span class="n">VT</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">R</span><span class="p">.</span><span class="n">second</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">R</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">TargetLowering</span><span class="o">::</span><span class="n">getRegForInlineAsmConstraint</span><span class="p">(</span><span class="n">TRI</span><span class="p">,</span> <span class="n">Constraint</span><span class="p">,</span> <span class="n">VT</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// LowerAsmOperandForConstraint - Lower the specified operand into the Ops</span>
<span class="c1">/// vector.  If it is invalid, don&#39;t add anything to Ops.</span>
<span class="kt">void</span> <span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">LowerAsmOperandForConstraint</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span>
                                                     <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">Constraint</span><span class="p">,</span>
                                                     <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;&amp;</span><span class="n">Ops</span><span class="p">,</span>
                                                     <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">(</span><span class="n">Op</span><span class="p">);</span>
  <span class="n">SDValue</span> <span class="n">Result</span><span class="p">;</span>

  <span class="c1">// Only support length 1 constraints for now.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Constraint</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

  <span class="kt">char</span> <span class="n">ConstraintLetter</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">ConstraintLetter</span><span class="p">)</span> <span class="p">{</span>
  <span class="nl">default:</span> <span class="k">break</span><span class="p">;</span> <span class="c1">// This will fall through to the generic implementation</span>
  <span class="k">case</span> <span class="sc">&#39;I&#39;</span>: <span class="c1">// Signed 16 bit constant</span>
    <span class="c1">// If this fails, the parent routine will give an error</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ConstantSDNode</span> <span class="o">*</span><span class="n">C</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">ConstantSDNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Op</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">EVT</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">Op</span><span class="p">.</span><span class="n">getValueType</span><span class="p">();</span>
      <span class="kt">int64_t</span> <span class="n">Val</span> <span class="o">=</span> <span class="n">C</span><span class="o">-&gt;</span><span class="n">getSExtValue</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">isInt</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Val</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">Result</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getTargetConstant</span><span class="p">(</span><span class="n">Val</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Type</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="k">case</span> <span class="sc">&#39;J&#39;</span>: <span class="c1">// integer zero</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ConstantSDNode</span> <span class="o">*</span><span class="n">C</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">ConstantSDNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Op</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">EVT</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">Op</span><span class="p">.</span><span class="n">getValueType</span><span class="p">();</span>
      <span class="kt">int64_t</span> <span class="n">Val</span> <span class="o">=</span> <span class="n">C</span><span class="o">-&gt;</span><span class="n">getZExtValue</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">Val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Result</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getTargetConstant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Type</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="k">case</span> <span class="sc">&#39;K&#39;</span>: <span class="c1">// unsigned 16 bit immediate</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ConstantSDNode</span> <span class="o">*</span><span class="n">C</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">ConstantSDNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Op</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">EVT</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">Op</span><span class="p">.</span><span class="n">getValueType</span><span class="p">();</span>
      <span class="kt">uint64_t</span> <span class="n">Val</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">C</span><span class="o">-&gt;</span><span class="n">getZExtValue</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">isUInt</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Val</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">Result</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getTargetConstant</span><span class="p">(</span><span class="n">Val</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Type</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="k">case</span> <span class="sc">&#39;L&#39;</span>: <span class="c1">// signed 32 bit immediate where lower 16 bits are 0</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ConstantSDNode</span> <span class="o">*</span><span class="n">C</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">ConstantSDNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Op</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">EVT</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">Op</span><span class="p">.</span><span class="n">getValueType</span><span class="p">();</span>
      <span class="kt">int64_t</span> <span class="n">Val</span> <span class="o">=</span> <span class="n">C</span><span class="o">-&gt;</span><span class="n">getSExtValue</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">((</span><span class="n">isInt</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Val</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">Val</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)){</span>
        <span class="n">Result</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getTargetConstant</span><span class="p">(</span><span class="n">Val</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Type</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="k">case</span> <span class="sc">&#39;N&#39;</span>: <span class="c1">// immediate in the range of -65535 to -1 (inclusive)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ConstantSDNode</span> <span class="o">*</span><span class="n">C</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">ConstantSDNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Op</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">EVT</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">Op</span><span class="p">.</span><span class="n">getValueType</span><span class="p">();</span>
      <span class="kt">int64_t</span> <span class="n">Val</span> <span class="o">=</span> <span class="n">C</span><span class="o">-&gt;</span><span class="n">getSExtValue</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">((</span><span class="n">Val</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">65535</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">Val</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">Result</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getTargetConstant</span><span class="p">(</span><span class="n">Val</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Type</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="k">case</span> <span class="sc">&#39;O&#39;</span>: <span class="c1">// signed 15 bit immediate</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ConstantSDNode</span> <span class="o">*</span><span class="n">C</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">ConstantSDNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Op</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">EVT</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">Op</span><span class="p">.</span><span class="n">getValueType</span><span class="p">();</span>
      <span class="kt">int64_t</span> <span class="n">Val</span> <span class="o">=</span> <span class="n">C</span><span class="o">-&gt;</span><span class="n">getSExtValue</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">((</span><span class="n">isInt</span><span class="o">&lt;</span><span class="mi">15</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Val</span><span class="p">)))</span> <span class="p">{</span>
        <span class="n">Result</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getTargetConstant</span><span class="p">(</span><span class="n">Val</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Type</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="k">case</span> <span class="sc">&#39;P&#39;</span>: <span class="c1">// immediate in the range of 1 to 65535 (inclusive)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ConstantSDNode</span> <span class="o">*</span><span class="n">C</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">ConstantSDNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Op</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">EVT</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">Op</span><span class="p">.</span><span class="n">getValueType</span><span class="p">();</span>
      <span class="kt">int64_t</span> <span class="n">Val</span> <span class="o">=</span> <span class="n">C</span><span class="o">-&gt;</span><span class="n">getSExtValue</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">((</span><span class="n">Val</span> <span class="o">&lt;=</span> <span class="mi">65535</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">Val</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">Result</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getTargetConstant</span><span class="p">(</span><span class="n">Val</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Type</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">Result</span><span class="p">.</span><span class="n">getNode</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">Ops</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Result</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">TargetLowering</span><span class="o">::</span><span class="n">LowerAsmOperandForConstraint</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">Constraint</span><span class="p">,</span> <span class="n">Ops</span><span class="p">,</span> <span class="n">DAG</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">isLegalAddressingMode</span><span class="p">(</span><span class="k">const</span> <span class="n">DataLayout</span> <span class="o">&amp;</span><span class="n">DL</span><span class="p">,</span>
                                               <span class="k">const</span> <span class="n">AddrMode</span> <span class="o">&amp;</span><span class="n">AM</span><span class="p">,</span> <span class="n">Type</span> <span class="o">*</span><span class="n">Ty</span><span class="p">,</span>
                                               <span class="kt">unsigned</span> <span class="n">AS</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="c1">// No global is ever allowed as a base.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">AM</span><span class="p">.</span><span class="n">BaseGV</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">AM</span><span class="p">.</span><span class="n">Scale</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="mi">0</span>: <span class="c1">// &quot;r+i&quot; or just &quot;i&quot;, depending on HasBaseReg.</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="mi">1</span>:
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">AM</span><span class="p">.</span><span class="n">HasBaseReg</span><span class="p">)</span> <span class="c1">// allow &quot;r+i&quot;.</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// disallow &quot;r+r&quot; or &quot;r+r+i&quot;.</span>
  <span class="nl">default:</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Same with backend structure, the structure of inline assembly can be divided by
file name as Table: the structure of inline assembly.</p>
<table border="1" class="docutils">
<caption>inline assembly functions</caption>
<colgroup>
<col width="46%" />
<col width="54%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">File</th>
<th class="head">Function</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Cpu0ISelLowering.cpp</td>
<td>inline asm DAG node create</td>
</tr>
<tr class="row-odd"><td>Cpu0ISelDAGToDAG.cpp</td>
<td>save OP code</td>
</tr>
<tr class="row-even"><td>Cpu0AsmPrinter.cpp,</td>
<td>inline asm instructions printing</td>
</tr>
<tr class="row-odd"><td>Cpu0InstrInfo.cpp</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Except Cpu0ISelDAGToDAG.cpp, the others&#8217; function are same with backend.
The Cpu0ISelLowering.cpp inline asm is explained after the result of run with
ch11_2.cpp.
Cpu0ISelDAGToDAG.cpp just save OP code in SelectInlineAsmMemoryOperand().
Since the the OP code is Cpu0 inline
assembly instruction, no llvm IR DAG translation needed further. Save OP
directly and return false to notiy llvm system that Cpu0 backend has finished
processing this inline assembly instruction.</p>
<p>Run Chapter11_2 with ch11_2.cpp will get the following result.</p>
<div class="highlight-bash"><div class="highlight"><pre>1-160-129-73:input Jonathan<span class="nv">$ </span>clang -target mips-unknown-linux-gnu -c
ch11_2.cpp -emit-llvm -o ch11_2.bc

1-160-129-73:input Jonathan<span class="nv">$ </span>~/llvm/test/cmake_debug_build/Debug/bin/
llvm-dis ch11_2.bc -o -
...
target <span class="nv">triple</span> <span class="o">=</span> <span class="s2">&quot;mips-unknown-linux-gnu&quot;</span>

@g <span class="o">=</span> global <span class="o">[</span>3 x i32<span class="o">]</span> <span class="o">[</span>i32 1, i32 2, i32 3<span class="o">]</span>, align 4

; Function Attrs: nounwind
define i32 @_Z14inlineasm_adduv<span class="o">()</span> <span class="c">#0 {</span>
  %foo <span class="o">=</span> alloca i32, align 4
  %bar <span class="o">=</span> alloca i32, align 4
  store i32 10, i32* %foo, align 4
  store i32 15, i32* %bar, align 4
  %1 <span class="o">=</span> load i32* %foo, align 4
  %2 <span class="o">=</span> call i32 asm sideeffect <span class="s2">&quot;addu $0,$1,$2&quot;</span>, <span class="s2">&quot;=r,r,r&quot;</span><span class="o">(</span>i32 %1, i32 15<span class="o">)</span> <span class="c">#1,</span>
  !srcloc !1
  store i32 %2, i32* %foo, align 4
  %3 <span class="o">=</span> load i32* %foo, align 4
  ret i32 %3
<span class="o">}</span>

; Function Attrs: nounwind
define i32 @_Z18inlineasm_longlongv<span class="o">()</span> <span class="c">#0 {</span>
  %a <span class="o">=</span> alloca i32, align 4
  %b <span class="o">=</span> alloca i32, align 4
  %bar <span class="o">=</span> alloca i64, align 8
  %p <span class="o">=</span> alloca i32*, align 4
  %q <span class="o">=</span> alloca i32*, align 4
  store i64 21474836486, i64* %bar, align 8
  %1 <span class="o">=</span> bitcast i64* %bar to i32*
  store i32* %1, i32** %p, align 4
  %2 <span class="o">=</span> load i32** %p, align 4
  %3 <span class="o">=</span> call i32 asm sideeffect <span class="s2">&quot;ld $0,$1&quot;</span>, <span class="s2">&quot;=r,*m&quot;</span><span class="o">(</span>i32* %2<span class="o">)</span> <span class="c">#1, !srcloc !2</span>
  store i32 %3, i32* %a, align 4
  %4 <span class="o">=</span> load i32** %p, align 4
  %5 <span class="o">=</span> getelementptr inbounds i32* %4, i32 1
  store i32* %5, i32** %q, align 4
  %6 <span class="o">=</span> load i32** %q, align 4
  %7 <span class="o">=</span> call i32 asm sideeffect <span class="s2">&quot;ld $0,$1&quot;</span>, <span class="s2">&quot;=r,*m&quot;</span><span class="o">(</span>i32* %6<span class="o">)</span> <span class="c">#1, !srcloc !3</span>
  store i32 %7, i32* %b, align 4
  %8 <span class="o">=</span> load i32* %a, align 4
  %9 <span class="o">=</span> load i32* %b, align 4
  %10 <span class="o">=</span> add nsw i32 %8, %9
  ret i32 %10
<span class="o">}</span>

; Function Attrs: nounwind
define i32 @_Z20inlineasm_constraintv<span class="o">()</span> <span class="c">#0 {</span>
  %foo <span class="o">=</span> alloca i32, align 4
  %n_5 <span class="o">=</span> alloca i32, align 4
  %n5 <span class="o">=</span> alloca i32, align 4
  %n0 <span class="o">=</span> alloca i32, align 4
  %un5 <span class="o">=</span> alloca i32, align 4
  %n65536 <span class="o">=</span> alloca i32, align 4
  %n_65531 <span class="o">=</span> alloca i32, align 4
  store i32 10, i32* %foo, align 4
  store i32 -5, i32* %n_5, align 4
  store i32 5, i32* %n5, align 4
  store i32 0, i32* %n0, align 4
  store i32 5, i32* %un5, align 4
  store i32 65536, i32* %n65536, align 4
  store i32 -65531, i32* %n_65531, align 4
  %1 <span class="o">=</span> load i32* %foo, align 4
  %2 <span class="o">=</span> call i32 asm sideeffect <span class="s2">&quot;addiu $0,$1,$2&quot;</span>, <span class="s2">&quot;=r,r,I&quot;</span><span class="o">(</span>i32 %1, i32 -5<span class="o">)</span> <span class="c">#1,</span>
  !srcloc !4
  store i32 %2, i32* %foo, align 4
  %3 <span class="o">=</span> load i32* %foo, align 4
  %4 <span class="o">=</span> call i32 asm sideeffect <span class="s2">&quot;addiu $0,$1,$2&quot;</span>, <span class="s2">&quot;=r,r,J&quot;</span><span class="o">(</span>i32 %3, i32 0<span class="o">)</span> <span class="c">#1,</span>
  !srcloc !5
  store i32 %4, i32* %foo, align 4
  %5 <span class="o">=</span> load i32* %foo, align 4
  %6 <span class="o">=</span> call i32 asm sideeffect <span class="s2">&quot;addiu $0,$1,$2&quot;</span>, <span class="s2">&quot;=r,r,K&quot;</span><span class="o">(</span>i32 %5, i32 5<span class="o">)</span> <span class="c">#1,</span>
  !srcloc !6
  store i32 %6, i32* %foo, align 4
  %7 <span class="o">=</span> load i32* %foo, align 4
  %8 <span class="o">=</span> call i32 asm sideeffect <span class="s2">&quot;ori $0,$1,$2&quot;</span>, <span class="s2">&quot;=r,r,L&quot;</span><span class="o">(</span>i32 %7, i32 65536<span class="o">)</span> <span class="c">#1,</span>
  !srcloc !7
  store i32 %8, i32* %foo, align 4
  %9 <span class="o">=</span> load i32* %foo, align 4
  %10 <span class="o">=</span> call i32 asm sideeffect <span class="s2">&quot;addiu $0,$1,$2&quot;</span>, <span class="s2">&quot;=r,r,N&quot;</span><span class="o">(</span>i32 %9, i32 -65531<span class="o">)</span>
  <span class="c">#1, !srcloc !8</span>
  store i32 %10, i32* %foo, align 4
  %11 <span class="o">=</span> load i32* %foo, align 4
  %12 <span class="o">=</span> call i32 asm sideeffect <span class="s2">&quot;addiu $0,$1,$2&quot;</span>, <span class="s2">&quot;=r,r,O&quot;</span><span class="o">(</span>i32 %11, i32 -5<span class="o">)</span> <span class="c">#1,</span>
  !srcloc !9
  store i32 %12, i32* %foo, align 4
  %13 <span class="o">=</span> load i32* %foo, align 4
  %14 <span class="o">=</span> call i32 asm sideeffect <span class="s2">&quot;addiu $0,$1,$2&quot;</span>, <span class="s2">&quot;=r,r,P&quot;</span><span class="o">(</span>i32 %13, i32 5<span class="o">)</span> <span class="c">#1,</span>
  !srcloc !10
  store i32 %14, i32* %foo, align 4
  %15 <span class="o">=</span> load i32* %foo, align 4
  ret i32 %15
<span class="o">}</span>

; Function Attrs: nounwind
define i32 @_Z13inlineasm_argii<span class="o">(</span>i32 %u, i32 %v<span class="o">)</span> <span class="c">#0 {</span>
  %1 <span class="o">=</span> alloca i32, align 4
  %2 <span class="o">=</span> alloca i32, align 4
  %w <span class="o">=</span> alloca i32, align 4
  store i32 %u, i32* %1, align 4
  store i32 %v, i32* %2, align 4
  %3 <span class="o">=</span> load i32* %1, align 4
  %4 <span class="o">=</span> load i32* %2, align 4
  %5 <span class="o">=</span> call i32 asm sideeffect <span class="s2">&quot;subu $0,$1,$2&quot;</span>, <span class="s2">&quot;=r,r,r&quot;</span><span class="o">(</span>i32 %3, i32 %4<span class="o">)</span> <span class="c">#1,</span>
  !srcloc !11
  store i32 %5, i32* %w, align 4
  %6 <span class="o">=</span> load i32* %w, align 4
  ret i32 %6
<span class="o">}</span>

; Function Attrs: nounwind
define i32 @_Z16inlineasm_globalv<span class="o">()</span> <span class="c">#0 {</span>
  %c <span class="o">=</span> alloca i32, align 4
  %d <span class="o">=</span> alloca i32, align 4
  %1 <span class="o">=</span> call i32 asm sideeffect <span class="s2">&quot;ld $0,$1&quot;</span>, <span class="s2">&quot;=r,*m&quot;</span><span class="o">(</span>i32* getelementptr inbounds
  <span class="o">([</span>3 x i32<span class="o">]</span>* @g, i32 0, i32 2<span class="o">))</span> <span class="c">#1, !srcloc !12</span>
  store i32 %1, i32* %c, align 4
  %2 <span class="o">=</span> load i32* %c, align 4
  %3 <span class="o">=</span> call i32 asm sideeffect <span class="s2">&quot;addiu $0,$1,1&quot;</span>, <span class="s2">&quot;=r,r&quot;</span><span class="o">(</span>i32 %2<span class="o">)</span> <span class="c">#1, !srcloc !13</span>
  store i32 %3, i32* %d, align 4
  %4 <span class="o">=</span> load i32* %d, align 4
  ret i32 %4
<span class="o">}</span>

; Function Attrs: nounwind
define i32 @_Z14test_inlineasmv<span class="o">()</span> <span class="c">#0 {</span>
  %a <span class="o">=</span> alloca i32, align 4
  %b <span class="o">=</span> alloca i32, align 4
  %c <span class="o">=</span> alloca i32, align 4
  %d <span class="o">=</span> alloca i32, align 4
  %e <span class="o">=</span> alloca i32, align 4
  %f <span class="o">=</span> alloca i32, align 4
  %g <span class="o">=</span> alloca i32, align 4
  %1 <span class="o">=</span> call i32 @_Z14inlineasm_adduv<span class="o">()</span>
  store i32 %1, i32* %a, align 4
  %2 <span class="o">=</span> call i32 @_Z18inlineasm_longlongv<span class="o">()</span>
  store i32 %2, i32* %b, align 4
  %3 <span class="o">=</span> call i32 @_Z20inlineasm_constraintv<span class="o">()</span>
  store i32 %3, i32* %c, align 4
  %4 <span class="o">=</span> call i32 @_Z13inlineasm_argii<span class="o">(</span>i32 1, i32 10<span class="o">)</span>
  store i32 %4, i32* %d, align 4
  %5 <span class="o">=</span> call i32 @_Z13inlineasm_argii<span class="o">(</span>i32 6, i32 3<span class="o">)</span>
  store i32 %5, i32* %e, align 4
  %6 <span class="o">=</span> load i32* %e, align 4
  %7 <span class="o">=</span> call i32 asm sideeffect <span class="s2">&quot;addiu $0,$1,1&quot;</span>, <span class="s2">&quot;=r,r&quot;</span><span class="o">(</span>i32 %6<span class="o">)</span> <span class="c">#1, !srcloc !14</span>
  store i32 %7, i32* %f, align 4
  %8 <span class="o">=</span> call i32 @_Z16inlineasm_globalv<span class="o">()</span>
  store i32 %8, i32* %g, align 4
  %9 <span class="o">=</span> load i32* %a, align 4
  %10 <span class="o">=</span> load i32* %b, align 4
  %11 <span class="o">=</span> add nsw i32 %9, %10
  %12 <span class="o">=</span> load i32* %c, align 4
  %13 <span class="o">=</span> add nsw i32 %11, %12
  %14 <span class="o">=</span> load i32* %d, align 4
  %15 <span class="o">=</span> add nsw i32 %13, %14
  %16 <span class="o">=</span> load i32* %e, align 4
  %17 <span class="o">=</span> add nsw i32 %15, %16
  %18 <span class="o">=</span> load i32* %f, align 4
  %19 <span class="o">=</span> add nsw i32 %17, %18
  %20 <span class="o">=</span> load i32* %g, align 4
  %21 <span class="o">=</span> add nsw i32 %19, %20
  ret i32 %21
<span class="o">}</span>
...
1-160-129-73:input Jonathan<span class="nv">$ </span>~/llvm/test/cmake_debug_build/Debug/bin/llc
  -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>static -filetype<span class="o">=</span>asm ch11_2.bc -o -
  .section .mdebug.abi32
  .previous
  .file <span class="s2">&quot;ch11_2.bc&quot;</span>
  .text
  .globl  _Z14inlineasm_adduv
  .align  2
  .type _Z14inlineasm_adduv,@function
  .ent  _Z14inlineasm_adduv     <span class="c"># @_Z14inlineasm_adduv</span>
_Z14inlineasm_adduv:
  .frame  <span class="nv">$fp</span>,16,<span class="nv">$lr</span>
  .mask   0x00001000,-4
  .set  noreorder
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -16
  st  <span class="nv">$fp</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
  addu  <span class="nv">$fp</span>, <span class="nv">$sp</span>, <span class="nv">$zero</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 10
  st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 15
  st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  <span class="c">#APP</span>
  addu <span class="nv">$2</span>,<span class="nv">$3</span>,<span class="nv">$2</span>
  <span class="c">#NO_APP</span>
  st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  addu  <span class="nv">$sp</span>, <span class="nv">$fp</span>, <span class="nv">$zero</span>
  ld  <span class="nv">$fp</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 16
  ret <span class="nv">$lr</span>
  nop
  .set  macro
  .set  reorder
  .end  _Z14inlineasm_adduv
<span class="nv">$tmp3</span>:
  .size _Z14inlineasm_adduv, <span class="o">(</span><span class="nv">$tmp3</span><span class="o">)</span>-_Z14inlineasm_adduv

  .globl  _Z18inlineasm_longlongv
  .align  2
  .type _Z18inlineasm_longlongv,@function
  .ent  _Z18inlineasm_longlongv <span class="c"># @_Z18inlineasm_longlongv</span>
_Z18inlineasm_longlongv:
  .frame  <span class="nv">$fp</span>,32,<span class="nv">$lr</span>
  .mask   0x00001000,-4
  .set  noreorder
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -32
  st  <span class="nv">$fp</span>, 28<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
  addu  <span class="nv">$fp</span>, <span class="nv">$sp</span>, <span class="nv">$zero</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 6
  st  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 5
  st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$fp</span>, 8
  st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  <span class="c">#APP</span>
  ld <span class="nv">$2</span>,0<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  <span class="c">#NO_APP</span>
  st  <span class="nv">$2</span>, 24<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$2</span>, 4
  st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  <span class="c">#APP</span>
  ld <span class="nv">$2</span>,0<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  <span class="c">#NO_APP</span>
  st  <span class="nv">$2</span>, 20<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 24<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  addu  <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
  addu  <span class="nv">$sp</span>, <span class="nv">$fp</span>, <span class="nv">$zero</span>
  ld  <span class="nv">$fp</span>, 28<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 32
  ret <span class="nv">$lr</span>
  .set  macro
  .set  reorder
  .end  _Z18inlineasm_longlongv
<span class="nv">$tmp7</span>:
  .size _Z18inlineasm_longlongv, <span class="o">(</span><span class="nv">$tmp7</span><span class="o">)</span>-_Z18inlineasm_longlongv

  .globl  _Z20inlineasm_constraintv
  .align  2
  .type _Z20inlineasm_constraintv,@function
  .ent  _Z20inlineasm_constraintv <span class="c"># @_Z20inlineasm_constraintv</span>
_Z20inlineasm_constraintv:
  .frame  <span class="nv">$fp</span>,32,<span class="nv">$lr</span>
  .mask   0x00001000,-4
  .set  noreorder
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -32
  st  <span class="nv">$fp</span>, 28<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
  addu  <span class="nv">$fp</span>, <span class="nv">$sp</span>, <span class="nv">$zero</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 10
  st  <span class="nv">$2</span>, 24<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, -5
  st  <span class="nv">$2</span>, 20<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 5
  st  <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  addiu <span class="nv">$3</span>, <span class="nv">$zero</span>, 0
  st  <span class="nv">$3</span>, 12<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  lui <span class="nv">$2</span>, 1
  st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  lui <span class="nv">$2</span>, 65535
  ori <span class="nv">$2</span>, <span class="nv">$2</span>, 5
  st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 24<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  <span class="c">#APP</span>
  addiu <span class="nv">$2</span>,<span class="nv">$2</span>,-5
  <span class="c">#NO_APP</span>
  st  <span class="nv">$2</span>, 24<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  <span class="c">#APP</span>
  addiu <span class="nv">$2</span>,<span class="nv">$2</span>,0
  <span class="c">#NO_APP</span>
  st  <span class="nv">$2</span>, 24<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  <span class="c">#APP</span>
  addiu <span class="nv">$2</span>,<span class="nv">$2</span>,5
  <span class="c">#NO_APP</span>
  st  <span class="nv">$2</span>, 24<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  <span class="c">#APP</span>
  ori <span class="nv">$2</span>,<span class="nv">$2</span>,65536
  <span class="c">#NO_APP</span>
  st  <span class="nv">$2</span>, 24<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  <span class="c">#APP</span>
  addiu <span class="nv">$2</span>,<span class="nv">$2</span>,-65531
  <span class="c">#NO_APP</span>
  st  <span class="nv">$2</span>, 24<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  <span class="c">#APP</span>
  addiu <span class="nv">$2</span>,<span class="nv">$2</span>,-5
  <span class="c">#NO_APP</span>
  st  <span class="nv">$2</span>, 24<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  <span class="c">#APP</span>
  addiu <span class="nv">$2</span>,<span class="nv">$2</span>,5
  <span class="c">#NO_APP</span>
  st  <span class="nv">$2</span>, 24<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  addu  <span class="nv">$sp</span>, <span class="nv">$fp</span>, <span class="nv">$zero</span>
  ld  <span class="nv">$fp</span>, 28<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 32
  ret <span class="nv">$lr</span>
  nop
  .set  macro
  .set  reorder
  .end  _Z20inlineasm_constraintv
<span class="nv">$tmp11</span>:
  .size _Z20inlineasm_constraintv, <span class="o">(</span><span class="nv">$tmp11</span><span class="o">)</span>-_Z20inlineasm_constraintv

  .globl  _Z13inlineasm_argii
  .align  2
  .type _Z13inlineasm_argii,@function
  .ent  _Z13inlineasm_argii     <span class="c"># @_Z13inlineasm_argii</span>
_Z13inlineasm_argii:
  .frame  <span class="nv">$fp</span>,16,<span class="nv">$lr</span>
  .mask   0x00001000,-4
  .set  noreorder
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -16
  st  <span class="nv">$fp</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
  addu  <span class="nv">$fp</span>, <span class="nv">$sp</span>, <span class="nv">$zero</span>
  ld  <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 20<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  <span class="c">#APP</span>
  subu <span class="nv">$2</span>,<span class="nv">$3</span>,<span class="nv">$2</span>
  <span class="c">#NO_APP</span>
  st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  addu  <span class="nv">$sp</span>, <span class="nv">$fp</span>, <span class="nv">$zero</span>
  ld  <span class="nv">$fp</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 16
  ret <span class="nv">$lr</span>
  nop
  .set  macro
  .set  reorder
  .end  _Z13inlineasm_argii
<span class="nv">$tmp15</span>:
  .size _Z13inlineasm_argii, <span class="o">(</span><span class="nv">$tmp15</span><span class="o">)</span>-_Z13inlineasm_argii

  .globl  _Z16inlineasm_globalv
  .align  2
  .type _Z16inlineasm_globalv,@function
  .ent  _Z16inlineasm_globalv   <span class="c"># @_Z16inlineasm_globalv</span>
_Z16inlineasm_globalv:
  .frame  <span class="nv">$fp</span>,16,<span class="nv">$lr</span>
  .mask   0x00001000,-4
  .set  noreorder
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -16
  st  <span class="nv">$fp</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
  addu  <span class="nv">$fp</span>, <span class="nv">$sp</span>, <span class="nv">$zero</span>
  lui <span class="nv">$2</span>, %hi<span class="o">(</span>g<span class="o">)</span>
  ori <span class="nv">$2</span>, <span class="nv">$2</span>, %lo<span class="o">(</span>g<span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$2</span>, 8
  <span class="c">#APP</span>
  ld <span class="nv">$2</span>,0<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  <span class="c">#NO_APP</span>
  st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  <span class="c">#APP</span>
  addiu <span class="nv">$2</span>,<span class="nv">$2</span>,1
  <span class="c">#NO_APP</span>
  st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  addu  <span class="nv">$sp</span>, <span class="nv">$fp</span>, <span class="nv">$zero</span>
  ld  <span class="nv">$fp</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 16
  ret <span class="nv">$lr</span>
  nop
  .set  macro
  .set  reorder
  .end  _Z16inlineasm_globalv
<span class="nv">$tmp19</span>:
  .size _Z16inlineasm_globalv, <span class="o">(</span><span class="nv">$tmp19</span><span class="o">)</span>-_Z16inlineasm_globalv

  .globl  _Z14test_inlineasmv
  .align  2
  .type _Z14test_inlineasmv,@function
  .ent  _Z14test_inlineasmv     <span class="c"># @_Z14test_inlineasmv</span>
_Z14test_inlineasmv:
  .frame  <span class="nv">$fp</span>,48,<span class="nv">$lr</span>
  .mask   0x00005000,-4
  .set  noreorder
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -48
  st  <span class="nv">$lr</span>, 44<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
  st  <span class="nv">$fp</span>, 40<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
  addu  <span class="nv">$fp</span>, <span class="nv">$sp</span>, <span class="nv">$zero</span>
  jsub  _Z14inlineasm_adduv
  nop
  st  <span class="nv">$2</span>, 36<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  jsub  _Z18inlineasm_longlongv
  nop
  st  <span class="nv">$2</span>, 32<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  jsub  _Z20inlineasm_constraintv
  nop
  st  <span class="nv">$2</span>, 28<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 10
  st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 1
  st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  jsub  _Z13inlineasm_argii
  nop
  st  <span class="nv">$2</span>, 24<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 3
  st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 6
  st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  jsub  _Z13inlineasm_argii
  nop
  st  <span class="nv">$2</span>, 20<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  <span class="c">#APP</span>
  addiu <span class="nv">$2</span>,<span class="nv">$2</span>,1
  <span class="c">#NO_APP</span>
  st  <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  jsub  _Z16inlineasm_globalv
  nop
  st  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 32<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  ld  <span class="nv">$4</span>, 36<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  addu  <span class="nv">$3</span>, <span class="nv">$4</span>, <span class="nv">$3</span>
  ld  <span class="nv">$4</span>, 28<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  addu  <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
  ld  <span class="nv">$4</span>, 24<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  addu  <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
  ld  <span class="nv">$4</span>, 20<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  addu  <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
  ld  <span class="nv">$4</span>, 16<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  addu  <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
  addu  <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
  addu  <span class="nv">$sp</span>, <span class="nv">$fp</span>, <span class="nv">$zero</span>
  ld  <span class="nv">$fp</span>, 40<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
  ld  <span class="nv">$lr</span>, 44<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 48
  ret <span class="nv">$lr</span>
  nop
  .set  macro
  .set  reorder
  .end  _Z14test_inlineasmv
<span class="nv">$tmp23</span>:
  .size _Z14test_inlineasmv, <span class="o">(</span><span class="nv">$tmp23</span><span class="o">)</span>-_Z14test_inlineasmv

  .type g,@object               <span class="c"># @g</span>
  .data
  .globl  g
  .align  2
g:
  .4byte  1                       <span class="c"># 0x1</span>
  .4byte  2                       <span class="c"># 0x2</span>
  .4byte  3                       <span class="c"># 0x3</span>
  .size g, 12
</pre></div>
</div>
<p>The clang translate gcc style inline assembly __asm__  into llvm IR Inline
Assembler Expressions first <a class="footnote-reference" href="#id6" id="id3">[3]</a>, then replace the variable registers of SSA
form to physical registers during llc register allocation stage.
From above example,
functions LowerAsmOperandForConstraint() and getSingleConstraintMatchWeight()
of Cpu0ISelLowering.cpp will create different range of const operand by I, J,
K, L, N, O, or P, and register operand by r . For instance, the following
__asm__ will create the llvm asm immediately after it.</p>
<div class="highlight-c++"><div class="highlight"><pre>__asm__ __volatile__(&quot;addiu %0,%1,%2&quot;
                     :&quot;=r&quot;(foo) // 15
                     :&quot;r&quot;(foo), &quot;I&quot;(n_5)
                     );

%2 = call i32 asm sideeffect &quot;addiu $0,$1,$2&quot;, &quot;=r,r,I&quot;(i32 %1, i32 -5) #0, !srcloc !1

__asm__ __volatile__(&quot;addiu %0,%1,%2&quot;
                     :&quot;=r&quot;(foo) // 15
                     :&quot;r&quot;(foo), &quot;N&quot;(n_65531)
                     );

%10 = call i32 asm sideeffect &quot;addiu $0,$1,$2&quot;, &quot;=r,r,N&quot;(i32 %9, i32 -65531) #0, !srcloc !5

__asm__ __volatile__(&quot;addiu %0,%1,%2&quot;
                     :&quot;=r&quot;(foo) // 15
                     :&quot;r&quot;(foo), &quot;P&quot;(un5)
                     );

%14 = call i32 asm sideeffect &quot;addiu $0,$1,$2&quot;, &quot;=r,r,P&quot;(i32 %13, i32 5) #0, !srcloc !7
</pre></div>
</div>
<p>The r in __asm__ will generate register, %1, in llvm IR asm while I
in __asm__ will generate const operand, -5, in llvm IR asm. Remind,
the LowerAsmOperandForConstraint() limit the positive or negative const operand
value range to 16 bits since FL type immediate operand is 16 bits in Cpu0
instruction. The range of N is -65535 to -1 and range of P is 65535 to 1.
For any value out of
the range, the code in LowerAsmOperandForConstraint() will treat it as error
since FL instruction format has 16 bits limitation.</p>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://www.embecosm.com/appnotes/ean10/ean10-howto-llvmas-1.0.html">http://www.embecosm.com/appnotes/ean10/ean10-howto-llvmas-1.0.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><a class="reference external" href="http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html">http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td><a class="reference external" href="http://llvm.org/docs/LangRef.html#inline-assembler-expressions">http://llvm.org/docs/LangRef.html#inline-assembler-expressions</a></td></tr>
</tbody>
</table>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="elf.html">ELF Support</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="c++.html">C++ support</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2013, LLVM.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>