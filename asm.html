<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Assembler &#8212; Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css?v=fce32b03" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css?v=4ae1632d" />
    <script src="_static/documentation_options.js?v=4745d852"></script>
    <script src="_static/doctools.js?v=fd6eb6e6"></script>
    <script src="_static/sphinx_highlight.js?v=6ffebe34"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="C++ support" href="c%2B%2B.html" />
    <link rel="prev" title="ELF Support" href="elf.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</span></a></h1>
        <h2 class="heading"><span>Assembler</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="Top">
      
        <p>
        «&#160;&#160;<a href="elf.html">ELF Support</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="c%2B%2B.html">C++ support</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="assembler">
<span id="sec-asm"></span><h1>Assembler<a class="headerlink" href="#assembler" title="Link to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#asmparser-support" id="id10">AsmParser support</a></p></li>
<li><p><a class="reference internal" href="#assembler-structure" id="id11">Assembler structure</a></p></li>
<li><p><a class="reference internal" href="#inline-assembly" id="id12">Inline assembly</a></p></li>
</ul>
</nav>
<p>This chapter covers the assembly programming support in the Cpu0 backend.</p>
<p>When it comes to assembly language programming, there are two types of usage in
C/C++ as follows:</p>
<p class="rubric">ordinary assembly</p>
<div class="highlight-cpp-objdump notranslate"><div class="highlight"><pre><span></span><span class="k">asm</span><span class="p">(</span><span class="s">&quot;ld       $2, 8($sp)&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">inline assembly</p>
<div class="highlight-cpp-objdump notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">15</span><span class="p">;</span>

<span class="n">__asm__</span><span class="w"> </span><span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;addu %0,%1,%2&quot;</span>
<span class="w">                     </span><span class="o">:</span><span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="w"> </span><span class="c1">// 5</span>
<span class="w">                     </span><span class="o">:</span><span class="s">&quot;r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">(</span><span class="n">bar</span><span class="p">)</span>
<span class="w">                     </span><span class="p">);</span>
</pre></div>
</div>
<p>In LLVM, the first method is supported by the LLVM AsmParser, and the second by
the inline assembly handler.</p>
<p>With AsmParser and inline assembly support in the Cpu0 backend, we can hand-code
assembly language in a C/C++ file and translate it into an object file (in ELF
format).</p>
<section id="asmparser-support">
<h2><a class="toc-backref" href="#id10" role="doc-backlink">AsmParser support</a><a class="headerlink" href="#asmparser-support" title="Link to this heading">¶</a></h2>
<p>This section lists all the AsmParser code for the Cpu0 backend, with only brief
explanations. Please refer to <a class="footnote-reference brackets" href="#llvmas" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> for a more detailed explanation of AsmParser.</p>
<p>Running Chapter10_1/ with ch11_1.cpp will produce the following error message.</p>
<p>Run Chapter10_1/ with ch11_1.cpp will get the following error message.</p>
<p class="rubric">lbdex/input/ch11_1.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">asm</span><span class="p">(</span><span class="s2">&quot;ld	$2, 8($sp)&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;st	$0, 4($sp)&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;addiu $3,	$ZERO, 0&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;add $v1, $at, $v0&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;sub $3, $2, $3&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;mul $2, $1, $3&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;div $3, $2&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;divu $2, $3&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;and $2, $1, $3&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;or $3, $1, $2&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;xor $1, $2, $3&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;mult $4, $3&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;multu $3, $2&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;mfhi $3&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;mflo $2&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;mthi $2&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;mtlo $2&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;sra $2, $2, 2&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;rol $2, $1, 3&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;ror $3, $3, 4&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;shl $2, $2, 2&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;shr $2, $3, 5&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;cmp $sw, $2, $3&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;jeq $sw, 20&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;jne $sw, 16&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;jlt $sw, -20&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;jle $sw, -16&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;jgt $sw, -4&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;jge $sw, -12&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;jsub 0x000010000&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;jr $4&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;ret $lr&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;jalr $t9&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;li $3, 0x00700000&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;la $3, 0x00800000($6)&quot;</span><span class="p">);</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;la $3, 0x00900000&quot;</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>clang<span class="w"> </span>-c<span class="w"> </span>ch11_1.cpp<span class="w"> </span>-emit-llvm<span class="w"> </span>-o
<span class="go">ch11_1.bc</span>
<span class="gp">JonathantekiiMac:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/bin/llc
<span class="go">-march=cpu0 -relocation-model=pic -filetype=obj ch11_1.bc</span>
<span class="go">-o ch11_1.cpu0.o</span>
<span class="go">LLVM ERROR: Inline asm not supported by this streamer because we don&#39;t have</span>
<span class="go">an asm parser for this target</span>
</pre></div>
</div>
<p>Since we haven’t implemented the Cpu0 assembler, the error message shown above
occurs. Cpu0 can translate LLVM IR into assembly and object files directly, but
it cannot translate hand-written assembly instructions into an object file.</p>
<p>Chapter11_1/ includes the AsmParser implementation as follows:</p>
<p class="rubric">lbdex/chapters/Chapter11_1/AsmParser/Cpu0AsmParser.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>//===-- Cpu0AsmParser.cpp - Parse Cpu0 assembly to MCInst instructions ----===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#include &quot;Cpu0.h&quot;
#if CH &gt;= CH11_1

#include &quot;MCTargetDesc/Cpu0MCExpr.h&quot;
#include &quot;MCTargetDesc/Cpu0MCTargetDesc.h&quot;
#include &quot;Cpu0RegisterInfo.h&quot;
#include &quot;llvm/ADT/APInt.h&quot;
#include &quot;llvm/ADT/StringSwitch.h&quot;
#include &quot;llvm/MC/MCContext.h&quot;
#include &quot;llvm/MC/MCExpr.h&quot;
#include &quot;llvm/MC/MCInst.h&quot;
#include &quot;llvm/MC/MCInstBuilder.h&quot;
#include &quot;llvm/MC/MCParser/MCAsmLexer.h&quot;
#include &quot;llvm/MC/MCParser/MCParsedAsmOperand.h&quot;
#include &quot;llvm/MC/MCParser/MCTargetAsmParser.h&quot;
#include &quot;llvm/MC/MCStreamer.h&quot;
#include &quot;llvm/MC/MCSubtargetInfo.h&quot;
#include &quot;llvm/MC/MCSymbol.h&quot;
#include &quot;llvm/MC/MCParser/MCAsmLexer.h&quot;
#include &quot;llvm/MC/MCParser/MCParsedAsmOperand.h&quot;
#include &quot;llvm/MC/MCValue.h&quot;
#include &quot;llvm/Support/Debug.h&quot;
#include &quot;llvm/Support/MathExtras.h&quot;
#include &quot;llvm/Support/TargetRegistry.h&quot;

using namespace llvm;

#define DEBUG_TYPE &quot;cpu0-asm-parser&quot;

namespace {
class Cpu0AssemblerOptions {
public:
  Cpu0AssemblerOptions():
    reorder(true), macro(true) {
  }

  bool isReorder() {return reorder;}
  void setReorder() {reorder = true;}
  void setNoreorder() {reorder = false;}

  bool isMacro() {return macro;}
  void setMacro() {macro = true;}
  void setNomacro() {macro = false;}

private:
  bool reorder;
  bool macro;
};
}

namespace {
class Cpu0AsmParser : public MCTargetAsmParser {
  MCAsmParser &amp;Parser;
  Cpu0AssemblerOptions Options;


#define GET_ASSEMBLER_HEADER
#include &quot;Cpu0GenAsmMatcher.inc&quot;

  bool MatchAndEmitInstruction(SMLoc IDLoc, unsigned &amp;Opcode,
                               OperandVector &amp;Operands, MCStreamer &amp;Out,
                               uint64_t &amp;ErrorInfo,
                               bool MatchingInlineAsm) override;

  bool ParseRegister(unsigned &amp;RegNo, SMLoc &amp;StartLoc, SMLoc &amp;EndLoc) override;

  OperandMatchResultTy tryParseRegister(unsigned &amp;RegNo, SMLoc &amp;StartLoc,
                                        SMLoc &amp;EndLoc) override;

  bool ParseInstruction(ParseInstructionInfo &amp;Info, StringRef Name,
                        SMLoc NameLoc, OperandVector &amp;Operands) override;

  bool ParseDirective(AsmToken DirectiveID) override;

  OperandMatchResultTy parseMemOperand(OperandVector &amp;);

  bool ParseOperand(OperandVector &amp;Operands, StringRef Mnemonic);

  int tryParseRegister(StringRef Mnemonic);

  bool tryParseRegisterOperand(OperandVector &amp;Operands,
                               StringRef Mnemonic);

  bool needsExpansion(MCInst &amp;Inst);

  void expandInstruction(MCInst &amp;Inst, SMLoc IDLoc,
                         SmallVectorImpl&lt;MCInst&gt; &amp;Instructions);
  void expandLoadImm(MCInst &amp;Inst, SMLoc IDLoc,
                     SmallVectorImpl&lt;MCInst&gt; &amp;Instructions);
  void expandLoadAddressImm(MCInst &amp;Inst, SMLoc IDLoc,
                            SmallVectorImpl&lt;MCInst&gt; &amp;Instructions);
  void expandLoadAddressReg(MCInst &amp;Inst, SMLoc IDLoc,
                            SmallVectorImpl&lt;MCInst&gt; &amp;Instructions);
  bool reportParseError(StringRef ErrorMsg);

  bool parseMemOffset(const MCExpr *&amp;Res);
  bool parseRelocOperand(const MCExpr *&amp;Res);

  const MCExpr *evaluateRelocExpr(const MCExpr *Expr, StringRef RelocStr);

  bool parseDirectiveSet();

  bool parseSetAtDirective();
  bool parseSetNoAtDirective();
  bool parseSetMacroDirective();
  bool parseSetNoMacroDirective();
  bool parseSetReorderDirective();
  bool parseSetNoReorderDirective();

  int matchRegisterName(StringRef Symbol);

  int matchRegisterByNumber(unsigned RegNum, StringRef Mnemonic);

  unsigned getReg(int RC,int RegNo);

public:
  Cpu0AsmParser(const MCSubtargetInfo &amp;sti, MCAsmParser &amp;parser,
                const MCInstrInfo &amp;MII, const MCTargetOptions &amp;Options)
    : MCTargetAsmParser(Options, sti, MII), Parser(parser) {
    // Initialize the set of available features.
    setAvailableFeatures(ComputeAvailableFeatures(getSTI().getFeatureBits()));
  }

  MCAsmParser &amp;getParser() const { return Parser; }
  MCAsmLexer &amp;getLexer() const { return Parser.getLexer(); }

};
}

namespace {

/// Cpu0Operand - Instances of this class represent a parsed Cpu0 machine
/// instruction.
class Cpu0Operand : public MCParsedAsmOperand {

  enum KindTy {
    k_Immediate,
    k_Memory,
    k_Register,
    k_Token
  } Kind;

public:
  Cpu0Operand(KindTy K) : MCParsedAsmOperand(), Kind(K) {}

  struct Token {
    const char *Data;
    unsigned Length;
  };
  struct PhysRegOp {
    unsigned RegNum; /// Register Number
  };
  struct ImmOp {
    const MCExpr *Val;
  };
  struct MemOp {
    unsigned Base;
    const MCExpr *Off;
  };

  union {
    struct Token Tok;
    struct PhysRegOp Reg;
    struct ImmOp Imm;
    struct MemOp Mem;
  };

  SMLoc StartLoc, EndLoc;

public:
  void addRegOperands(MCInst &amp;Inst, unsigned N) const {
    assert(N == 1 &amp;&amp; &quot;Invalid number of operands!&quot;);
    Inst.addOperand(MCOperand::createReg(getReg()));
  }

  void addExpr(MCInst &amp;Inst, const MCExpr *Expr) const{
    // Add as immediate when possible.  Null MCExpr = 0.
    if (Expr == 0)
      Inst.addOperand(MCOperand::createImm(0));
    else if (const MCConstantExpr *CE = dyn_cast&lt;MCConstantExpr&gt;(Expr))
      Inst.addOperand(MCOperand::createImm(CE-&gt;getValue()));
    else
      Inst.addOperand(MCOperand::createExpr(Expr));
  }

  void addImmOperands(MCInst &amp;Inst, unsigned N) const {
    assert(N == 1 &amp;&amp; &quot;Invalid number of operands!&quot;);
    const MCExpr *Expr = getImm();
    addExpr(Inst,Expr);
  }

  void addMemOperands(MCInst &amp;Inst, unsigned N) const {
    assert(N == 2 &amp;&amp; &quot;Invalid number of operands!&quot;);

    Inst.addOperand(MCOperand::createReg(getMemBase()));

    const MCExpr *Expr = getMemOff();
    addExpr(Inst,Expr);
  }

  bool isReg() const override { return Kind == k_Register; }
  bool isImm() const override { return Kind == k_Immediate; }
  bool isToken() const override { return Kind == k_Token; }
  bool isMem() const override { return Kind == k_Memory; }

  StringRef getToken() const {
    assert(Kind == k_Token &amp;&amp; &quot;Invalid access!&quot;);
    return StringRef(Tok.Data, Tok.Length);
  }

  unsigned getReg() const override {
    assert((Kind == k_Register) &amp;&amp; &quot;Invalid access!&quot;);
    return Reg.RegNum;
  }

  const MCExpr *getImm() const {
    assert((Kind == k_Immediate) &amp;&amp; &quot;Invalid access!&quot;);
    return Imm.Val;
  }

  unsigned getMemBase() const {
    assert((Kind == k_Memory) &amp;&amp; &quot;Invalid access!&quot;);
    return Mem.Base;
  }

  const MCExpr *getMemOff() const {
    assert((Kind == k_Memory) &amp;&amp; &quot;Invalid access!&quot;);
    return Mem.Off;
  }

  static std::unique_ptr&lt;Cpu0Operand&gt; CreateToken(StringRef Str, SMLoc S) {
    auto Op = std::make_unique&lt;Cpu0Operand&gt;(k_Token);
    Op-&gt;Tok.Data = Str.data();
    Op-&gt;Tok.Length = Str.size();
    Op-&gt;StartLoc = S;
    Op-&gt;EndLoc = S;
    return Op;
  }

  /// Internal constructor for register kinds
  static std::unique_ptr&lt;Cpu0Operand&gt; CreateReg(unsigned RegNum, SMLoc S, 
                                                SMLoc E) {
    auto Op = std::make_unique&lt;Cpu0Operand&gt;(k_Register);
    Op-&gt;Reg.RegNum = RegNum;
    Op-&gt;StartLoc = S;
    Op-&gt;EndLoc = E;
    return Op;
  }

  static std::unique_ptr&lt;Cpu0Operand&gt; CreateImm(const MCExpr *Val, SMLoc S, SMLoc E) {
    auto Op = std::make_unique&lt;Cpu0Operand&gt;(k_Immediate);
    Op-&gt;Imm.Val = Val;
    Op-&gt;StartLoc = S;
    Op-&gt;EndLoc = E;
    return Op;
  }

  static std::unique_ptr&lt;Cpu0Operand&gt; CreateMem(unsigned Base, const MCExpr *Off,
                                 SMLoc S, SMLoc E) {
    auto Op = std::make_unique&lt;Cpu0Operand&gt;(k_Memory);
    Op-&gt;Mem.Base = Base;
    Op-&gt;Mem.Off = Off;
    Op-&gt;StartLoc = S;
    Op-&gt;EndLoc = E;
    return Op;
  }

  /// getStartLoc - Get the location of the first token of this operand.
  SMLoc getStartLoc() const override { return StartLoc; }
  /// getEndLoc - Get the location of the last token of this operand.
  SMLoc getEndLoc() const override { return EndLoc; }

  void print(raw_ostream &amp;OS) const override {
    switch (Kind) {
    case k_Immediate:
      OS &lt;&lt; &quot;Imm&lt;&quot;;
      OS &lt;&lt; *Imm.Val;
      OS &lt;&lt; &quot;&gt;&quot;;
      break;
    case k_Memory:
      OS &lt;&lt; &quot;Mem&lt;&quot;;
      OS &lt;&lt; Mem.Base;
      OS &lt;&lt; &quot;, &quot;;
      OS &lt;&lt; *Mem.Off;
      OS &lt;&lt; &quot;&gt;&quot;;
      break;
    case k_Register:
      OS &lt;&lt; &quot;Register&lt;&quot; &lt;&lt; Reg.RegNum &lt;&lt; &quot;&gt;&quot;;
      break;
    case k_Token:
      OS &lt;&lt; Tok.Data;
      break;
    }
  }
};
}

void printCpu0Operands(OperandVector &amp;Operands) {
  for (size_t i = 0; i &lt; Operands.size(); i++) {
    Cpu0Operand* op = static_cast&lt;Cpu0Operand*&gt;(&amp;*Operands[i]);
    assert(op != nullptr);
    LLVM_DEBUG(dbgs() &lt;&lt; &quot;&lt;&quot; &lt;&lt; *op &lt;&lt; &quot;&gt;&quot;);
  }
  LLVM_DEBUG(dbgs() &lt;&lt; &quot;\n&quot;);
}

//@1 {
bool Cpu0AsmParser::needsExpansion(MCInst &amp;Inst) {

  switch(Inst.getOpcode()) {
    case Cpu0::LoadImm32Reg:
    case Cpu0::LoadAddr32Imm:
    case Cpu0::LoadAddr32Reg:
      return true;
    default:
      return false;
  }
}

void Cpu0AsmParser::expandInstruction(MCInst &amp;Inst, SMLoc IDLoc,
                        SmallVectorImpl&lt;MCInst&gt; &amp;Instructions){
  switch(Inst.getOpcode()) {
    case Cpu0::LoadImm32Reg:
      return expandLoadImm(Inst, IDLoc, Instructions);
    case Cpu0::LoadAddr32Imm:
      return expandLoadAddressImm(Inst,IDLoc,Instructions);
    case Cpu0::LoadAddr32Reg:
      return expandLoadAddressReg(Inst,IDLoc,Instructions);
    }
}
//@1 }

void Cpu0AsmParser::expandLoadImm(MCInst &amp;Inst, SMLoc IDLoc,
                                  SmallVectorImpl&lt;MCInst&gt; &amp;Instructions){
  MCInst tmpInst;
  const MCOperand &amp;ImmOp = Inst.getOperand(1);
  assert(ImmOp.isImm() &amp;&amp; &quot;expected immediate operand kind&quot;);
  const MCOperand &amp;RegOp = Inst.getOperand(0);
  assert(RegOp.isReg() &amp;&amp; &quot;expected register operand kind&quot;);

  int ImmValue = ImmOp.getImm();
  tmpInst.setLoc(IDLoc);
  if ( 0 &lt;= ImmValue &amp;&amp; ImmValue &lt;= 65535) {
    // for 0 &lt;= j &lt;= 65535.
    // li d,j =&gt; ori d,$zero,j
    tmpInst.setOpcode(Cpu0::ORi);
    tmpInst.addOperand(MCOperand::createReg(RegOp.getReg()));
    tmpInst.addOperand(
              MCOperand::createReg(Cpu0::ZERO));
    tmpInst.addOperand(MCOperand::createImm(ImmValue));
    Instructions.push_back(tmpInst);
  } else if ( ImmValue &lt; 0 &amp;&amp; ImmValue &gt;= -32768) {
    // for -32768 &lt;= j &lt; 0.
    // li d,j =&gt; addiu d,$zero,j
    tmpInst.setOpcode(Cpu0::ADDiu); //TODO:no ADDiu64 in td files?
    tmpInst.addOperand(MCOperand::createReg(RegOp.getReg()));
    tmpInst.addOperand(
              MCOperand::createReg(Cpu0::ZERO));
    tmpInst.addOperand(MCOperand::createImm(ImmValue));
    Instructions.push_back(tmpInst);
  } else {
    // for any other value of j that is representable as a 32-bit integer.
    // li d,j =&gt; lui d,hi16(j)
    //           ori d,d,lo16(j)
    tmpInst.setOpcode(Cpu0::LUi);
    tmpInst.addOperand(MCOperand::createReg(RegOp.getReg()));
    tmpInst.addOperand(MCOperand::createImm((ImmValue &amp; 0xffff0000) &gt;&gt; 16));
    Instructions.push_back(tmpInst);
    tmpInst.clear();
    tmpInst.setOpcode(Cpu0::ORi);
    tmpInst.addOperand(MCOperand::createReg(RegOp.getReg()));
    tmpInst.addOperand(MCOperand::createReg(RegOp.getReg()));
    tmpInst.addOperand(MCOperand::createImm(ImmValue &amp; 0xffff));
    tmpInst.setLoc(IDLoc);
    Instructions.push_back(tmpInst);
  }
}

void Cpu0AsmParser::expandLoadAddressReg(MCInst &amp;Inst, SMLoc IDLoc,
                                         SmallVectorImpl&lt;MCInst&gt; &amp;Instructions){
  MCInst tmpInst;
  const MCOperand &amp;ImmOp = Inst.getOperand(2);
  assert(ImmOp.isImm() &amp;&amp; &quot;expected immediate operand kind&quot;);
  const MCOperand &amp;SrcRegOp = Inst.getOperand(1);
  assert(SrcRegOp.isReg() &amp;&amp; &quot;expected register operand kind&quot;);
  const MCOperand &amp;DstRegOp = Inst.getOperand(0);
  assert(DstRegOp.isReg() &amp;&amp; &quot;expected register operand kind&quot;);
  int ImmValue = ImmOp.getImm();
  if ( -32768 &lt;= ImmValue &amp;&amp; ImmValue &lt;= 32767) {
    // for -32768 &lt;= j &lt; 32767.
    //la d,j(s) =&gt; addiu d,s,j
    tmpInst.setOpcode(Cpu0::ADDiu); //TODO:no ADDiu64 in td files?
    tmpInst.addOperand(MCOperand::createReg(DstRegOp.getReg()));
    tmpInst.addOperand(MCOperand::createReg(SrcRegOp.getReg()));
    tmpInst.addOperand(MCOperand::createImm(ImmValue));
    Instructions.push_back(tmpInst);
  } else {
    // for any other value of j that is representable as a 32-bit integer.
    // la d,j(s) =&gt; lui d,hi16(j)
    //              ori d,d,lo16(j)
    //              add d,d,s
    tmpInst.setOpcode(Cpu0::LUi);
    tmpInst.addOperand(MCOperand::createReg(DstRegOp.getReg()));
    tmpInst.addOperand(MCOperand::createImm((ImmValue &amp; 0xffff0000) &gt;&gt; 16));
    Instructions.push_back(tmpInst);
    tmpInst.clear();
    tmpInst.setOpcode(Cpu0::ORi);
    tmpInst.addOperand(MCOperand::createReg(DstRegOp.getReg()));
    tmpInst.addOperand(MCOperand::createReg(DstRegOp.getReg()));
    tmpInst.addOperand(MCOperand::createImm(ImmValue &amp; 0xffff));
    Instructions.push_back(tmpInst);
    tmpInst.clear();
    tmpInst.setOpcode(Cpu0::ADD);
    tmpInst.addOperand(MCOperand::createReg(DstRegOp.getReg()));
    tmpInst.addOperand(MCOperand::createReg(DstRegOp.getReg()));
    tmpInst.addOperand(MCOperand::createReg(SrcRegOp.getReg()));
    Instructions.push_back(tmpInst);
  }
}

void Cpu0AsmParser::expandLoadAddressImm(MCInst &amp;Inst, SMLoc IDLoc,
                                         SmallVectorImpl&lt;MCInst&gt; &amp;Instructions){
  MCInst tmpInst;
  const MCOperand &amp;ImmOp = Inst.getOperand(1);
  assert(ImmOp.isImm() &amp;&amp; &quot;expected immediate operand kind&quot;);
  const MCOperand &amp;RegOp = Inst.getOperand(0);
  assert(RegOp.isReg() &amp;&amp; &quot;expected register operand kind&quot;);
  int ImmValue = ImmOp.getImm();
  if ( -32768 &lt;= ImmValue &amp;&amp; ImmValue &lt;= 32767) {
    // for -32768 &lt;= j &lt; 32767.
    //la d,j =&gt; addiu d,$zero,j
    tmpInst.setOpcode(Cpu0::ADDiu);
    tmpInst.addOperand(MCOperand::createReg(RegOp.getReg()));
    tmpInst.addOperand(
              MCOperand::createReg(Cpu0::ZERO));
    tmpInst.addOperand(MCOperand::createImm(ImmValue));
    Instructions.push_back(tmpInst);
  } else {
    // for any other value of j that is representable as a 32-bit integer.
    // la d,j =&gt; lui d,hi16(j)
    //           ori d,d,lo16(j)
    tmpInst.setOpcode(Cpu0::LUi);
    tmpInst.addOperand(MCOperand::createReg(RegOp.getReg()));
    tmpInst.addOperand(MCOperand::createImm((ImmValue &amp; 0xffff0000) &gt;&gt; 16));
    Instructions.push_back(tmpInst);
    tmpInst.clear();
    tmpInst.setOpcode(Cpu0::ORi);
    tmpInst.addOperand(MCOperand::createReg(RegOp.getReg()));
    tmpInst.addOperand(MCOperand::createReg(RegOp.getReg()));
    tmpInst.addOperand(MCOperand::createImm(ImmValue &amp; 0xffff));
    Instructions.push_back(tmpInst);
  }
}

//@2 {
bool Cpu0AsmParser::MatchAndEmitInstruction(SMLoc IDLoc, unsigned &amp;Opcode,
                                            OperandVector &amp;Operands,
                                            MCStreamer &amp;Out,
                                            uint64_t &amp;ErrorInfo,
                                            bool MatchingInlineAsm) {
  printCpu0Operands(Operands);
  MCInst Inst;
  unsigned MatchResult = MatchInstructionImpl(Operands, Inst, ErrorInfo,
                                              MatchingInlineAsm);
  switch (MatchResult) {
  default: break;
  case Match_Success: {
    if (needsExpansion(Inst)) {
      SmallVector&lt;MCInst, 4&gt; Instructions;
      expandInstruction(Inst, IDLoc, Instructions);
      for(unsigned i =0; i &lt; Instructions.size(); i++){
        Out.emitInstruction(Instructions[i], getSTI());
      }
    } else {
        Inst.setLoc(IDLoc);
        Out.emitInstruction(Inst, getSTI());
      }
    return false;
  }
//@2 }
  case Match_MissingFeature:
    Error(IDLoc, &quot;instruction requires a CPU feature not currently enabled&quot;);
    return true;
  case Match_InvalidOperand: {
    SMLoc ErrorLoc = IDLoc;
    if (ErrorInfo != ~0U) {
      if (ErrorInfo &gt;= Operands.size())
        return Error(IDLoc, &quot;too few operands for instruction&quot;);

      ErrorLoc = ((Cpu0Operand &amp;)*Operands[ErrorInfo]).getStartLoc();
      if (ErrorLoc == SMLoc()) ErrorLoc = IDLoc;
    }

    return Error(ErrorLoc, &quot;invalid operand for instruction&quot;);
  }
  case Match_MnemonicFail:
    return Error(IDLoc, &quot;invalid instruction&quot;);
  }
  return true;
}

int Cpu0AsmParser::matchRegisterName(StringRef Name) {

   int CC;
    CC = StringSwitch&lt;unsigned&gt;(Name)
      .Case(&quot;zero&quot;,  Cpu0::ZERO)
      .Case(&quot;at&quot;,  Cpu0::AT)
      .Case(&quot;v0&quot;,  Cpu0::V0)
      .Case(&quot;v1&quot;,  Cpu0::V1)
      .Case(&quot;a0&quot;,  Cpu0::A0)
      .Case(&quot;a1&quot;,  Cpu0::A1)
      .Case(&quot;t9&quot;,  Cpu0::T9)
      .Case(&quot;t0&quot;,  Cpu0::T0)
      .Case(&quot;t1&quot;,  Cpu0::T1)
      .Case(&quot;s0&quot;,  Cpu0::S0)
      .Case(&quot;s1&quot;,  Cpu0::S1)
      .Case(&quot;sw&quot;,  Cpu0::SW)
      .Case(&quot;gp&quot;,  Cpu0::GP)
      .Case(&quot;fp&quot;,  Cpu0::FP)
      .Case(&quot;sp&quot;,  Cpu0::SP)
      .Case(&quot;lr&quot;,  Cpu0::LR)
      .Case(&quot;pc&quot;,  Cpu0::PC)
      .Case(&quot;hi&quot;,  Cpu0::HI)
      .Case(&quot;lo&quot;,  Cpu0::LO)
      .Case(&quot;epc&quot;, Cpu0::EPC)
      .Default(-1);

  if (CC != -1)
    return CC;

  return -1;
}

unsigned Cpu0AsmParser::getReg(int RC,int RegNo) {
  return *(getContext().getRegisterInfo()-&gt;getRegClass(RC).begin() + RegNo);
}

int Cpu0AsmParser::matchRegisterByNumber(unsigned RegNum, StringRef Mnemonic) {
  if (RegNum &gt; 15)
    return -1;

  return getReg(Cpu0::CPURegsRegClassID, RegNum);
}

int Cpu0AsmParser::tryParseRegister(StringRef Mnemonic) {
  const AsmToken &amp;Tok = Parser.getTok();
  int RegNum = -1;

  if (Tok.is(AsmToken::Identifier)) {
    std::string lowerCase = Tok.getString().lower();
    RegNum = matchRegisterName(lowerCase);
  } else if (Tok.is(AsmToken::Integer))
    RegNum = matchRegisterByNumber(static_cast&lt;unsigned&gt;(Tok.getIntVal()),
                                   Mnemonic.lower());
    else
      return RegNum;  //error
  return RegNum;
}

bool Cpu0AsmParser::
  tryParseRegisterOperand(OperandVector &amp;Operands,
                          StringRef Mnemonic){

  SMLoc S = Parser.getTok().getLoc();
  int RegNo = -1;

    RegNo = tryParseRegister(Mnemonic);
  if (RegNo == -1)
    return true;

  Operands.push_back(Cpu0Operand::CreateReg(RegNo, S,
      Parser.getTok().getLoc()));
  Parser.Lex(); // Eat register token.
  return false;
}

bool Cpu0AsmParser::ParseOperand(OperandVector &amp;Operands,
                                 StringRef Mnemonic) {
  LLVM_DEBUG(dbgs() &lt;&lt; &quot;ParseOperand\n&quot;);
  // Check if the current operand has a custom associated parser, if so, try to
  // custom parse the operand, or fallback to the general approach.
  OperandMatchResultTy ResTy = MatchOperandParserImpl(Operands, Mnemonic);
  if (ResTy == MatchOperand_Success)
    return false;
  // If there wasn&#39;t a custom match, try the generic matcher below. Otherwise,
  // there was a match, but an error occurred, in which case, just return that
  // the operand parsing failed.
  if (ResTy == MatchOperand_ParseFail)
    return true;

  LLVM_DEBUG(dbgs() &lt;&lt; &quot;.. Generic Parser\n&quot;);

  switch (getLexer().getKind()) {
  default:
    Error(Parser.getTok().getLoc(), &quot;unexpected token in operand&quot;);
    return true;
  case AsmToken::Dollar: {
    // parse register
    SMLoc S = Parser.getTok().getLoc();
    Parser.Lex(); // Eat dollar token.
    // parse register operand
    if (!tryParseRegisterOperand(Operands, Mnemonic)) {
      if (getLexer().is(AsmToken::LParen)) {
        // check if it is indexed addressing operand
        Operands.push_back(Cpu0Operand::CreateToken(&quot;(&quot;, S));
        Parser.Lex(); // eat parenthesis
        if (getLexer().isNot(AsmToken::Dollar))
          return true;

        Parser.Lex(); // eat dollar
        if (tryParseRegisterOperand(Operands, Mnemonic))
          return true;

        if (!getLexer().is(AsmToken::RParen))
          return true;

        S = Parser.getTok().getLoc();
        Operands.push_back(Cpu0Operand::CreateToken(&quot;)&quot;, S));
        Parser.Lex();
      }
      return false;
    }
    // maybe it is a symbol reference
    StringRef Identifier;
    if (Parser.parseIdentifier(Identifier))
      return true;

    SMLoc E = SMLoc::getFromPointer(Parser.getTok().getLoc().getPointer() - 1);

    MCSymbol *Sym = getContext().getOrCreateSymbol(&quot;$&quot; + Identifier);

    // Otherwise create a symbol ref.
    const MCExpr *Res = MCSymbolRefExpr::create(Sym, MCSymbolRefExpr::VK_None,
                                                getContext());

    Operands.push_back(Cpu0Operand::CreateImm(Res, S, E));
    return false;
  }
  case AsmToken::Identifier:
  case AsmToken::LParen:
  case AsmToken::Minus:
  case AsmToken::Plus:
  case AsmToken::Integer:
  case AsmToken::String: {
     // quoted label names
    const MCExpr *IdVal;
    SMLoc S = Parser.getTok().getLoc();
    if (getParser().parseExpression(IdVal))
      return true;
    SMLoc E = SMLoc::getFromPointer(Parser.getTok().getLoc().getPointer() - 1);
    Operands.push_back(Cpu0Operand::CreateImm(IdVal, S, E));
    return false;
  }
  case AsmToken::Percent: {
    // it is a symbol reference or constant expression
    const MCExpr *IdVal;
    SMLoc S = Parser.getTok().getLoc(); // start location of the operand
    if (parseRelocOperand(IdVal))
      return true;

    SMLoc E = SMLoc::getFromPointer(Parser.getTok().getLoc().getPointer() - 1);

    Operands.push_back(Cpu0Operand::CreateImm(IdVal, S, E));
    return false;
  } // case AsmToken::Percent
  } // switch(getLexer().getKind())
  return true;
}

const MCExpr *Cpu0AsmParser::evaluateRelocExpr(const MCExpr *Expr,
                                               StringRef RelocStr) {
  Cpu0MCExpr::Cpu0ExprKind Kind =
      StringSwitch&lt;Cpu0MCExpr::Cpu0ExprKind&gt;(RelocStr)
          .Case(&quot;call16&quot;, Cpu0MCExpr::CEK_GOT_CALL)
          .Case(&quot;call_hi&quot;, Cpu0MCExpr::CEK_CALL_HI16)
          .Case(&quot;call_lo&quot;, Cpu0MCExpr::CEK_CALL_LO16)
          .Case(&quot;dtp_hi&quot;, Cpu0MCExpr::CEK_DTP_HI)
          .Case(&quot;dtp_lo&quot;, Cpu0MCExpr::CEK_DTP_LO)
          .Case(&quot;got&quot;, Cpu0MCExpr::CEK_GOT)
          .Case(&quot;got_hi&quot;, Cpu0MCExpr::CEK_GOT_HI16)
          .Case(&quot;got_lo&quot;, Cpu0MCExpr::CEK_GOT_LO16)
          .Case(&quot;gottprel&quot;, Cpu0MCExpr::CEK_GOTTPREL)
          .Case(&quot;gp_rel&quot;, Cpu0MCExpr::CEK_GPREL)
          .Case(&quot;hi&quot;, Cpu0MCExpr::CEK_ABS_HI)
          .Case(&quot;lo&quot;, Cpu0MCExpr::CEK_ABS_LO)
          .Case(&quot;tlsgd&quot;, Cpu0MCExpr::CEK_TLSGD)
          .Case(&quot;tlsldm&quot;, Cpu0MCExpr::CEK_TLSLDM)
          .Case(&quot;tp_hi&quot;, Cpu0MCExpr::CEK_TP_HI)
          .Case(&quot;tp_lo&quot;, Cpu0MCExpr::CEK_TP_LO)
          .Default(Cpu0MCExpr::CEK_None);

  assert(Kind != Cpu0MCExpr::CEK_None);
  return Cpu0MCExpr::create(Kind, Expr, getContext());
}

bool Cpu0AsmParser::parseRelocOperand(const MCExpr *&amp;Res) {

  Parser.Lex(); // eat % token
  const AsmToken &amp;Tok = Parser.getTok(); // get next token, operation
  if (Tok.isNot(AsmToken::Identifier))
    return true;

  std::string Str = Tok.getIdentifier().str();

  Parser.Lex(); // eat identifier
  // now make expression from the rest of the operand
  const MCExpr *IdVal;
  SMLoc EndLoc;

  if (getLexer().getKind() == AsmToken::LParen) {
    while (1) {
      Parser.Lex(); // eat &#39;(&#39; token
      if (getLexer().getKind() == AsmToken::Percent) {
        Parser.Lex(); // eat % token
        const AsmToken &amp;nextTok = Parser.getTok();
        if (nextTok.isNot(AsmToken::Identifier))
          return true;
        Str += &quot;(%&quot;;
        Str += nextTok.getIdentifier();
        Parser.Lex(); // eat identifier
        if (getLexer().getKind() != AsmToken::LParen)
          return true;
      } else
        break;
    }
    if (getParser().parseParenExpression(IdVal,EndLoc))
      return true;

    while (getLexer().getKind() == AsmToken::RParen)
      Parser.Lex(); // eat &#39;)&#39; token

  } else
    return true; // parenthesis must follow reloc operand

  Res = evaluateRelocExpr(IdVal, Str);
  return false;
}

bool Cpu0AsmParser::ParseRegister(unsigned &amp;RegNo, SMLoc &amp;StartLoc,
                                  SMLoc &amp;EndLoc) {

  StartLoc = Parser.getTok().getLoc();
  RegNo = tryParseRegister(&quot;&quot;);
  EndLoc = Parser.getTok().getLoc();
  return (RegNo == (unsigned)-1);
}

OperandMatchResultTy Cpu0AsmParser::tryParseRegister(unsigned &amp;RegNo,
                                                     SMLoc &amp;StartLoc,
                                                     SMLoc &amp;EndLoc) {
  StartLoc = Parser.getTok().getLoc();
  RegNo = tryParseRegister(&quot;&quot;);
  EndLoc = Parser.getTok().getLoc();
  return (RegNo == (unsigned)-1) ? MatchOperand_NoMatch
                                 : MatchOperand_Success;
}

bool Cpu0AsmParser::parseMemOffset(const MCExpr *&amp;Res) {
  switch(getLexer().getKind()) {
  default:
    return true;
  case AsmToken::Integer:
  case AsmToken::Minus:
  case AsmToken::Plus:
    return (getParser().parseExpression(Res));
  case AsmToken::Percent:
    return parseRelocOperand(Res);
  case AsmToken::LParen:
    return false;  // it&#39;s probably assuming 0
  }
  return true;
}

// eg, 12($sp) or 12(la)
OperandMatchResultTy Cpu0AsmParser::parseMemOperand(
               OperandVector &amp;Operands) {

  const MCExpr *IdVal = 0;
  SMLoc S;
  // first operand is the offset
  S = Parser.getTok().getLoc();

  if (parseMemOffset(IdVal))
    return MatchOperand_ParseFail;

  const AsmToken &amp;Tok = Parser.getTok(); // get next token
  if (Tok.isNot(AsmToken::LParen)) {
    Cpu0Operand &amp;Mnemonic = static_cast&lt;Cpu0Operand &amp;&gt;(*Operands[0]);
    if (Mnemonic.getToken() == &quot;la&quot;) {
      SMLoc E = SMLoc::getFromPointer(Parser.getTok().getLoc().getPointer()-1);
      Operands.push_back(Cpu0Operand::CreateImm(IdVal, S, E));
      return MatchOperand_Success;
    }
    Error(Parser.getTok().getLoc(), &quot;&#39;(&#39; expected&quot;);
    return MatchOperand_ParseFail;
  }

  Parser.Lex(); // Eat &#39;(&#39; token.

  const AsmToken &amp;Tok1 = Parser.getTok(); // get next token
  if (Tok1.is(AsmToken::Dollar)) {
    Parser.Lex(); // Eat &#39;$&#39; token.
    if (tryParseRegisterOperand(Operands,&quot;&quot;)) {
      Error(Parser.getTok().getLoc(), &quot;unexpected token in operand&quot;);
      return MatchOperand_ParseFail;
    }

  } else {
    Error(Parser.getTok().getLoc(), &quot;unexpected token in operand&quot;);
    return MatchOperand_ParseFail;
  }

  const AsmToken &amp;Tok2 = Parser.getTok(); // get next token
  if (Tok2.isNot(AsmToken::RParen)) {
    Error(Parser.getTok().getLoc(), &quot;&#39;)&#39; expected&quot;);
    return MatchOperand_ParseFail;
  }

  SMLoc E = SMLoc::getFromPointer(Parser.getTok().getLoc().getPointer() - 1);

  Parser.Lex(); // Eat &#39;)&#39; token.

  if (!IdVal)
    IdVal = MCConstantExpr::create(0, getContext());

  // Replace the register operand with the memory operand.
  std::unique_ptr&lt;Cpu0Operand&gt; op(
      static_cast&lt;Cpu0Operand *&gt;(Operands.back().release()));
  int RegNo = op-&gt;getReg();
  // remove register from operands
  Operands.pop_back();
  // and add memory operand
  Operands.push_back(Cpu0Operand::CreateMem(RegNo, IdVal, S, E));
  return MatchOperand_Success;
}

bool Cpu0AsmParser::
ParseInstruction(ParseInstructionInfo &amp;Info, StringRef Name, SMLoc NameLoc,
                 OperandVector &amp;Operands) {

  // Create the leading tokens for the mnemonic, split by &#39;.&#39; characters.
  size_t Start = 0, Next = Name.find(&#39;.&#39;);
  StringRef Mnemonic = Name.slice(Start, Next);
  // Refer to the explanation in source code of function DecodeJumpFR(...) in 
  // Cpu0Disassembler.cpp
  if (Mnemonic == &quot;ret&quot;)
    Mnemonic = &quot;jr&quot;;

  Operands.push_back(Cpu0Operand::CreateToken(Mnemonic, NameLoc));

  // Read the remaining operands.
  if (getLexer().isNot(AsmToken::EndOfStatement)) {
    // Read the first operand.
    if (ParseOperand(Operands, Name)) {
      SMLoc Loc = getLexer().getLoc();
      Parser.eatToEndOfStatement();
      return Error(Loc, &quot;unexpected token in argument list&quot;);
    }

    while (getLexer().is(AsmToken::Comma) ) {
      Parser.Lex();  // Eat the comma.

      // Parse and remember the operand.
      if (ParseOperand(Operands, Name)) {
        SMLoc Loc = getLexer().getLoc();
        Parser.eatToEndOfStatement();
        return Error(Loc, &quot;unexpected token in argument list&quot;);
      }
    }
  }

  if (getLexer().isNot(AsmToken::EndOfStatement)) {
    SMLoc Loc = getLexer().getLoc();
    Parser.eatToEndOfStatement();
    return Error(Loc, &quot;unexpected token in argument list&quot;);
  }

  Parser.Lex(); // Consume the EndOfStatement
  return false;
}

bool Cpu0AsmParser::reportParseError(StringRef ErrorMsg) {
   SMLoc Loc = getLexer().getLoc();
   Parser.eatToEndOfStatement();
   return Error(Loc, ErrorMsg);
}

bool Cpu0AsmParser::parseSetReorderDirective() {
  Parser.Lex();
  // if this is not the end of the statement, report error
  if (getLexer().isNot(AsmToken::EndOfStatement)) {
    reportParseError(&quot;unexpected token in statement&quot;);
    return false;
  }
  Options.setReorder();
  Parser.Lex(); // Consume the EndOfStatement
  return false;
}

bool Cpu0AsmParser::parseSetNoReorderDirective() {
    Parser.Lex();
    // if this is not the end of the statement, report error
    if (getLexer().isNot(AsmToken::EndOfStatement)) {
      reportParseError(&quot;unexpected token in statement&quot;);
      return false;
    }
    Options.setNoreorder();
    Parser.Lex(); // Consume the EndOfStatement
    return false;
}

bool Cpu0AsmParser::parseSetMacroDirective() {
  Parser.Lex();
  // if this is not the end of the statement, report error
  if (getLexer().isNot(AsmToken::EndOfStatement)) {
    reportParseError(&quot;unexpected token in statement&quot;);
    return false;
  }
  Options.setMacro();
  Parser.Lex(); // Consume the EndOfStatement
  return false;
}

bool Cpu0AsmParser::parseSetNoMacroDirective() {
  Parser.Lex();
  // if this is not the end of the statement, report error
  if (getLexer().isNot(AsmToken::EndOfStatement)) {
    reportParseError(&quot;`noreorder&#39; must be set before `nomacro&#39;&quot;);
    return false;
  }
  if (Options.isReorder()) {
    reportParseError(&quot;`noreorder&#39; must be set before `nomacro&#39;&quot;);
    return false;
  }
  Options.setNomacro();
  Parser.Lex(); // Consume the EndOfStatement
  return false;
}
bool Cpu0AsmParser::parseDirectiveSet() {

  // get next token
  const AsmToken &amp;Tok = Parser.getTok();

  if (Tok.getString() == &quot;reorder&quot;) {
    return parseSetReorderDirective();
  } else if (Tok.getString() == &quot;noreorder&quot;) {
    return parseSetNoReorderDirective();
  } else if (Tok.getString() == &quot;macro&quot;) {
    return parseSetMacroDirective();
  } else if (Tok.getString() == &quot;nomacro&quot;) {
    return parseSetNoMacroDirective();
  }
  return true;
}

bool Cpu0AsmParser::ParseDirective(AsmToken DirectiveID) {

  if (DirectiveID.getString() == &quot;.ent&quot;) {
    // ignore this directive for now
    Parser.Lex();
    return false;
  }

  if (DirectiveID.getString() == &quot;.end&quot;) {
    // ignore this directive for now
    Parser.Lex();
    return false;
  }

  if (DirectiveID.getString() == &quot;.frame&quot;) {
    // ignore this directive for now
    Parser.eatToEndOfStatement();
    return false;
  }

  if (DirectiveID.getString() == &quot;.set&quot;) {
    return parseDirectiveSet();
  }

  if (DirectiveID.getString() == &quot;.fmask&quot;) {
    // ignore this directive for now
    Parser.eatToEndOfStatement();
    return false;
  }

  if (DirectiveID.getString() == &quot;.mask&quot;) {
    // ignore this directive for now
    Parser.eatToEndOfStatement();
    return false;
  }

  if (DirectiveID.getString() == &quot;.gpword&quot;) {
    // ignore this directive for now
    Parser.eatToEndOfStatement();
    return false;
  }

  return true;
}

extern &quot;C&quot; void LLVMInitializeCpu0AsmParser() {
  RegisterMCAsmParser&lt;Cpu0AsmParser&gt; X(TheCpu0Target);
  RegisterMCAsmParser&lt;Cpu0AsmParser&gt; Y(TheCpu0elTarget);
}

#define GET_REGISTER_MATCHER
#define GET_MATCHER_IMPLEMENTATION
#include &quot;Cpu0GenAsmMatcher.inc&quot;

#else // #if CH &gt;= CH11_1
extern &quot;C&quot; void LLVMInitializeCpu0AsmParser() {}
#endif
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_1/AsmParser/CMakeLists.txt</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">add_llvm_component_library</span><span class="p">(</span><span class="n">LLVMCpu0AsmParser</span>
  <span class="n">Cpu0AsmParser</span><span class="o">.</span><span class="n">cpp</span>

  <span class="n">LINK_COMPONENTS</span>
  <span class="n">MC</span>
  <span class="n">MCParser</span>
  <span class="n">Cpu0Desc</span>
  <span class="n">Cpu0Info</span>
  <span class="n">Support</span>

  <span class="n">ADD_TO_COMPONENT</span>
  <span class="n">Cpu0</span>
  <span class="p">)</span>
</pre></div>
</div>
<p>The <cite>Cpu0AsmParser.cpp</cite> file contains around one thousand lines of code that
handle assembly language parsing. With a little patience, you can understand it.</p>
<p>To enable building the files in the AsmParser directory, modify
<cite>CMakeLists.txt</cite> as follows:</p>
<p class="rubric">lbdex/chapters/Chapter11_1/CMakeLists.txt</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">set</span><span class="p">(</span><span class="n">LLVM_TARGET_DEFINITIONS</span> <span class="n">Cpu0Asm</span><span class="o">.</span><span class="n">td</span><span class="p">)</span>
<span class="n">tablegen</span><span class="p">(</span><span class="n">LLVM</span> <span class="n">Cpu0GenAsmMatcher</span><span class="o">.</span><span class="n">inc</span> <span class="o">-</span><span class="n">gen</span><span class="o">-</span><span class="n">asm</span><span class="o">-</span><span class="n">matcher</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">Cpu0AsmParser</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">add_subdirectory</span><span class="p">(</span><span class="n">AsmParser</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_1/Cpu0Asm.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//===--</span> <span class="n">Cpu0Asm</span><span class="o">.</span><span class="n">td</span> <span class="o">-</span> <span class="n">Describe</span> <span class="n">the</span> <span class="n">Cpu0</span> <span class="n">Target</span> <span class="n">Machine</span> <span class="o">------*-</span> <span class="n">tablegen</span> <span class="o">-*-===//</span>
<span class="o">//</span>
<span class="o">//</span>                     <span class="n">The</span> <span class="n">LLVM</span> <span class="n">Compiler</span> <span class="n">Infrastructure</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">This</span> <span class="n">file</span> <span class="ow">is</span> <span class="n">distributed</span> <span class="n">under</span> <span class="n">the</span> <span class="n">University</span> <span class="n">of</span> <span class="n">Illinois</span> <span class="n">Open</span> <span class="n">Source</span>
<span class="o">//</span> <span class="n">License</span><span class="o">.</span> <span class="n">See</span> <span class="n">LICENSE</span><span class="o">.</span><span class="n">TXT</span> <span class="k">for</span> <span class="n">details</span><span class="o">.</span>
<span class="o">//</span>
<span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">//</span> <span class="n">This</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">top</span> <span class="n">level</span> <span class="n">entry</span> <span class="n">point</span> <span class="k">for</span> <span class="n">the</span> <span class="n">Cpu0</span> <span class="n">target</span><span class="o">.</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">//</span> <span class="n">Target</span><span class="o">-</span><span class="n">independent</span> <span class="n">interfaces</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="n">include</span> <span class="s2">&quot;llvm/Target/Target.td&quot;</span>

<span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">//</span> <span class="n">Target</span><span class="o">-</span><span class="n">dependent</span> <span class="n">interfaces</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="n">include</span> <span class="s2">&quot;Cpu0RegisterInfo.td&quot;</span>
<span class="n">include</span> <span class="s2">&quot;Cpu0RegisterInfoGPROutForAsm.td&quot;</span>
<span class="n">include</span> <span class="s2">&quot;Cpu0.td&quot;</span>

</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_1/Cpu0RegisterInfoGPROutForAsm.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">//</span> <span class="n">Register</span> <span class="n">Classes</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="k">def</span><span class="w"> </span><span class="nf">GPROut</span> <span class="p">:</span> <span class="n">RegisterClass</span><span class="o">&lt;</span><span class="s2">&quot;Cpu0&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">i32</span><span class="p">],</span> <span class="mi">32</span><span class="p">,</span> <span class="p">(</span><span class="n">add</span> <span class="n">CPURegs</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>

</pre></div>
</div>
<p>The <cite>CMakeLists.txt</cite> modification shown above generates <cite>Cpu0GenAsmMatcher.inc</cite>,
which is used by <cite>Cpu0AsmParser.cpp</cite>.</p>
<p><cite>Cpu0Asm.td</cite> includes <cite>Cpu0RegisterInfoGPROutForAsm.td</cite>, which defines <cite>GPROut</cite>
as mapping to <cite>CPURegs</cite>. Meanwhile, <cite>Cpu0Other.td</cite> includes
<cite>Cpu0RegisterInfoGPROutForOther.td</cite>, which defines <cite>GPROut</cite> to map to <cite>CPURegs</cite>
excluding <cite>SW</cite>.</p>
<p><cite>Cpu0Other.td</cite> is used when translating LLVM IR to Cpu0 instructions. In this
case, the <cite>SW</cite> register is reserved for storing CPU status and must not be
allocated as a general-purpose register.</p>
<p>For example, if <cite>GPROut</cite> includes <cite>SW</cite>, compiling the C statement <cite>a = (b &amp; c);</cite>
might generate the instruction <cite>and $sw, $1, $2</cite>. This would overwrite the
interrupt status in <cite>$sw</cite>.</p>
<p>However, when programming in assembly, instructions like <cite>andi $sw, $sw, 0xffdf</cite>
are allowed. This kind of assembly is accepted, and the Cpu0 backend considers
it safe. An assembler programmer may use <cite>andi $sw, $sw, 0xffdf</cite> to disable
trace debug messages, and <cite>ori $sw, $sw, 0x0020</cite> to enable them.</p>
<p>Additionally, interrupt bits can also be enabled or disabled using <cite>ori</cite> and
<cite>andi</cite> instructions.</p>
<p>The <cite>EPC</cite> must be set to <cite>CPURegs</cite> as shown below. Otherwise,
<cite>MatchInstructionImpl()</cite> in <cite>MatchAndEmitInstruction()</cite> will fail for the
instruction <cite>asm(“mfc0 $pc, $epc”);</cite>.</p>
<p class="rubric">lbdex/chapters/Chapter2/Cpu0RegisterInfo.td</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">def</span><span class="w"> </span><span class="n">CPURegs</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">RegisterClass</span><span class="o">&lt;</span><span class="s">&quot;Cpu0&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">i32</span><span class="p">],</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">add</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">PC</span><span class="p">,</span><span class="w"> </span><span class="n">EPC</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_1/Cpu0.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">Cpu0AsmParser</span> <span class="p">:</span> <span class="n">AsmParser</span> <span class="p">{</span>
  <span class="n">let</span> <span class="n">ShouldEmitMatchRegisterName</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">def</span><span class="w"> </span><span class="nf">Cpu0AsmParserVariant</span> <span class="p">:</span> <span class="n">AsmParserVariant</span> <span class="p">{</span>
  <span class="nb">int</span> <span class="n">Variant</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="o">//</span> <span class="n">Recognize</span> <span class="n">hard</span> <span class="n">coded</span> <span class="n">registers</span><span class="o">.</span>
  <span class="n">string</span> <span class="n">RegisterPrefix</span> <span class="o">=</span> <span class="s2">&quot;$&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">def</span><span class="w"> </span><span class="n">Cpu0</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Target</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">let</span> <span class="n">AssemblyParsers</span> <span class="o">=</span> <span class="p">[</span><span class="n">Cpu0AsmParser</span><span class="p">];</span>
  <span class="n">let</span> <span class="n">AssemblyParserVariants</span> <span class="o">=</span> <span class="p">[</span><span class="n">Cpu0AsmParserVariant</span><span class="p">];</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_1/Cpu0InstrFormats.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Pseudo</span><span class="o">-</span><span class="n">instructions</span> <span class="k">for</span> <span class="n">alternate</span> <span class="n">assembly</span> <span class="n">syntax</span> <span class="p">(</span><span class="n">never</span> <span class="n">used</span> <span class="n">by</span> <span class="n">codegen</span><span class="p">)</span><span class="o">.</span>
<span class="o">//</span> <span class="n">These</span> <span class="n">are</span> <span class="n">aliases</span> <span class="n">that</span> <span class="n">require</span> <span class="n">C</span><span class="o">++</span> <span class="n">handling</span> <span class="n">to</span> <span class="n">convert</span> <span class="n">to</span> <span class="n">the</span> <span class="n">target</span>
<span class="o">//</span> <span class="n">instruction</span><span class="p">,</span> <span class="k">while</span> <span class="n">InstAliases</span> <span class="n">can</span> <span class="n">be</span> <span class="n">handled</span> <span class="n">directly</span> <span class="n">by</span> <span class="n">tblgen</span><span class="o">.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Cpu0AsmPseudoInst</span><span class="o">&lt;</span><span class="n">dag</span> <span class="n">outs</span><span class="p">,</span> <span class="n">dag</span> <span class="n">ins</span><span class="p">,</span> <span class="n">string</span> <span class="n">asmstr</span><span class="o">&gt;</span><span class="p">:</span>
  <span class="n">Cpu0Inst</span><span class="o">&lt;</span><span class="n">outs</span><span class="p">,</span> <span class="n">ins</span><span class="p">,</span> <span class="n">asmstr</span><span class="p">,</span> <span class="p">[],</span> <span class="n">IIPseudo</span><span class="p">,</span> <span class="n">Pseudo</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">let</span> <span class="n">isPseudo</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">let</span> <span class="n">Pattern</span> <span class="o">=</span> <span class="p">[];</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_1/Cpu0InstrInfo.td</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">def</span><span class="w"> </span><span class="n">Cpu0MemAsmOperand</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">AsmOperandClass</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">let</span><span class="w"> </span><span class="n">Name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Mem&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="n">let</span><span class="w"> </span><span class="n">ParserMethod</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;parseMemOperand&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Address operand</span>
<span class="n">def</span><span class="w"> </span><span class="n">mem</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Operand</span><span class="o">&lt;</span><span class="n">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="n">let</span><span class="w"> </span><span class="n">ParserMatchClass</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Cpu0MemAsmOperand</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">...</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>//===----------------------------------------------------------------------===//
// Pseudo Instruction definition
//===----------------------------------------------------------------------===//

let Predicates = [Ch11_1] in {
class LoadImm32&lt; string instr_asm, Operand Od, RegisterClass RC&gt; :
  Cpu0AsmPseudoInst&lt;(outs RC:$ra), (ins Od:$imm32),
                     !strconcat(instr_asm, &quot;\t$ra, $imm32&quot;)&gt; ;
def LoadImm32Reg : LoadImm32&lt;&quot;li&quot;, shamt, GPROut&gt;;

class LoadAddress&lt;string instr_asm, Operand MemOpnd, RegisterClass RC&gt; :
  Cpu0AsmPseudoInst&lt;(outs RC:$ra), (ins MemOpnd:$addr),
                     !strconcat(instr_asm, &quot;\t$ra, $addr&quot;)&gt; ;
def LoadAddr32Reg : LoadAddress&lt;&quot;la&quot;, mem, GPROut&gt;;

class LoadAddressImm&lt;string instr_asm, Operand Od, RegisterClass RC&gt; :
  Cpu0AsmPseudoInst&lt;(outs RC:$ra), (ins Od:$imm32),
                     !strconcat(instr_asm, &quot;\t$ra, $imm32&quot;)&gt; ;
def LoadAddr32Imm : LoadAddressImm&lt;&quot;la&quot;, shamt, GPROut&gt;;
}
</pre></div>
</div>
<p>In the <cite>Cpu0InstrInfo.td</cite> file, the directive <strong>let ParserMethod =
“parseMemOperand”</strong> declares that the method <cite>parseMemOperand()</cite> will be used
to handle the <strong>mem</strong> operand in Cpu0 instructions such as <cite>ld</cite> and <cite>st</cite>.</p>
<p>For example, in the instruction <cite>ld $2, 4($sp)</cite>, the <strong>mem</strong> operand is <cite>4($sp)</cite>.</p>
<p>Together with the directive <strong>let ParserMatchClass = Cpu0MemAsmOperand;</strong>, LLVM
will invoke the <cite>parseMemOperand()</cite> function in <cite>Cpu0AsmParser.cpp</cite> whenever it
encounters a <strong>mem</strong> operand like <cite>4($sp)</cite> in assembly code.</p>
<p>With the above <strong>let</strong> assignments, TableGen will generate the corresponding
structure and functions in <cite>Cpu0GenAsmMatcher.inc</cite>.</p>
<p class="rubric">build/lib/Target/Cpu0/Cpu0GenAsmMatcher.inc</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="k">enum</span><span class="w"> </span><span class="nc">OperandMatchResultTy</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">MatchOperand_Success</span><span class="p">,</span><span class="w">    </span><span class="c1">// operand matched successfully</span>
<span class="w">    </span><span class="n">MatchOperand_NoMatch</span><span class="p">,</span><span class="w">    </span><span class="c1">// operand did not match</span>
<span class="w">    </span><span class="n">MatchOperand_ParseFail</span><span class="w">   </span><span class="c1">// operand matched but had errors</span>
<span class="w">  </span><span class="p">};</span>
<span class="w">  </span><span class="n">OperandMatchResultTy</span><span class="w"> </span><span class="nf">MatchOperandParserImpl</span><span class="p">(</span>
<span class="w">    </span><span class="n">OperandVector</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Operands</span><span class="p">,</span>
<span class="w">    </span><span class="n">StringRef</span><span class="w"> </span><span class="n">Mnemonic</span><span class="p">);</span>
<span class="w">  </span><span class="n">OperandMatchResultTy</span><span class="w"> </span><span class="nf">tryCustomParseOperand</span><span class="p">(</span>
<span class="w">    </span><span class="n">OperandVector</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Operands</span><span class="p">,</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">MCK</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">OperandMatchResultTy</span><span class="w"> </span><span class="n">Cpu0AsmParser</span><span class="o">::</span>
<span class="n">tryCustomParseOperand</span><span class="p">(</span><span class="n">OperandVector</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Operands</span><span class="p">,</span>
<span class="w">            </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">MCK</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="k">switch</span><span class="p">(</span><span class="n">MCK</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">MCK_Mem</span><span class="p">:</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">parseMemOperand</span><span class="p">(</span><span class="n">Operands</span><span class="p">);</span>
<span class="w">  </span><span class="k">default</span><span class="o">:</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">MatchOperand_NoMatch</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">MatchOperand_NoMatch</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">OperandMatchResultTy</span><span class="w"> </span><span class="n">Cpu0AsmParser</span><span class="o">::</span>
<span class="n">MatchOperandParserImpl</span><span class="p">(</span><span class="n">OperandVector</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Operands</span><span class="p">,</span>
<span class="w">             </span><span class="n">StringRef</span><span class="w"> </span><span class="n">Mnemonic</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>

<span class="c1">/// MatchClassKind - The kinds of classes which participate in</span>
<span class="c1">/// instruction matching.</span>
<span class="k">enum</span><span class="w"> </span><span class="nc">MatchClassKind</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="n">MCK_Mem</span><span class="p">,</span><span class="w"> </span><span class="c1">// user defined class &#39;Cpu0MemAsmOperand&#39;</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The three pseudo instruction definitions in <cite>Cpu0InstrInfo.td</cite>, such as
<cite>LoadImm32Reg</cite>, are handled by <cite>Cpu0AsmParser.cpp</cite> as follows:</p>
<p class="rubric">lbdex/chapters/Chapter11_1/AsmParser/Cpu0AsmParser.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">bool</span> <span class="n">Cpu0AsmParser</span><span class="p">::</span><span class="n">needsExpansion</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">)</span> <span class="p">{</span>

  <span class="n">switch</span><span class="p">(</span><span class="n">Inst</span><span class="o">.</span><span class="n">getOpcode</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">LoadImm32Reg</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">LoadAddr32Imm</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">LoadAddr32Reg</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">true</span><span class="p">;</span>
    <span class="n">default</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">false</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">Cpu0AsmParser</span><span class="p">::</span><span class="n">expandInstruction</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="n">IDLoc</span><span class="p">,</span>
                        <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCInst</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Instructions</span><span class="p">){</span>
  <span class="n">switch</span><span class="p">(</span><span class="n">Inst</span><span class="o">.</span><span class="n">getOpcode</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">LoadImm32Reg</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">expandLoadImm</span><span class="p">(</span><span class="n">Inst</span><span class="p">,</span> <span class="n">IDLoc</span><span class="p">,</span> <span class="n">Instructions</span><span class="p">);</span>
    <span class="k">case</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">LoadAddr32Imm</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">expandLoadAddressImm</span><span class="p">(</span><span class="n">Inst</span><span class="p">,</span><span class="n">IDLoc</span><span class="p">,</span><span class="n">Instructions</span><span class="p">);</span>
    <span class="k">case</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">LoadAddr32Reg</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">expandLoadAddressReg</span><span class="p">(</span><span class="n">Inst</span><span class="p">,</span><span class="n">IDLoc</span><span class="p">,</span><span class="n">Instructions</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">bool</span> <span class="n">Cpu0AsmParser</span><span class="p">::</span><span class="n">MatchAndEmitInstruction</span><span class="p">(</span><span class="n">SMLoc</span> <span class="n">IDLoc</span><span class="p">,</span> <span class="n">unsigned</span> <span class="o">&amp;</span><span class="n">Opcode</span><span class="p">,</span>
                                            <span class="n">OperandVector</span> <span class="o">&amp;</span><span class="n">Operands</span><span class="p">,</span>
                                            <span class="n">MCStreamer</span> <span class="o">&amp;</span><span class="n">Out</span><span class="p">,</span>
                                            <span class="n">uint64_t</span> <span class="o">&amp;</span><span class="n">ErrorInfo</span><span class="p">,</span>
                                            <span class="nb">bool</span> <span class="n">MatchingInlineAsm</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printCpu0Operands</span><span class="p">(</span><span class="n">Operands</span><span class="p">);</span>
  <span class="n">MCInst</span> <span class="n">Inst</span><span class="p">;</span>
  <span class="n">unsigned</span> <span class="n">MatchResult</span> <span class="o">=</span> <span class="n">MatchInstructionImpl</span><span class="p">(</span><span class="n">Operands</span><span class="p">,</span> <span class="n">Inst</span><span class="p">,</span> <span class="n">ErrorInfo</span><span class="p">,</span>
                                              <span class="n">MatchingInlineAsm</span><span class="p">);</span>
  <span class="n">switch</span> <span class="p">(</span><span class="n">MatchResult</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">default</span><span class="p">:</span> <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Match_Success</span><span class="p">:</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">needsExpansion</span><span class="p">(</span><span class="n">Inst</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">MCInst</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">Instructions</span><span class="p">;</span>
      <span class="n">expandInstruction</span><span class="p">(</span><span class="n">Inst</span><span class="p">,</span> <span class="n">IDLoc</span><span class="p">,</span> <span class="n">Instructions</span><span class="p">);</span>
      <span class="k">for</span><span class="p">(</span><span class="n">unsigned</span> <span class="n">i</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Instructions</span><span class="o">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">Out</span><span class="o">.</span><span class="n">emitInstruction</span><span class="p">(</span><span class="n">Instructions</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">getSTI</span><span class="p">());</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">Inst</span><span class="o">.</span><span class="n">setLoc</span><span class="p">(</span><span class="n">IDLoc</span><span class="p">);</span>
        <span class="n">Out</span><span class="o">.</span><span class="n">emitInstruction</span><span class="p">(</span><span class="n">Inst</span><span class="p">,</span> <span class="n">getSTI</span><span class="p">());</span>
      <span class="p">}</span>
    <span class="k">return</span> <span class="n">false</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Finally, remember that the <cite>CPURegs</cite> list below must follow the order of register
numbers, because the AsmParser uses this order when encoding register numbers.</p>
<p class="rubric">lbdex/chapters/Chapter11_1/Cpu0RegisterInfo.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">//</span> <span class="n">The</span> <span class="n">register</span> <span class="n">string</span><span class="p">,</span> <span class="n">such</span> <span class="k">as</span> <span class="s2">&quot;9&quot;</span> <span class="ow">or</span> <span class="s2">&quot;gp&quot;</span> <span class="n">will</span> <span class="n">show</span> <span class="n">on</span> <span class="s2">&quot;llvm-objdump -d&quot;</span>
<span class="o">//@</span> <span class="n">All</span> <span class="n">registers</span> <span class="n">definition</span>
<span class="n">let</span> <span class="n">Namespace</span> <span class="o">=</span> <span class="s2">&quot;Cpu0&quot;</span> <span class="ow">in</span> <span class="p">{</span>
  <span class="o">//@</span> <span class="n">General</span> <span class="n">Purpose</span> <span class="n">Registers</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">ZERO</span> <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span>  <span class="s2">&quot;zero&quot;</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">AT</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span>  <span class="s2">&quot;1&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">V0</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span>  <span class="s2">&quot;2&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">V1</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span>  <span class="s2">&quot;3&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">A0</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">,</span>  <span class="s2">&quot;4&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">A1</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">,</span>  <span class="s2">&quot;5&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">T9</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">,</span>  <span class="s2">&quot;t9&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">T0</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">7</span><span class="p">,</span>  <span class="s2">&quot;7&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">T1</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span>  <span class="s2">&quot;8&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">S0</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">9</span><span class="p">,</span>  <span class="s2">&quot;9&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">S1</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">GP</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">11</span><span class="p">,</span> <span class="s2">&quot;gp&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">FP</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">12</span><span class="p">,</span> <span class="s2">&quot;fp&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">SP</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">13</span><span class="p">,</span> <span class="s2">&quot;sp&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">LR</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">14</span><span class="p">,</span> <span class="s2">&quot;lr&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">SW</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">15</span><span class="p">,</span> <span class="s2">&quot;sw&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="o">//</span>  <span class="k">def</span><span class="w"> </span><span class="nf">MAR</span>  <span class="p">:</span> <span class="n">Register</span><span class="o">&lt;</span> <span class="mi">16</span><span class="p">,</span> <span class="s2">&quot;mar&quot;</span><span class="o">&gt;</span><span class="p">,</span>  <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="o">//</span>  <span class="k">def</span><span class="w"> </span><span class="nf">MDR</span>  <span class="p">:</span> <span class="n">Register</span><span class="o">&lt;</span> <span class="mi">17</span><span class="p">,</span> <span class="s2">&quot;mdr&quot;</span><span class="o">&gt;</span><span class="p">,</span>  <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>

<span class="o">//</span><span class="c1">#if CH &gt;= CH4_1 1</span>
  <span class="o">//</span> <span class="n">Hi</span><span class="o">/</span><span class="n">Lo</span> <span class="n">registers</span> <span class="n">number</span> <span class="ow">and</span> <span class="n">name</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">HI</span>   <span class="p">:</span> <span class="n">Cpu0Reg</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;ac0&quot;</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">18</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">LO</span>   <span class="p">:</span> <span class="n">Cpu0Reg</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;ac0&quot;</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="o">//</span><span class="c1">#endif</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">PC</span>   <span class="p">:</span> <span class="n">Cpu0C0Reg</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;pc&quot;</span><span class="o">&gt;</span><span class="p">,</span>  <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">EPC</span>  <span class="p">:</span> <span class="n">Cpu0C0Reg</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;epc&quot;</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">21</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">//</span><span class="nd">@Register</span> <span class="n">Classes</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="k">def</span><span class="w"> </span><span class="nf">CPURegs</span> <span class="p">:</span> <span class="n">RegisterClass</span><span class="o">&lt;</span><span class="s2">&quot;Cpu0&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">i32</span><span class="p">],</span> <span class="mi">32</span><span class="p">,</span> <span class="p">(</span><span class="n">add</span>
  <span class="o">//</span> <span class="n">Reserved</span>
  <span class="n">ZERO</span><span class="p">,</span> <span class="n">AT</span><span class="p">,</span> 
  <span class="o">//</span> <span class="n">Return</span> <span class="n">Values</span> <span class="ow">and</span> <span class="n">Arguments</span>
  <span class="n">V0</span><span class="p">,</span> <span class="n">V1</span><span class="p">,</span> <span class="n">A0</span><span class="p">,</span> <span class="n">A1</span><span class="p">,</span> 
  <span class="o">//</span> <span class="n">Not</span> <span class="n">preserved</span> <span class="n">across</span> <span class="n">procedure</span> <span class="n">calls</span>
  <span class="n">T9</span><span class="p">,</span> <span class="n">T0</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span>
  <span class="o">//</span> <span class="n">Callee</span> <span class="n">save</span>
  <span class="n">S0</span><span class="p">,</span> <span class="n">S1</span><span class="p">,</span>
  <span class="o">//</span> <span class="n">Reserved</span>
  <span class="n">GP</span><span class="p">,</span> <span class="n">FP</span><span class="p">,</span> 
  <span class="n">SP</span><span class="p">,</span> <span class="n">LR</span><span class="p">,</span> <span class="n">SW</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>

</pre></div>
</div>
<p>Run <cite>Chapter11_1/</cite> with <cite>ch11_1.cpp</cite> to get the correct result as shown below:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/bin/llc
<span class="go">-march=cpu0 -relocation-model=pic -filetype=obj ch11_1.bc -o</span>
<span class="go">ch11_1.cpu0.o</span>
<span class="gp">JonathantekiiMac:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/bin/
<span class="go">llvm-objdump -d ch11_1.cpu0.o</span>

<span class="go">ch11_1.cpu0.o:  file format ELF32-unknown</span>

<span class="go">Disassembly of section .text:</span>
<span class="go">.text:</span>
<span class="go">       0:     01 2d 00 08                                     ld      $2, 8($sp)</span>
<span class="go">       4:     02 0d 00 04                                     st      $zero, 4($sp)</span>
<span class="go">       8:     09 30 00 00                                     addiu   $3, $zero, 0</span>
<span class="go">       c:     13 31 20 00                                     add     $3, $1, $2</span>
<span class="go">      10:     14 32 30 00                                     sub     $3, $2, $3</span>
<span class="go">      ...</span>
</pre></div>
</div>
<p>The instructions <cite>cmp</cite> and <cite>jeg</cite> display the <cite>$sw</cite> register explicitly in both
assembly and disassembly. You can modify the code in the AsmParser and
Disassembler (discussed in the last chapter) to hide <cite>$sw</cite> in these instructions
—for example, displaying <cite>jeq 20</cite> instead of <cite>jeq $sw, 20</cite>.</p>
<p>Both <cite>AsmParser</cite> and <cite>Cpu0AsmParser</cite> inherit from <cite>MCAsmParser</cite> as follows:</p>
<p class="rubric">llvm/lib/MC/MCParser/AsmParser.cpp</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">AsmParser</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">MCAsmParser</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
<span class="p">...</span>
</pre></div>
</div>
<p><cite>AsmParser</cite> will call the <cite>ParseInstruction()</cite> and <cite>MatchAndEmitInstruction()</cite>
functions of <cite>Cpu0AsmParser</cite> as follows:</p>
<p class="rubric">llvm/lib/MC/MCParser/AsmParser.cpp</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">AsmParser::parseStatement</span><span class="p">(</span><span class="n">ParseStatementInfo</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Info</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="c1">// Directives start with &quot;.&quot;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IDVal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;.&#39;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">IDVal</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="s">&quot;.&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// First query the target-specific parser. It will return &#39;true&#39; if it</span>
<span class="w">    </span><span class="c1">// isn&#39;t interested in this directive.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">getTargetParser</span><span class="p">().</span><span class="n">ParseDirective</span><span class="p">(</span><span class="n">ID</span><span class="p">))</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">HadError</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getTargetParser</span><span class="p">().</span><span class="n">ParseInstruction</span><span class="p">(</span><span class="n">IInfo</span><span class="p">,</span><span class="w"> </span><span class="n">OpcodeStr</span><span class="p">,</span><span class="w"> </span><span class="n">IDLoc</span><span class="p">,</span>
<span class="w">                                                     </span><span class="n">Info</span><span class="p">.</span><span class="n">ParsedOperands</span><span class="p">);</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="c1">// If parsing succeeded, match the instruction.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">HadError</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">ErrorInfo</span><span class="p">;</span>
<span class="w">    </span><span class="n">getTargetParser</span><span class="p">().</span><span class="n">MatchAndEmitInstruction</span><span class="p">(</span><span class="n">IDLoc</span><span class="p">,</span><span class="w"> </span><span class="n">Info</span><span class="p">.</span><span class="n">Opcode</span><span class="p">,</span>
<span class="w">                                              </span><span class="n">Info</span><span class="p">.</span><span class="n">ParsedOperands</span><span class="p">,</span><span class="w"> </span><span class="n">Out</span><span class="p">,</span>
<span class="w">                                              </span><span class="n">ErrorInfo</span><span class="p">,</span><span class="w"> </span><span class="n">ParsingInlineAsm</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="assembler-structure">
<h2><a class="toc-backref" href="#id11" role="doc-backlink">Assembler structure</a><a class="headerlink" href="#assembler-structure" title="Link to this heading">¶</a></h2>
<p>Run <cite>llc</cite> with the option <cite>-debug-only=asm-matcher,cpu0-asm-parser</cite> to observe
how the Cpu0 assembler works.</p>
<p>The <cite>AsmParser</cite> directory handles the translation from assembly to object files.</p>
<p>The assembling Data Flow Diagram (DFD) is shown in <a class="reference internal" href="#asm-f1"><span class="std std-numref">Fig. 53</span></a> and
<a class="reference internal" href="#asm-f2"><span class="std std-numref">Fig. 54</span></a>.</p>
<figure class="align-default" id="id4">
<span id="asm-f1"></span><div class="graphviz"><img src="_images/graphviz-f4e64af295d5ee47948e15907814b637976bb795.png" alt="// Free usage license, author: Chung-Shu Chen 陳鍾樞
// dot -tPng asmDfd.gv -oasmDfd.png

digraph G {
  rankdir=LR;
  subgraph cluster_0 {
    style=filled;
//    label = &quot;Assemble flow&quot;;
    node [style=filled,color=white]; user, asmParser, encoder, elfobj;
    user -&gt; asmParser [ label = &quot;cpu0 assembly&quot; ];
    asmParser -&gt; encoder [ label = &quot;opcode ID &amp; operand IDs&quot; ];
    encoder -&gt; elfobj [ label = &quot;binary&quot; ];
    color=lightgrey
  }
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 53 </span><span class="caption-text">Assembly flow</span><a class="headerlink" href="#id4" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-default" id="id5">
<span id="asm-f2"></span><div class="graphviz"><img src="_images/graphviz-9e04112f609361c035e611beec163b0e5f7e0c9c.png" alt="// Free usage license, author: Chung-Shu Chen 陳鍾樞
// dot -Tpng asmDfdEx.gv -oasmDfdEx.png

digraph G {
  rankdir=LR;
  subgraph cluster_2 {
    style=filled;
//    label = &quot;Assemble flow, for instance: add $v1, $v0, $at&quot;;
    subgraph clusterA {
      label = &quot;asmParser&quot;;
      node [style=filled,color=white]; ParseInstruction [label=&quot;ParseInstruction()&quot;];
      node [style=filled,color=white]; MatchAndEmitInstruction [label=&quot;MatchAndEmitInstruction()&quot;];
      ParseInstruction -&gt; MatchAndEmitInstruction [ label = &quot;Operands:\n (Cpu0::ADD, Cpu0::V1,\n Cpu0::AT, Cpu0::V0)&quot; ];
    }
    subgraph clusterB {
      label = &quot;encoder: Cpu0MCCodeEmitter.cpp&quot;;
      node [style=filled,color=white]; encodeInstruction [label=&quot;encodeInstruction()&quot;];
    }
    MatchAndEmitInstruction -&gt; encodeInstruction [ label = &quot;Inst.Opcode=\nCpu0::ADD,\nInst.Operand[0] = V1,\nInst.Operand[1] = AT,\nInst.Operand[2] = V0&quot; ];
    color=lightgrey
  }
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 54 </span><span class="caption-text">Assembly flow, for instance: add $v1, $v0, $at</span><a class="headerlink" href="#id5" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Given an example assembly instruction <cite>add $v1, $v0, $at</cite>, the LLVM AsmParser
core calls the backend <cite>ParseInstruction()</cite> function in <cite>Cpu0AsmParser.cpp</cite>
when it detects that the first token at the beginning of the line is an
identifier.</p>
<p><cite>ParseInstruction()</cite> parses a single assembly instruction, creates the operand
objects, and returns them to the LLVM AsmParser. Then, the AsmParser calls the
backend <cite>MatchAndEmitInstruction()</cite> function to assign the opcode and operands
to an <cite>MCInst</cite>. The encoder then encodes the binary instruction from the <cite>MCInst</cite>
using information from <cite>Cpu0InstrInfo.td</cite>, which includes the binary values for
the opcode ID and operand IDs of the instruction.</p>
<p>Below is a list of the key functions and data structures in
<cite>MatchAndEmitInstruction()</cite> and <cite>encodeInstruction()</cite>, with explanations provided
in comments beginning with <cite>///</cite>.</p>
<p class="rubric">llvm/build/lib/Target/Cpu0/Cpu0GenAsmMatcher.inc</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="nc">InstructionConversionKind</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Convert__Reg1_0__Reg1_1__Reg1_2</span><span class="p">,</span>
<span class="w">  </span><span class="n">Convert__Reg1_0__Reg1_1__Imm1_2</span><span class="p">,</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="n">CVT_NUM_SIGNATURES</span>
<span class="p">};</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// end anonymous namespace</span>

<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">MatchEntry</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">Mnemonic</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">Opcode</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">ConvertFn</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">RequiredFeatures</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">Classes</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="w">    </span><span class="n">StringRef</span><span class="w"> </span><span class="nf">getMnemonic</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">StringRef</span><span class="p">(</span><span class="n">MnemonicTable</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Mnemonic</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">                       </span><span class="n">MnemonicTable</span><span class="p">[</span><span class="n">Mnemonic</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">MatchEntry</span><span class="w"> </span><span class="n">MatchTable0</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="cm">/* add */</span><span class="p">,</span><span class="w"> </span><span class="n">Cpu0</span><span class="o">::</span><span class="n">ADD</span><span class="p">,</span><span class="w"> </span><span class="n">Convert__Reg1_0__Reg1_1__Reg1_2</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">MCK_CPURegs</span><span class="p">,</span><span class="w"> </span><span class="n">MCK_CPURegs</span><span class="p">,</span><span class="w"> </span><span class="n">MCK_CPURegs</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="cm">/* addiu */</span><span class="p">,</span><span class="w"> </span><span class="n">Cpu0</span><span class="o">::</span><span class="n">ADDiu</span><span class="p">,</span><span class="w"> </span><span class="n">Convert__Reg1_0__Reg1_1__Imm1_2</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">MCK_CPURegs</span><span class="p">,</span><span class="w"> </span><span class="n">MCK_CPURegs</span><span class="p">,</span><span class="w"> </span><span class="n">MCK_Imm</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">};</span>

<span class="kt">unsigned</span><span class="w"> </span><span class="n">Cpu0AsmParser</span><span class="o">::</span>
<span class="nf">MatchInstructionImpl</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">OperandVector</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Operands</span><span class="p">,</span>
<span class="w">                     </span><span class="n">MCInst</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ErrorInfo</span><span class="p">,</span>
<span class="w">                     </span><span class="kt">bool</span><span class="w"> </span><span class="n">matchingInlineAsm</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">VariantID</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="c1">// Find the appropriate table for this asm variant.</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">MatchEntry</span><span class="w"> </span><span class="o">*</span><span class="n">Start</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">End</span><span class="p">;</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">VariantID</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">default</span><span class="o">:</span><span class="w"> </span><span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;invalid variant!&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">0</span><span class="p">:</span><span class="w"> </span><span class="n">Start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">MatchTable0</span><span class="p">);</span><span class="w"> </span><span class="n">End</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">MatchTable0</span><span class="p">);</span><span class="w"> </span><span class="k">break</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// Search the table.</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">MnemonicRange</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">equal_range</span><span class="p">(</span><span class="n">Start</span><span class="p">,</span><span class="w"> </span><span class="n">End</span><span class="p">,</span><span class="w"> </span><span class="n">Mnemonic</span><span class="p">,</span><span class="w"> </span><span class="n">LessOpcode</span><span class="p">());</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MatchEntry</span><span class="w"> </span><span class="o">*</span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MnemonicRange</span><span class="p">.</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">ie</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MnemonicRange</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
<span class="w">       </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">ie</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="c1">// We have selected a definite instruction, convert the parsed</span>
<span class="w">    </span><span class="c1">// operands into the appropriate MCInst.</span>

<span class="w">    </span><span class="c1">/// For instance ADD , V1, AT, V0</span>
<span class="w">    </span><span class="c1">/// MnemonicRange.first = &amp;MatchTable0[0]</span>
<span class="w">    </span><span class="c1">/// MnemonicRange.second = &amp;MatchTable0[1]</span>
<span class="w">    </span><span class="c1">/// it.ConvertFn = Convert__Reg1_0__Reg1_1__Reg1_2</span>

<span class="w">    </span><span class="n">convertToMCInst</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">ConvertFn</span><span class="p">,</span><span class="w"> </span><span class="n">Inst</span><span class="p">,</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">Opcode</span><span class="p">,</span><span class="w"> </span><span class="n">Operands</span><span class="p">);</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">ConversionTable</span><span class="p">[</span><span class="n">CVT_NUM_SIGNATURES</span><span class="p">][</span><span class="mi">9</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Convert__Reg1_0__Reg1_1__Reg1_2</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">CVT_95_Reg</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">CVT_95_Reg</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">CVT_95_Reg</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">CVT_Done</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="c1">// Convert__Reg1_0__Reg1_1__Imm1_2</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">CVT_95_Reg</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">CVT_95_Reg</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">CVT_95_addImmOperands</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">CVT_Done</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">};</span>

<span class="c1">/// When kind = Convert__Reg1_0__Reg1_1__Reg1_2, ConversionTable[Kind] is equal to CVT_95_Reg</span>
<span class="c1">/// For Operands[1], Operands[2], Operands[3] do the following:</span>
<span class="c1">///   static_cast&lt;Cpu0Operand&amp;&gt;(*Operands[OpIdx]).addRegOperands(Inst, 1);</span>
<span class="c1">/// Since p = 0, 2, 4, then OpIdx = 1, 2, 3 when OpIdx=*(p+1).</span>
<span class="c1">/// Since, Operands[1] = V1, Operands[2] = AT, Operands[3] = V0,</span>
<span class="c1">///   for &quot;ADD , V1, AT, V0&quot; which created by ParseInstruction().</span>
<span class="c1">/// Inst.Opcode = ADD, Inst.Operand[0] = V1, Inst.Operand[1] = AT,</span>
<span class="c1">///   Inst.Operand[2] = V0.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">Cpu0AsmParser</span><span class="o">::</span>
<span class="nf">convertToMCInst</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">Kind</span><span class="p">,</span><span class="w"> </span><span class="n">MCInst</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">Opcode</span><span class="p">,</span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="n">OperandVector</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Operands</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">Kind</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">CVT_NUM_SIGNATURES</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="s">&quot;Invalid signature!&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">Converter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ConversionTable</span><span class="p">[</span><span class="n">Kind</span><span class="p">];</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">OpIdx</span><span class="p">;</span>
<span class="w">  </span><span class="n">Inst</span><span class="p">.</span><span class="n">setOpcode</span><span class="p">(</span><span class="n">Opcode</span><span class="p">);</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Converter</span><span class="p">;</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span><span class="w"> </span><span class="n">p</span><span class="o">+=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">OpIdx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">default</span><span class="o">:</span><span class="w"> </span><span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;invalid conversion entry!&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">CVT_Reg</span><span class="p">:</span>
<span class="w">      </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Cpu0Operand</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">Operands</span><span class="p">[</span><span class="n">OpIdx</span><span class="p">]).</span><span class="n">addRegOperands</span><span class="p">(</span><span class="n">Inst</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_1/AsmParser/Cpu0AsmParser.cpp</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// For &quot;ADD , V1, AT, V0&quot;, ParseInstruction() set Operands[1].Reg.RegNum = V1,</span>
<span class="c1">///   Operands[2].Reg.RegNum = AT, ..., by Cpu0Operand::CreateReg(RegNo, S,</span>
<span class="c1">///   Parser.getTok().getLoc()) in calling ParseOperand().</span>
<span class="c1">/// So, after (*Operands[1..3]).addRegOperands(Inst, 1),</span>
<span class="c1">///   Inst.Opcode = ADD, Inst.Operand[0] = V1, Inst.Operand[1] = AT,</span>
<span class="c1">///   Inst.Operand[2] = V0.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Cpu0Operand</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">MCParsedAsmOperand</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">addRegOperands</span><span class="p">(</span><span class="n">MCInst</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">N</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="s">&quot;Invalid number of operands!&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">Inst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">createReg</span><span class="p">(</span><span class="n">getReg</span><span class="p">()));</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">getReg</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">assert</span><span class="p">((</span><span class="n">Kind</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">k_Register</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="s">&quot;Invalid access!&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Reg</span><span class="p">.</span><span class="n">RegNum</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_1/MCTargetDesc/Cpu0MCCodeEmitter.cpp</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="n">Cpu0MCCodeEmitter</span><span class="o">::</span>
<span class="nf">encodeInstruction</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MCInst</span><span class="w"> </span><span class="o">&amp;</span><span class="n">MI</span><span class="p">,</span><span class="w"> </span><span class="n">raw_ostream</span><span class="w"> </span><span class="o">&amp;</span><span class="n">OS</span><span class="p">,</span>
<span class="w">                  </span><span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCFixup</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Fixups</span><span class="p">,</span>
<span class="w">                  </span><span class="k">const</span><span class="w"> </span><span class="n">MCSubtargetInfo</span><span class="w"> </span><span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">Binary</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getBinaryCodeForInstr</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span><span class="w"> </span><span class="n">Fixups</span><span class="p">,</span><span class="w"> </span><span class="n">STI</span><span class="p">);</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="n">EmitInstruction</span><span class="p">(</span><span class="n">Binary</span><span class="p">,</span><span class="w"> </span><span class="n">Size</span><span class="p">,</span><span class="w"> </span><span class="n">OS</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">llvm/build/lib/Target/Cpu0/Cpu0GenMCCodeEmitter.inc</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">uint64_t</span><span class="w"> </span><span class="nf">Cpu0MCCodeEmitter::getBinaryCodeForInstr</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MCInst</span><span class="w"> </span><span class="o">&amp;</span><span class="n">MI</span><span class="p">,</span>
<span class="w">    </span><span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCFixup</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Fixups</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">MCSubtargetInfo</span><span class="w"> </span><span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">InstBits</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="n">UINT64_C</span><span class="p">(</span><span class="mi">318767104</span><span class="p">),</span><span class="w">      </span><span class="c1">// ADD  /// 318767104=0x13000000</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">  </span><span class="p">};</span>
<span class="w">  </span><span class="p">...</span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">opcode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MI</span><span class="p">.</span><span class="n">getOpcode</span><span class="p">();</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">opcode</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">Cpu0</span><span class="o">::</span><span class="no">ADD</span><span class="p">:</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">      </span><span class="c1">// op: ra</span>
<span class="w">      </span><span class="n">op</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getMachineOpValue</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span><span class="w"> </span><span class="n">MI</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">Fixups</span><span class="p">,</span><span class="w"> </span><span class="n">STI</span><span class="p">);</span>
<span class="w">      </span><span class="n">Value</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="p">(</span><span class="n">op</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">UINT64_C</span><span class="p">(</span><span class="mi">15</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span>
<span class="w">      </span><span class="c1">// op: rb</span>
<span class="w">      </span><span class="n">op</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getMachineOpValue</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span><span class="w"> </span><span class="n">MI</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">Fixups</span><span class="p">,</span><span class="w"> </span><span class="n">STI</span><span class="p">);</span>
<span class="w">      </span><span class="n">Value</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="p">(</span><span class="n">op</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">UINT64_C</span><span class="p">(</span><span class="mi">15</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>
<span class="w">      </span><span class="c1">// op: rc</span>
<span class="w">      </span><span class="n">op</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getMachineOpValue</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span><span class="w"> </span><span class="n">MI</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="n">Fixups</span><span class="p">,</span><span class="w"> </span><span class="n">STI</span><span class="p">);</span>
<span class="w">      </span><span class="n">Value</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="p">(</span><span class="n">op</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">UINT64_C</span><span class="p">(</span><span class="mi">15</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">12</span><span class="p">;</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">Value</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<figure class="align-default" id="id6">
<span id="asm-f3"></span><div class="graphviz"><img src="_images/graphviz-2889935ba11aad6060cc2ae79fe4fa1df1e9898d.png" alt="// Free usage license, author: Chung-Shu Chen 陳鍾樞
// dot -Tpng asmDfdEx2.gv -oasmDfdEx2.png

digraph G {
  rankdir=LR;
  subgraph cluster_2 {
    style=filled;
//    label = &quot;Data flow in MatchAndEmitInstruction(), for instance: add $v1, $v0, $at&quot;;
    subgraph clusterA {
      label = &quot;MatchAndEmitInstruction()&quot;;
      node [style=filled,color=white]; MatchTable0 [label=&quot;Start = std::\nbegin(MatchTable0);\nEnd = std::end\n(MatchTable0);&quot;];
      node [style=filled,color=white]; equal_range [label=&quot;std::equal_range(Start, End, \nMnemonic, LessOpcode());&quot;];
      node [style=filled,color=white]; convertToMCInst [label=&quot;convertToMCInst\n(Kind, ...)&quot;];
      MatchTable0 -&gt; equal_range [ label = &quot;Start,\nEnd&quot; ];
      equal_range -&gt; convertToMCInst [ label = &quot;Kind=\nConvert__Reg1_0__\nReg1_1__Reg1_2&quot; ];
    }
    color=lightgrey
  }
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 55 </span><span class="caption-text">Data flow in MatchAndEmitInstruction(), for instance: add $v1,
$v0, $at”</span><a class="headerlink" href="#id6" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-default" id="id7">
<span id="asm-f4"></span><div class="graphviz"><img src="_images/graphviz-94a291c09f4209233b3a490219186a2d0496d7b8.png" alt="// Free usage license, author: Chung-Shu Chen 陳鍾樞
// dot -Tpng asmDfdEx3.gv -oasmDfdEx3.png

digraph G {
  rankdir=LR;
  subgraph cluster_2 {
    style=filled;
//    label = &quot;Data flow in and between MatchAndEmitInstruction() and encodeInstruction(), for instance: add $v1, $v0, $at&quot;;
    subgraph clusterA {
      label = &quot;MatchAndEmitInstruction()&quot;;
      node [style=filled,color=white]; convertToMCInst [label=&quot;convertToMCInst()&quot;];
    }
    subgraph clusterB {
      label = &quot;encodeInstruction()&quot;;
      node [style=filled,color=white]; getBinaryCodeForInstr [label=&quot;getBinaryCodeForInstr()&quot;];
      node [style=filled,color=white]; EmitInstruction [label=&quot;EmitInstruction()&quot;];
      getBinaryCodeForInstr -&gt; EmitInstruction [ label = &quot;Binary&quot; ];
    }
    convertToMCInst -&gt; getBinaryCodeForInstr [ label = &quot;Inst.Opcode = ADD,\nInst.Operand[0] = V1,\nInst.Operand[1] = AT,\nInst.Operand[2] = V0&quot; ];
    color=lightgrey
  }
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 56 </span><span class="caption-text">Data flow between MatchAndEmitInstruction() and encodeInstruction(),
for instance: add $v1, $v0, $at</span><a class="headerlink" href="#id7" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p><cite>MatchTable0</cite> includes all possible combinations of opcodes and operand types.</p>
<p>Even if a user’s assembly instruction passes the syntax check in
<cite>Cpu0AsmParser</cite>, <cite>MatchAndEmitInstruction()</cite> can still fail. For example, the
instruction <cite>asm(“move $3, $2”);</cite> may succeed, but <cite>asm(“move $3, $2, $1”);</cite>
will fail.</p>
<p>The flow of function calls for <cite>Cpu0AsmParser</cite> is shown in <a class="reference internal" href="#asm-flow"><span class="std std-numref">Fig. 57</span></a>.</p>
<figure class="align-default" id="id8">
<span id="asm-flow"></span><div class="graphviz"><img src="_images/graphviz-37324607cc14116e970c4de177039d205034ea87.png" alt="digraph G {
  rankdir=TB;
  &quot;parseStatement()&quot; -&gt; &quot;ParseInstruction()&quot; [label=&quot;1. OpcodeStr&quot;];
  &quot;ParseInstruction()&quot; -&gt; &quot;parseStatement()&quot; [label=&quot;Info.ParseOperands&quot;];
  &quot;parseStatement()&quot; -&gt; &quot;MatchAndEmitInstruction()&quot; [label=&quot;2. Info.ParsedOperands&quot;];
  &quot;MatchAndEmitInstruction()&quot; -&gt; &quot;MatchInstructionImpl()&quot;;
  &quot;ParseInstruction()&quot; -&gt; &quot;ParseOperand()&quot; [label=&quot;OpcodeStr&quot;];
  &quot;ParseOperand()&quot; -&gt; &quot;ParseInstruction()&quot; [label=&quot;Operands&quot;];
  &quot;ParseOperand()&quot; -&gt; &quot;MatchOperandParserImpl()&quot;;
  &quot;MatchAndEmitInstruction()&quot; -&gt; &quot;MCObjectStreamer::emitInstruction()&quot; [label=&quot;MCInst&quot;];
  subgraph clusterAsm {
    label = &quot;/lib/MC/MCParser/AsmParser.cpp&quot;;
    &quot;parseStatement()&quot;;
  }
  subgraph clusterCpu0Asm {
    label = &quot;Cpu0AsmParser.cpp&quot;;
    &quot;MatchAndEmitInstruction()&quot;;
    &quot;ParseOperand()&quot;;
    &quot;ParseInstruction()&quot;;
  }
  subgraph clusterAsmParserInc {
    label = &quot;Cpu0GenAsmMatcher.inc&quot;;
    &quot;MatchInstructionImpl()&quot;;
    &quot;MatchOperandParserImpl()&quot;;
    &quot;convertToMapAndConstraints()&quot;;
    &quot;tryCustomParseOperand()&quot;;
    &quot;MatchInstructionImpl()&quot; -&gt; &quot;convertToMapAndConstraints()&quot;;
    &quot;MatchOperandParserImpl()&quot; -&gt; &quot;tryCustomParseOperand()&quot;;
  }
  subgraph clusterObj {
    label = &quot;lib/MC/MCObjectStreamer.cpp&quot;;
    &quot;MCObjectStreamer::emitInstruction()&quot;;
  }
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 57 </span><span class="caption-text">Flow of calling functions for Cpu0AsmParser.</span><a class="headerlink" href="#id8" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<ul class="simple">
<li><p>After <cite>ParseInstruction()</cite> and <cite>MatchAndEmitInstruction()</cite> are called, an
<cite>MCInst</cite> object is produced.</p>
<ul>
<li><p>In <cite>MatchAndEmitInstruction()</cite>, the assembler calls
<cite>MCObjectStreamer::emitInstruction()</cite> to encode the instruction into binary.
See <a class="reference internal" href="genobj.html#genobj-f11"><span class="std std-numref">Fig. 33</span></a> for reference.</p></li>
</ul>
</li>
<li><p>Run <cite>llc</cite> with the option <cite>-debug</cite> or
<cite>-debug-only=asm-matcher,cpu0-asm-parser</cite> to display debug messages and trace
the assembler flow, as shown below.</p></li>
<li><p>For Cpu0, only memory operands (used in L-type or J-type instructions) will
trigger a call to <cite>tryCustomParseOperand()</cite>.</p></li>
</ul>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">input % ~/llvm/test/build/bin/clang -target mips-unknown-linux-gnu -c</span>
<span class="go">ch11_1.cpp -emit-llvm -o ch11_1.bc</span>
<span class="go">input % ~/llvm/test/build/bin/llc -march=cpu0 -relocation-model=pic</span>
<span class="go">-filetype=obj -debug-only=asm-matcher,cpu0-asm-parser ch11_1.bc -o</span>
<span class="go">ch11_1.cpu0.o</span>

<span class="go">ParseOperand</span>
<span class="go">.. Generic Parser</span>
<span class="go">ParseOperand</span>
<span class="go">&lt;ld&gt;&lt;Register&lt;19&gt;&gt;&lt;Mem&lt;9, 8&gt;&gt;</span>
<span class="go">AsmMatcher: found 1 encodings with mnemonic &#39;ld&#39;</span>
<span class="go">Trying to match opcode LD</span>
<span class="go">  Matching formal operand class MCK_CPURegs against actual operand at index 1</span>
<span class="go">  (Register&lt;19&gt;): match success using generic matcher</span>
<span class="go">  Matching formal operand class MCK_Mem against actual operand at index 2</span>
<span class="go">  (Mem&lt;9, 8&gt;): match success using generic matcher</span>
<span class="go">  Matching formal operand class InvalidMatchClass against actual operand at</span>
<span class="go">  index 3: actual operand index out of range Opcode result: complete match,</span>
<span class="go">  selecting this opcode</span>
</pre></div>
</div>
<p>The other functions in <cite>Cpu0AsmParser</cite> are called in the following flow:</p>
<ul class="simple">
<li><p><cite>ParseDirective()</cite>
→ <cite>parseDirectiveSet()</cite>
→ <cite>parseSetReorderDirective()</cite>,
<cite>parseSetNoReorderDirective()</cite>,
<cite>parseSetMacroDirective()</cite>,
<cite>parseSetNoMacroDirective()</cite>
→ <cite>reportParseError()</cite></p></li>
<li><p><cite>ParseInstruction()</cite>
→ <cite>ParseOperand()</cite>
→ <cite>MatchOperandParserImpl()</cite> (in <cite>Cpu0GenAsmMatcher.inc</cite>)
→ <cite>tryCustomParseOperand()</cite> (in <cite>Cpu0GenAsmMatcher.inc</cite>)
→ <cite>parseMemOperand()</cite>
→ <cite>parseMemOffset()</cite>, <cite>tryParseRegisterOperand()</cite></p></li>
<li><p><cite>MatchAndEmitInstruction()</cite>
→ <cite>MatchInstructionImpl()</cite> (in <cite>Cpu0GenAsmMatcher.inc</cite>)
→ <cite>needsExpansion()</cite>
→ <cite>expandInstruction()</cite></p></li>
<li><p><cite>parseMemOffset()</cite>
→ <cite>parseRelocOperand()</cite>
→ <cite>getVariantKind()</cite></p></li>
<li><p><cite>tryParseRegisterOperand()</cite>
→ <cite>tryParseRegister()</cite>
→ <cite>matchRegisterName()</cite>
→ <cite>getReg()</cite>, <cite>matchRegisterByNumber()</cite></p></li>
<li><p><cite>expandInstruction()</cite>
→ <cite>expandLoadImm()</cite>, <cite>expandLoadAddressImm()</cite>, <cite>expandLoadAddressReg()</cite>
→ <cite>EmitInstruction()</cite> (in <cite>Cpu0AsmPrint.cpp</cite>)</p></li>
</ul>
</section>
<section id="inline-assembly">
<h2><a class="toc-backref" href="#id12" role="doc-backlink">Inline assembly</a><a class="headerlink" href="#inline-assembly" title="Link to this heading">¶</a></h2>
<p>Run Chapter11_1 with ch11_2 will get the following error.</p>
<p class="rubric">lbdex/input/ch11_2.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="s2">&quot;C&quot;</span> <span class="nb">int</span> <span class="n">printf</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="nb">format</span><span class="p">,</span> <span class="o">...</span><span class="p">);</span>
<span class="nb">int</span> <span class="n">inlineasm_addu</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">foo</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="n">const</span> <span class="nb">int</span> <span class="n">bar</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>

<span class="o">//</span>  <span class="n">call</span> <span class="n">i32</span> <span class="n">asm</span> <span class="n">sideeffect</span> <span class="s2">&quot;addu $0,$1,$2&quot;</span><span class="p">,</span> <span class="s2">&quot;=r,r,r&quot;</span><span class="p">(</span><span class="n">i32</span> <span class="o">%</span><span class="mi">1</span><span class="p">,</span> <span class="n">i32</span> <span class="o">%</span><span class="mi">2</span><span class="p">)</span> <span class="c1">#1, !srcloc !1</span>
  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s2">&quot;addu %0,%1,%2&quot;</span>
                       <span class="p">:</span><span class="s2">&quot;=r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="o">//</span> <span class="mi">5</span>
                       <span class="p">:</span><span class="s2">&quot;r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span> <span class="s2">&quot;r&quot;</span><span class="p">(</span><span class="n">bar</span><span class="p">)</span>
                       <span class="p">);</span>

  <span class="k">return</span> <span class="n">foo</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">inlineasm_longlong</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">long</span> <span class="n">long</span> <span class="n">bar</span> <span class="o">=</span> <span class="mh">0x0000000500000006</span><span class="p">;</span>
  <span class="nb">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">bar</span><span class="p">;</span>
<span class="o">//</span>  <span class="nb">int</span><span class="o">*</span> <span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="o">//</span> <span class="n">Do</span> <span class="ow">not</span> <span class="nb">set</span> <span class="n">q</span> <span class="n">here</span><span class="o">.</span>

<span class="o">//</span>  <span class="n">call</span> <span class="n">i32</span> <span class="n">asm</span> <span class="n">sideeffect</span> <span class="s2">&quot;ld $0,$1&quot;</span><span class="p">,</span> <span class="s2">&quot;=r,*m&quot;</span><span class="p">(</span><span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="mi">2</span><span class="p">)</span> <span class="c1">#2, !srcloc !2</span>
  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s2">&quot;ld %0,%1&quot;</span>
                       <span class="p">:</span><span class="s2">&quot;=r&quot;</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">//</span> <span class="mh">0x700070007000700b</span>
                       <span class="p">:</span><span class="s2">&quot;m&quot;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span>
                       <span class="p">);</span>
  <span class="nb">int</span><span class="o">*</span> <span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="o">//</span> <span class="n">Set</span> <span class="n">q</span> <span class="n">just</span> <span class="n">before</span> <span class="n">inline</span> <span class="n">asm</span> <span class="n">refer</span> <span class="n">to</span> <span class="n">avoid</span> <span class="n">register</span> <span class="n">clobbered</span><span class="o">.</span> 
<span class="o">//</span>  <span class="n">call</span> <span class="n">i32</span> <span class="n">asm</span> <span class="n">sideeffect</span> <span class="s2">&quot;ld $0,$1&quot;</span><span class="p">,</span> <span class="s2">&quot;=r,*m&quot;</span><span class="p">(</span><span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="mi">6</span><span class="p">)</span> <span class="c1">#2, !srcloc !3</span>
  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s2">&quot;ld %0,%1&quot;</span>
                       <span class="p">:</span><span class="s2">&quot;=r&quot;</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">//</span> <span class="mi">11</span>
                       <span class="p">:</span><span class="s2">&quot;m&quot;</span><span class="p">(</span><span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="o">//</span>              <span class="n">Or</span> <span class="n">use</span> <span class="p">:</span><span class="s2">&quot;m&quot;</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="n">to</span> <span class="n">avoid</span> <span class="n">register</span> <span class="n">clobbered</span><span class="o">.</span> 
                       <span class="p">);</span>

  <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">inlineasm_constraint</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">foo</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="n">const</span> <span class="nb">int</span> <span class="n">n_5</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span><span class="p">;</span>
  <span class="n">const</span> <span class="nb">int</span> <span class="n">n5</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="n">const</span> <span class="nb">int</span> <span class="n">n0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">un5</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="n">const</span> <span class="nb">int</span> <span class="n">n65536</span> <span class="o">=</span> <span class="mh">0x10000</span><span class="p">;</span>
  <span class="n">const</span> <span class="nb">int</span> <span class="n">n_65531</span> <span class="o">=</span> <span class="o">-</span><span class="mi">65531</span><span class="p">;</span>

<span class="o">//</span>   <span class="n">call</span> <span class="n">i32</span> <span class="n">asm</span> <span class="n">sideeffect</span> <span class="s2">&quot;addiu $0,$1,$2&quot;</span><span class="p">,</span> <span class="s2">&quot;=r,r,I&quot;</span><span class="p">(</span><span class="n">i32</span> <span class="o">%</span><span class="mi">1</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">15</span><span class="p">)</span> <span class="c1">#1, !srcloc !2</span>
  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s2">&quot;addiu %0,%1,%2&quot;</span>
                       <span class="p">:</span><span class="s2">&quot;=r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="o">//</span> <span class="mi">15</span>
                       <span class="p">:</span><span class="s2">&quot;r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span> <span class="s2">&quot;I&quot;</span><span class="p">(</span><span class="n">n_5</span><span class="p">)</span>
                       <span class="p">);</span>

  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s2">&quot;addiu %0,%1,%2&quot;</span>
                       <span class="p">:</span><span class="s2">&quot;=r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="o">//</span> <span class="mi">15</span>
                       <span class="p">:</span><span class="s2">&quot;r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span> <span class="s2">&quot;J&quot;</span><span class="p">(</span><span class="n">n0</span><span class="p">)</span>
                       <span class="p">);</span>

  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s2">&quot;addiu %0,%1,%2&quot;</span>
                       <span class="p">:</span><span class="s2">&quot;=r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="o">//</span> <span class="mi">10</span>
                       <span class="p">:</span><span class="s2">&quot;r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span> <span class="s2">&quot;K&quot;</span><span class="p">(</span><span class="n">n5</span><span class="p">)</span>
                       <span class="p">);</span>

  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s2">&quot;ori %0,%1,%2&quot;</span>
                       <span class="p">:</span><span class="s2">&quot;=r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="o">//</span> <span class="mi">10</span>
                       <span class="p">:</span><span class="s2">&quot;r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span> <span class="s2">&quot;L&quot;</span><span class="p">(</span><span class="n">n65536</span><span class="p">)</span> <span class="o">//</span> <span class="mh">0x10000</span> <span class="o">=</span> <span class="mi">65536</span>
                       <span class="p">);</span>

  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s2">&quot;addiu %0,%1,%2&quot;</span>
                       <span class="p">:</span><span class="s2">&quot;=r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="o">//</span> <span class="mi">15</span>
                       <span class="p">:</span><span class="s2">&quot;r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span> <span class="s2">&quot;N&quot;</span><span class="p">(</span><span class="n">n_65531</span><span class="p">)</span>
                       <span class="p">);</span>

  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s2">&quot;addiu %0,%1,%2&quot;</span>
                       <span class="p">:</span><span class="s2">&quot;=r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="o">//</span> <span class="mi">10</span>
                       <span class="p">:</span><span class="s2">&quot;r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span> <span class="s2">&quot;O&quot;</span><span class="p">(</span><span class="n">n_5</span><span class="p">)</span>
                       <span class="p">);</span>

  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s2">&quot;addiu %0,%1,%2&quot;</span>
                       <span class="p">:</span><span class="s2">&quot;=r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="o">//</span> <span class="mi">15</span>
                       <span class="p">:</span><span class="s2">&quot;r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span> <span class="s2">&quot;P&quot;</span><span class="p">(</span><span class="n">un5</span><span class="p">)</span>
                       <span class="p">);</span>

  <span class="k">return</span> <span class="n">foo</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">inlineasm_arg</span><span class="p">(</span><span class="nb">int</span> <span class="n">u</span><span class="p">,</span> <span class="nb">int</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">w</span><span class="p">;</span>

  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s2">&quot;subu %0,%1,%2&quot;</span>
                       <span class="p">:</span><span class="s2">&quot;=r&quot;</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                       <span class="p">:</span><span class="s2">&quot;r&quot;</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="s2">&quot;r&quot;</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                       <span class="p">);</span>

  <span class="k">return</span> <span class="n">w</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">g</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span>

<span class="nb">int</span> <span class="n">inlineasm_global</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">;</span>
  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s2">&quot;ld %0,%1&quot;</span>
                       <span class="p">:</span><span class="s2">&quot;=r&quot;</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">//</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span>
                       <span class="p">:</span><span class="s2">&quot;m&quot;</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                       <span class="p">);</span>

  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s2">&quot;addiu %0,%1,1&quot;</span>
                       <span class="p">:</span><span class="s2">&quot;=r&quot;</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">//</span> <span class="n">d</span><span class="o">=</span><span class="mi">4</span>
                       <span class="p">:</span><span class="s2">&quot;r&quot;</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                       <span class="p">);</span>

  <span class="k">return</span> <span class="n">d</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">#ifdef TESTSOFTFLOATLIB</span>
<span class="o">//</span> <span class="n">test_float</span><span class="p">()</span> <span class="n">will</span> <span class="n">call</span> <span class="n">soft</span> <span class="nb">float</span> <span class="n">library</span>
<span class="nb">int</span> <span class="n">inlineasm_float</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">float</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">2.2</span><span class="p">;</span>
  <span class="nb">float</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">3.3</span><span class="p">;</span>
  
  <span class="nb">int</span> <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">);</span>

  <span class="nb">int</span> <span class="n">d</span><span class="p">;</span>
  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s2">&quot;addiu %0,%1,1&quot;</span>
                       <span class="p">:</span><span class="s2">&quot;=r&quot;</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                       <span class="p">:</span><span class="s2">&quot;r&quot;</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                       <span class="p">);</span>

  <span class="k">return</span> <span class="n">d</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">#endif</span>

<span class="nb">int</span> <span class="n">test_inlineasm</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">;</span>

  <span class="n">a</span> <span class="o">=</span> <span class="n">inlineasm_addu</span><span class="p">();</span> <span class="o">//</span> <span class="mi">25</span>
  <span class="n">b</span> <span class="o">=</span> <span class="n">inlineasm_longlong</span><span class="p">();</span> <span class="o">//</span> <span class="mi">11</span>
  <span class="n">c</span> <span class="o">=</span> <span class="n">inlineasm_constraint</span><span class="p">();</span> <span class="o">//</span> <span class="mi">15</span>
  <span class="n">d</span> <span class="o">=</span> <span class="n">inlineasm_arg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span> <span class="o">//</span> <span class="o">-</span><span class="mi">9</span>
  <span class="n">e</span> <span class="o">=</span> <span class="n">inlineasm_arg</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="o">//</span> <span class="mi">3</span>
  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s2">&quot;addiu %0,%1,1&quot;</span>
                       <span class="p">:</span><span class="s2">&quot;=r&quot;</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">//</span> <span class="n">e</span><span class="o">=</span><span class="mi">4</span>
                       <span class="p">:</span><span class="s2">&quot;r&quot;</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                       <span class="p">);</span>

  <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="n">c</span><span class="o">+</span><span class="n">d</span><span class="o">+</span><span class="n">e</span><span class="o">+</span><span class="n">f</span><span class="p">);</span> <span class="o">//</span> <span class="mi">25</span><span class="o">+</span><span class="mi">11</span><span class="o">+</span><span class="mi">15</span><span class="o">-</span><span class="mi">9</span><span class="o">+</span><span class="mi">3</span><span class="o">+</span><span class="mi">4</span><span class="o">=</span><span class="mi">49</span>
<span class="p">}</span>

</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">1-160-129-73:input Jonathan$ </span>~/llvm/test/build/bin/llc
<span class="go">-march=cpu0 -relocation-model=static -filetype=asm ch11_2.bc -o -</span>
<span class="go">  .section .mdebug.abi32</span>
<span class="go">  .previous</span>
<span class="go">  .file &quot;ch11_2.bc&quot;</span>
<span class="go">error: couldn&#39;t allocate output register for constraint &#39;r&#39;</span>
</pre></div>
</div>
<p>The <cite>ch11_2.cpp</cite> file is an inline assembly example. Clang supports inline
assembly similarly to GCC.</p>
<p>Inline assembly is used in C/C++ when a program needs to access a specific
allocated register or memory location for a C/C++ variable. For example, the
variable <cite>foo</cite> in <cite>ch11_2.cpp</cite> may be allocated by the compiler to register <cite>$2</cite>,
<cite>$3</cite>, or another register.</p>
<p>Inline assembly helps bridge the gap between high-level languages and assembly
language. See reference <a class="footnote-reference brackets" href="#inlineas" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>.</p>
<p><cite>Chapter11_2</cite> adds support for inline assembly as follows:</p>
<p class="rubric">lbdex/chapters/Chapter11_2/Cpu0AsmPrinter.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="nb">bool</span> <span class="n">PrintAsmOperand</span><span class="p">(</span><span class="n">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">OpNo</span><span class="p">,</span>
                       <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">ExtraCode</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">)</span> <span class="n">override</span><span class="p">;</span>
  <span class="nb">bool</span> <span class="n">PrintAsmMemoryOperand</span><span class="p">(</span><span class="n">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">OpNum</span><span class="p">,</span>
                             <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">ExtraCode</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">)</span> <span class="n">override</span><span class="p">;</span>
  <span class="n">void</span> <span class="n">printOperand</span><span class="p">(</span><span class="n">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="nb">int</span> <span class="n">opNum</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_2/Cpu0AsmPrinter.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// Print out an operand for an inline asm expression.
bool Cpu0AsmPrinter::PrintAsmOperand(const MachineInstr *MI, unsigned OpNum,
                                     const char *ExtraCode, raw_ostream &amp;O) {
  // Does this asm operand have a single letter operand modifier?
  if (ExtraCode &amp;&amp; ExtraCode[0]) {
    if (ExtraCode[1] != 0) return true; // Unknown modifier.

    const MachineOperand &amp;MO = MI-&gt;getOperand(OpNum);
    switch (ExtraCode[0]) {
    default:
      // See if this is a generic print operand
      return AsmPrinter::PrintAsmOperand(MI,OpNum, ExtraCode,O);
    case &#39;X&#39;: // hex const int
      if ((MO.getType()) != MachineOperand::MO_Immediate)
        return true;
      O &lt;&lt; &quot;0x&quot; &lt;&lt; StringRef(utohexstr(MO.getImm())).lower();
      return false;
    case &#39;x&#39;: // hex const int (low 16 bits)
      if ((MO.getType()) != MachineOperand::MO_Immediate)
        return true;
      O &lt;&lt; &quot;0x&quot; &lt;&lt; StringRef(utohexstr(MO.getImm() &amp; 0xffff)).lower();
      return false;
    case &#39;d&#39;: // decimal const int
      if ((MO.getType()) != MachineOperand::MO_Immediate)
        return true;
      O &lt;&lt; MO.getImm();
      return false;
    case &#39;m&#39;: // decimal const int minus 1
      if ((MO.getType()) != MachineOperand::MO_Immediate)
        return true;
      O &lt;&lt; MO.getImm() - 1;
      return false;
    case &#39;z&#39;: {
      // $0 if zero, regular printing otherwise
      if (MO.getType() != MachineOperand::MO_Immediate)
        return true;
      int64_t Val = MO.getImm();
      if (Val)
        O &lt;&lt; Val;
      else
        O &lt;&lt; &quot;$0&quot;;
      return false;
    }
    }
  }

  printOperand(MI, OpNum, O);
  return false;
}

bool Cpu0AsmPrinter::PrintAsmMemoryOperand(const MachineInstr *MI,
                                           unsigned OpNum,
                                           const char *ExtraCode,
                                           raw_ostream &amp;O) {
  int Offset = 0;
  // Currently we are expecting either no ExtraCode or &#39;D&#39;
  if (ExtraCode) {
    return true; // Unknown modifier.
  }

  const MachineOperand &amp;MO = MI-&gt;getOperand(OpNum);
  assert(MO.isReg() &amp;&amp; &quot;unexpected inline asm memory operand&quot;);
  O &lt;&lt; Offset &lt;&lt; &quot;($&quot; &lt;&lt; Cpu0InstPrinter::getRegisterName(MO.getReg()) &lt;&lt; &quot;)&quot;;

  return false;
}

void Cpu0AsmPrinter::printOperand(const MachineInstr *MI, int opNum,
                                  raw_ostream &amp;O) {
  const MachineOperand &amp;MO = MI-&gt;getOperand(opNum);
  bool closeP = false;

  if (MO.getTargetFlags())
    closeP = true;

  switch(MO.getTargetFlags()) {
  case Cpu0II::MO_GPREL:    O &lt;&lt; &quot;%gp_rel(&quot;; break;
  case Cpu0II::MO_GOT_CALL: O &lt;&lt; &quot;%call16(&quot;; break;
  case Cpu0II::MO_GOT:      O &lt;&lt; &quot;%got(&quot;;    break;
  case Cpu0II::MO_ABS_HI:   O &lt;&lt; &quot;%hi(&quot;;     break;
  case Cpu0II::MO_ABS_LO:   O &lt;&lt; &quot;%lo(&quot;;     break;
  case Cpu0II::MO_GOT_HI16: O &lt;&lt; &quot;%got_hi16(&quot;; break;
  case Cpu0II::MO_GOT_LO16: O &lt;&lt; &quot;%got_lo16(&quot;; break;
  }

  switch (MO.getType()) {
    case MachineOperand::MO_Register:
      O &lt;&lt; &#39;$&#39;
        &lt;&lt; StringRef(Cpu0InstPrinter::getRegisterName(MO.getReg())).lower();
      break;

    case MachineOperand::MO_Immediate:
      O &lt;&lt; MO.getImm();
      break;

    case MachineOperand::MO_MachineBasicBlock:
      O &lt;&lt; *MO.getMBB()-&gt;getSymbol();
      return;

    case MachineOperand::MO_GlobalAddress:
      O &lt;&lt; *getSymbol(MO.getGlobal());
      break;

    case MachineOperand::MO_BlockAddress: {
      MCSymbol *BA = GetBlockAddressSymbol(MO.getBlockAddress());
      O &lt;&lt; BA-&gt;getName();
      break;
    }

    case MachineOperand::MO_ExternalSymbol:
      O &lt;&lt; *GetExternalSymbolSymbol(MO.getSymbolName());
      break;

    case MachineOperand::MO_JumpTableIndex:
      O &lt;&lt; MAI-&gt;getPrivateGlobalPrefix() &lt;&lt; &quot;JTI&quot; &lt;&lt; getFunctionNumber()
        &lt;&lt; &#39;_&#39; &lt;&lt; MO.getIndex();
      break;

    case MachineOperand::MO_ConstantPoolIndex:
      O &lt;&lt; MAI-&gt;getPrivateGlobalPrefix() &lt;&lt; &quot;CPI&quot;
        &lt;&lt; getFunctionNumber() &lt;&lt; &quot;_&quot; &lt;&lt; MO.getIndex();
      if (MO.getOffset())
        O &lt;&lt; &quot;+&quot; &lt;&lt; MO.getOffset();
      break;

    default:
      llvm_unreachable(&quot;&lt;unknown operand type&gt;&quot;);
  }

  if (closeP) O &lt;&lt; &quot;)&quot;;
}
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_2/Cpu0InstrInfo.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">///</span> <span class="n">Return</span> <span class="n">the</span> <span class="n">number</span> <span class="n">of</span> <span class="nb">bytes</span> <span class="n">of</span> <span class="n">code</span> <span class="n">the</span> <span class="n">specified</span> <span class="n">instruction</span> <span class="n">may</span> <span class="n">be</span><span class="o">.</span>
<span class="n">unsigned</span> <span class="n">Cpu0InstrInfo</span><span class="p">::</span><span class="n">GetInstSizeInBytes</span><span class="p">(</span><span class="n">const</span> <span class="n">MachineInstr</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">case</span>  <span class="n">TargetOpcode</span><span class="p">::</span><span class="n">INLINEASM</span><span class="p">:</span> <span class="p">{</span>       <span class="o">//</span> <span class="n">Inline</span> <span class="n">Asm</span><span class="p">:</span> <span class="n">Variable</span> <span class="n">size</span><span class="o">.</span>
    <span class="n">const</span> <span class="n">MachineFunction</span> <span class="o">*</span><span class="n">MF</span> <span class="o">=</span> <span class="n">MI</span><span class="o">.</span><span class="n">getParent</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">();</span>
    <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">AsmStr</span> <span class="o">=</span> <span class="n">MI</span><span class="o">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">getSymbolName</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">getInlineAsmLength</span><span class="p">(</span><span class="n">AsmStr</span><span class="p">,</span> <span class="o">*</span><span class="n">MF</span><span class="o">-&gt;</span><span class="n">getTarget</span><span class="p">()</span><span class="o">.</span><span class="n">getMCAsmInfo</span><span class="p">());</span>
  <span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_2/Cpu0ISelDAGToDAG.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="nb">bool</span> <span class="n">SelectInlineAsmMemoryOperand</span><span class="p">(</span><span class="n">const</span> <span class="n">SDValue</span> <span class="o">&amp;</span><span class="n">Op</span><span class="p">,</span>
                                    <span class="n">unsigned</span> <span class="n">ConstraintID</span><span class="p">,</span>
                                    <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">OutOps</span><span class="p">)</span> <span class="n">override</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_2/Cpu0ISelDAGToDAG.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">inlineasm</span> <span class="n">begin</span>
<span class="nb">bool</span> <span class="n">Cpu0DAGToDAGISel</span><span class="p">::</span>
<span class="n">SelectInlineAsmMemoryOperand</span><span class="p">(</span><span class="n">const</span> <span class="n">SDValue</span> <span class="o">&amp;</span><span class="n">Op</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">ConstraintID</span><span class="p">,</span>
                             <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">OutOps</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">//</span> <span class="n">All</span> <span class="n">memory</span> <span class="n">constraints</span> <span class="n">can</span> <span class="n">at</span> <span class="n">least</span> <span class="n">accept</span> <span class="n">raw</span> <span class="n">pointers</span><span class="o">.</span>
  <span class="n">switch</span><span class="p">(</span><span class="n">ConstraintID</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">default</span><span class="p">:</span>
    <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s2">&quot;Unexpected asm memory constraint&quot;</span><span class="p">);</span>
  <span class="k">case</span> <span class="n">InlineAsm</span><span class="p">::</span><span class="n">Constraint_m</span><span class="p">:</span>
    <span class="n">OutOps</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Op</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="o">//</span> <span class="n">inlineasm</span> <span class="n">end</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_2/Cpu0ISelLowering.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="o">//</span> <span class="n">Inline</span> <span class="n">asm</span> <span class="n">support</span>
    <span class="n">ConstraintType</span> <span class="n">getConstraintType</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">Constraint</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span><span class="p">;</span>

    <span class="o">///</span> <span class="n">Examine</span> <span class="n">constraint</span> <span class="n">string</span> <span class="ow">and</span> <span class="n">operand</span> <span class="nb">type</span> <span class="ow">and</span> <span class="n">determine</span> <span class="n">a</span> <span class="n">weight</span> <span class="n">value</span><span class="o">.</span>
    <span class="o">///</span> <span class="n">The</span> <span class="n">operand</span> <span class="nb">object</span> <span class="n">must</span> <span class="n">already</span> <span class="n">have</span> <span class="n">been</span> <span class="nb">set</span> <span class="n">up</span> <span class="k">with</span> <span class="n">the</span> <span class="n">operand</span> <span class="nb">type</span><span class="o">.</span>
    <span class="n">ConstraintWeight</span> <span class="n">getSingleConstraintMatchWeight</span><span class="p">(</span>
      <span class="n">AsmOperandInfo</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">constraint</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span><span class="p">;</span>

    <span class="o">///</span> <span class="n">This</span> <span class="n">function</span> <span class="n">parses</span> <span class="n">registers</span> <span class="n">that</span> <span class="n">appear</span> <span class="ow">in</span> <span class="n">inline</span><span class="o">-</span><span class="n">asm</span> <span class="n">constraints</span><span class="o">.</span>
    <span class="o">///</span> <span class="n">It</span> <span class="n">returns</span> <span class="n">pair</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="n">on</span> <span class="n">failure</span><span class="o">.</span>
    <span class="n">std</span><span class="p">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">unsigned</span><span class="p">,</span> <span class="n">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*&gt;</span>
    <span class="n">parseRegForInlineAsmConstraint</span><span class="p">(</span><span class="n">const</span> <span class="n">StringRef</span> <span class="o">&amp;</span><span class="n">C</span><span class="p">,</span> <span class="n">MVT</span> <span class="n">VT</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>

    <span class="n">std</span><span class="p">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">unsigned</span><span class="p">,</span> <span class="n">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*&gt;</span>
    <span class="n">getRegForInlineAsmConstraint</span><span class="p">(</span><span class="n">const</span> <span class="n">TargetRegisterInfo</span> <span class="o">*</span><span class="n">TRI</span><span class="p">,</span>
                                 <span class="n">StringRef</span> <span class="n">Constraint</span><span class="p">,</span> <span class="n">MVT</span> <span class="n">VT</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span><span class="p">;</span>

    <span class="o">///</span> <span class="n">LowerAsmOperandForConstraint</span> <span class="o">-</span> <span class="n">Lower</span> <span class="n">the</span> <span class="n">specified</span> <span class="n">operand</span> <span class="n">into</span> <span class="n">the</span> <span class="n">Ops</span>
    <span class="o">///</span> <span class="n">vector</span><span class="o">.</span>  <span class="n">If</span> <span class="n">it</span> <span class="ow">is</span> <span class="n">invalid</span><span class="p">,</span> <span class="n">don</span><span class="s1">&#39;t add anything to Ops. If hasMemory is</span>
    <span class="o">///</span> <span class="n">true</span> <span class="n">it</span> <span class="n">means</span> <span class="n">one</span> <span class="n">of</span> <span class="n">the</span> <span class="n">asm</span> <span class="n">constraint</span> <span class="n">of</span> <span class="n">the</span> <span class="n">inline</span> <span class="n">asm</span> <span class="n">instruction</span>
    <span class="o">///</span> <span class="n">being</span> <span class="n">processed</span> <span class="ow">is</span> <span class="s1">&#39;m&#39;</span><span class="o">.</span>
    <span class="n">void</span> <span class="n">LowerAsmOperandForConstraint</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span>
                                      <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">Constraint</span><span class="p">,</span>
                                      <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ops</span><span class="p">,</span>
                                      <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span><span class="p">;</span>

    <span class="nb">bool</span> <span class="n">isLegalAddressingMode</span><span class="p">(</span><span class="n">const</span> <span class="n">DataLayout</span> <span class="o">&amp;</span><span class="n">DL</span><span class="p">,</span> <span class="n">const</span> <span class="n">AddrMode</span> <span class="o">&amp;</span><span class="n">AM</span><span class="p">,</span>
                               <span class="n">Type</span> <span class="o">*</span><span class="n">Ty</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">AS</span><span class="p">,</span>
                               <span class="n">Instruction</span> <span class="o">*</span><span class="n">I</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter11_2/Cpu0ISelLowering.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>//===----------------------------------------------------------------------===//
//                           Cpu0 Inline Assembly Support
//===----------------------------------------------------------------------===//

/// getConstraintType - Given a constraint letter, return the type of
/// constraint it is for this target.
Cpu0TargetLowering::ConstraintType 
Cpu0TargetLowering::getConstraintType(StringRef Constraint) const
{
  // Cpu0 specific constraints
  // GCC config/mips/constraints.md
  // &#39;c&#39; : A register suitable for use in an indirect
  //       jump. This will always be $t9 for -mabicalls.
  if (Constraint.size() == 1) {
    switch (Constraint[0]) {
      default : break;
      case &#39;c&#39;:
        return C_RegisterClass;
      case &#39;R&#39;:
        return C_Memory;
    }
  }
  return TargetLowering::getConstraintType(Constraint);
}

/// Examine constraint type and operand type and determine a weight value.
/// This object must already have been set up with the operand type
/// and the current alternative constraint selected.
TargetLowering::ConstraintWeight
Cpu0TargetLowering::getSingleConstraintMatchWeight(
    AsmOperandInfo &amp;info, const char *constraint) const {
  ConstraintWeight weight = CW_Invalid;
  Value *CallOperandVal = info.CallOperandVal;
    // If we don&#39;t have a value, we can&#39;t do a match,
    // but allow it at the lowest weight.
  if (!CallOperandVal)
    return CW_Default;
  Type *type = CallOperandVal-&gt;getType();
  // Look at the constraint type.
  switch (*constraint) {
  default:
    weight = TargetLowering::getSingleConstraintMatchWeight(info, constraint);
    break;
  case &#39;c&#39;: // $t9 for indirect jumps
    if (type-&gt;isIntegerTy())
      weight = CW_SpecificReg;
    break;
  case &#39;I&#39;: // signed 16 bit immediate
  case &#39;J&#39;: // integer zero
  case &#39;K&#39;: // unsigned 16 bit immediate
  case &#39;L&#39;: // signed 32 bit immediate where lower 16 bits are 0
  case &#39;N&#39;: // immediate in the range of -65535 to -1 (inclusive)
  case &#39;O&#39;: // signed 15 bit immediate (+- 16383)
  case &#39;P&#39;: // immediate in the range of 65535 to 1 (inclusive)
    if (isa&lt;ConstantInt&gt;(CallOperandVal))
      weight = CW_Constant;
    break;
  case &#39;R&#39;:
    weight = CW_Memory;
    break;
  }
  return weight;
}

/// This is a helper function to parse a physical register string and split it
/// into non-numeric and numeric parts (Prefix and Reg). The first boolean flag
/// that is returned indicates whether parsing was successful. The second flag
/// is true if the numeric part exists.
static std::pair&lt;bool, bool&gt;
parsePhysicalReg(const StringRef &amp;C, std::string &amp;Prefix,
                 unsigned long long &amp;Reg) {
  if (C.front() != &#39;{&#39; || C.back() != &#39;}&#39;)
    return std::make_pair(false, false);

  // Search for the first numeric character.
  StringRef::const_iterator I, B = C.begin() + 1, E = C.end() - 1;
  I = std::find_if(B, E, isdigit);

  Prefix.assign(B, I - B);

  // The second flag is set to false if no numeric characters were found.
  if (I == E)
    return std::make_pair(true, false);

  // Parse the numeric characters.
  return std::make_pair(!getAsUnsignedInteger(StringRef(I, E - I), 10, Reg),
                        true);
}

std::pair&lt;unsigned, const TargetRegisterClass *&gt; Cpu0TargetLowering::
parseRegForInlineAsmConstraint(const StringRef &amp;C, MVT VT) const {
  const TargetRegisterClass *RC;
  std::string Prefix;
  unsigned long long Reg;

  std::pair&lt;bool, bool&gt; R = parsePhysicalReg(C, Prefix, Reg);

  if (!R.first)
    return std::make_pair(0U, nullptr);
  if (!R.second)
    return std::make_pair(0U, nullptr);

 // Parse $0-$15.
  assert(Prefix == &quot;$&quot;);
  RC = getRegClassFor((VT == MVT::Other) ? MVT::i32 : VT);

  assert(Reg &lt; RC-&gt;getNumRegs());
  return std::make_pair(*(RC-&gt;begin() + Reg), RC);
}

/// Given a register class constraint, like &#39;r&#39;, if this corresponds directly
/// to an LLVM register class, return a register of 0 and the register class
/// pointer.
std::pair&lt;unsigned, const TargetRegisterClass *&gt;
Cpu0TargetLowering::getRegForInlineAsmConstraint(const TargetRegisterInfo *TRI,
                                                 StringRef Constraint,
                                                 MVT VT) const
{
  if (Constraint.size() == 1) {
    switch (Constraint[0]) {
    case &#39;r&#39;:
      if (VT == MVT::i32 || VT == MVT::i16 || VT == MVT::i8) {
        return std::make_pair(0U, &amp;Cpu0::CPURegsRegClass);
      }
      if (VT == MVT::i64)
        return std::make_pair(0U, &amp;Cpu0::CPURegsRegClass);
      // This will generate an error message
      return std::make_pair(0u, static_cast&lt;const TargetRegisterClass*&gt;(0));
    case &#39;c&#39;: // register suitable for indirect jump
      if (VT == MVT::i32)
        return std::make_pair((unsigned)Cpu0::T9, &amp;Cpu0::CPURegsRegClass);
      assert(0 &amp;&amp; &quot;Unexpected type.&quot;);
    }
  }

  std::pair&lt;unsigned, const TargetRegisterClass *&gt; R;
  R = parseRegForInlineAsmConstraint(Constraint, VT);

  if (R.second)
    return R;

  return TargetLowering::getRegForInlineAsmConstraint(TRI, Constraint, VT);
}

/// LowerAsmOperandForConstraint - Lower the specified operand into the Ops
/// vector.  If it is invalid, don&#39;t add anything to Ops.
void Cpu0TargetLowering::LowerAsmOperandForConstraint(SDValue Op,
                                                     std::string &amp;Constraint,
                                                     std::vector&lt;SDValue&gt;&amp;Ops,
                                                     SelectionDAG &amp;DAG) const {
  SDLoc DL(Op);
  SDValue Result;

  // Only support length 1 constraints for now.
  if (Constraint.length() &gt; 1) return;

  char ConstraintLetter = Constraint[0];
  switch (ConstraintLetter) {
  default: break; // This will fall through to the generic implementation
  case &#39;I&#39;: // Signed 16 bit constant
    // If this fails, the parent routine will give an error
    if (ConstantSDNode *C = dyn_cast&lt;ConstantSDNode&gt;(Op)) {
      EVT Type = Op.getValueType();
      int64_t Val = C-&gt;getSExtValue();
      if (isInt&lt;16&gt;(Val)) {
        Result = DAG.getTargetConstant(Val, DL, Type);
        break;
      }
    }
    return;
  case &#39;J&#39;: // integer zero
    if (ConstantSDNode *C = dyn_cast&lt;ConstantSDNode&gt;(Op)) {
      EVT Type = Op.getValueType();
      int64_t Val = C-&gt;getZExtValue();
      if (Val == 0) {
        Result = DAG.getTargetConstant(0, DL, Type);
        break;
      }
    }
    return;
  case &#39;K&#39;: // unsigned 16 bit immediate
    if (ConstantSDNode *C = dyn_cast&lt;ConstantSDNode&gt;(Op)) {
      EVT Type = Op.getValueType();
      uint64_t Val = (uint64_t)C-&gt;getZExtValue();
      if (isUInt&lt;16&gt;(Val)) {
        Result = DAG.getTargetConstant(Val, DL, Type);
        break;
      }
    }
    return;
  case &#39;L&#39;: // signed 32 bit immediate where lower 16 bits are 0
    if (ConstantSDNode *C = dyn_cast&lt;ConstantSDNode&gt;(Op)) {
      EVT Type = Op.getValueType();
      int64_t Val = C-&gt;getSExtValue();
      if ((isInt&lt;32&gt;(Val)) &amp;&amp; ((Val &amp; 0xffff) == 0)){
        Result = DAG.getTargetConstant(Val, DL, Type);
        break;
      }
    }
    return;
  case &#39;N&#39;: // immediate in the range of -65535 to -1 (inclusive)
    if (ConstantSDNode *C = dyn_cast&lt;ConstantSDNode&gt;(Op)) {
      EVT Type = Op.getValueType();
      int64_t Val = C-&gt;getSExtValue();
      if ((Val &gt;= -65535) &amp;&amp; (Val &lt;= -1)) {
        Result = DAG.getTargetConstant(Val, DL, Type);
        break;
      }
    }
    return;
  case &#39;O&#39;: // signed 15 bit immediate
    if (ConstantSDNode *C = dyn_cast&lt;ConstantSDNode&gt;(Op)) {
      EVT Type = Op.getValueType();
      int64_t Val = C-&gt;getSExtValue();
      if ((isInt&lt;15&gt;(Val))) {
        Result = DAG.getTargetConstant(Val, DL, Type);
        break;
      }
    }
    return;
  case &#39;P&#39;: // immediate in the range of 1 to 65535 (inclusive)
    if (ConstantSDNode *C = dyn_cast&lt;ConstantSDNode&gt;(Op)) {
      EVT Type = Op.getValueType();
      int64_t Val = C-&gt;getSExtValue();
      if ((Val &lt;= 65535) &amp;&amp; (Val &gt;= 1)) {
        Result = DAG.getTargetConstant(Val, DL, Type);
        break;
      }
    }
    return;
  }

  if (Result.getNode()) {
    Ops.push_back(Result);
    return;
  }

  TargetLowering::LowerAsmOperandForConstraint(Op, Constraint, Ops, DAG);
}

bool Cpu0TargetLowering::isLegalAddressingMode(const DataLayout &amp;DL,
                                               const AddrMode &amp;AM, Type *Ty,
                                               unsigned AS, Instruction *I) const {
  // No global is ever allowed as a base.
  if (AM.BaseGV)
    return false;

  switch (AM.Scale) {
  case 0: // &quot;r+i&quot; or just &quot;i&quot;, depending on HasBaseReg.
    break;
  case 1:
    if (!AM.HasBaseReg) // allow &quot;r+i&quot;.
      break;
    return false; // disallow &quot;r+r&quot; or &quot;r+r+i&quot;.
  default:
    return false;
  }

  return true;
}
</pre></div>
</div>
<p>Similar to the backend structure, the structure of inline assembly can also be
organized by file name, as shown in the table titled <em>“The structure of inline
assembly”</em>.</p>
<table class="docutils align-default" id="id9">
<caption><span class="caption-number">Table 39 </span><span class="caption-text">inline assembly functions</span><a class="headerlink" href="#id9" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>File</p></th>
<th class="head"><p>Function</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Cpu0ISelLowering.cpp</p></td>
<td><p>inline asm DAG node create</p></td>
</tr>
<tr class="row-odd"><td><p>Cpu0ISelDAGToDAG.cpp</p></td>
<td><p>save OP code</p></td>
</tr>
<tr class="row-even"><td><p>Cpu0AsmPrinter.cpp,</p></td>
<td><p>inline asm instructions printing</p></td>
</tr>
<tr class="row-odd"><td><p>Cpu0InstrInfo.cpp</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Except for <cite>Cpu0ISelDAGToDAG.cpp</cite>, the other functions are the same as those
used in the backend’s normal code compilation.</p>
<p>The inline assembly handling in <cite>Cpu0ISelLowering.cpp</cite> is explained after showing
the result of running with <cite>ch11_2.cpp</cite>.</p>
<p><cite>Cpu0ISelDAGToDAG.cpp</cite> simply saves the opcode in
<cite>SelectInlineAsmMemoryOperand()</cite>. Since the opcode represents a Cpu0 inline
assembly instruction, no further LLVM IR DAG translation is needed. The function
just saves the opcode directly and returns <cite>false</cite> to notify the LLVM system that
the Cpu0 backend has finished processing this inline assembly instruction.</p>
<p>Run <cite>Chapter11_2</cite> with <cite>ch11_2.cpp</cite> to get the following result:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">1-160-129-73:input Jonathan$ </span>clang<span class="w"> </span>-target<span class="w"> </span>mips-unknown-linux-gnu<span class="w"> </span>-c
<span class="go">ch11_2.cpp -emit-llvm -o ch11_2.bc</span>

<span class="gp">1-160-129-73:input Jonathan$ </span>~/llvm/test/build/bin/
<span class="go">llvm-dis ch11_2.bc -o -</span>
<span class="go">...</span>
<span class="go">target triple = &quot;mips-unknown-linux-gnu&quot;</span>

<span class="go">@g = global [3 x i32] [i32 1, i32 2, i32 3], align 4</span>

<span class="go">; Function Attrs: nounwind</span>
<span class="go">define i32 @_Z14inlineasm_adduv() #0 {</span>
<span class="gp">  %</span><span class="nv">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>alloca<span class="w"> </span>i32,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>alloca<span class="w"> </span>i32,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="go">  store i32 10, i32* %foo, align 4</span>
<span class="go">  store i32 15, i32* %bar, align 4</span>
<span class="gp">  %</span><span class="nv">1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>load<span class="w"> </span>i32*<span class="w"> </span>%foo,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>call<span class="w"> </span>i32<span class="w"> </span>asm<span class="w"> </span>sideeffect<span class="w"> </span><span class="s2">&quot;addu </span><span class="nv">$0</span><span class="s2">,</span><span class="nv">$1</span><span class="s2">,</span><span class="nv">$2</span><span class="s2">&quot;</span>,<span class="w"> </span><span class="s2">&quot;=r,r,r&quot;</span><span class="o">(</span>i32<span class="w"> </span>%1,<span class="w"> </span>i32<span class="w"> </span><span class="m">15</span><span class="o">)</span><span class="w"> </span><span class="c1">#1,</span>
<span class="go">  !srcloc !1</span>
<span class="go">  store i32 %2, i32* %foo, align 4</span>
<span class="gp">  %</span><span class="nv">3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>load<span class="w"> </span>i32*<span class="w"> </span>%foo,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="go">  ret i32 %3</span>
<span class="go">}</span>

<span class="go">; Function Attrs: nounwind</span>
<span class="go">define i32 @_Z18inlineasm_longlongv() #0 {</span>
<span class="gp">  %</span><span class="nv">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>alloca<span class="w"> </span>i32,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>alloca<span class="w"> </span>i32,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>alloca<span class="w"> </span>i64,<span class="w"> </span>align<span class="w"> </span><span class="m">8</span>
<span class="gp">  %</span><span class="nv">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>alloca<span class="w"> </span>i32*,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>alloca<span class="w"> </span>i32*,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="go">  store i64 21474836486, i64* %bar, align 8</span>
<span class="gp">  %</span><span class="nv">1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>bitcast<span class="w"> </span>i64*<span class="w"> </span>%bar<span class="w"> </span>to<span class="w"> </span>i32*
<span class="go">  store i32* %1, i32** %p, align 4</span>
<span class="gp">  %</span><span class="nv">2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>load<span class="w"> </span>i32**<span class="w"> </span>%p,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>call<span class="w"> </span>i32<span class="w"> </span>asm<span class="w"> </span>sideeffect<span class="w"> </span><span class="s2">&quot;ld </span><span class="nv">$0</span><span class="s2">,</span><span class="nv">$1</span><span class="s2">&quot;</span>,<span class="w"> </span><span class="s2">&quot;=r,*m&quot;</span><span class="o">(</span>i32*<span class="w"> </span>%2<span class="o">)</span><span class="w"> </span><span class="c1">#1, !srcloc !2</span>
<span class="go">  store i32 %3, i32* %a, align 4</span>
<span class="gp">  %</span><span class="nv">4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>load<span class="w"> </span>i32**<span class="w"> </span>%p,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>getelementptr<span class="w"> </span>inbounds<span class="w"> </span>i32*<span class="w"> </span>%4,<span class="w"> </span>i32<span class="w"> </span><span class="m">1</span>
<span class="go">  store i32* %5, i32** %q, align 4</span>
<span class="gp">  %</span><span class="nv">6</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>load<span class="w"> </span>i32**<span class="w"> </span>%q,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">7</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>call<span class="w"> </span>i32<span class="w"> </span>asm<span class="w"> </span>sideeffect<span class="w"> </span><span class="s2">&quot;ld </span><span class="nv">$0</span><span class="s2">,</span><span class="nv">$1</span><span class="s2">&quot;</span>,<span class="w"> </span><span class="s2">&quot;=r,*m&quot;</span><span class="o">(</span>i32*<span class="w"> </span>%6<span class="o">)</span><span class="w"> </span><span class="c1">#1, !srcloc !3</span>
<span class="go">  store i32 %7, i32* %b, align 4</span>
<span class="gp">  %</span><span class="nv">8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>load<span class="w"> </span>i32*<span class="w"> </span>%a,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">9</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>load<span class="w"> </span>i32*<span class="w"> </span>%b,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">10</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>add<span class="w"> </span>nsw<span class="w"> </span>i32<span class="w"> </span>%8,<span class="w"> </span>%9
<span class="go">  ret i32 %10</span>
<span class="go">}</span>

<span class="go">; Function Attrs: nounwind</span>
<span class="go">define i32 @_Z20inlineasm_constraintv() #0 {</span>
<span class="gp">  %</span><span class="nv">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>alloca<span class="w"> </span>i32,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">n_5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>alloca<span class="w"> </span>i32,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">n5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>alloca<span class="w"> </span>i32,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">n0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>alloca<span class="w"> </span>i32,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">un5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>alloca<span class="w"> </span>i32,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">n65536</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>alloca<span class="w"> </span>i32,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">n_65531</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>alloca<span class="w"> </span>i32,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="go">  store i32 10, i32* %foo, align 4</span>
<span class="go">  store i32 -5, i32* %n_5, align 4</span>
<span class="go">  store i32 5, i32* %n5, align 4</span>
<span class="go">  store i32 0, i32* %n0, align 4</span>
<span class="go">  store i32 5, i32* %un5, align 4</span>
<span class="go">  store i32 65536, i32* %n65536, align 4</span>
<span class="go">  store i32 -65531, i32* %n_65531, align 4</span>
<span class="gp">  %</span><span class="nv">1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>load<span class="w"> </span>i32*<span class="w"> </span>%foo,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>call<span class="w"> </span>i32<span class="w"> </span>asm<span class="w"> </span>sideeffect<span class="w"> </span><span class="s2">&quot;addiu </span><span class="nv">$0</span><span class="s2">,</span><span class="nv">$1</span><span class="s2">,</span><span class="nv">$2</span><span class="s2">&quot;</span>,<span class="w"> </span><span class="s2">&quot;=r,r,I&quot;</span><span class="o">(</span>i32<span class="w"> </span>%1,<span class="w"> </span>i32<span class="w"> </span>-5<span class="o">)</span><span class="w"> </span><span class="c1">#1,</span>
<span class="go">  !srcloc !4</span>
<span class="go">  store i32 %2, i32* %foo, align 4</span>
<span class="gp">  %</span><span class="nv">3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>load<span class="w"> </span>i32*<span class="w"> </span>%foo,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>call<span class="w"> </span>i32<span class="w"> </span>asm<span class="w"> </span>sideeffect<span class="w"> </span><span class="s2">&quot;addiu </span><span class="nv">$0</span><span class="s2">,</span><span class="nv">$1</span><span class="s2">,</span><span class="nv">$2</span><span class="s2">&quot;</span>,<span class="w"> </span><span class="s2">&quot;=r,r,J&quot;</span><span class="o">(</span>i32<span class="w"> </span>%3,<span class="w"> </span>i32<span class="w"> </span><span class="m">0</span><span class="o">)</span><span class="w"> </span><span class="c1">#1,</span>
<span class="go">  !srcloc !5</span>
<span class="go">  store i32 %4, i32* %foo, align 4</span>
<span class="gp">  %</span><span class="nv">5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>load<span class="w"> </span>i32*<span class="w"> </span>%foo,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">6</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>call<span class="w"> </span>i32<span class="w"> </span>asm<span class="w"> </span>sideeffect<span class="w"> </span><span class="s2">&quot;addiu </span><span class="nv">$0</span><span class="s2">,</span><span class="nv">$1</span><span class="s2">,</span><span class="nv">$2</span><span class="s2">&quot;</span>,<span class="w"> </span><span class="s2">&quot;=r,r,K&quot;</span><span class="o">(</span>i32<span class="w"> </span>%5,<span class="w"> </span>i32<span class="w"> </span><span class="m">5</span><span class="o">)</span><span class="w"> </span><span class="c1">#1,</span>
<span class="go">  !srcloc !6</span>
<span class="go">  store i32 %6, i32* %foo, align 4</span>
<span class="gp">  %</span><span class="nv">7</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>load<span class="w"> </span>i32*<span class="w"> </span>%foo,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>call<span class="w"> </span>i32<span class="w"> </span>asm<span class="w"> </span>sideeffect<span class="w"> </span><span class="s2">&quot;ori </span><span class="nv">$0</span><span class="s2">,</span><span class="nv">$1</span><span class="s2">,</span><span class="nv">$2</span><span class="s2">&quot;</span>,<span class="w"> </span><span class="s2">&quot;=r,r,L&quot;</span><span class="o">(</span>i32<span class="w"> </span>%7,<span class="w"> </span>i32<span class="w"> </span><span class="m">65536</span><span class="o">)</span><span class="w"> </span><span class="c1">#1,</span>
<span class="go">  !srcloc !7</span>
<span class="go">  store i32 %8, i32* %foo, align 4</span>
<span class="gp">  %</span><span class="nv">9</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>load<span class="w"> </span>i32*<span class="w"> </span>%foo,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">10</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>call<span class="w"> </span>i32<span class="w"> </span>asm<span class="w"> </span>sideeffect<span class="w"> </span><span class="s2">&quot;addiu </span><span class="nv">$0</span><span class="s2">,</span><span class="nv">$1</span><span class="s2">,</span><span class="nv">$2</span><span class="s2">&quot;</span>,<span class="w"> </span><span class="s2">&quot;=r,r,N&quot;</span><span class="o">(</span>i32<span class="w"> </span>%9,<span class="w"> </span>i32<span class="w"> </span>-65531<span class="o">)</span>
<span class="gp">  #</span><span class="m">1</span>,<span class="w"> </span>!srcloc<span class="w"> </span>!8
<span class="go">  store i32 %10, i32* %foo, align 4</span>
<span class="gp">  %</span><span class="nv">11</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>load<span class="w"> </span>i32*<span class="w"> </span>%foo,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">12</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>call<span class="w"> </span>i32<span class="w"> </span>asm<span class="w"> </span>sideeffect<span class="w"> </span><span class="s2">&quot;addiu </span><span class="nv">$0</span><span class="s2">,</span><span class="nv">$1</span><span class="s2">,</span><span class="nv">$2</span><span class="s2">&quot;</span>,<span class="w"> </span><span class="s2">&quot;=r,r,O&quot;</span><span class="o">(</span>i32<span class="w"> </span>%11,<span class="w"> </span>i32<span class="w"> </span>-5<span class="o">)</span><span class="w"> </span><span class="c1">#1,</span>
<span class="go">  !srcloc !9</span>
<span class="go">  store i32 %12, i32* %foo, align 4</span>
<span class="gp">  %</span><span class="nv">13</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>load<span class="w"> </span>i32*<span class="w"> </span>%foo,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">14</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>call<span class="w"> </span>i32<span class="w"> </span>asm<span class="w"> </span>sideeffect<span class="w"> </span><span class="s2">&quot;addiu </span><span class="nv">$0</span><span class="s2">,</span><span class="nv">$1</span><span class="s2">,</span><span class="nv">$2</span><span class="s2">&quot;</span>,<span class="w"> </span><span class="s2">&quot;=r,r,P&quot;</span><span class="o">(</span>i32<span class="w"> </span>%13,<span class="w"> </span>i32<span class="w"> </span><span class="m">5</span><span class="o">)</span><span class="w"> </span><span class="c1">#1,</span>
<span class="go">  !srcloc !10</span>
<span class="go">  store i32 %14, i32* %foo, align 4</span>
<span class="gp">  %</span><span class="nv">15</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>load<span class="w"> </span>i32*<span class="w"> </span>%foo,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="go">  ret i32 %15</span>
<span class="go">}</span>

<span class="go">; Function Attrs: nounwind</span>
<span class="go">define i32 @_Z13inlineasm_argii(i32 %u, i32 %v) #0 {</span>
<span class="gp">  %</span><span class="nv">1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>alloca<span class="w"> </span>i32,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>alloca<span class="w"> </span>i32,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>alloca<span class="w"> </span>i32,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="go">  store i32 %u, i32* %1, align 4</span>
<span class="go">  store i32 %v, i32* %2, align 4</span>
<span class="gp">  %</span><span class="nv">3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>load<span class="w"> </span>i32*<span class="w"> </span>%1,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>load<span class="w"> </span>i32*<span class="w"> </span>%2,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>call<span class="w"> </span>i32<span class="w"> </span>asm<span class="w"> </span>sideeffect<span class="w"> </span><span class="s2">&quot;subu </span><span class="nv">$0</span><span class="s2">,</span><span class="nv">$1</span><span class="s2">,</span><span class="nv">$2</span><span class="s2">&quot;</span>,<span class="w"> </span><span class="s2">&quot;=r,r,r&quot;</span><span class="o">(</span>i32<span class="w"> </span>%3,<span class="w"> </span>i32<span class="w"> </span>%4<span class="o">)</span><span class="w"> </span><span class="c1">#1,</span>
<span class="go">  !srcloc !11</span>
<span class="go">  store i32 %5, i32* %w, align 4</span>
<span class="gp">  %</span><span class="nv">6</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>load<span class="w"> </span>i32*<span class="w"> </span>%w,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="go">  ret i32 %6</span>
<span class="go">}</span>

<span class="go">; Function Attrs: nounwind</span>
<span class="go">define i32 @_Z16inlineasm_globalv() #0 {</span>
<span class="gp">  %</span><span class="nv">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>alloca<span class="w"> </span>i32,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>alloca<span class="w"> </span>i32,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>call<span class="w"> </span>i32<span class="w"> </span>asm<span class="w"> </span>sideeffect<span class="w"> </span><span class="s2">&quot;ld </span><span class="nv">$0</span><span class="s2">,</span><span class="nv">$1</span><span class="s2">&quot;</span>,<span class="w"> </span><span class="s2">&quot;=r,*m&quot;</span><span class="o">(</span>i32*<span class="w"> </span>getelementptr<span class="w"> </span>inbounds
<span class="go">  ([3 x i32]* @g, i32 0, i32 2)) #1, !srcloc !12</span>
<span class="go">  store i32 %1, i32* %c, align 4</span>
<span class="gp">  %</span><span class="nv">2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>load<span class="w"> </span>i32*<span class="w"> </span>%c,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>call<span class="w"> </span>i32<span class="w"> </span>asm<span class="w"> </span>sideeffect<span class="w"> </span><span class="s2">&quot;addiu </span><span class="nv">$0</span><span class="s2">,</span><span class="nv">$1</span><span class="s2">,1&quot;</span>,<span class="w"> </span><span class="s2">&quot;=r,r&quot;</span><span class="o">(</span>i32<span class="w"> </span>%2<span class="o">)</span><span class="w"> </span><span class="c1">#1, !srcloc !13</span>
<span class="go">  store i32 %3, i32* %d, align 4</span>
<span class="gp">  %</span><span class="nv">4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>load<span class="w"> </span>i32*<span class="w"> </span>%d,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="go">  ret i32 %4</span>
<span class="go">}</span>

<span class="go">; Function Attrs: nounwind</span>
<span class="go">define i32 @_Z14test_inlineasmv() #0 {</span>
<span class="gp">  %</span><span class="nv">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>alloca<span class="w"> </span>i32,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>alloca<span class="w"> </span>i32,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>alloca<span class="w"> </span>i32,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>alloca<span class="w"> </span>i32,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>alloca<span class="w"> </span>i32,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>alloca<span class="w"> </span>i32,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>alloca<span class="w"> </span>i32,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>call<span class="w"> </span>i32<span class="w"> </span>@_Z14inlineasm_adduv<span class="o">()</span>
<span class="go">  store i32 %1, i32* %a, align 4</span>
<span class="gp">  %</span><span class="nv">2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>call<span class="w"> </span>i32<span class="w"> </span>@_Z18inlineasm_longlongv<span class="o">()</span>
<span class="go">  store i32 %2, i32* %b, align 4</span>
<span class="gp">  %</span><span class="nv">3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>call<span class="w"> </span>i32<span class="w"> </span>@_Z20inlineasm_constraintv<span class="o">()</span>
<span class="go">  store i32 %3, i32* %c, align 4</span>
<span class="gp">  %</span><span class="nv">4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>call<span class="w"> </span>i32<span class="w"> </span>@_Z13inlineasm_argii<span class="o">(</span>i32<span class="w"> </span><span class="m">1</span>,<span class="w"> </span>i32<span class="w"> </span><span class="m">10</span><span class="o">)</span>
<span class="go">  store i32 %4, i32* %d, align 4</span>
<span class="gp">  %</span><span class="nv">5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>call<span class="w"> </span>i32<span class="w"> </span>@_Z13inlineasm_argii<span class="o">(</span>i32<span class="w"> </span><span class="m">6</span>,<span class="w"> </span>i32<span class="w"> </span><span class="m">3</span><span class="o">)</span>
<span class="go">  store i32 %5, i32* %e, align 4</span>
<span class="gp">  %</span><span class="nv">6</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>load<span class="w"> </span>i32*<span class="w"> </span>%e,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">7</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>call<span class="w"> </span>i32<span class="w"> </span>asm<span class="w"> </span>sideeffect<span class="w"> </span><span class="s2">&quot;addiu </span><span class="nv">$0</span><span class="s2">,</span><span class="nv">$1</span><span class="s2">,1&quot;</span>,<span class="w"> </span><span class="s2">&quot;=r,r&quot;</span><span class="o">(</span>i32<span class="w"> </span>%6<span class="o">)</span><span class="w"> </span><span class="c1">#1, !srcloc !14</span>
<span class="go">  store i32 %7, i32* %f, align 4</span>
<span class="gp">  %</span><span class="nv">8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>call<span class="w"> </span>i32<span class="w"> </span>@_Z16inlineasm_globalv<span class="o">()</span>
<span class="go">  store i32 %8, i32* %g, align 4</span>
<span class="gp">  %</span><span class="nv">9</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>load<span class="w"> </span>i32*<span class="w"> </span>%a,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">10</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>load<span class="w"> </span>i32*<span class="w"> </span>%b,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">11</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>add<span class="w"> </span>nsw<span class="w"> </span>i32<span class="w"> </span>%9,<span class="w"> </span>%10
<span class="gp">  %</span><span class="nv">12</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>load<span class="w"> </span>i32*<span class="w"> </span>%c,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">13</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>add<span class="w"> </span>nsw<span class="w"> </span>i32<span class="w"> </span>%11,<span class="w"> </span>%12
<span class="gp">  %</span><span class="nv">14</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>load<span class="w"> </span>i32*<span class="w"> </span>%d,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">15</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>add<span class="w"> </span>nsw<span class="w"> </span>i32<span class="w"> </span>%13,<span class="w"> </span>%14
<span class="gp">  %</span><span class="nv">16</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>load<span class="w"> </span>i32*<span class="w"> </span>%e,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">17</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>add<span class="w"> </span>nsw<span class="w"> </span>i32<span class="w"> </span>%15,<span class="w"> </span>%16
<span class="gp">  %</span><span class="nv">18</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>load<span class="w"> </span>i32*<span class="w"> </span>%f,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">19</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>add<span class="w"> </span>nsw<span class="w"> </span>i32<span class="w"> </span>%17,<span class="w"> </span>%18
<span class="gp">  %</span><span class="nv">20</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>load<span class="w"> </span>i32*<span class="w"> </span>%g,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="gp">  %</span><span class="nv">21</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>add<span class="w"> </span>nsw<span class="w"> </span>i32<span class="w"> </span>%19,<span class="w"> </span>%20
<span class="go">  ret i32 %21</span>
<span class="go">}</span>
<span class="go">...</span>
<span class="gp">1-160-129-73:input Jonathan$ </span>~/llvm/test/build/bin/llc
<span class="go">  -march=cpu0 -relocation-model=static -filetype=asm ch11_2.bc -o -</span>
<span class="go">  .section .mdebug.abi32</span>
<span class="go">  .previous</span>
<span class="go">  .file &quot;ch11_2.bc&quot;</span>
<span class="go">  .text</span>
<span class="go">  .globl  _Z14inlineasm_adduv</span>
<span class="go">  .align  2</span>
<span class="go">  .type _Z14inlineasm_adduv,@function</span>
<span class="go">  .ent  _Z14inlineasm_adduv     # @_Z14inlineasm_adduv</span>
<span class="go">_Z14inlineasm_adduv:</span>
<span class="go">  .frame  $fp,16,$lr</span>
<span class="go">  .mask   0x00001000,-4</span>
<span class="go">  .set  noreorder</span>
<span class="go">  .set  nomacro</span>
<span class="gp"># </span>BB#0:
<span class="go">  addiu $sp, $sp, -16</span>
<span class="go">  st  $fp, 12($sp)            # 4-byte Folded Spill</span>
<span class="go">  addu  $fp, $sp, $zero</span>
<span class="go">  addiu $2, $zero, 10</span>
<span class="go">  st  $2, 8($fp)</span>
<span class="go">  addiu $2, $zero, 15</span>
<span class="go">  st  $2, 4($fp)</span>
<span class="go">  ld  $3, 8($fp)</span>
<span class="gp">  #</span>APP
<span class="go">  addu $2,$3,$2</span>
<span class="gp">  #</span>NO_APP
<span class="go">  st  $2, 8($fp)</span>
<span class="go">  addu  $sp, $fp, $zero</span>
<span class="go">  ld  $fp, 12($sp)            # 4-byte Folded Reload</span>
<span class="go">  addiu $sp, $sp, 16</span>
<span class="go">  ret $lr</span>
<span class="go">  nop</span>
<span class="go">  .set  macro</span>
<span class="go">  .set  reorder</span>
<span class="go">  .end  _Z14inlineasm_adduv</span>
<span class="gp">$</span>tmp3:
<span class="go">  .size _Z14inlineasm_adduv, ($tmp3)-_Z14inlineasm_adduv</span>

<span class="go">  .globl  _Z18inlineasm_longlongv</span>
<span class="go">  .align  2</span>
<span class="go">  .type _Z18inlineasm_longlongv,@function</span>
<span class="go">  .ent  _Z18inlineasm_longlongv # @_Z18inlineasm_longlongv</span>
<span class="go">_Z18inlineasm_longlongv:</span>
<span class="go">  .frame  $fp,32,$lr</span>
<span class="go">  .mask   0x00001000,-4</span>
<span class="go">  .set  noreorder</span>
<span class="go">  .set  nomacro</span>
<span class="gp"># </span>BB#0:
<span class="go">  addiu $sp, $sp, -32</span>
<span class="go">  st  $fp, 28($sp)            # 4-byte Folded Spill</span>
<span class="go">  addu  $fp, $sp, $zero</span>
<span class="go">  addiu $2, $zero, 6</span>
<span class="go">  st  $2, 12($fp)</span>
<span class="go">  addiu $2, $zero, 5</span>
<span class="go">  st  $2, 8($fp)</span>
<span class="go">  addiu $2, $fp, 8</span>
<span class="go">  st  $2, 4($fp)</span>
<span class="gp">  #</span>APP
<span class="go">  ld $2,0($2)</span>
<span class="gp">  #</span>NO_APP
<span class="go">  st  $2, 24($fp)</span>
<span class="go">  ld  $2, 4($fp)</span>
<span class="go">  addiu $2, $2, 4</span>
<span class="go">  st  $2, 0($fp)</span>
<span class="gp">  #</span>APP
<span class="go">  ld $2,0($2)</span>
<span class="gp">  #</span>NO_APP
<span class="go">  st  $2, 20($fp)</span>
<span class="go">  ld  $3, 24($fp)</span>
<span class="go">  addu  $2, $3, $2</span>
<span class="go">  addu  $sp, $fp, $zero</span>
<span class="go">  ld  $fp, 28($sp)            # 4-byte Folded Reload</span>
<span class="go">  addiu $sp, $sp, 32</span>
<span class="go">  ret $lr</span>
<span class="go">  .set  macro</span>
<span class="go">  .set  reorder</span>
<span class="go">  .end  _Z18inlineasm_longlongv</span>
<span class="gp">$</span>tmp7:
<span class="go">  .size _Z18inlineasm_longlongv, ($tmp7)-_Z18inlineasm_longlongv</span>

<span class="go">  .globl  _Z20inlineasm_constraintv</span>
<span class="go">  .align  2</span>
<span class="go">  .type _Z20inlineasm_constraintv,@function</span>
<span class="go">  .ent  _Z20inlineasm_constraintv # @_Z20inlineasm_constraintv</span>
<span class="go">_Z20inlineasm_constraintv:</span>
<span class="go">  .frame  $fp,32,$lr</span>
<span class="go">  .mask   0x00001000,-4</span>
<span class="go">  .set  noreorder</span>
<span class="go">  .set  nomacro</span>
<span class="gp"># </span>BB#0:
<span class="go">  addiu $sp, $sp, -32</span>
<span class="go">  st  $fp, 28($sp)            # 4-byte Folded Spill</span>
<span class="go">  addu  $fp, $sp, $zero</span>
<span class="go">  addiu $2, $zero, 10</span>
<span class="go">  st  $2, 24($fp)</span>
<span class="go">  addiu $2, $zero, -5</span>
<span class="go">  st  $2, 20($fp)</span>
<span class="go">  addiu $2, $zero, 5</span>
<span class="go">  st  $2, 16($fp)</span>
<span class="go">  addiu $3, $zero, 0</span>
<span class="go">  st  $3, 12($fp)</span>
<span class="go">  st  $2, 8($fp)</span>
<span class="go">  lui $2, 1</span>
<span class="go">  st  $2, 4($fp)</span>
<span class="go">  lui $2, 65535</span>
<span class="go">  ori $2, $2, 5</span>
<span class="go">  st  $2, 0($fp)</span>
<span class="go">  ld  $2, 24($fp)</span>
<span class="gp">  #</span>APP
<span class="go">  addiu $2,$2,-5</span>
<span class="gp">  #</span>NO_APP
<span class="go">  st  $2, 24($fp)</span>
<span class="gp">  #</span>APP
<span class="go">  addiu $2,$2,0</span>
<span class="gp">  #</span>NO_APP
<span class="go">  st  $2, 24($fp)</span>
<span class="gp">  #</span>APP
<span class="go">  addiu $2,$2,5</span>
<span class="gp">  #</span>NO_APP
<span class="go">  st  $2, 24($fp)</span>
<span class="gp">  #</span>APP
<span class="go">  ori $2,$2,65536</span>
<span class="gp">  #</span>NO_APP
<span class="go">  st  $2, 24($fp)</span>
<span class="gp">  #</span>APP
<span class="go">  addiu $2,$2,-65531</span>
<span class="gp">  #</span>NO_APP
<span class="go">  st  $2, 24($fp)</span>
<span class="gp">  #</span>APP
<span class="go">  addiu $2,$2,-5</span>
<span class="gp">  #</span>NO_APP
<span class="go">  st  $2, 24($fp)</span>
<span class="gp">  #</span>APP
<span class="go">  addiu $2,$2,5</span>
<span class="gp">  #</span>NO_APP
<span class="go">  st  $2, 24($fp)</span>
<span class="go">  addu  $sp, $fp, $zero</span>
<span class="go">  ld  $fp, 28($sp)            # 4-byte Folded Reload</span>
<span class="go">  addiu $sp, $sp, 32</span>
<span class="go">  ret $lr</span>
<span class="go">  nop</span>
<span class="go">  .set  macro</span>
<span class="go">  .set  reorder</span>
<span class="go">  .end  _Z20inlineasm_constraintv</span>
<span class="gp">$</span>tmp11:
<span class="go">  .size _Z20inlineasm_constraintv, ($tmp11)-_Z20inlineasm_constraintv</span>

<span class="go">  .globl  _Z13inlineasm_argii</span>
<span class="go">  .align  2</span>
<span class="go">  .type _Z13inlineasm_argii,@function</span>
<span class="go">  .ent  _Z13inlineasm_argii     # @_Z13inlineasm_argii</span>
<span class="go">_Z13inlineasm_argii:</span>
<span class="go">  .frame  $fp,16,$lr</span>
<span class="go">  .mask   0x00001000,-4</span>
<span class="go">  .set  noreorder</span>
<span class="go">  .set  nomacro</span>
<span class="gp"># </span>BB#0:
<span class="go">  addiu $sp, $sp, -16</span>
<span class="go">  st  $fp, 12($sp)            # 4-byte Folded Spill</span>
<span class="go">  addu  $fp, $sp, $zero</span>
<span class="go">  ld  $2, 16($fp)</span>
<span class="go">  st  $2, 8($fp)</span>
<span class="go">  ld  $2, 20($fp)</span>
<span class="go">  st  $2, 4($fp)</span>
<span class="go">  ld  $3, 8($fp)</span>
<span class="gp">  #</span>APP
<span class="go">  subu $2,$3,$2</span>
<span class="gp">  #</span>NO_APP
<span class="go">  st  $2, 0($fp)</span>
<span class="go">  addu  $sp, $fp, $zero</span>
<span class="go">  ld  $fp, 12($sp)            # 4-byte Folded Reload</span>
<span class="go">  addiu $sp, $sp, 16</span>
<span class="go">  ret $lr</span>
<span class="go">  nop</span>
<span class="go">  .set  macro</span>
<span class="go">  .set  reorder</span>
<span class="go">  .end  _Z13inlineasm_argii</span>
<span class="gp">$</span>tmp15:
<span class="go">  .size _Z13inlineasm_argii, ($tmp15)-_Z13inlineasm_argii</span>

<span class="go">  .globl  _Z16inlineasm_globalv</span>
<span class="go">  .align  2</span>
<span class="go">  .type _Z16inlineasm_globalv,@function</span>
<span class="go">  .ent  _Z16inlineasm_globalv   # @_Z16inlineasm_globalv</span>
<span class="go">_Z16inlineasm_globalv:</span>
<span class="go">  .frame  $fp,16,$lr</span>
<span class="go">  .mask   0x00001000,-4</span>
<span class="go">  .set  noreorder</span>
<span class="go">  .set  nomacro</span>
<span class="gp"># </span>BB#0:
<span class="go">  addiu $sp, $sp, -16</span>
<span class="go">  st  $fp, 12($sp)            # 4-byte Folded Spill</span>
<span class="go">  addu  $fp, $sp, $zero</span>
<span class="go">  lui $2, %hi(g)</span>
<span class="go">  ori $2, $2, %lo(g)</span>
<span class="go">  addiu $2, $2, 8</span>
<span class="gp">  #</span>APP
<span class="go">  ld $2,0($2)</span>
<span class="gp">  #</span>NO_APP
<span class="go">  st  $2, 8($fp)</span>
<span class="gp">  #</span>APP
<span class="go">  addiu $2,$2,1</span>
<span class="gp">  #</span>NO_APP
<span class="go">  st  $2, 4($fp)</span>
<span class="go">  addu  $sp, $fp, $zero</span>
<span class="go">  ld  $fp, 12($sp)            # 4-byte Folded Reload</span>
<span class="go">  addiu $sp, $sp, 16</span>
<span class="go">  ret $lr</span>
<span class="go">  nop</span>
<span class="go">  .set  macro</span>
<span class="go">  .set  reorder</span>
<span class="go">  .end  _Z16inlineasm_globalv</span>
<span class="gp">$</span>tmp19:
<span class="go">  .size _Z16inlineasm_globalv, ($tmp19)-_Z16inlineasm_globalv</span>

<span class="go">  .globl  _Z14test_inlineasmv</span>
<span class="go">  .align  2</span>
<span class="go">  .type _Z14test_inlineasmv,@function</span>
<span class="go">  .ent  _Z14test_inlineasmv     # @_Z14test_inlineasmv</span>
<span class="go">_Z14test_inlineasmv:</span>
<span class="go">  .frame  $fp,48,$lr</span>
<span class="go">  .mask   0x00005000,-4</span>
<span class="go">  .set  noreorder</span>
<span class="go">  .set  nomacro</span>
<span class="gp"># </span>BB#0:
<span class="go">  addiu $sp, $sp, -48</span>
<span class="go">  st  $lr, 44($sp)            # 4-byte Folded Spill</span>
<span class="go">  st  $fp, 40($sp)            # 4-byte Folded Spill</span>
<span class="go">  addu  $fp, $sp, $zero</span>
<span class="go">  jsub  _Z14inlineasm_adduv</span>
<span class="go">  nop</span>
<span class="go">  st  $2, 36($fp)</span>
<span class="go">  jsub  _Z18inlineasm_longlongv</span>
<span class="go">  nop</span>
<span class="go">  st  $2, 32($fp)</span>
<span class="go">  jsub  _Z20inlineasm_constraintv</span>
<span class="go">  nop</span>
<span class="go">  st  $2, 28($fp)</span>
<span class="go">  addiu $2, $zero, 10</span>
<span class="go">  st  $2, 4($sp)</span>
<span class="go">  addiu $2, $zero, 1</span>
<span class="go">  st  $2, 0($sp)</span>
<span class="go">  jsub  _Z13inlineasm_argii</span>
<span class="go">  nop</span>
<span class="go">  st  $2, 24($fp)</span>
<span class="go">  addiu $2, $zero, 3</span>
<span class="go">  st  $2, 4($sp)</span>
<span class="go">  addiu $2, $zero, 6</span>
<span class="go">  st  $2, 0($sp)</span>
<span class="go">  jsub  _Z13inlineasm_argii</span>
<span class="go">  nop</span>
<span class="go">  st  $2, 20($fp)</span>
<span class="gp">  #</span>APP
<span class="go">  addiu $2,$2,1</span>
<span class="gp">  #</span>NO_APP
<span class="go">  st  $2, 16($fp)</span>
<span class="go">  jsub  _Z16inlineasm_globalv</span>
<span class="go">  nop</span>
<span class="go">  st  $2, 12($fp)</span>
<span class="go">  ld  $3, 32($fp)</span>
<span class="go">  ld  $4, 36($fp)</span>
<span class="go">  addu  $3, $4, $3</span>
<span class="go">  ld  $4, 28($fp)</span>
<span class="go">  addu  $3, $3, $4</span>
<span class="go">  ld  $4, 24($fp)</span>
<span class="go">  addu  $3, $3, $4</span>
<span class="go">  ld  $4, 20($fp)</span>
<span class="go">  addu  $3, $3, $4</span>
<span class="go">  ld  $4, 16($fp)</span>
<span class="go">  addu  $3, $3, $4</span>
<span class="go">  addu  $2, $3, $2</span>
<span class="go">  addu  $sp, $fp, $zero</span>
<span class="go">  ld  $fp, 40($sp)            # 4-byte Folded Reload</span>
<span class="go">  ld  $lr, 44($sp)            # 4-byte Folded Reload</span>
<span class="go">  addiu $sp, $sp, 48</span>
<span class="go">  ret $lr</span>
<span class="go">  nop</span>
<span class="go">  .set  macro</span>
<span class="go">  .set  reorder</span>
<span class="go">  .end  _Z14test_inlineasmv</span>
<span class="gp">$</span>tmp23:
<span class="go">  .size _Z14test_inlineasmv, ($tmp23)-_Z14test_inlineasmv</span>

<span class="go">  .type g,@object               # @g</span>
<span class="go">  .data</span>
<span class="go">  .globl  g</span>
<span class="go">  .align  2</span>
<span class="go">g:</span>
<span class="go">  .4byte  1                       # 0x1</span>
<span class="go">  .4byte  2                       # 0x2</span>
<span class="go">  .4byte  3                       # 0x3</span>
<span class="go">  .size g, 12</span>
</pre></div>
</div>
<p>Clang first translates GCC-style inline assembly (<cite>__asm__</cite>) into LLVM IR
Inline Assembler Expressions <a class="footnote-reference brackets" href="#cia" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>. Then, during the <cite>llc</cite> register allocation
stage, it replaces the SSA-form variable registers with physical registers.</p>
<p>In the above example, the functions <cite>LowerAsmOperandForConstraint()</cite> and
<cite>getSingleConstraintMatchWeight()</cite> in <cite>Cpu0ISelLowering.cpp</cite> generate different
ranges of constant operands based on constraint codes <cite>I</cite>, <cite>J</cite>, <cite>K</cite>, <cite>L</cite>, <cite>N</cite>,
<cite>O</cite>, or <cite>P</cite>, and register operands based on <cite>r</cite>.</p>
<p>For instance, the following <cite>__asm__</cite> generates the corresponding LLVM inline
assembly immediately after it:</p>
<div class="highlight-cpp-objdump notranslate"><div class="highlight"><pre><span></span><span class="n">__asm__</span><span class="w"> </span><span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;addiu %0,%1,%2&quot;</span>
<span class="w">                     </span><span class="o">:</span><span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="w"> </span><span class="c1">// 15</span>
<span class="w">                     </span><span class="o">:</span><span class="s">&quot;r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;I&quot;</span><span class="p">(</span><span class="n">n_5</span><span class="p">)</span>
<span class="w">                     </span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">%2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="k">asm</span><span class="w"> </span><span class="k">sideeffect</span><span class="w"> </span><span class="s">&quot;addiu $0,$1,$2&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;=r,r,I&quot;</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv nv-Anonymous">%1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">-5</span><span class="p">)</span><span class="w"> </span><span class="vg">#0</span><span class="p">,</span><span class="w"> </span><span class="nv">!srcloc</span><span class="w"> </span><span class="nv nv-Anonymous">!1</span>
</pre></div>
</div>
<div class="highlight-cpp-objdump notranslate"><div class="highlight"><pre><span></span><span class="n">__asm__</span><span class="w"> </span><span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;addiu %0,%1,%2&quot;</span>
<span class="w">                     </span><span class="o">:</span><span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="w"> </span><span class="c1">// 15</span>
<span class="w">                     </span><span class="o">:</span><span class="s">&quot;r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;N&quot;</span><span class="p">(</span><span class="n">n_65531</span><span class="p">)</span>
<span class="w">                     </span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">%10</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="k">asm</span><span class="w"> </span><span class="k">sideeffect</span><span class="w"> </span><span class="s">&quot;addiu $0,$1,$2&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;=r,r,N&quot;</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv nv-Anonymous">%9</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">-65531</span><span class="p">)</span><span class="w"> </span><span class="vg">#0</span><span class="p">,</span><span class="w"> </span><span class="nv">!srcloc</span><span class="w"> </span><span class="nv nv-Anonymous">!5</span>
</pre></div>
</div>
<div class="highlight-cpp-objdump notranslate"><div class="highlight"><pre><span></span><span class="n">__asm__</span><span class="w"> </span><span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;addiu %0,%1,%2&quot;</span>
<span class="w">                     </span><span class="o">:</span><span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="w"> </span><span class="c1">// 15</span>
<span class="w">                     </span><span class="o">:</span><span class="s">&quot;r&quot;</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;P&quot;</span><span class="p">(</span><span class="n">un5</span><span class="p">)</span>
<span class="w">                     </span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">%14</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="k">asm</span><span class="w"> </span><span class="k">sideeffect</span><span class="w"> </span><span class="s">&quot;addiu $0,$1,$2&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;=r,r,P&quot;</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv nv-Anonymous">%13</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">5</span><span class="p">)</span><span class="w"> </span><span class="vg">#0</span><span class="p">,</span><span class="w"> </span><span class="nv">!srcloc</span><span class="w"> </span><span class="nv nv-Anonymous">!7</span>
</pre></div>
</div>
<p>The <cite>r</cite> constraint in <cite>__asm__</cite> will generate a register operand (e.g., <cite>%1</cite>) in
LLVM IR inline assembly. The <cite>I</cite> constraint will generate a constant operand
(e.g., <cite>-5</cite>) in LLVM IR inline assembly.</p>
<p>Note that <cite>LowerAsmOperandForConstraint()</cite> limits the range of positive and
negative constant operand values to 16 bits, since the FL-type immediate operand
in Cpu0 instructions is 16 bits.</p>
<p>As a result:</p>
<ul class="simple">
<li><p>The range of <cite>N</cite> is from <cite>-65535</cite> to <cite>-1</cite>.</p></li>
<li><p>The range of <cite>P</cite> is from <cite>1</cite> to <cite>65535</cite>.</p></li>
</ul>
<p>Any value outside of these ranges is treated as an error in
<cite>LowerAsmOperandForConstraint()</cite>, due to the 16-bit limitation of the FL
instruction format.</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="llvmas" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://www.embecosm.com/appnotes/ean10/ean10-howto-llvmas-1.0.html">http://www.embecosm.com/appnotes/ean10/ean10-howto-llvmas-1.0.html</a></p>
</aside>
<aside class="footnote brackets" id="inlineas" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html">http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html</a></p>
</aside>
<aside class="footnote brackets" id="cia" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">3</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://llvm.org/docs/LangRef.html#inline-assembler-expressions">http://llvm.org/docs/LangRef.html#inline-assembler-expressions</a></p>
</aside>
</aside>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="Bottom">
      
        <p>
        «&#160;&#160;<a href="elf.html">ELF Support</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="c%2B%2B.html">C++ support</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
    &#169; Copyright 2016, Chen Chung-Shu.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 9.1.0.
    </div>
  </body>
</html>