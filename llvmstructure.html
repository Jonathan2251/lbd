
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Cpu0 architecture and LLVM structure &#8212; Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Backend structure" href="backendstructure.html" />
    <link rel="prev" title="About" href="about.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</span></a></h1>
        <h2 class="heading"><span>Cpu0 architecture and LLVM structure</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="about.html">About</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="backendstructure.html">Backend structure</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="cpu0-architecture-and-llvm-structure">
<span id="sec-llvmstructure"></span><h1>Cpu0 architecture and LLVM structure<a class="headerlink" href="#cpu0-architecture-and-llvm-structure" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#cpu0-processor-architecture-details" id="id65">Cpu0 Processor Architecture Details</a></p>
<ul>
<li><p><a class="reference internal" href="#brief-introduction" id="id66">Brief introduction</a></p></li>
<li><p><a class="reference internal" href="#the-cpu0-instruction-set" id="id67">The Cpu0 Instruction Set</a></p>
<ul>
<li><p><a class="reference internal" href="#why-not-using-add-instead-of-sub" id="id68">Why not using ADD instead of SUB?</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-status-register" id="id69">The Status Register</a></p></li>
<li><p><a class="reference internal" href="#cpu0-s-stages-of-instruction-execution" id="id70">Cpu0’s Stages of Instruction Execution</a></p></li>
<li><p><a class="reference internal" href="#cpu0-s-interrupt-vector" id="id71">Cpu0’s Interrupt Vector</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#llvm-structure" id="id72">LLVM Structure</a></p>
<ul>
<li><p><a class="reference internal" href="#three-phase-design" id="id73">Three-phase design</a></p></li>
<li><p><a class="reference internal" href="#llvm-s-target-description-files-td" id="id74">LLVM’s Target Description Files: .td</a></p></li>
<li><p><a class="reference internal" href="#llvm-code-generation-sequence" id="id75">LLVM Code Generation Sequence</a></p></li>
<li><p><a class="reference internal" href="#ssa-form" id="id76">SSA form</a></p></li>
<li><p><a class="reference internal" href="#dsa-form" id="id77">DSA form</a></p></li>
<li><p><a class="reference internal" href="#llvm-vs-gcc-in-structure" id="id78">LLVM vs GCC in structure</a></p></li>
<li><p><a class="reference internal" href="#llvm-blog" id="id79">LLVM blog</a></p></li>
<li><p><a class="reference internal" href="#dag-directed-acyclic-graph" id="id80">DAG (Directed Acyclic Graph)</a></p></li>
<li><p><a class="reference internal" href="#instruction-selection" id="id81">Instruction Selection</a></p></li>
<li><p><a class="reference internal" href="#caller-and-callee-saved-registers" id="id82">Caller and callee saved registers</a></p></li>
<li><p><a class="reference internal" href="#live-in-and-live-out-register" id="id83">Live in and live out register</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#create-cpu0-backend" id="id84">Create Cpu0 backend</a></p>
<ul>
<li><p><a class="reference internal" href="#cpu0-backend-machine-id-and-relocation-records" id="id85">Cpu0 backend machine ID and relocation records</a></p></li>
<li><p><a class="reference internal" href="#creating-the-initial-cpu0-td-files" id="id86">Creating the Initial Cpu0 .td Files</a></p></li>
<li><p><a class="reference internal" href="#write-cmake-file" id="id87">Write cmake file</a></p></li>
<li><p><a class="reference internal" href="#target-registration" id="id88">Target Registration</a></p></li>
<li><p><a class="reference internal" href="#build-libraries-and-td" id="id89">Build libraries and td</a></p></li>
</ul>
</li>
</ul>
</div>
<p>Before you begin this tutorial, you should know that you can always try to
develop your own backend by porting code from existing backends.
The majority of the code you will want to investigate can be found in the
/lib/Target directory of your root LLVM installation.
As most major RISC instruction sets have some similarities, this may be the
avenue you might try if you are an experienced programmer and knowledgable of
compiler backends.</p>
<p>On the other hand, there is a steep learning curve and you may easily get stuck
debugging your new backend. You can easily spend a lot of time tracing which
methods are callbacks of some function, or which are calling some overridden
method deep in the LLVM codebase - and with a codebase as large as LLVM, all of
this can easily become difficult to keep track of.
This tutorial will help you work through this process while learning the
fundamentals of LLVM backend design.
It will show you what is necessary to get your first backend functional and
complete, and it should help you understand how to debug your backend when it
produces incorrect machine code using output provided by the compiler.</p>
<p>This chapter details the Cpu0 instruction set and the structure of LLVM.
The LLVM structure information is adapted from Chris Lattner’s LLVM chapter of
the Architecture of Open Source Applications book <a class="footnote-reference brackets" href="#aosa-book" id="id1">10</a>. You can read
the original article from the AOSA website if you prefer.</p>
<p>At the end of this Chapter, you will begin to create a new LLVM backend by
writing register and instruction definitions in the Target Description files
which will be used in next chapter.</p>
<p>Finally, there are compiler knowledge like DAG (Directed-Acyclic-Graph) and
instruction selection needed in llvm backend design, and they are explained
here.</p>
<section id="cpu0-processor-architecture-details">
<h2><a class="toc-backref" href="#id65">Cpu0 Processor Architecture Details</a><a class="headerlink" href="#cpu0-processor-architecture-details" title="Permalink to this headline">¶</a></h2>
<p>This section is based on materials available here <a class="footnote-reference brackets" href="#cpu0-chinese" id="id2">1</a> (Chinese)
and here <a class="footnote-reference brackets" href="#cpu0-english" id="id3">2</a> (English). However, I changed some ISA from original
Cpu0 for designing a simple integer operational CPU and llvm backend. This is
my intention for writing this book that I want to know what a simple and robotic
CPU ISA and llvm backend can be.</p>
<section id="brief-introduction">
<h3><a class="toc-backref" href="#id66">Brief introduction</a><a class="headerlink" href="#brief-introduction" title="Permalink to this headline">¶</a></h3>
<p>Cpu0 is a 32-bit architecture. It has 16 general purpose registers (R0, …,
R15), co-processor registers (like Mips), and other special registers. Its
structure is illustrated in <a class="reference internal" href="#llvmstructure-f1"><span class="std std-numref">Fig. 3</span></a> below.</p>
<figure class="align-center" id="id43">
<span id="llvmstructure-f1"></span><a class="reference internal image-reference" href="_images/14.png"><img alt="_images/14.png" src="_images/14.png" style="width: 608px; height: 360px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 3 </span><span class="caption-text">Architectural block diagram of the Cpu0 processor</span><a class="headerlink" href="#id43" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>The registers are used for the following purposes:</p>
<table class="docutils align-default" id="id44">
<caption><span class="caption-number">Table 2 </span><span class="caption-text">Cpu0 general purpose registers (GPR)</span><a class="headerlink" href="#id44" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 29%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Register</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>R0</p></td>
<td><p>Constant register, value is 0</p></td>
</tr>
<tr class="row-odd"><td><p>R1-R10</p></td>
<td><p>General-purpose registers</p></td>
</tr>
<tr class="row-even"><td><p>R11</p></td>
<td><p>Global Pointer register (GP)</p></td>
</tr>
<tr class="row-odd"><td><p>R12</p></td>
<td><p>Frame Pointer register (FP)</p></td>
</tr>
<tr class="row-even"><td><p>R13</p></td>
<td><p>Stack Pointer register (SP)</p></td>
</tr>
<tr class="row-odd"><td><p>R14</p></td>
<td><p>Link Register (LR)</p></td>
</tr>
<tr class="row-even"><td><p>R15</p></td>
<td><p>Status Word Register (SW)</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="id45">
<caption><span class="caption-number">Table 3 </span><span class="caption-text">Cpu0 co-processor 0 registers (C0R)</span><a class="headerlink" href="#id45" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 31%" />
<col style="width: 69%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Register</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>Program Counter (PC)</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>Error Program Counter (EPC)</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="id46">
<caption><span class="caption-number">Table 4 </span><span class="caption-text">Cpu0 other registers</span><a class="headerlink" href="#id46" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 29%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Register</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>IR</p></td>
<td><p>Instruction register</p></td>
</tr>
<tr class="row-odd"><td><p>MAR</p></td>
<td><p>Memory Address Register (MAR)</p></td>
</tr>
<tr class="row-even"><td><p>MDR</p></td>
<td><p>Memory Data Register (MDR)</p></td>
</tr>
<tr class="row-odd"><td><p>HI</p></td>
<td><p>High part of MULT result</p></td>
</tr>
<tr class="row-even"><td><p>LO</p></td>
<td><p>Low part of MULT result</p></td>
</tr>
</tbody>
</table>
</section>
<section id="the-cpu0-instruction-set">
<h3><a class="toc-backref" href="#id67">The Cpu0 Instruction Set</a><a class="headerlink" href="#the-cpu0-instruction-set" title="Permalink to this headline">¶</a></h3>
<p>The Cpu0 instruction set can be divided into three types: L-type instructions,
which are generally associated with memory operations, A-type instructions for
arithmetic operations, and J-type instructions that are typically used when
altering control flow (i.e. jumps).
<a class="reference internal" href="#llvmstructure-f2"><span class="std std-numref">Fig. 4</span></a> illustrates how the bitfields are broken down
for each type of instruction.</p>
<figure class="align-center" id="id47">
<span id="llvmstructure-f2"></span><a class="reference internal image-reference" href="_images/22.png"><img alt="_images/22.png" src="_images/22.png" style="width: 601px; height: 331px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 4 </span><span class="caption-text">Cpu0’s three instruction formats</span><a class="headerlink" href="#id47" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>The Cpu0 has two ISA, the first ISA-I is cpu032I which hired CMP instruction
from ARM; the second ISA-II is cpu032II which hired SLT instruction from Mips.
The cpu032II include all cpu032I instruction set and add SLT, BEQ, …,
instructions. The main purpose to add cpu032II is for instruction set design
explanation. As you will see in later chapter (chapter Control flow statements),
the SLT instruction will has better performance than CMP old style instruction.
The following table details the cpu032I instruction set:</p>
<ul class="simple">
<li><p>First column F.: meaning Format.</p></li>
</ul>
<table class="colwidths-given docutils align-default" id="id48">
<caption><span class="caption-number">Table 5 </span><span class="caption-text">cpu032I Instruction Set</span><a class="headerlink" href="#id48" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 3%" />
<col style="width: 11%" />
<col style="width: 8%" />
<col style="width: 31%" />
<col style="width: 19%" />
<col style="width: 28%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>F.</p></th>
<th class="head"><p>Mnemonic</p></th>
<th class="head"><p>Opcode</p></th>
<th class="head"><p>Meaning</p></th>
<th class="head"><p>Syntax</p></th>
<th class="head"><p>Operation</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>L</p></td>
<td><p>NOP</p></td>
<td><p>00</p></td>
<td><p>No Operation</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>L</p></td>
<td><p>LD</p></td>
<td><p>01</p></td>
<td><p>Load word</p></td>
<td><p>LD Ra, [Rb+Cx]</p></td>
<td><p>Ra &lt;= [Rb+Cx]</p></td>
</tr>
<tr class="row-even"><td><p>L</p></td>
<td><p>ST</p></td>
<td><p>02</p></td>
<td><p>Store word</p></td>
<td><p>ST Ra, [Rb+Cx]</p></td>
<td><p>[Rb+Cx] &lt;= Ra</p></td>
</tr>
<tr class="row-odd"><td><p>L</p></td>
<td><p>LB</p></td>
<td><p>03</p></td>
<td><p>Load byte</p></td>
<td><p>LB Ra, [Rb+Cx]</p></td>
<td><p>Ra &lt;= (byte)[Rb+Cx] <a class="footnote-reference brackets" href="#lb-note" id="id4">3</a></p></td>
</tr>
<tr class="row-even"><td><p>L</p></td>
<td><p>LBu</p></td>
<td><p>04</p></td>
<td><p>Load byte unsigned</p></td>
<td><p>LBu Ra, [Rb+Cx]</p></td>
<td><p>Ra &lt;= (byte)[Rb+Cx] <a class="footnote-reference brackets" href="#lb-note" id="id5">3</a></p></td>
</tr>
<tr class="row-odd"><td><p>L</p></td>
<td><p>SB</p></td>
<td><p>05</p></td>
<td><p>Store byte</p></td>
<td><p>SB Ra, [Rb+Cx]</p></td>
<td><p>[Rb+Cx] &lt;= (byte)Ra</p></td>
</tr>
<tr class="row-even"><td><p>L</p></td>
<td><p>LH</p></td>
<td><p>06</p></td>
<td><p>Load half word</p></td>
<td><p>LH Ra, [Rb+Cx]</p></td>
<td><p>Ra &lt;= (2bytes)[Rb+Cx] <a class="footnote-reference brackets" href="#lb-note" id="id6">3</a></p></td>
</tr>
<tr class="row-odd"><td><p>L</p></td>
<td><p>LHu</p></td>
<td><p>07</p></td>
<td><p>Load half word unsigned</p></td>
<td><p>LHu Ra, [Rb+Cx]</p></td>
<td><p>Ra &lt;= (2bytes)[Rb+Cx] <a class="footnote-reference brackets" href="#lb-note" id="id7">3</a></p></td>
</tr>
<tr class="row-even"><td><p>L</p></td>
<td><p>SH</p></td>
<td><p>08</p></td>
<td><p>Store half word</p></td>
<td><p>SH Ra, [Rb+Cx]</p></td>
<td><p>[Rb+Cx] &lt;= Ra</p></td>
</tr>
<tr class="row-odd"><td><p>L</p></td>
<td><p>ADDiu</p></td>
<td><p>09</p></td>
<td><p>Add immediate</p></td>
<td><p>ADDiu Ra, Rb, Cx</p></td>
<td><p>Ra &lt;= (Rb + Cx)</p></td>
</tr>
<tr class="row-even"><td><p>L</p></td>
<td><p>ANDi</p></td>
<td><p>0C</p></td>
<td><p>AND imm</p></td>
<td><p>ANDi Ra, Rb, Cx</p></td>
<td><p>Ra &lt;= (Rb &amp; Cx)</p></td>
</tr>
<tr class="row-odd"><td><p>L</p></td>
<td><p>ORi</p></td>
<td><p>0D</p></td>
<td><p>OR</p></td>
<td><p>ORi Ra, Rb, Cx</p></td>
<td><p>Ra &lt;= (Rb | Cx)</p></td>
</tr>
<tr class="row-even"><td><p>L</p></td>
<td><p>XORi</p></td>
<td><p>0E</p></td>
<td><p>XOR</p></td>
<td><p>XORi Ra, Rb, Cx</p></td>
<td><p>Ra &lt;= (Rb ^ Cx)</p></td>
</tr>
<tr class="row-odd"><td><p>L</p></td>
<td><p>LUi</p></td>
<td><p>0F</p></td>
<td><p>Load upper</p></td>
<td><p>LUi Ra, Cx</p></td>
<td><p>Ra &lt;= (Cx &lt;&lt; 16)</p></td>
</tr>
<tr class="row-even"><td><p>A</p></td>
<td><p>ADDu</p></td>
<td><p>11</p></td>
<td><p>Add unsigned</p></td>
<td><p>ADD Ra, Rb, Rc</p></td>
<td><p>Ra &lt;= Rb + Rc <a class="footnote-reference brackets" href="#u-note" id="id8">4</a></p></td>
</tr>
<tr class="row-odd"><td><p>A</p></td>
<td><p>SUBu</p></td>
<td><p>12</p></td>
<td><p>Sub unsigned</p></td>
<td><p>SUB Ra, Rb, Rc</p></td>
<td><p>Ra &lt;= Rb - Rc <a class="footnote-reference brackets" href="#u-note" id="id9">4</a></p></td>
</tr>
<tr class="row-even"><td><p>A</p></td>
<td><p>ADD</p></td>
<td><p>13</p></td>
<td><p>Add</p></td>
<td><p>ADD Ra, Rb, Rc</p></td>
<td><p>Ra &lt;= Rb + Rc <a class="footnote-reference brackets" href="#u-note" id="id10">4</a></p></td>
</tr>
<tr class="row-odd"><td><p>A</p></td>
<td><p>SUB</p></td>
<td><p>14</p></td>
<td><p>Subtract</p></td>
<td><p>SUB Ra, Rb, Rc</p></td>
<td><p>Ra &lt;= Rb - Rc <a class="footnote-reference brackets" href="#u-note" id="id11">4</a></p></td>
</tr>
<tr class="row-even"><td><p>A</p></td>
<td><p>CLZ</p></td>
<td><p>15</p></td>
<td><p>Count Leading Zero</p></td>
<td><p>CLZ Ra, Rb</p></td>
<td><p>Ra &lt;= bits of leading zero on Rb</p></td>
</tr>
<tr class="row-odd"><td><p>A</p></td>
<td><p>CLO</p></td>
<td><p>16</p></td>
<td><p>Count Leading One</p></td>
<td><p>CLO Ra, Rb</p></td>
<td><p>Ra &lt;= bits of leading one on Rb</p></td>
</tr>
<tr class="row-even"><td><p>A</p></td>
<td><p>MUL</p></td>
<td><p>17</p></td>
<td><p>Multiply</p></td>
<td><p>MUL Ra, Rb, Rc</p></td>
<td><p>Ra &lt;= Rb * Rc</p></td>
</tr>
<tr class="row-odd"><td><p>A</p></td>
<td><p>AND</p></td>
<td><p>18</p></td>
<td><p>Bitwise and</p></td>
<td><p>AND Ra, Rb, Rc</p></td>
<td><p>Ra &lt;= Rb &amp; Rc</p></td>
</tr>
<tr class="row-even"><td><p>A</p></td>
<td><p>OR</p></td>
<td><p>19</p></td>
<td><p>Bitwise or</p></td>
<td><p>OR Ra, Rb, Rc</p></td>
<td><p>Ra &lt;= Rb | Rc</p></td>
</tr>
<tr class="row-odd"><td><p>A</p></td>
<td><p>XOR</p></td>
<td><p>1A</p></td>
<td><p>Bitwise exclusive or</p></td>
<td><p>XOR Ra, Rb, Rc</p></td>
<td><p>Ra &lt;= Rb ^ Rc</p></td>
</tr>
<tr class="row-even"><td><p>A</p></td>
<td><p>NOR</p></td>
<td><p>1B</p></td>
<td><p>Bitwise boolean nor</p></td>
<td><p>NOR Ra, Rb, Rc</p></td>
<td><p>Ra &lt;= Rb nor Rc</p></td>
</tr>
<tr class="row-odd"><td><p>A</p></td>
<td><p>ROL</p></td>
<td><p>1C</p></td>
<td><p>Rotate left</p></td>
<td><p>ROL Ra, Rb, Cx</p></td>
<td><p>Ra &lt;= Rb rol Cx</p></td>
</tr>
<tr class="row-even"><td><p>A</p></td>
<td><p>ROR</p></td>
<td><p>1D</p></td>
<td><p>Rotate right</p></td>
<td><p>ROR Ra, Rb, Cx</p></td>
<td><p>Ra &lt;= Rb ror Cx</p></td>
</tr>
<tr class="row-odd"><td><p>A</p></td>
<td><p>SHL</p></td>
<td><p>1E</p></td>
<td><p>Shift left</p></td>
<td><p>SHL Ra, Rb, Cx</p></td>
<td><p>Ra &lt;= Rb &lt;&lt; Cx</p></td>
</tr>
<tr class="row-even"><td><p>A</p></td>
<td><p>SHR</p></td>
<td><p>1F</p></td>
<td><p>Shift right</p></td>
<td><p>SHR Ra, Rb, Cx</p></td>
<td><p>Ra &lt;= Rb &gt;&gt; Cx</p></td>
</tr>
<tr class="row-odd"><td><p>A</p></td>
<td><p>SRA</p></td>
<td><p>20</p></td>
<td><p>Shift right</p></td>
<td><p>SRA Ra, Rb, Cx</p></td>
<td><p>Ra &lt;= Rb ‘&gt;&gt; Cx <a class="footnote-reference brackets" href="#sra-note" id="id12">6</a></p></td>
</tr>
<tr class="row-even"><td><p>A</p></td>
<td><p>SRAV</p></td>
<td><p>21</p></td>
<td><p>Shift right</p></td>
<td><p>SRAV Ra, Rb, Rc</p></td>
<td><p>Ra &lt;= Rb ‘&gt;&gt; Rc <a class="footnote-reference brackets" href="#sra-note" id="id13">6</a></p></td>
</tr>
<tr class="row-odd"><td><p>A</p></td>
<td><p>SHLV</p></td>
<td><p>22</p></td>
<td><p>Shift left</p></td>
<td><p>SHLV Ra, Rb, Rc</p></td>
<td><p>Ra &lt;= Rb &lt;&lt; Rc</p></td>
</tr>
<tr class="row-even"><td><p>A</p></td>
<td><p>SHRV</p></td>
<td><p>23</p></td>
<td><p>Shift right</p></td>
<td><p>SHRV Ra, Rb, Rc</p></td>
<td><p>Ra &lt;= Rb &gt;&gt; Rc</p></td>
</tr>
<tr class="row-odd"><td><p>A</p></td>
<td><p>ROL</p></td>
<td><p>24</p></td>
<td><p>Rotate left</p></td>
<td><p>ROL Ra, Rb, Rc</p></td>
<td><p>Ra &lt;= Rb rol Rc</p></td>
</tr>
<tr class="row-even"><td><p>A</p></td>
<td><p>ROR</p></td>
<td><p>25</p></td>
<td><p>Rotate right</p></td>
<td><p>ROR Ra, Rb, Rc</p></td>
<td><p>Ra &lt;= Rb ror Rc</p></td>
</tr>
<tr class="row-odd"><td><p>A</p></td>
<td><p>CMP</p></td>
<td><p>2A</p></td>
<td><p>Compare</p></td>
<td><p>CMP Ra, Rb</p></td>
<td><p>SW &lt;= (Ra cond Rb) <a class="footnote-reference brackets" href="#cond-note" id="id14">5</a></p></td>
</tr>
<tr class="row-even"><td><p>A</p></td>
<td><p>CMPu</p></td>
<td><p>2B</p></td>
<td><p>Compare</p></td>
<td><p>CMPu Ra, Rb</p></td>
<td><p>SW &lt;= (Ra cond Rb) <a class="footnote-reference brackets" href="#cond-note" id="id15">5</a></p></td>
</tr>
<tr class="row-odd"><td><p>J</p></td>
<td><p>JEQ</p></td>
<td><p>30</p></td>
<td><p>Jump if equal (==)</p></td>
<td><p>JEQ Cx</p></td>
<td><p>if SW(==), PC &lt;= PC + Cx</p></td>
</tr>
<tr class="row-even"><td><p>J</p></td>
<td><p>JNE</p></td>
<td><p>31</p></td>
<td><p>Jump if not equal (!=)</p></td>
<td><p>JNE Cx</p></td>
<td><p>if SW(!=), PC &lt;= PC + Cx</p></td>
</tr>
<tr class="row-odd"><td><p>J</p></td>
<td><p>JLT</p></td>
<td><p>32</p></td>
<td><p>Jump if less than (&lt;)</p></td>
<td><p>JLT Cx</p></td>
<td><p>if SW(&lt;), PC &lt;= PC + Cx</p></td>
</tr>
<tr class="row-even"><td><p>J</p></td>
<td><p>JGT</p></td>
<td><p>33</p></td>
<td><p>Jump if greater than (&gt;)</p></td>
<td><p>JGT Cx</p></td>
<td><p>if SW(&gt;), PC &lt;= PC + Cx</p></td>
</tr>
<tr class="row-odd"><td><p>J</p></td>
<td><p>JLE</p></td>
<td><p>34</p></td>
<td><p>Jump if less than or equals (&lt;=)</p></td>
<td><p>JLE Cx</p></td>
<td><p>if SW(&lt;=), PC &lt;= PC + Cx</p></td>
</tr>
<tr class="row-even"><td><p>J</p></td>
<td><p>JGE</p></td>
<td><p>35</p></td>
<td><p>Jump if greater than or equals (&gt;=)</p></td>
<td><p>JGE Cx</p></td>
<td><p>if SW(&gt;=), PC &lt;= PC + Cx</p></td>
</tr>
<tr class="row-odd"><td><p>J</p></td>
<td><p>JMP</p></td>
<td><p>36</p></td>
<td><p>Jump (unconditional)</p></td>
<td><p>JMP Cx</p></td>
<td><p>PC &lt;= PC + Cx</p></td>
</tr>
<tr class="row-even"><td><p>J</p></td>
<td><p>JALR</p></td>
<td><p>39</p></td>
<td><p>Indirect jump</p></td>
<td><p>JALR Rb</p></td>
<td><p>LR &lt;= PC; PC &lt;= Rb <a class="footnote-reference brackets" href="#call-note" id="id16">7</a></p></td>
</tr>
<tr class="row-odd"><td><p>J</p></td>
<td><p>BAL</p></td>
<td><p>3A</p></td>
<td><p>Branch and link</p></td>
<td><p>BAL Cx</p></td>
<td><p>LR &lt;= PC; PC &lt;= PC + Cx</p></td>
</tr>
<tr class="row-even"><td><p>J</p></td>
<td><p>JSUB</p></td>
<td><p>3B</p></td>
<td><p>Jump to subroutine</p></td>
<td><p>JSUB Cx</p></td>
<td><p>LR &lt;= PC; PC &lt;= PC + Cx</p></td>
</tr>
<tr class="row-odd"><td><p>J</p></td>
<td><p>JR/RET</p></td>
<td><p>3C</p></td>
<td><p>Return from subroutine</p></td>
<td><p>JR $1 or RET LR</p></td>
<td><p>PC &lt;= LR <a class="footnote-reference brackets" href="#jr-note" id="id17">8</a></p></td>
</tr>
<tr class="row-even"><td><p>A</p></td>
<td><p>MULT</p></td>
<td><p>41</p></td>
<td><p>Multiply for 64 bits result</p></td>
<td><p>MULT Ra, Rb</p></td>
<td><p>(HI,LO) &lt;= MULT(Ra,Rb)</p></td>
</tr>
<tr class="row-odd"><td><p>A</p></td>
<td><p>MULTU</p></td>
<td><p>42</p></td>
<td><p>MULT for unsigned 64 bits</p></td>
<td><p>MULTU Ra, Rb</p></td>
<td><p>(HI,LO) &lt;= MULTU(Ra,Rb)</p></td>
</tr>
<tr class="row-even"><td><p>A</p></td>
<td><p>DIV</p></td>
<td><p>43</p></td>
<td><p>Divide</p></td>
<td><p>DIV Ra, Rb</p></td>
<td><p>HI&lt;=Ra%Rb, LO&lt;=Ra/Rb</p></td>
</tr>
<tr class="row-odd"><td><p>A</p></td>
<td><p>DIVU</p></td>
<td><p>44</p></td>
<td><p>Divide unsigned</p></td>
<td><p>DIVU Ra, Rb</p></td>
<td><p>HI&lt;=Ra%Rb, LO&lt;=Ra/Rb</p></td>
</tr>
<tr class="row-even"><td><p>A</p></td>
<td><p>MFHI</p></td>
<td><p>46</p></td>
<td><p>Move HI to GPR</p></td>
<td><p>MFHI Ra</p></td>
<td><p>Ra &lt;= HI</p></td>
</tr>
<tr class="row-odd"><td><p>A</p></td>
<td><p>MFLO</p></td>
<td><p>47</p></td>
<td><p>Move LO to GPR</p></td>
<td><p>MFLO Ra</p></td>
<td><p>Ra &lt;= LO</p></td>
</tr>
<tr class="row-even"><td><p>A</p></td>
<td><p>MTHI</p></td>
<td><p>48</p></td>
<td><p>Move GPR to HI</p></td>
<td><p>MTHI Ra</p></td>
<td><p>HI &lt;= Ra</p></td>
</tr>
<tr class="row-odd"><td><p>A</p></td>
<td><p>MTLO</p></td>
<td><p>49</p></td>
<td><p>Move GPR to LO</p></td>
<td><p>MTLO Ra</p></td>
<td><p>LO &lt;= Ra</p></td>
</tr>
<tr class="row-even"><td><p>A</p></td>
<td><p>MFC0</p></td>
<td><p>50</p></td>
<td><p>Move C0R to GPR</p></td>
<td><p>MFC0 Ra, Rb</p></td>
<td><p>Ra &lt;= Rb</p></td>
</tr>
<tr class="row-odd"><td><p>A</p></td>
<td><p>MTC0</p></td>
<td><p>51</p></td>
<td><p>Move GPR to C0R</p></td>
<td><p>MTC0 Ra, Rb</p></td>
<td><p>Ra &lt;= Rb</p></td>
</tr>
<tr class="row-even"><td><p>A</p></td>
<td><p>C0MOV</p></td>
<td><p>52</p></td>
<td><p>Move C0R to C0R</p></td>
<td><p>C0MOV Ra, Rb</p></td>
<td><p>Ra &lt;= Rb</p></td>
</tr>
</tbody>
</table>
<p>The following table details the cpu032II instruction set added:</p>
<table class="colwidths-given docutils align-default" id="id49">
<caption><span class="caption-number">Table 6 </span><span class="caption-text">cpu032II Instruction Set</span><a class="headerlink" href="#id49" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 3%" />
<col style="width: 11%" />
<col style="width: 8%" />
<col style="width: 31%" />
<col style="width: 19%" />
<col style="width: 28%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>F.</p></th>
<th class="head"><p>Mnemonic</p></th>
<th class="head"><p>Opcode</p></th>
<th class="head"><p>Meaning</p></th>
<th class="head"><p>Syntax</p></th>
<th class="head"><p>Operation</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>L</p></td>
<td><p>SLTi</p></td>
<td><p>26</p></td>
<td><p>Set less Then</p></td>
<td><p>SLTi Ra, Rb, Cx</p></td>
<td><p>Ra &lt;= (Rb &lt; Cx)</p></td>
</tr>
<tr class="row-odd"><td><p>L</p></td>
<td><p>SLTiu</p></td>
<td><p>27</p></td>
<td><p>SLTi unsigned</p></td>
<td><p>SLTiu Ra, Rb, Cx</p></td>
<td><p>Ra &lt;= (Rb &lt; Cx)</p></td>
</tr>
<tr class="row-even"><td><p>A</p></td>
<td><p>SLT</p></td>
<td><p>28</p></td>
<td><p>Set less Then</p></td>
<td><p>SLT Ra, Rb, Rc</p></td>
<td><p>Ra &lt;= (Rb &lt; Rc)</p></td>
</tr>
<tr class="row-odd"><td><p>A</p></td>
<td><p>SLTu</p></td>
<td><p>29</p></td>
<td><p>SLT unsigned</p></td>
<td><p>SLTu Ra, Rb, Rc</p></td>
<td><p>Ra &lt;= (Rb &lt; Rc)</p></td>
</tr>
<tr class="row-even"><td><p>L</p></td>
<td><p>BEQ</p></td>
<td><p>37</p></td>
<td><p>Branch if equal</p></td>
<td><p>BEQ Ra, Rb, Cx</p></td>
<td><p>if (Ra==Rb), PC &lt;= PC + Cx</p></td>
</tr>
<tr class="row-odd"><td><p>L</p></td>
<td><p>BNE</p></td>
<td><p>38</p></td>
<td><p>Branch if not equal</p></td>
<td><p>BNE Ra, Rb, Cx</p></td>
<td><p>if (Ra!=Rb), PC &lt;= PC + Cx</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>Cpu0 unsigned instructions</strong></p>
<p>Like Mips, except DIVU, the mathematic unsigned instructions such as ADDu and
SUBu, are instructions of no overflow exception.
The ADDu and SUBu handle both signed and unsigned integers well.
For example, (ADDu 1, -2) is -1; (ADDu 0x01, 0xfffffffe) is 0xffffffff = (4G
- 1).
If you treat the result is negative then it is -1.
On the other hand, it’s (+4G - 1) if you treat the result is positive.</p>
</div>
<section id="why-not-using-add-instead-of-sub">
<h4><a class="toc-backref" href="#id68">Why not using ADD instead of SUB?</a><a class="headerlink" href="#why-not-using-add-instead-of-sub" title="Permalink to this headline">¶</a></h4>
<p>From text book of computer introduction, we know SUB can be replaced by
ADD as follows,</p>
<ul class="simple">
<li><p>(A - B) = (A + (-B))</p></li>
</ul>
<p>Since Mips uses 32 bits to represent int type of C language, if B is the
value of -2G, then</p>
<ul class="simple">
<li><p>(A - (-2G)) = (A + (2G))</p></li>
</ul>
<p>But the problem is value -2G can be represented in 32 bits machine while 2G
cannot,
since the range of 2’s complement representation for 32 bits is (-2G .. 2G-1).
The 2’s complement reprentation has the merit of fast computation in circuits
design, it is widely used in real CPU implementation.
That’s why almost every CPU create SUB instruction, rather than using ADD
instead of.</p>
</section>
</section>
<section id="the-status-register">
<h3><a class="toc-backref" href="#id69">The Status Register</a><a class="headerlink" href="#the-status-register" title="Permalink to this headline">¶</a></h3>
<p>The Cpu0 status word register (SW) contains the state of the Negative (N),
Zero (Z), Carry (C), Overflow (V), Debug (D), Mode (M), and Interrupt (I) flags.
The bit layout of the SW register is shown in <a class="reference internal" href="#llvmstructure-f3"><span class="std std-numref">Fig. 5</span></a>
below.</p>
<figure class="align-center" id="id50">
<span id="llvmstructure-f3"></span><a class="reference internal image-reference" href="_images/3.png"><img alt="_images/3.png" src="_images/3.png" style="width: 684px; height: 126px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 5 </span><span class="caption-text">Cpu0 status word (SW) register</span><a class="headerlink" href="#id50" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>When a CMP Ra, Rb instruction executes, the condition flags will change.
For example:</p>
<ul class="simple">
<li><p>If Ra &gt; Rb, then N = 0, Z = 0</p></li>
<li><p>If Ra &lt; Rb, then N = 1, Z = 0</p></li>
<li><p>If Ra = Rb, then N = 0, Z = 1</p></li>
</ul>
<p>The direction (i.e. taken/not taken) of the conditional jump instructions JGT,
JLT, JGE, JLE, JEQ, JNE is determined by the N and Z flags in the SW register.</p>
</section>
<section id="cpu0-s-stages-of-instruction-execution">
<h3><a class="toc-backref" href="#id70">Cpu0’s Stages of Instruction Execution</a><a class="headerlink" href="#cpu0-s-stages-of-instruction-execution" title="Permalink to this headline">¶</a></h3>
<p>The Cpu0 architecture has a five-stage pipeline. The stages are instruction
fetch (IF), instruction decode (ID), execute (EX), memory access (MEM) and
write backe (WB).
Here is a description of what happens in the processor for each stage:</p>
<ol class="arabic simple">
<li><p>Instruction fetch (IF)</p></li>
</ol>
<ul class="simple">
<li><p>The Cpu0 fetches the instruction pointed to by the Program Counter (PC) into
the Instruction Register (IR): IR = [PC].</p></li>
<li><p>The PC is then updated to point to the next instruction: PC = PC + 4.</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p>Instruction decode (ID)</p></li>
</ol>
<ul class="simple">
<li><p>The control unit decodes the instruction stored in IR, which routes necessary
data stored in registers to the ALU, and sets the ALU’s operation mode based
on the current instruction’s opcode.</p></li>
</ul>
<ol class="arabic simple" start="3">
<li><p>Execute (EX)</p></li>
</ol>
<ul class="simple">
<li><p>The ALU executes the operation designated by the control unit upon data in
registers.
Except load and store instructions, the result is stored in the destination
register after the ALU is done.</p></li>
</ul>
<ol class="arabic simple" start="4">
<li><p>Memory access (MEM)</p></li>
</ol>
<ul class="simple">
<li><p>Read data from data cache to pipeline register MEM/WB if it is load
instruction; write data from register to data cache if it is strore
instruction.</p></li>
</ul>
<ol class="arabic simple" start="5">
<li><p>Write-back (WB)</p></li>
</ol>
<ul class="simple">
<li><p>Move data from pipeline register MEM/WB to Register if it is load instruction.</p></li>
</ul>
</section>
<section id="cpu0-s-interrupt-vector">
<h3><a class="toc-backref" href="#id71">Cpu0’s Interrupt Vector</a><a class="headerlink" href="#cpu0-s-interrupt-vector" title="Permalink to this headline">¶</a></h3>
<table class="docutils align-default" id="id51">
<caption><span class="caption-number">Table 7 </span><span class="caption-text">Cpu0’s Interrupt Vector</span><a class="headerlink" href="#id51" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 40%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Address</p></th>
<th class="head"><p>type</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x00</p></td>
<td><p>Reset</p></td>
</tr>
<tr class="row-odd"><td><p>0x04</p></td>
<td><p>Error Handle</p></td>
</tr>
<tr class="row-even"><td><p>0x08</p></td>
<td><p>Interrupt</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="llvm-structure">
<h2><a class="toc-backref" href="#id72">LLVM Structure</a><a class="headerlink" href="#llvm-structure" title="Permalink to this headline">¶</a></h2>
<p>This section introduces the compiler data structure, algorithm and mechanism
that llvm uses.</p>
<section id="three-phase-design">
<h3><a class="toc-backref" href="#id73">Three-phase design</a><a class="headerlink" href="#three-phase-design" title="Permalink to this headline">¶</a></h3>
<p>The text in this and the following sub-section comes from the AOSA chapter on
LLVM written by Chris Lattner <a class="footnote-reference brackets" href="#aosa-book" id="id18">10</a>.</p>
<p>The most popular design for a traditional static compiler (like most C
compilers) is the three phase design whose major components are the front end,
the optimizer and the back end, as seen in <a class="reference internal" href="#llvmstructure-f6"><span class="std std-numref">Fig. 6</span></a>.
The front end parses source code, checking it for errors, and builds a
language-specific Abstract Syntax Tree (AST) to represent the input code.
The AST is optionally converted to a new representation for optimization, and
the optimizer and back end are run on the code.</p>
<figure class="align-center" id="id52">
<span id="llvmstructure-f6"></span><a class="reference internal image-reference" href="_images/61.png"><img alt="_images/61.png" src="_images/61.png" style="width: 329.0px; height: 44.099999999999994px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 6 </span><span class="caption-text">Three Major Components of a Three Phase Compiler</span><a class="headerlink" href="#id52" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>The optimizer is responsible for doing a broad variety of transformations to
try to improve the code’s running time, such as eliminating redundant
computations, and is usually more or less independent of language and target.
The back end (also known as the code generator) then maps the code onto the
target instruction set.
In addition to making correct code, it is responsible for generating good code
that takes advantage of unusual features of the supported architecture.
Common parts of a compiler back end include instruction selection, register
allocation, and instruction scheduling.</p>
<p>This model applies equally well to interpreters and JIT compilers.
The Java Virtual Machine (JVM) is also an implementation of this model, which
uses Java bytecode as the interface between the front end and optimizer.</p>
<p>The most important win of this classical design comes when a compiler decides
to support multiple source languages or target architectures.
If the compiler uses a common code representation in its optimizer, then a
front end can be written for any language that can compile to it, and a back
end can be written for any target that can compile from it, as shown in
<a class="reference internal" href="#llvmstructure-f7"><span class="std std-numref">Fig. 7</span></a>.</p>
<figure class="align-center" id="id53">
<span id="llvmstructure-f7"></span><a class="reference internal image-reference" href="_images/7.png"><img alt="_images/7.png" src="_images/7.png" style="width: 585.9px; height: 209.29999999999998px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 7 </span><span class="caption-text">Retargetablity</span><a class="headerlink" href="#id53" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>With this design, porting the compiler to support a new source language (e.g.,
Algol or BASIC) requires implementing a new front end, but the existing
optimizer and back end can be reused.
If these parts weren’t separated, implementing a new source language would
require starting over from scratch, so supporting N targets and M source
languages would need N*M compilers.</p>
<p>Another advantage of the three-phase design (which follows directly from
retargetability) is that the compiler serves a broader set of programmers than
it would if it only supported one source language and one target.
For an open source project, this means that there is a larger community of
potential contributors to draw from, which naturally leads to more enhancements
and improvements to the compiler.
This is the reason why open source compilers that serve many communities (like
GCC) tend to generate better optimized machine code than narrower compilers
like FreePASCAL.
This isn’t the case for proprietary compilers, whose quality is directly
related to the project’s budget.
For example, the Intel ICC Compiler is widely known for the quality of code it
generates, even though it serves a narrow audience.</p>
<p>A final major win of the three-phase design is that the skills required to
implement a front end are different than those required for the optimizer and
back end.
Separating these makes it easier for a “front-end person” to enhance and
maintain their part of the compiler.
While this is a social issue, not a technical one, it matters a lot in
practice, particularly for open source projects that want to reduce the barrier
to contributing as much as possible.</p>
<p>The most important aspect of its design is the LLVM Intermediate Representation
(IR), which is the form it uses to represent code in the compiler.
LLVM IR is designed to host mid-level analyses and transformations that you
find in the optimizer chapter of a compiler.
It was designed with many specific goals in mind, including supporting
lightweight runtime optimizations, cross-function/interprocedural
optimizations, whole program analysis, and aggressive restructuring
transformations, etc.
The most important aspect of it, though, is that it is itself defined as a
first class language with well-defined semantics.
To make this concrete, here is a simple example of a .ll file:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@add1</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="nl">entry:</span><span class="w"></span>
<span class="w">  </span><span class="nv">%tmp1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="nv">%b</span><span class="w"></span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%tmp1</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@add2</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="nl">entry:</span><span class="w"></span>
<span class="w">  </span><span class="nv">%tmp1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">eq</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="w"></span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%tmp1</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%done</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%recurse</span><span class="w"></span>
<span class="nl">recurse:</span><span class="w"></span>
<span class="w">  </span><span class="nv">%tmp2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">sub</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="w"></span>
<span class="w">  </span><span class="nv">%tmp3</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="w"></span>
<span class="w">  </span><span class="nv">%tmp4</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@add2</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%tmp2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%tmp3</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%tmp4</span><span class="w"></span>
<span class="nl">done:</span><span class="w"></span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Above LLVM IR corresponds to this C code, which provides two different ways to</span>
<span class="c1">//  add integers:</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">add1</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// Perhaps not the most efficient way to add two numbers.</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">add2</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">add2</span><span class="p">(</span><span class="n">a</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>As you can see from this example, LLVM IR is a low-level RISC-like virtual
instruction set.
Like a real RISC instruction set, it supports linear sequences of simple
instructions like add, subtract, compare, and branch.
These instructions are in three address form, which means that they take some
number of inputs and produce a result in a different register.
LLVM IR supports labels and generally looks like a weird form of assembly
language.</p>
<p>Unlike most RISC instruction sets, LLVM is strongly typed with a simple type
system (e.g., i32 is a 32-bit integer, i32** is a pointer to pointer to 32-bit
integer) and some details of the machine are abstracted away.
For example, the calling convention is abstracted through call and ret
instructions and explicit arguments.
Another significant difference from machine code is that the LLVM IR doesn’t
use a fixed set of named registers, it uses an infinite set of temporaries
named with a % character.</p>
<p>Beyond being implemented as a language, LLVM IR is actually defined in three
isomorphic forms: the textual format above, an in-memory data structure
inspected and modified by optimizations themselves, and an efficient and dense
on-disk binary “bitcode” format.
The LLVM Project also provides tools to convert the on-disk format from text to
binary: llvm-as assembles the textual .ll file into a .bc file containing the
bitcode goop and llvm-dis turns a .bc file into a .ll file.</p>
<p>The intermediate representation of a compiler is interesting because it can be
a “perfect world” for the compiler optimizer: unlike the front end and back end
of the compiler, the optimizer isn’t constrained by either a specific source
language or a specific target machine.
On the other hand, it has to serve both well: it has to be designed to be easy
for a front end to generate and be expressive enough to allow important
optimizations to be performed for real targets.</p>
</section>
<section id="llvm-s-target-description-files-td">
<h3><a class="toc-backref" href="#id74">LLVM’s Target Description Files: .td</a><a class="headerlink" href="#llvm-s-target-description-files-td" title="Permalink to this headline">¶</a></h3>
<p>The “mix and match” approach allows target authors to choose what makes sense
for their architecture and permits a large amount of code reuse across
different targets.
This brings up another challenge: each shared component needs to be able to
reason about target specific properties in a generic way.
For example, a shared register allocator needs to know the register file of
each target and the constraints that exist between instructions and their
register operands.
LLVM’s solution to this is for each target to provide a target description
in a declarative domain-specific language (a set of .td files) processed by the
tblgen tool.
The (simplified) build process for the x86 target is shown in
<a class="reference internal" href="#llvmstructure-f8"><span class="std std-numref">Fig. 8</span></a>.</p>
<figure class="align-center" id="id54">
<span id="llvmstructure-f8"></span><a class="reference internal image-reference" href="_images/8.png"><img alt="_images/8.png" src="_images/8.png" style="width: 595.0px; height: 299.59999999999997px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 8 </span><span class="caption-text">Simplified x86 Target Definition</span><a class="headerlink" href="#id54" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>The different subsystems supported by the .td files allow target authors to
build up the different pieces of their target.
For example, the x86 back end defines a register class that holds all of its
32-bit registers named “GR32” (in the .td files, target specific definitions
are all caps) like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">def</span><span class="w"> </span><span class="n">GR32</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">RegisterClass</span><span class="o">&lt;</span><span class="p">[</span><span class="n">i32</span><span class="p">],</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="p">[</span><span class="n">EAX</span><span class="p">,</span><span class="w"> </span><span class="n">ECX</span><span class="p">,</span><span class="w"> </span><span class="n">EDX</span><span class="p">,</span><span class="w"> </span><span class="n">ESI</span><span class="p">,</span><span class="w"> </span><span class="n">EDI</span><span class="p">,</span><span class="w"> </span><span class="n">EBX</span><span class="p">,</span><span class="w"> </span><span class="n">EBP</span><span class="p">,</span><span class="w"> </span><span class="n">ESP</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="n">R8D</span><span class="p">,</span><span class="w"> </span><span class="n">R9D</span><span class="p">,</span><span class="w"> </span><span class="n">R10D</span><span class="p">,</span><span class="w"> </span><span class="n">R11D</span><span class="p">,</span><span class="w"> </span><span class="n">R14D</span><span class="p">,</span><span class="w"> </span><span class="n">R15D</span><span class="p">,</span><span class="w"> </span><span class="n">R12D</span><span class="p">,</span><span class="w"> </span><span class="n">R13D</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The language used in .td files are Target(Hardware) Description Language that
let llvm backend compiler engineers to define the transformation for llvm IR
and the machine instructions of their CPUs. In frontend, compiler development
tools provide the “Parser Generator” for compiler development; in backend,
they provide the “Machine Code Generator” for development, as the following
figures.</p>
<div class="graphviz"><img src="_images/graphviz-e80cd3a8feebb119d4ff6e27663a4244fd0170ad.png" alt="digraph G {
  rankdir=TB;
  subgraph cluster_0 {
	node [color=black]; &quot;parser generator such as yacc/lex&quot;;
	node [shape=note];  &quot;code gen function embedded in BNF&quot;, &quot;regular expression + BNF&quot;, &quot;front parser&quot;;
	&quot;code gen function embedded in BNF&quot; -&gt; &quot;parser generator such as yacc/lex&quot;;
	&quot;regular expression + BNF&quot; -&gt; &quot;parser generator such as yacc/lex&quot;;
	&quot;parser generator such as yacc/lex&quot; -&gt; &quot;front parser&quot;;
  }
  subgraph cluster_1 {
	node [color=black]; &quot;yacc/lex&quot;;
	node [shape=note];  &quot;*.c, *.cpp&quot;, &quot;*.y, *.l&quot;, &quot;front parser: *.cpp&quot;;
	&quot;*.c, *.cpp&quot; -&gt; &quot;yacc/lex&quot;;
	&quot;*.y, *.l&quot; -&gt; &quot;yacc/lex&quot;;
	&quot;yacc/lex&quot; -&gt; &quot;front parser: *.cpp&quot;;
  }
  label = &quot;Front TableGen Flow&quot;;

}" class="graphviz" /></div>
<div class="graphviz"><img src="_images/graphviz-7240d3a52d93daa30d1869b1ca57aa1743b8c555.png" alt="digraph G {
  rankdir=TB;
  subgraph cluster_0 {
	node [color=black]; &quot;TableGen&quot;;
	node [shape=note];  &quot;Hardware/Target Description Language Files&quot;, &quot;Pattern Match files in c/c++\nfor IR -&gt; Machine Instructions&quot;;
	&quot;Hardware/Target Description Language Files&quot; -&gt; &quot;TableGen&quot;;
	&quot;TableGen&quot; -&gt; &quot;Pattern Match files in c/c++\nfor IR -&gt; Machine Instructions&quot;;
  }
  subgraph cluster_1 {
	node [color=black]; &quot;llvm-tblgen&quot;;
	node [shape=note];  &quot;*.td&quot;, &quot;*.inc&quot;;
	&quot;*.td&quot; -&gt; &quot;llvm-tblgen&quot; -&gt; &quot;*.inc&quot;;
  }
  label = &quot;llvm TableGen Flow&quot;;

}" class="graphviz" /></div>
<p>Since the c++’s grammar is more context-sensitive than context-free, llvm
frontend project clang uses handcode parser without BNF generator tools.
In backend development, the IR to machine instructions transformation can
get great benefits from TableGen tools. Though c++ compiler cannot get
benefit from BNF generator tools, many computer languages and script languages
are more context-free and can get benefit from the tools.</p>
<p>The following come from wiki:</p>
<p>Java syntax has a context-free grammar that can be parsed by a simple LALR
parser. Parsing C++ is more complicated <a class="footnote-reference brackets" href="#java-cpp" id="id19">9</a>.</p>
<p>The gnu g++ compiler abandoned BNF tools since version 3.x.
I think another reason beyond that c++ has more context-sensitive grammar is
handcode parser can provide better error diagnosis than BNF tool since
BNF tool always select the rules from BNF grammar if match.</p>
</section>
<section id="llvm-code-generation-sequence">
<h3><a class="toc-backref" href="#id75">LLVM Code Generation Sequence</a><a class="headerlink" href="#llvm-code-generation-sequence" title="Permalink to this headline">¶</a></h3>
<p>Following diagram come from tricore_llvm.pdf.</p>
<figure class="align-center" id="id55">
<span id="llvmstructure-f9"></span><a class="reference internal image-reference" href="_images/9.png"><img alt="_images/9.png" src="_images/9.png" style="width: 1030px; height: 537px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 9 </span><span class="caption-text">tricore_llvm.pdf: Code generation sequence. On the path from LLVM code to
assembly code, numerous passes are run through and several data structures
are used to represent the intermediate results.</span><a class="headerlink" href="#id55" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>LLVM is a Static Single Assignment (SSA) based representation.
LLVM provides an infinite virtual registers which can hold values of primitive
type (integral, floating point, or pointer values).
So, every operand can be saved in different virtual register in llvm SSA
representation.
Comment is “;” in llvm representation.
Following is the llvm SSA instructions.</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%a</span><span class="w">  </span><span class="c">; store i32 type of 0 to virtual register %a, %a is</span>
<span class="w">            </span><span class="c">;  pointer type which point to i32 value</span>
<span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%c</span><span class="w"> </span><span class="c">; store %b contents to %c point to, %b isi32 type virtual</span>
<span class="w">            </span><span class="c">;  register, %c is pointer type which point to i32 value.</span>
<span class="nv">%a1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%a</span><span class="w">    </span><span class="c">; load the memory value where %a point to and assign the</span>
<span class="w">            </span><span class="c">;  memory value to %a1</span>
<span class="nv">%a3</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a2</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="w">  </span><span class="c">; add %a2 and 1 and save to %a3</span>
</pre></div>
</div>
<p>We explain the code generation process as below.
If you don’t feel comfortable, please check tricore_llvm.pdf section 4.2 first.
You can read “The LLVM Target-Independent Code Generator” from here <a class="footnote-reference brackets" href="#codegen" id="id20">12</a>
and “LLVM Language Reference Manual” from here <a class="footnote-reference brackets" href="#langref" id="id21">13</a>
before go ahead, but we think the section
4.2 of tricore_llvm.pdf is enough and suggesting you read the web site
documents as above only when you are still not
quite understand, even if you have read the articles of this section and
next two sections for DAG and Instruction Selection.</p>
<ol class="arabic simple">
<li><p>Instruction Selection</p></li>
</ol>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">// In this stage, transfer the llvm opcode into machine opcode, but the operand</span>
<span class="go">//  still is llvm virtual operand.</span>
<span class="go">    store i16 0, i16* %a // store 0 of i16 type to where virtual register %a</span>
<span class="go">                         //  point to.</span>
<span class="go">=&gt;  st i16 0, i32* %a    // Use Cpu0 backend instruction st instead of IR store.</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p>Scheduling and Formation</p></li>
</ol>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">// In this stage, reorder the instructions sequence for optimization in</span>
<span class="go">//  instructions cycle or in register pressure.</span>
<span class="go">    st i32 %a, i16* %b,  i16 5 // st %a to *(%b+5)</span>
<span class="go">    st %b, i32* %c, i16 0</span>
<span class="gp">    %</span><span class="nv">d</span> <span class="o">=</span> ld i32* %c

<span class="go">// Transfer above instructions order as follows. In RISC CPU of Mips, the ld</span>
<span class="go">//  %c uses the result of the previous instruction st %c. So it must waits 1</span>
<span class="go">//  cycle. Meaning the ld cannot follow st immediately.</span>
<span class="go">=&gt;  st %b, i32* %c, i16 0</span>
<span class="go">    st i32 %a, i16* %b,  i16 5</span>
<span class="gp">    %</span><span class="nv">d</span> <span class="o">=</span> ld i32* %c, i16 <span class="m">0</span>
<span class="go">// If without reorder instructions, a instruction nop which do nothing must be</span>
<span class="go">//  filled, contribute one instruction cycle more than optimization. (Actually,</span>
<span class="go">//  Mips is scheduled with hardware dynamically and will insert nop between st</span>
<span class="go">//  and ld instructions if compiler didn&#39;t insert nop.)</span>
<span class="go">    st i32 %a, i16* %b,  i16 5</span>
<span class="go">    st %b, i32* %c, i16 0</span>
<span class="go">    nop</span>
<span class="gp">    %</span><span class="nv">d</span> <span class="o">=</span> ld i32* %c, i16 <span class="m">0</span>

<span class="go">// Minimum register pressure</span>
<span class="go">//  Suppose %c is alive after the instructions basic block (meaning %c will be</span>
<span class="go">//  used after the basic block), %a and %b are not alive after that.</span>
<span class="go">// The following no-reorder-version need 3 registers at least</span>
<span class="gp">    %</span><span class="nv">a</span> <span class="o">=</span> add i32 <span class="m">1</span>, i32 <span class="m">0</span>
<span class="gp">    %</span><span class="nv">b</span> <span class="o">=</span> add i32 <span class="m">2</span>, i32 <span class="m">0</span>
<span class="go">    st %a,  i32* %c, 1</span>
<span class="go">    st %b,  i32* %c, 2</span>

<span class="go">// The reorder version needs 2 registers only (by allocate %a and %b in the same</span>
<span class="go">//  register)</span>
<span class="go">=&gt; %a = add i32 1, i32 0</span>
<span class="go">    st %a,  i32* %c, 1</span>
<span class="gp">    %</span><span class="nv">b</span> <span class="o">=</span> add i32 <span class="m">2</span>, i32 <span class="m">0</span>
<span class="go">    st %b,  i32* %c, 2</span>
</pre></div>
</div>
<ol class="arabic" start="3">
<li><p>SSA-based Machine Code Optimization</p>
<p>For example, common expression remove, shown in next section DAG.</p>
</li>
<li><p>Register Allocation</p>
<p>Allocate real register for virtual register.</p>
</li>
<li><p>Prologue/Epilogue Code Insertion</p>
<p>Explain in section Add Prologue/Epilogue functions</p>
</li>
<li><p>Late Machine Code Optimizations</p>
<p>Any “last-minute” peephole optimizations of the final machine code can be
applied during this phase.
For example, replace x = x * 2 by x = x &lt; 1 for integer operand.</p>
</li>
<li><p>Code Emission</p>
<p>Finally, the completed machine code is emitted. For static compilation,
the end result is an assembly code file; for JIT compilation, the opcodes
of the machine instructions are written into memory.</p>
</li>
</ol>
<p>The llvm code generation sequence also can be obtained by
<code class="docutils literal notranslate"><span class="pre">llc</span> <span class="pre">-debug-pass=Structure</span></code> as the following. The first 4 code generation
sequences from <a class="reference internal" href="#llvmstructure-f9"><span class="std std-numref">Fig. 9</span></a> are in the
<strong>‘DAG-&gt;DAG Pattern Instruction Selection’</strong> of the <code class="docutils literal notranslate"><span class="pre">llc</span> <span class="pre">-debug-pass=Structure</span></code>
displayed. The order of Peephole Optimizations and Prologue/Epilogue Insertion
is inconsistent between <a class="reference internal" href="#llvmstructure-f9"><span class="std std-numref">Fig. 9</span></a> and
<code class="docutils literal notranslate"><span class="pre">llc</span> <span class="pre">-debug-pass=Structure</span></code> (please check the * in the following).
No need to be bothered with this since the the LLVM is under development and
changed from time to time.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-79-200:input Jonathan$ </span>llc --help-hidden
<span class="go">OVERVIEW: llvm system compiler</span>

<span class="go">USAGE: llc [options] &lt;input bitcode&gt;</span>

<span class="go">OPTIONS:</span>
<span class="go">...</span>
<span class="go">  -debug-pass                             - Print PassManager debugging information</span>
<span class="go">    =None                                 -   disable debug output</span>
<span class="go">    =Arguments                            -   print pass arguments to pass to &#39;opt&#39;</span>
<span class="go">    =Structure                            -   print pass structure before run()</span>
<span class="go">    =Executions                           -   print pass name before it is executed</span>
<span class="go">    =Details                              -   print pass details when it is executed</span>

<span class="gp">118-165-79-200:input Jonathan$ </span>llc -march<span class="o">=</span>mips -debug-pass<span class="o">=</span>Structure ch3.bc
<span class="go">...</span>
<span class="go">Target Library Information</span>
<span class="go">Target Transform Info</span>
<span class="go">Data Layout</span>
<span class="go">Target Pass Configuration</span>
<span class="go">No Alias Analysis (always returns &#39;may&#39; alias)</span>
<span class="go">Type-Based Alias Analysis</span>
<span class="go">Basic Alias Analysis (stateless AA impl)</span>
<span class="go">Create Garbage Collector Module Metadata</span>
<span class="go">Machine Module Information</span>
<span class="go">Machine Branch Probability Analysis</span>
<span class="go">  ModulePass Manager</span>
<span class="go">    FunctionPass Manager</span>
<span class="go">      Preliminary module verification</span>
<span class="go">      Dominator Tree Construction</span>
<span class="go">      Module Verifier</span>
<span class="go">      Natural Loop Information</span>
<span class="go">      Loop Pass Manager</span>
<span class="go">        Canonicalize natural loops</span>
<span class="go">      Scalar Evolution Analysis</span>
<span class="go">      Loop Pass Manager</span>
<span class="go">        Canonicalize natural loops</span>
<span class="go">        Induction Variable Users</span>
<span class="go">        Loop Strength Reduction</span>
<span class="go">      Lower Garbage Collection Instructions</span>
<span class="go">      Remove unreachable blocks from the CFG</span>
<span class="go">      Exception handling preparation</span>
<span class="go">      Optimize for code generation</span>
<span class="go">      Insert stack protectors</span>
<span class="go">      Preliminary module verification</span>
<span class="go">      Dominator Tree Construction</span>
<span class="go">      Module Verifier</span>
<span class="go">      Machine Function Analysis</span>
<span class="go">      Natural Loop Information</span>
<span class="go">      Branch Probability Analysis</span>
<span class="go">    * MIPS DAG-&gt;DAG Pattern Instruction Selection</span>
<span class="go">      Expand ISel Pseudo-instructions</span>
<span class="go">      Tail Duplication</span>
<span class="go">      Optimize machine instruction PHIs</span>
<span class="go">      MachineDominator Tree Construction</span>
<span class="go">      Slot index numbering</span>
<span class="go">      Merge disjoint stack slots</span>
<span class="go">      Local Stack Slot Allocation</span>
<span class="go">      Remove dead machine instructions</span>
<span class="go">      MachineDominator Tree Construction</span>
<span class="go">      Machine Natural Loop Construction</span>
<span class="go">      Machine Loop Invariant Code Motion</span>
<span class="go">      Machine Common Subexpression Elimination</span>
<span class="go">      Machine code sinking</span>
<span class="go">    * Peephole Optimizations</span>
<span class="go">      Process Implicit Definitions</span>
<span class="go">      Remove unreachable machine basic blocks</span>
<span class="go">      Live Variable Analysis</span>
<span class="go">      Eliminate PHI nodes for register allocation</span>
<span class="go">      Two-Address instruction pass</span>
<span class="go">      Slot index numbering</span>
<span class="go">      Live Interval Analysis</span>
<span class="go">      Debug Variable Analysis</span>
<span class="go">      Simple Register Coalescing</span>
<span class="go">      Live Stack Slot Analysis</span>
<span class="go">      Calculate spill weights</span>
<span class="go">      Virtual Register Map</span>
<span class="go">      Live Register Matrix</span>
<span class="go">      Bundle Machine CFG Edges</span>
<span class="go">      Spill Code Placement Analysis</span>
<span class="go">    * Greedy Register Allocator</span>
<span class="go">      Virtual Register Rewriter</span>
<span class="go">      Stack Slot Coloring</span>
<span class="go">      Machine Loop Invariant Code Motion</span>
<span class="go">    * Prologue/Epilogue Insertion &amp; Frame Finalization</span>
<span class="go">      Control Flow Optimizer</span>
<span class="go">      Tail Duplication</span>
<span class="go">      Machine Copy Propagation Pass</span>
<span class="go">    * Post-RA pseudo instruction expansion pass</span>
<span class="go">      MachineDominator Tree Construction</span>
<span class="go">      Machine Natural Loop Construction</span>
<span class="go">      Post RA top-down list latency scheduler</span>
<span class="go">      Analyze Machine Code For Garbage Collection</span>
<span class="go">      Machine Block Frequency Analysis</span>
<span class="go">      Branch Probability Basic Block Placement</span>
<span class="go">      Mips Delay Slot Filler</span>
<span class="go">      Mips Long Branch</span>
<span class="go">      MachineDominator Tree Construction</span>
<span class="go">      Machine Natural Loop Construction</span>
<span class="go">    * Mips Assembly Printer</span>
<span class="go">      Delete Garbage Collector Information</span>
</pre></div>
</div>
</section>
<section id="ssa-form">
<h3><a class="toc-backref" href="#id76">SSA form</a><a class="headerlink" href="#ssa-form" title="Permalink to this headline">¶</a></h3>
<p>SSA form says that each variable is assigned exactly once.
LLVM IR is SSA form which has unbounded virtual registers (each variable is
assigned exactly once and is keeped in different virtual register).
As the result, the optimization steps used in code generation sequence which
include stages of <strong>Instruction Selection</strong>, <strong>Scheduling and Formation</strong> and
<strong>Register Allocation</strong>, won’t loss any optimization opportunity.
For example, if using limited virtual registers instead of unlimited as the
following code,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">%</span><span class="nv">a</span> <span class="o">=</span> add nsw i32 <span class="m">1</span>, i32 <span class="m">0</span>
<span class="go">store i32 %a, i32* %c, align 4</span>
<span class="gp">%</span><span class="nv">a</span> <span class="o">=</span> add nsw i32 <span class="m">2</span>, i32 <span class="m">0</span>
<span class="go">store i32 %a, i32* %c, align 4</span>
</pre></div>
</div>
<p>Above using limited virtual registers, so virtual register %a used twice.
Compiler have to generate the following code since it assigns virtual register
%a as output at two different statement.</p>
<blockquote>
<div><dl class="simple">
<dt>=&gt; %a = add i32 1, i32 0</dt><dd><p>st %a,  i32* %c, 1
%a = add i32 2, i32 0
st %a,  i32* %c, 2</p>
</dd>
</dl>
</div></blockquote>
<p>Above code have to run in sequence. On the other hand, the SSA form as the
following can be reodered and run in parallel with the following different
version <a class="footnote-reference brackets" href="#dragonbooks-10-2-3" id="id22">14</a>.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">  %</span><span class="nv">a</span> <span class="o">=</span> add nsw i32 <span class="m">1</span>, i32 <span class="m">0</span>
<span class="go">  store i32 %a, i32* %c, align 4</span>
<span class="gp">  %</span><span class="nv">b</span> <span class="o">=</span> add nsw i32 <span class="m">2</span>, i32 <span class="m">0</span>
<span class="go">  store i32 %b, i32* %d, align 4</span>

<span class="go">// version 1</span>
<span class="go">=&gt; %a = add i32 1, i32 0</span>
<span class="go">    st %a,  i32* %c, 0</span>
<span class="gp">    %</span><span class="nv">b</span> <span class="o">=</span> add i32 <span class="m">2</span>, i32 <span class="m">0</span>
<span class="go">    st %b,  i32* %d, 0</span>

<span class="go">// version 2</span>
<span class="go">=&gt; %a = add i32 1, i32 0</span>
<span class="gp">    %</span><span class="nv">b</span> <span class="o">=</span> add i32 <span class="m">2</span>, i32 <span class="m">0</span>
<span class="go">    st %a,  i32* %c, 0</span>
<span class="go">    st %b,  i32* %d, 0</span>

<span class="go">// version 3</span>
<span class="go">=&gt; %b = add i32 2, i32 0</span>
<span class="go">    st %b,  i32* %d, 0</span>
<span class="gp">    %</span><span class="nv">a</span> <span class="o">=</span> add i32 <span class="m">1</span>, i32 <span class="m">0</span>
<span class="go">    st %a,  i32* %c, 0</span>
</pre></div>
</div>
</section>
<section id="dsa-form">
<h3><a class="toc-backref" href="#id77">DSA form</a><a class="headerlink" href="#dsa-form" title="Permalink to this headline">¶</a></h3>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">for (int i = 0; i &lt; 1000; i++) {</span>
<span class="go">  b[i] = f(g(a[i]));</span>
<span class="go">}</span>
</pre></div>
</div>
<p>For the source program as above, the following are the SSA form in source code
level and llvm IR level respectively.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="w">  </span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="nv">%pi</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">alloca</span><span class="w"> </span><span class="kt">i32</span><span class="w"></span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%pi</span><span class="w"></span>
<span class="w">  </span><span class="nv">%i</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%pi</span><span class="w"></span>
<span class="w">  </span><span class="nv">%cmp</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">slt</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i</span><span class="p">,</span><span class="w"> </span><span class="m">1000</span><span class="w"></span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cmp</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%true</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%end</span><span class="w"></span>
<span class="nl">true:</span><span class="w"></span>
<span class="w">  </span><span class="nv">%a_idx</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a_addr</span><span class="w"></span>
<span class="w">  </span><span class="nv">%val0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%a_idx</span><span class="w"></span>
<span class="w">  </span><span class="nv">%t</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%g</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%val0</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nv">%val1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%f</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%t</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nv">%b_idx</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b_addr</span><span class="w"></span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%val1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%b_idx</span><span class="w"></span>
<span class="nl">end:</span><span class="w"></span>
</pre></div>
</div>
<p>The following is the DSA (Dynamic Single Assignment) form.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="w">  </span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="nv">%pi</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">alloca</span><span class="w"> </span><span class="kt">i32</span><span class="w"></span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%pi</span><span class="w"></span>
<span class="w">  </span><span class="nv">%i</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%pi</span><span class="w"></span>
<span class="w">  </span><span class="nv">%cmp</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">slt</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i</span><span class="p">,</span><span class="w"> </span><span class="m">1000</span><span class="w"></span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cmp</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%true</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%end</span><span class="w"></span>
<span class="nl">true:</span><span class="w"></span>
<span class="w">  </span><span class="nv">%a_idx</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a_addr</span><span class="w"></span>
<span class="w">  </span><span class="nv">%val0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%a_idx</span><span class="w"></span>
<span class="w">  </span><span class="nv">%t_idx</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%t_addr</span><span class="w"></span>
<span class="w">  </span><span class="nv">%temp</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%g</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%val0</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%temp</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%t_idx</span><span class="w"></span>
<span class="w">  </span><span class="nv">%val1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%f</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%temp</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nv">%b_idx</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b_addr</span><span class="w"></span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%val1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%b_idx</span><span class="w"></span>
<span class="nl">end:</span><span class="w"></span>
</pre></div>
</div>
<p>In some internet video applications and muti-core (SMP) platforms, splitting g()
and f() to two different loop have better perfomance. DSA can split as the
following while SSA cannot. Of course, it’s possible to do extra analysis on
%temp of SSA and reverse it into %t_idx and %t_addr as the following DSA. But in
compiler discussion, the translation is from high to low level of machine code.
Besides, as you see, the llvm ir lose the for loop information already though
it can be reconstructed by extra analysis. So, in this book and almost every
paper in compiler discuss with this high-to-low premise, otherwise it’s talking
about reverse engineering in assembler or compiler.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="nv">%pi</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">alloca</span><span class="w"> </span><span class="kt">i32</span><span class="w"></span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%pi</span><span class="w"></span>
<span class="w">  </span><span class="nv">%i</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%pi</span><span class="w"></span>
<span class="w">  </span><span class="nv">%cmp</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">slt</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i</span><span class="p">,</span><span class="w"> </span><span class="m">1000</span><span class="w"></span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cmp</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%true</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%end</span><span class="w"></span>
<span class="nl">true:</span><span class="w"></span>
<span class="w">  </span><span class="nv">%a_idx</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a_addr</span><span class="w"></span>
<span class="w">  </span><span class="nv">%val0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%a_idx</span><span class="w"></span>
<span class="w">  </span><span class="nv">%t_idx</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%t_addr</span><span class="w"></span>
<span class="w">  </span><span class="nv">%temp</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%g</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%val0</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%temp</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%t_idx</span><span class="w"></span>
<span class="nl">end:</span><span class="w"></span>

<span class="w">  </span><span class="nv">%pi</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">alloca</span><span class="w"> </span><span class="kt">i32</span><span class="w"></span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%pi</span><span class="w"></span>
<span class="w">  </span><span class="nv">%i</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%pi</span><span class="w"></span>
<span class="w">  </span><span class="nv">%cmp</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">slt</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i</span><span class="p">,</span><span class="w"> </span><span class="m">1000</span><span class="w"></span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cmp</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%true</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%end</span><span class="w"></span>
<span class="nl">true:</span><span class="w"></span>
<span class="w">  </span><span class="nv">%t_idx</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%t_addr</span><span class="w"></span>
<span class="w">  </span><span class="nv">%temp</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%t_idx</span><span class="w"></span>
<span class="w">  </span><span class="nv">%val1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%f</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%temp</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nv">%b_idx</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b_addr</span><span class="w"></span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%val1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%b_idx</span><span class="w"></span>
<span class="nl">end:</span><span class="w"></span>
</pre></div>
</div>
<p>Now, the data dependences only exist on t[i] between “t[i] = g(a[i])” and
“b[i] = f(t[i])” for each i = (0..999). The program can be run on many different
order, and it provides many parallel processing opportunities for multi-core
(SMP) and heterogeneous processors. For instance, g(x) is run on GPU and f(x)
is run on CPU.</p>
</section>
<section id="llvm-vs-gcc-in-structure">
<h3><a class="toc-backref" href="#id78">LLVM vs GCC in structure</a><a class="headerlink" href="#llvm-vs-gcc-in-structure" title="Permalink to this headline">¶</a></h3>
<p>GCC document is here <a class="footnote-reference brackets" href="#gnu" id="id23">15</a> .</p>
<table class="docutils align-default" id="id56">
<caption><span class="caption-number">Table 8 </span><span class="caption-text">clang vs gcc-frontend</span><a class="headerlink" href="#id56" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 28%" />
<col style="width: 35%" />
<col style="width: 37%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>frontend</p></th>
<th class="head"><p>clang</p></th>
<th class="head"><p>gcc-frontend <a class="footnote-reference brackets" href="#gcc-frontend" id="id24">16</a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>LANGUAGE</p></td>
<td><p>C/C++</p></td>
<td><p>C/C++</p></td>
</tr>
<tr class="row-odd"><td><p>parsing</p></td>
<td><p>parsing</p></td>
<td><p>parsing</p></td>
</tr>
<tr class="row-even"><td><p>AST</p></td>
<td><p>clang-AST</p></td>
<td><p>GENERIC <a class="footnote-reference brackets" href="#generic" id="id25">17</a></p></td>
</tr>
<tr class="row-odd"><td><p>optimization &amp; codgen</p></td>
<td><p>clang-backend</p></td>
<td><p>gimplifier</p></td>
</tr>
<tr class="row-even"><td><p>IR</p></td>
<td><p>LLVM IR</p></td>
<td><p>GIMPLE <a class="footnote-reference brackets" href="#gimple" id="id26">18</a></p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="id57">
<caption><span class="caption-number">Table 9 </span><span class="caption-text">llvm vs gcc (kernal and target/backend)</span><a class="headerlink" href="#id57" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 31%" />
<col style="width: 39%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>backend</p></th>
<th class="head"><p>llvm</p></th>
<th class="head"><p>gcc</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>IR</p></td>
<td><p>LLVM IR</p></td>
<td><p>GIMPLE</p></td>
</tr>
<tr class="row-odd"><td><p>transfer</p></td>
<td><p>optimziation &amp; pass</p></td>
<td><p>optimization &amp; plugins</p></td>
</tr>
<tr class="row-even"><td><p>DAG</p></td>
<td><p>DAG</p></td>
<td><p>RTL <a class="footnote-reference brackets" href="#rtl" id="id27">19</a></p></td>
</tr>
<tr class="row-odd"><td><p>codgen</p></td>
<td><p>tblgen for td</p></td>
<td><p>codgen for md <a class="footnote-reference brackets" href="#md" id="id28">20</a></p></td>
</tr>
</tbody>
</table>
<p>Both LLVM IR and GIMPLE are SSA form.
LLVM IR originally designed to be fully reusable across arbitrary tools besides
compiler itself. GCC community never had desire to enable any tools besides
compiler (Richard Stallman resisted attempts to make IR more reusable to prevent
third-party commercial tools from reusing GCC’s frontends). Thus GIMPLE
(GCC’s IR) was never considered to be more than an implementation detail, in
particular it doesn’t provide a full description of compiled program (e.g. it
lacks program’s call graph, type definitions, stack offsets and alias
information) <a class="footnote-reference brackets" href="#llvm-ir-vs-gimple" id="id29">21</a>.</p>
</section>
<section id="llvm-blog">
<h3><a class="toc-backref" href="#id79">LLVM blog</a><a class="headerlink" href="#llvm-blog" title="Permalink to this headline">¶</a></h3>
<p>User uses null pointer to guard code is correct. Undef is only happened in
compiler optimization <a class="footnote-reference brackets" href="#null-pointer-ex" id="id30">22</a>.
However when user forget to bind null pointer in guarding code directly or
indirectly, compiler such as llvm and gcc may treat null pointer as undef and
optimzation out <a class="footnote-reference brackets" href="#null-pointer" id="id31">23</a>.</p>
</section>
<section id="dag-directed-acyclic-graph">
<h3><a class="toc-backref" href="#id80">DAG (Directed Acyclic Graph)</a><a class="headerlink" href="#dag-directed-acyclic-graph" title="Permalink to this headline">¶</a></h3>
<p>Many important techniques for local optimization begin by transforming a basic
block into DAG <a class="footnote-reference brackets" href="#dragonbooks-8-5" id="id32">24</a>.
For example, the basic block code and it’s corresponding DAG as
<a class="reference internal" href="#llvmstructure-f10"><span class="std std-numref">Fig. 10</span></a>.</p>
<figure class="align-center" id="id58">
<span id="llvmstructure-f10"></span><a class="reference internal image-reference" href="_images/102.png"><img alt="_images/102.png" src="_images/102.png" style="width: 379.20000000000005px; height: 142.4px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 10 </span><span class="caption-text">DAG example</span><a class="headerlink" href="#id58" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>If b is not live on exit from the block, then we can do “common expression
remove” as the following table.</p>
<table class="docutils align-default" id="id59">
<caption><span class="caption-number">Table 10 </span><span class="caption-text">common expression remove process</span><a class="headerlink" href="#id59" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 35%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Replace node b with node d</p></th>
<th class="head"><p>Replace b<sub>0</sub>, c<sub>0</sub>, d<sub>0</sub> with b, c, d</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>a = b<sub>0</sub> + c<sub>0</sub></p></td>
<td><p>a = b + c</p></td>
</tr>
<tr class="row-odd"><td><p>d = a – d<sub>0</sub></p></td>
<td><p>d = a – d</p></td>
</tr>
<tr class="row-even"><td><p>c = d + c</p></td>
<td><p>c = d + c</p></td>
</tr>
</tbody>
</table>
<p>After removing b and traversing the DAGs from bottom to top (traverse binary
tree by Depth-first In-order search) , the first column of above table will be
gotten.</p>
<p>As you can imagine, the “common expression remove” can apply both in IR or
machine code.</p>
<p>DAG is like a tree which opcode is the node and operand (register and
const/immediate/offset) is leaf.
It can also be represented by list as prefix order in tree.
For example, (+ b, c), (+ b, 1) is IR DAG representation.</p>
<p>In addition to DAG optimization, the “kill” register has also mentioned in
section 8.5.5 of the compiler book <a class="footnote-reference brackets" href="#dragonbooks-8-5" id="id33">24</a>. This optimization
method also applied in llvm implementation.</p>
</section>
<section id="instruction-selection">
<h3><a class="toc-backref" href="#id81">Instruction Selection</a><a class="headerlink" href="#instruction-selection" title="Permalink to this headline">¶</a></h3>
<p>The major function of backend is that translate IR code into machine code at
stage of Instruction Selection as <a class="reference internal" href="#llvmstructure-f11"><span class="std std-numref">Fig. 11</span></a>.</p>
<figure class="align-center" id="id60">
<span id="llvmstructure-f11"></span><a class="reference internal image-reference" href="_images/111.png"><img alt="_images/111.png" src="_images/111.png" style="width: 346.5px; height: 81.19999999999999px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 11 </span><span class="caption-text">IR and it’s corresponding machine instruction</span><a class="headerlink" href="#id60" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>For machine instruction selection, the best solution is representing IR and
machine instruction by DAG.
To simplify in view, the register leaf is skipped in
<a class="reference internal" href="#llvmstructure-f12"><span class="std std-numref">Fig. 12</span></a>.
The r<sub>j</sub> + r<sub>k</sub> is IR DAG representation (for symbol
notation, not llvm SSA form).
ADD is machine instruction.</p>
<figure class="align-center" id="id61">
<span id="llvmstructure-f12"></span><a class="reference internal image-reference" href="_images/121.png"><img alt="_images/121.png" src="_images/121.png" style="width: 690.1999999999999px; height: 426.29999999999995px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 12 </span><span class="caption-text">Instruction DAG representation</span><a class="headerlink" href="#id61" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>The IR DAG and machine instruction DAG can also represented as list.
For example, (+ r<sub>i</sub>, r<sub>j</sub>j) and (- r<sub>i</sub>, 1) are
lists for IR DAG; (ADD r<sub>i</sub>, r<sub>j</sub>) and
(SUBI r<sub>i</sub>, 1) are lists for machine instruction DAG.</p>
<p>Now, let’s check the ADDiu instruction defined in Cpu0InstrInfo.td as follows,</p>
<p class="rubric">lbdex/chapters/Chapter2/Cpu0InstrFormats.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">//</span> <span class="n">Format</span> <span class="n">L</span> <span class="n">instruction</span> <span class="k">class</span> <span class="nc">in</span> <span class="n">Cpu0</span> <span class="p">:</span> <span class="o">&lt;|</span><span class="n">opcode</span><span class="o">|</span><span class="n">ra</span><span class="o">|</span><span class="n">rb</span><span class="o">|</span><span class="n">cx</span><span class="o">|&gt;</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="k">class</span> <span class="nc">FL</span><span class="o">&lt;</span><span class="n">bits</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span> <span class="n">op</span><span class="p">,</span> <span class="n">dag</span> <span class="n">outs</span><span class="p">,</span> <span class="n">dag</span> <span class="n">ins</span><span class="p">,</span> <span class="n">string</span> <span class="n">asmstr</span><span class="p">,</span> <span class="nb">list</span><span class="o">&lt;</span><span class="n">dag</span><span class="o">&gt;</span> <span class="n">pattern</span><span class="p">,</span>
         <span class="n">InstrItinClass</span> <span class="n">itin</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">Cpu0Inst</span><span class="o">&lt;</span><span class="n">outs</span><span class="p">,</span> <span class="n">ins</span><span class="p">,</span> <span class="n">asmstr</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">itin</span><span class="p">,</span> <span class="n">FrmL</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="n">bits</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span>  <span class="n">ra</span><span class="p">;</span>
  <span class="n">bits</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span>  <span class="n">rb</span><span class="p">;</span>
  <span class="n">bits</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span> <span class="n">imm16</span><span class="p">;</span>

  <span class="n">let</span> <span class="n">Opcode</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span>

  <span class="n">let</span> <span class="n">Inst</span><span class="p">{</span><span class="mi">23</span><span class="o">-</span><span class="mi">20</span><span class="p">}</span> <span class="o">=</span> <span class="n">ra</span><span class="p">;</span>
  <span class="n">let</span> <span class="n">Inst</span><span class="p">{</span><span class="mi">19</span><span class="o">-</span><span class="mi">16</span><span class="p">}</span> <span class="o">=</span> <span class="n">rb</span><span class="p">;</span>
  <span class="n">let</span> <span class="n">Inst</span><span class="p">{</span><span class="mi">15</span><span class="o">-</span><span class="mi">0</span><span class="p">}</span>  <span class="o">=</span> <span class="n">imm16</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter2/Cpu0InstrInfo.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Node</span> <span class="n">immediate</span> <span class="n">fits</span> <span class="k">as</span> <span class="mi">16</span><span class="o">-</span><span class="n">bit</span> <span class="n">sign</span> <span class="n">extended</span> <span class="n">on</span> <span class="n">target</span> <span class="n">immediate</span><span class="o">.</span>
<span class="o">//</span> <span class="n">e</span><span class="o">.</span><span class="n">g</span><span class="o">.</span> <span class="n">addi</span><span class="p">,</span> <span class="n">andi</span>
<span class="k">def</span> <span class="nf">immSExt16</span>  <span class="p">:</span> <span class="n">PatLeaf</span><span class="o">&lt;</span><span class="p">(</span><span class="n">imm</span><span class="p">),</span> <span class="p">[{</span> <span class="k">return</span> <span class="n">isInt</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">(</span><span class="n">N</span><span class="o">-&gt;</span><span class="n">getSExtValue</span><span class="p">());</span> <span class="p">}]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// Arithmetic and logical instructions with 2 register operands.
class ArithLogicI&lt;bits&lt;8&gt; op, string instr_asm, SDNode OpNode,
                  Operand Od, PatLeaf imm_type, RegisterClass RC&gt; :
  FL&lt;op, (outs GPROut:$ra), (ins RC:$rb, Od:$imm16),
     !strconcat(instr_asm, &quot;\t$ra, $rb, $imm16&quot;),
     [(set GPROut:$ra, (OpNode RC:$rb, imm_type:$imm16))], IIAlu&gt; {
  let isReMaterializable = 1;
}
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">IR</span> <span class="s2">&quot;add&quot;</span> <span class="n">defined</span> <span class="ow">in</span> <span class="n">include</span><span class="o">/</span><span class="n">llvm</span><span class="o">/</span><span class="n">Target</span><span class="o">/</span><span class="n">TargetSelectionDAG</span><span class="o">.</span><span class="n">td</span><span class="p">,</span> <span class="n">line</span> <span class="mi">315</span> <span class="p">(</span><span class="k">def</span> <span class="nf">add</span><span class="p">)</span><span class="o">.</span>
<span class="k">def</span> <span class="nf">ADDiu</span>   <span class="p">:</span> <span class="n">ArithLogicI</span><span class="o">&lt;</span><span class="mh">0x09</span><span class="p">,</span> <span class="s2">&quot;addiu&quot;</span><span class="p">,</span> <span class="n">add</span><span class="p">,</span> <span class="n">simm16</span><span class="p">,</span> <span class="n">immSExt16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p><a class="reference internal" href="#llvmstructure-f13"><span class="std std-numref">Fig. 13</span></a> shows how the pattern match work in the IR node,
<strong>add</strong>, and instruction node, <strong>ADDiu</strong>, which both defined in
Cpu0InstrInfo.td. In
this example, IR node “add %a, 5” will be translated to “addiu $r1, 5” after %a
is allcated to register $r1 in regiter allocation stage since the IR
pattern[(set RC:$ra, (OpNode RC:$rb, imm_type:$imm16))] is set in ADDiu and the
2nd operand is “signed immediate” which matched “%a, 5”. In addition to pattern
match, the .td also set assembly string “addiu” and op code 0x09.
With this information, the LLVM TableGen will generate instruction both in
assembly and binary automatically (the binary instruction can be issued in obj
file of ELF format which will be explained at later chapter).
Similarly, the machine instruction DAG nodes LD and ST can be translated from IR
DAG nodes <strong>load</strong> and <strong>store</strong>. Notice that the $rb in
<a class="reference internal" href="#llvmstructure-f13"><span class="std std-numref">Fig. 13</span></a> is virtual register name (not machine register).
The detail for <a class="reference internal" href="#llvmstructure-f13"><span class="std std-numref">Fig. 13</span></a> depicted after it.</p>
<figure class="align-center" id="id62">
<span id="llvmstructure-f13"></span><a class="reference internal image-reference" href="_images/131.png"><img alt="_images/131.png" src="_images/131.png" style="width: 514.4px; height: 336.8px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 13 </span><span class="caption-text">Pattern match for ADDiu instruction and IR node add</span><a class="headerlink" href="#id62" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<div class="graphviz"><img src="_images/graphviz-eb9fc0bb17fc20a11689973dff5acba29a085428.png" alt="digraph &quot;DAG&quot; {
  rankdir=&quot;TB&quot;;      
  label = &quot;Figure: Pattern match for ADDiu instruction and IR node add in detail&quot;;
  td [ penwidth = 1, fontname = &quot;Courier New&quot;, shape = &quot;rectangle&quot;, label =&lt;&lt;table border=&quot;0&quot; cellborder=&quot;0&quot; cellpadding=&quot;3&quot; bgcolor=&quot;white&quot;&gt;
    &lt;tr&gt;&lt;td bgcolor=&quot;grey&quot; align=&quot;center&quot; colspan=&quot;2&quot;&gt;&lt;font color=&quot;white&quot;&gt;Cpu0InstrInfo.td&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td align=&quot;left&quot; port=&quot;f0&quot;&gt;def immSExt16  : PatLeaf&amp;#60;(imm), [{ return isInt&amp;#60;16&amp;#62;(N-&amp;#60;getSExtValue()); }]&amp;#62;;&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td align=&quot;left&quot;&gt;class ArithLogicI&amp;#60;bits&amp;#60;8&amp;#62; op, string instr_asm, SDNode OpNode&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td align=&quot;left&quot; port=&quot;f1&quot;&gt;                  Operand Od, PatLeaf imm_type, RegisterClass RC&amp;#62; &lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td align=&quot;left&quot; port=&quot;f2&quot;&gt; FL&amp;#60;0op, (outs RC:$ra), (ins RC:$rb, Od:$imm16),&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td align=&quot;left&quot; port=&quot;f3&quot;&gt;  !strconcat(instr_asm, &quot;\t$ra, $rb, $imm16&quot;),&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td align=&quot;left&quot; port=&quot;f4&quot;&gt; [(set RC:$ra, (OpNode RC:$rb, imm_type:$imm16))], IIAlu&amp;#62; {&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td align=&quot;left&quot; port=&quot;f5&quot;&gt; let isReMaterializable = 1;&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td align=&quot;left&quot;&gt;}&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td align=&quot;left&quot; port=&quot;f6&quot;&gt;def ADDiu   : ArithLogicI&amp;#60;0x09, &quot;addiu&quot;, add, simm16, immSExt16, CPURegs&amp;#62;; &lt;/td&gt;&lt;/tr&gt;
    &lt;/table&gt;&gt; ];
  a [shape=Mrecord,label=&quot;&lt;aa&gt;def ADDiu   : ArithLogicI\&lt;|&lt;a0&gt;0x09, |&lt;a1&gt;\&quot;addiu\&quot;, |&lt;a2&gt;add, |&lt;a3&gt;simm16, |&lt;a4&gt;immSExt16, |&lt;a5&gt;CPURegs\&gt;;&quot;];
  p [shape=Mrecord,label=&quot;&lt;p8&gt;RC:|&lt;p9&gt;$ra|&lt;p0&gt;OpNode|&lt;p1&gt;RC:|&lt;p2&gt;$rb|&lt;p3&gt;imm_type:|&lt;p4&gt;$imm16&quot;];
  q [shape=Mrecord,label=&quot;&lt;q8&gt;CPURegs:|&lt;q9&gt;$ra|&lt;q0&gt;add|&lt;q1&gt;CPURegs:|&lt;q2&gt;$rb|&lt;q3&gt;immSExt16:|&lt;q4&gt;$imm16&quot;];
  asm [shape=Mrecord,label=&quot;&lt;asm0&gt;\!strconcat\(|&lt;asm1&gt;instr_asm, \&quot;\\t|&lt;asm2&gt;$ra, |&lt;asm3&gt;$rb, |&lt;asm4&gt;$imm16\)&quot;];
  mi [shape=Mrecord,label=&quot;&lt;mi0&gt;addiu|&lt;mi1&gt;$r2|&lt;mi2&gt;$r1|&lt;mi3&gt;5&quot;];
  
  td -&gt; a;
  td:f0:e -&gt; q:q3 [label=&quot;%0 = add %a, 5 -- (5 is true for immSExt16, \nso pattern match for ADDiu succeed&quot;];
  a:a2 -&gt; p:p0;
  a:a5 -&gt; p:p1;
  a:a5 -&gt; p:p8;
  a:a4 -&gt; p:p3;
  td:f4:w -&gt; p:w;
  td:f3:w -&gt; asm:w;
  p:p0 -&gt; q:q0;
  p:p1 -&gt; q:q1;
  p:p8 -&gt; q:q8;
  p:p3 -&gt; q:q3;
  p:e -&gt; q:e [label=&quot;expand pattern match rule&quot;];
  q:q0 -&gt; asm:asm0;
  q:q9 -&gt; asm:asm1;
  q:q2 -&gt; asm:asm2;
  q:q4 -&gt; asm:asm4;
  q:e -&gt; asm:e [label=&quot;expand machine asm instruction&quot;];
  asm:asm1 -&gt; mi:mi0 [label=&quot;addiu&quot;];
  asm:asm2 -&gt; mi:mi1 [label=&quot;$r2&quot;];
  asm:asm3 -&gt; mi:mi2 [label=&quot;$r1&quot;];
  asm:asm4 -&gt; mi:mi3 [label=&quot;5&quot;];
  asm:e -&gt; mi:e[label=&quot;When llvm assign $r2 as destination register, $r1 as source 0 register&quot;];
}" class="graphviz" /></div>
<p>From DAG instruction selection we mentioned, the leaf node must be a Data Node.
ADDiu is format L type which the last operand must fits in 16 bits range.
So, Cpu0InstrInfo.td define a PatLeaf type of immSExt16 to let llvm system know
the PatLeaf range. If the imm16 value is out of this range,
<strong>“isInt&lt;16&gt;(N-&gt;getSExtValue())”</strong> will return false and this pattern won’t use
ADDiu in instruction selection stage.</p>
<p>Some cpu/fpu (floating point processor) has multiply-and-add floating point
instruction, fmadd.
It can be represented by DAG list (fadd (fmul ra, rc), rb).
For this implementation, we can assign fmadd DAG pattern to instruction td as
follows,</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def FMADDS : AForm_1&lt;59, 29,
          (ops F4RC:$FRT, F4RC:$FRA, F4RC:$FRC, F4RC:$FRB),
          &quot;fmadds $FRT, $FRA, $FRC, $FRB&quot;,
          [(set F4RC:$FRT, (fadd (fmul F4RC:$FRA, F4RC:$FRC),
                       F4RC:$FRB))]&gt;;
</pre></div>
</div>
<p>Similar with ADDiu, [(set F4RC:$FRT, (fadd (fmul F4RC:$FRA, F4RC:$FRC),
F4RC:$FRB))] is the pattern which include nodes <strong>fmul</strong> and <strong>fadd</strong>.</p>
<p>Now, for the following basic block notation IR and llvm SSA IR code,</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>d = a * c
e = d + b
...
</pre></div>
</div>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nv">%d</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">fmul</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="nv">%c</span><span class="w"></span>
<span class="nv">%e</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">fadd</span><span class="w"> </span><span class="nv">%d</span><span class="p">,</span><span class="w"> </span><span class="nv">%b</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
</pre></div>
</div>
<p>the Instruction Selection Process will translate this two IR DAG node
(fmul %a, %c) (fadd %d, %b) into one machine instruction DAG node (<strong>fmadd</strong>
%a, %c, %b), rather than translate them into two machine instruction nodes
<strong>fmul</strong> and <strong>fadd</strong> if the FMADDS is appear before FMUL and FADD in your td
file.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">%</span><span class="nv">e</span> <span class="o">=</span> fmadd %a, %c, %b
<span class="go">...</span>
</pre></div>
</div>
<p>As you can see, the IR notation representation is easier to read than llvm SSA
IR form.
So, this notation form is used in this book sometimes.</p>
<p>For the following basic block code,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">a = b + c   // in notation IR form</span>
<span class="go">d = a – d</span>
<span class="gp">%</span><span class="nv">e</span> <span class="o">=</span> fmadd %a, %c, %b // <span class="k">in</span> llvm SSA IR form
</pre></div>
</div>
<p>We can apply <a class="reference internal" href="#llvmstructure-f8"><span class="std std-numref">Fig. 8</span></a> Instruction Tree Patterns to get the
following machine code,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">load  rb, M(sp+8); // assume b allocate in sp+8, sp is stack point register</span>
<span class="go">load  rc, M(sp+16);</span>
<span class="go">add ra, rb, rc;</span>
<span class="go">load  rd, M(sp+24);</span>
<span class="go">sub rd, ra, rd;</span>
<span class="go">fmadd re, ra, rc, rb;</span>
</pre></div>
</div>
</section>
<section id="caller-and-callee-saved-registers">
<h3><a class="toc-backref" href="#id82">Caller and callee saved registers</a><a class="headerlink" href="#caller-and-callee-saved-registers" title="Permalink to this headline">¶</a></h3>
<p class="rubric">lbdex/input/ch9_caller_callee_save_registers.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="nb">int</span> <span class="n">add1</span><span class="p">(</span><span class="nb">int</span> <span class="n">x</span><span class="p">);</span>

<span class="nb">int</span> <span class="n">callee</span><span class="p">()</span>
<span class="p">{</span> 
  <span class="nb">int</span> <span class="n">t1</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">add1</span><span class="p">(</span><span class="n">t1</span><span class="p">);</span>  
  <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">-</span> <span class="n">t1</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Run Mips backend with above input will get the following result.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>~/llvm/release/build/bin/llc
<span class="go">-O0 -march=mips -relocation-model=static -filetype=asm</span>
<span class="go">ch9_caller_callee_save_registers.bc -o -</span>
<span class="go">      .text</span>
<span class="go">      .abicalls</span>
<span class="go">      .option pic0</span>
<span class="go">      .section        .mdebug.abi32,&quot;&quot;,@progbits</span>
<span class="go">      .nan    legacy</span>
<span class="go">      .file   &quot;ch9_caller_callee_save_registers.bc&quot;</span>
<span class="go">      .text</span>
<span class="go">      .globl  _Z6calleev</span>
<span class="go">      .align  2</span>
<span class="go">      .type   _Z6calleev,@function</span>
<span class="go">      .set    nomicromips</span>
<span class="go">      .set    nomips16</span>
<span class="go">      .ent    _Z6calleev</span>
<span class="go">_Z6callerv:                             # @_Z6callerv</span>
<span class="go">      .cfi_startproc</span>
<span class="go">      .frame  $fp,32,$ra</span>
<span class="go">      .mask   0xc0000000,-4</span>
<span class="go">      .fmask  0x00000000,0</span>
<span class="go">      .set    noreorder</span>
<span class="go">      .set    nomacro</span>
<span class="go">      .set    noat</span>
<span class="gp"># </span>BB#0:
<span class="go">      addiu   $sp, $sp, -32</span>
<span class="gp">$</span>tmp0:
<span class="go">      .cfi_def_cfa_offset 32</span>
<span class="go">      sw      $ra, 28($sp)            # 4-byte Folded Spill</span>
<span class="go">      sw      $fp, 24($sp)            # 4-byte Folded Spill</span>
<span class="gp">$</span>tmp1:
<span class="go">      .cfi_offset 31, -4</span>
<span class="gp">$</span>tmp2:
<span class="go">      .cfi_offset 30, -8</span>
<span class="go">      move     $fp, $sp</span>
<span class="gp">$</span>tmp3:
<span class="go">      .cfi_def_cfa_register 30</span>
<span class="go">      addiu   $1, $zero, 3</span>
<span class="go">      sw      $1, 20($fp)   # store t1 to 20($fp)</span>
<span class="go">      move     $4, $1</span>
<span class="go">      jal     _Z4add1i</span>
<span class="go">      nop</span>
<span class="go">      sw      $2, 16($fp)   # $2 : the return vaule for fuction add1()</span>
<span class="go">      lw      $1, 20($fp)   # load t1 from 20($fp)</span>
<span class="go">      subu    $1, $2, $1</span>
<span class="go">      sw      $1, 16($fp)</span>
<span class="go">      move     $2, $1     # move result to return register $2</span>
<span class="go">      move     $sp, $fp</span>
<span class="go">      lw      $fp, 24($sp)            # 4-byte Folded Reload</span>
<span class="go">      lw      $ra, 28($sp)            # 4-byte Folded Reload</span>
<span class="go">      addiu   $sp, $sp, 32</span>
<span class="go">      jr      $ra</span>
<span class="go">      nop</span>
<span class="go">      .set    at</span>
<span class="go">      .set    macro</span>
<span class="go">      .set    reorder</span>
<span class="go">      .end    _Z6calleev</span>
<span class="gp">$</span>func_end0:
<span class="go">      .size   _Z6calleev, ($func_end0)-_Z6calleev</span>
<span class="go">      .cfi_endproc</span>
</pre></div>
</div>
<p>Caller and callee saved registers definition as follows,</p>
<ul class="simple">
<li><p>If the caller wants to use caller-saved registers after callee function, it
must save caller-saved registers’ content to memory for using and restore
these registers from memory after function call.</p></li>
<li><p>If the callee wants to use callee-saved registers, it must save its content
to memory before using them and restore these registers from memory before
return.</p></li>
</ul>
<p>As above definition, if a register is not a callee-saved-registers, then it
must be caller-saved-registers because the callee doesn’t retore it and the
value is changed after callee function.
So, Mips only define the callee-saved registers in MipsCallingConv.td, and
can be found in CSR_O32_SaveList of MipsGenRgisterInfo.inc for the default
ABI.</p>
<p>As above assembly output, Mips allocates t1 variable to register $1 and no need
to spill $1 since $1 is caller saved register.
On the other hand, $ra is callee saved register, so it spills at beginning of
the assembly output since jal uses $ra register.
Cpu0 $lr is the same register as Mips $ra, so it calls setAliasRegs(MF,
SavedRegs, Cpu0::LR) in determineCalleeSaves() of Cpu0SEFrameLowering.cpp when
the function has called another function.</p>
</section>
<section id="live-in-and-live-out-register">
<h3><a class="toc-backref" href="#id83">Live in and live out register</a><a class="headerlink" href="#live-in-and-live-out-register" title="Permalink to this headline">¶</a></h3>
<p>As the example of last sub-section. The $ra is “live in” register since the
return address is decided by caller. The $2 is “live out” register since the
return value of the function is saved in this register, and caller can get the
result by read it directly as the comment in above example.
Through mark “live in” and “live out” registers, backend provides
llvm middle layer information to remove useless instructions in variables
access.
Of course, llvm applies the DAG analysis mentioned in the previous sub-section
to finish it.
Since C supports seperate compilation for different functions, the “live in”
and “out” information from backend provides the optimization opportunity to
llvm.
LLVM provides function addLiveIn() to mark “live in” register but no function
addLiveOut() provided.
For the “live out” register, Mips backend marks it by
DAG=DAG.getCopyToReg(…, $2, …) and return DAG instead, since all local
varaiables are not exist after function exit.</p>
</section>
</section>
<section id="create-cpu0-backend">
<h2><a class="toc-backref" href="#id84">Create Cpu0 backend</a><a class="headerlink" href="#create-cpu0-backend" title="Permalink to this headline">¶</a></h2>
<p>From now on, the Cpu0 backend will be created from scratch step by step.
To make readers easily understanding the backend structure, Cpu0
example code can be generated chapter by chapter through command here
<a class="footnote-reference brackets" href="#chapters-ex" id="id34">11</a>.
Cpu0 example code, lbdex, can be found at near left bottom of this web site. Or
here <a class="reference external" href="http://jonathan2251.github.io/lbd/lbdex.tar.gz">http://jonathan2251.github.io/lbd/lbdex.tar.gz</a>.</p>
<section id="cpu0-backend-machine-id-and-relocation-records">
<h3><a class="toc-backref" href="#id85">Cpu0 backend machine ID and relocation records</a><a class="headerlink" href="#cpu0-backend-machine-id-and-relocation-records" title="Permalink to this headline">¶</a></h3>
<p>To create a new backend, there are some files in &lt;&lt;llvm root dir&gt;&gt; need to be
modified. The added information include both the ID and name of machine, and
relocation records. Chapter “ELF Support” include the relocation records
introduction. The following files are modified to add Cpu0 backend as follows,</p>
<p class="rubric">lbdex/llvm/modify/llvm/config-ix.cmake</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>...
elseif (LLVM_NATIVE_ARCH MATCHES &quot;cpu0&quot;)
  set(LLVM_NATIVE_ARCH Cpu0)
...
</pre></div>
</div>
<p class="rubric">lbdex/llvm/modify/llvm/CMakeLists.txt</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">set</span><span class="p">(</span><span class="s">LLVM_ALL_TARGETS</span>
<span class="w">  </span><span class="s">...</span>
<span class="w">  </span><span class="s">Cpu0</span>
<span class="w">  </span><span class="s">...</span>
<span class="w">  </span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">lbdex/llvm/modify/llvm/include/llvm/ADT/Triple.h</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">...</span><span class="w"></span>
<span class="cp">#undef mips</span>
<span class="cp">#undef cpu0</span>
<span class="p">...</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">Triple</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">enum</span><span class="w"> </span><span class="nc">ArchType</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="n">cpu0</span><span class="p">,</span><span class="w">       </span><span class="c1">// For Tutorial Backend Cpu0</span>
<span class="w">    </span><span class="n">cpu0el</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/llvm/modify/llvm/include/llvm/Object/ELFObjectFile.h</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">...</span><span class="w"></span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">ELFT</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">StringRef</span><span class="w"> </span><span class="n">ELFObjectFile</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;::</span><span class="n">getFileFormatName</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">EF</span><span class="p">.</span><span class="n">getHeader</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">[</span><span class="n">ELF</span><span class="o">::</span><span class="n">EI_CLASS</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="n">ELF</span><span class="o">::</span><span class="n">ELFCLASS32</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">EF</span><span class="p">.</span><span class="n">getHeader</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">e_machine</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="n">ELF</span><span class="o">::</span><span class="n">EM_CPU0</span><span class="o">:</span><span class="w">        </span><span class="c1">// llvm-objdump -t -r</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;ELF32-cpu0&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">ELFT</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="n">ELFObjectFile</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;::</span><span class="n">getArch</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">IsLittleEndian</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ELFT</span><span class="o">::</span><span class="n">TargetEndianness</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">support</span><span class="o">::</span><span class="n">little</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">EF</span><span class="p">.</span><span class="n">getHeader</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">e_machine</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="n">ELF</span><span class="o">::</span><span class="n">EM_CPU0</span><span class="o">:</span><span class="w">  </span><span class="c1">// llvm-objdump -t -r</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">EF</span><span class="p">.</span><span class="n">getHeader</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">[</span><span class="n">ELF</span><span class="o">::</span><span class="n">EI_CLASS</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="n">ELF</span><span class="o">::</span><span class="n">ELFCLASS32</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">IsLittleEndian</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">Triple</span><span class="o">::</span><span class="n">cpu0el</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Triple</span><span class="o">::</span><span class="n">cpu0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">default</span><span class="o">:</span><span class="w"></span>
<span class="w">      </span><span class="n">report_fatal_error</span><span class="p">(</span><span class="s">&quot;Invalid ELFCLASS!&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/llvm/modify/llvm/include/llvm/Support/ELF.h</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="n">EM_CPU0</span><span class="w">          </span><span class="o">=</span><span class="w"> </span><span class="mi">999</span><span class="w">  </span><span class="c1">// Document LLVM Backend Tutorial Cpu0</span>
<span class="p">};</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="c1">// Cpu0 Specific e_flags</span>
<span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">EF_CPU0_NOREORDER</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000001</span><span class="p">,</span><span class="w"> </span><span class="c1">// Don&#39;t reorder instructions</span>
<span class="w">  </span><span class="n">EF_CPU0_PIC</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000002</span><span class="p">,</span><span class="w"> </span><span class="c1">// Position independent code</span>
<span class="w">  </span><span class="n">EF_CPU0_ARCH_32</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="mh">0x50000000</span><span class="p">,</span><span class="w"> </span><span class="c1">// CPU032 instruction set per linux not elf.h</span>
<span class="w">  </span><span class="n">EF_CPU0_ARCH</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="mh">0xf0000000</span><span class="w">  </span><span class="c1">// Mask for applying EF_CPU0_ARCH_ variant</span>
<span class="p">};</span><span class="w"></span>

<span class="c1">// ELF Relocation types for Mips</span>
<span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;ELFRelocs/Cpu0.def&quot;</span><span class="cp"></span>
<span class="p">};</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/llvm/modify/llvm/lib/MC/MCSubtargetInfo.cpp</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">Cpu0DisableUnreconginizedMessage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">MCSubtargetInfo::InitMCProcessorInfo</span><span class="p">(</span><span class="n">StringRef</span><span class="w"> </span><span class="n">CPU</span><span class="p">,</span><span class="w"> </span><span class="n">StringRef</span><span class="w"> </span><span class="n">FS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="cp">#if 1 </span><span class="c1">// Disable reconginized processor message. For Cpu0</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">TargetTriple</span><span class="p">.</span><span class="n">getArch</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">Triple</span><span class="o">::</span><span class="n">cpu0</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">      </span><span class="n">TargetTriple</span><span class="p">.</span><span class="n">getArch</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">Triple</span><span class="o">::</span><span class="n">cpu0el</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">Cpu0DisableUnreconginizedMessage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="cp">#endif</span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">MCSchedModel</span><span class="w"> </span><span class="o">&amp;</span><span class="n">MCSubtargetInfo</span><span class="o">::</span><span class="n">getSchedModelForCPU</span><span class="p">(</span><span class="n">StringRef</span><span class="w"> </span><span class="n">CPU</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="cp">#if 1 </span><span class="c1">// Disable reconginized processor message. For Cpu0</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">TargetTriple</span><span class="p">.</span><span class="n">getArch</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">Triple</span><span class="o">::</span><span class="n">cpu0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">        </span><span class="n">TargetTriple</span><span class="p">.</span><span class="n">getArch</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">Triple</span><span class="o">::</span><span class="n">cpu0el</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="cp">#endif</span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/llvm/modify/llvm/lib/MC/SubtargetFeature.cpp</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">Cpu0DisableUnreconginizedMessage</span><span class="p">;</span><span class="w"> </span><span class="c1">// For Cpu0</span>
<span class="p">...</span><span class="w"></span>
<span class="n">FeatureBitset</span><span class="w"></span>
<span class="n">SubtargetFeatures</span><span class="o">::</span><span class="n">ToggleFeature</span><span class="p">(</span><span class="n">FeatureBitset</span><span class="w"> </span><span class="n">Bits</span><span class="p">,</span><span class="w"> </span><span class="n">StringRef</span><span class="w"> </span><span class="n">Feature</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">SubtargetFeatureKV</span><span class="o">&gt;</span><span class="w"> </span><span class="n">FeatureTable</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">Cpu0DisableUnreconginizedMessage</span><span class="p">)</span><span class="w"> </span><span class="c1">// For Cpu0</span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">FeatureBitset</span><span class="w"></span>
<span class="n">SubtargetFeatures</span><span class="o">::</span><span class="n">ApplyFeatureFlag</span><span class="p">(</span><span class="n">FeatureBitset</span><span class="w"> </span><span class="n">Bits</span><span class="p">,</span><span class="w"> </span><span class="n">StringRef</span><span class="w"> </span><span class="n">Feature</span><span class="p">,</span><span class="w"></span>
<span class="w">                                    </span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">SubtargetFeatureKV</span><span class="o">&gt;</span><span class="w"> </span><span class="n">FeatureTable</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">Cpu0DisableUnreconginizedMessage</span><span class="p">)</span><span class="w"> </span><span class="c1">// For Cpu0</span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">FeatureBitset</span><span class="w"></span>
<span class="n">SubtargetFeatures</span><span class="o">::</span><span class="n">getFeatureBits</span><span class="p">(</span><span class="n">StringRef</span><span class="w"> </span><span class="n">CPU</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">SubtargetFeatureKV</span><span class="o">&gt;</span><span class="w"> </span><span class="n">CPUTable</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">SubtargetFeatureKV</span><span class="o">&gt;</span><span class="w"> </span><span class="n">FeatureTable</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">Cpu0DisableUnreconginizedMessage</span><span class="p">)</span><span class="w"> </span><span class="c1">// For Cpu0</span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lib/object/ELF.cpp</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">...</span><span class="w"></span>

<span class="n">StringRef</span><span class="w"> </span><span class="n">getELFRelocationTypeName</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">Machine</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">Type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">Machine</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="n">ELF</span><span class="o">::</span><span class="n">EM_CPU0</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">Type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;llvm/Support/ELFRelocs/Cpu0.def&quot;</span><span class="cp"></span>
<span class="w">    </span><span class="k">default</span><span class="o">:</span><span class="w"></span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">include/llvm/Support/ELFRelocs/Cpu0.def</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="c1">#ifndef ELF_RELOC</span>
<span class="c1">#error &quot;ELF_RELOC must be defined&quot;</span>
<span class="c1">#endif</span>

<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_NONE</span><span class="p">,</span>                <span class="mi">0</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_32</span><span class="p">,</span>                  <span class="mi">2</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_HI16</span><span class="p">,</span>                <span class="mi">5</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_LO16</span><span class="p">,</span>                <span class="mi">6</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_GPREL16</span><span class="p">,</span>             <span class="mi">7</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_LITERAL</span><span class="p">,</span>             <span class="mi">8</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_GOT16</span><span class="p">,</span>               <span class="mi">9</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_PC16</span><span class="p">,</span>               <span class="mi">10</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_CALL16</span><span class="p">,</span>             <span class="mi">11</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_GPREL32</span><span class="p">,</span>            <span class="mi">12</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_PC24</span><span class="p">,</span>               <span class="mi">13</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_GOT_HI16</span><span class="p">,</span>           <span class="mi">22</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_GOT_LO16</span><span class="p">,</span>           <span class="mi">23</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_RELGOT</span><span class="p">,</span>             <span class="mi">36</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_TLS_GD</span><span class="p">,</span>             <span class="mi">42</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_TLS_LDM</span><span class="p">,</span>            <span class="mi">43</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_TLS_DTP_HI16</span><span class="p">,</span>       <span class="mi">44</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_TLS_DTP_LO16</span><span class="p">,</span>       <span class="mi">45</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_TLS_GOTTPREL</span><span class="p">,</span>       <span class="mi">46</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_TLS_TPREL32</span><span class="p">,</span>        <span class="mi">47</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_TLS_TP_HI16</span><span class="p">,</span>        <span class="mi">49</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_TLS_TP_LO16</span><span class="p">,</span>        <span class="mi">50</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_GLOB_DAT</span><span class="p">,</span>           <span class="mi">51</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_JUMP_SLOT</span><span class="p">,</span>          <span class="mi">127</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">lbdex/llvm/modify/llvm/lib/Support/Triple.cpp</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nf">Triple::getArchTypeName</span><span class="p">(</span><span class="n">ArchType</span><span class="w"> </span><span class="n">Kind</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">Kind</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="nl">cpu0</span><span class="p">:</span><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;cpu0&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="nl">cpu0el</span><span class="p">:</span><span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;cpu0el&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">Triple</span><span class="o">::</span><span class="n">getArchTypePrefix</span><span class="p">(</span><span class="n">ArchType</span><span class="w"> </span><span class="n">Kind</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">Kind</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="nl">cpu0</span><span class="p">:</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="nl">cpu0el</span><span class="p">:</span><span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;cpu0&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="n">Triple</span><span class="o">::</span><span class="n">ArchType</span><span class="w"> </span><span class="n">Triple</span><span class="o">::</span><span class="n">getArchTypeForLLVMName</span><span class="p">(</span><span class="n">StringRef</span><span class="w"> </span><span class="n">Name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">StringSwitch</span><span class="o">&lt;</span><span class="n">Triple</span><span class="o">::</span><span class="n">ArchType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Name</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;cpu0&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">cpu0</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;cpu0el&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">cpu0el</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="n">Triple</span><span class="o">::</span><span class="n">ArchType</span><span class="w"> </span><span class="n">parseArch</span><span class="p">(</span><span class="n">StringRef</span><span class="w"> </span><span class="n">ArchName</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">StringSwitch</span><span class="o">&lt;</span><span class="n">Triple</span><span class="o">::</span><span class="n">ArchType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ArchName</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">Cases</span><span class="p">(</span><span class="s">&quot;cpu0&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;cpu0eb&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;cpu0allegrex&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">Triple</span><span class="o">::</span><span class="n">cpu0</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">Cases</span><span class="p">(</span><span class="s">&quot;cpu0el&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;cpu0allegrexel&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">Triple</span><span class="o">::</span><span class="n">cpu0el</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="n">Triple</span><span class="o">::</span><span class="n">ObjectFormatType</span><span class="w"> </span><span class="n">getDefaultFormat</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Triple</span><span class="w"> </span><span class="o">&amp;</span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="n">Triple</span><span class="o">::</span><span class="n">cpu0</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="n">Triple</span><span class="o">::</span><span class="n">cpu0el</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">getArchPointerBitWidth</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">Triple</span><span class="o">::</span><span class="n">ArchType</span><span class="w"> </span><span class="n">Arch</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">Arch</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">Triple</span><span class="o">::</span><span class="n">cpu0</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">Triple</span><span class="o">::</span><span class="n">cpu0el</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="n">Triple</span><span class="w"> </span><span class="n">Triple</span><span class="o">::</span><span class="n">get32BitArchVariant</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">Triple</span><span class="w"> </span><span class="nf">T</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">getArch</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="n">Triple</span><span class="o">::</span><span class="n">cpu0</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="n">Triple</span><span class="o">::</span><span class="n">cpu0el</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Already 32-bit.</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="creating-the-initial-cpu0-td-files">
<h3><a class="toc-backref" href="#id86">Creating the Initial Cpu0 .td Files</a><a class="headerlink" href="#creating-the-initial-cpu0-td-files" title="Permalink to this headline">¶</a></h3>
<p>As it has been discussed in the previous section, LLVM uses target description
files (which uses the .td file extension) to describe various components of a
target’s backend.
For example, these .td files may describe a target’s register set, instruction
set, scheduling information for instructions, and calling conventions.
When your backend is being compiled, the tablegen tool that ships with LLVM
will translate these .td files into C++ source code written to files that have
a .inc extension.
Please refer to <a class="footnote-reference brackets" href="#tblgen" id="id35">29</a> for more information regarding how to use tablegen.</p>
<p>Every backend has its own .td to define some target information.
These files have a similar syntax to C++. For Cpu0, the target description file
is called Cpu0Other.td, which is shown below:</p>
<p class="rubric">lbdex/chapters/Chapter2/Cpu0Other.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//===--</span> <span class="n">Cpu0Other</span><span class="o">.</span><span class="n">td</span> <span class="o">-</span> <span class="n">Describe</span> <span class="n">the</span> <span class="n">Cpu0</span> <span class="n">Target</span> <span class="n">Machine</span> <span class="o">----*-</span> <span class="n">tablegen</span> <span class="o">-*-===//</span>
<span class="o">//</span>
<span class="o">//</span>                     <span class="n">The</span> <span class="n">LLVM</span> <span class="n">Compiler</span> <span class="n">Infrastructure</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">This</span> <span class="n">file</span> <span class="ow">is</span> <span class="n">distributed</span> <span class="n">under</span> <span class="n">the</span> <span class="n">University</span> <span class="n">of</span> <span class="n">Illinois</span> <span class="n">Open</span> <span class="n">Source</span>
<span class="o">//</span> <span class="n">License</span><span class="o">.</span> <span class="n">See</span> <span class="n">LICENSE</span><span class="o">.</span><span class="n">TXT</span> <span class="k">for</span> <span class="n">details</span><span class="o">.</span>
<span class="o">//</span>
<span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">//</span> <span class="n">This</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">top</span> <span class="n">level</span> <span class="n">entry</span> <span class="n">point</span> <span class="k">for</span> <span class="n">the</span> <span class="n">Cpu0</span> <span class="n">target</span><span class="o">.</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">//</span> <span class="n">Target</span><span class="o">-</span><span class="n">independent</span> <span class="n">interfaces</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="n">include</span> <span class="s2">&quot;llvm/Target/Target.td&quot;</span>

<span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">//</span> <span class="n">Target</span><span class="o">-</span><span class="n">dependent</span> <span class="n">interfaces</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="n">include</span> <span class="s2">&quot;Cpu0RegisterInfo.td&quot;</span>
<span class="n">include</span> <span class="s2">&quot;Cpu0RegisterInfoGPROutForOther.td&quot;</span> <span class="o">//</span> <span class="k">except</span> <span class="n">AsmParser</span>
<span class="n">include</span> <span class="s2">&quot;Cpu0.td&quot;</span>

</pre></div>
</div>
<p>Cpu0Other.td and Cpu0.td includes a few other .td files.
Cpu0RegisterInfo.td (shown below) describes the Cpu0’s set of registers.
In this file, we see that each register has been given a name. For example,
<strong>“def PC”</strong> indicates that there is a register name as PC. Beside of register
information, it also define register class information.
You may have multiple register classes such as CPURegs, SR, C0Regs and GPROut.
GPROut defined in Cpu0RegisterInfoGPROutForOther.td which include CPURegs
except SW, so SW won’t be allocated as the output registers in register
allocation stage.</p>
<p class="rubric">lbdex/chapters/Chapter2/Cpu0RegisterInfo.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//===--</span> <span class="n">Cpu0RegisterInfo</span><span class="o">.</span><span class="n">td</span> <span class="o">-</span> <span class="n">Cpu0</span> <span class="n">Register</span> <span class="n">defs</span> <span class="o">-----------*-</span> <span class="n">tablegen</span> <span class="o">-*-===//</span>
<span class="o">//</span>
<span class="o">//</span>                     <span class="n">The</span> <span class="n">LLVM</span> <span class="n">Compiler</span> <span class="n">Infrastructure</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">This</span> <span class="n">file</span> <span class="ow">is</span> <span class="n">distributed</span> <span class="n">under</span> <span class="n">the</span> <span class="n">University</span> <span class="n">of</span> <span class="n">Illinois</span> <span class="n">Open</span> <span class="n">Source</span>
<span class="o">//</span> <span class="n">License</span><span class="o">.</span> <span class="n">See</span> <span class="n">LICENSE</span><span class="o">.</span><span class="n">TXT</span> <span class="k">for</span> <span class="n">details</span><span class="o">.</span>
<span class="o">//</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">//</span>  <span class="n">Declarations</span> <span class="n">that</span> <span class="n">describe</span> <span class="n">the</span> <span class="n">CPU0</span> <span class="n">register</span> <span class="n">file</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="o">//</span> <span class="n">We</span> <span class="n">have</span> <span class="n">banks</span> <span class="n">of</span> <span class="mi">16</span> <span class="n">registers</span> <span class="n">each</span><span class="o">.</span>
<span class="k">class</span> <span class="nc">Cpu0Reg</span><span class="o">&lt;</span><span class="n">bits</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span> <span class="n">Enc</span><span class="p">,</span> <span class="n">string</span> <span class="n">n</span><span class="o">&gt;</span> <span class="p">:</span> <span class="n">Register</span><span class="o">&lt;</span><span class="n">n</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="o">//</span> <span class="n">For</span> <span class="n">tablegen</span><span class="p">(</span><span class="o">...</span> <span class="o">-</span><span class="n">gen</span><span class="o">-</span><span class="n">emitter</span><span class="p">)</span>  <span class="ow">in</span> <span class="n">CMakeLists</span><span class="o">.</span><span class="n">txt</span>
  <span class="n">let</span> <span class="n">HWEncoding</span> <span class="o">=</span> <span class="n">Enc</span><span class="p">;</span>
  
  <span class="n">let</span> <span class="n">Namespace</span> <span class="o">=</span> <span class="s2">&quot;Cpu0&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">Cpu0</span> <span class="n">CPU</span> <span class="n">Registers</span>
<span class="k">class</span> <span class="nc">Cpu0GPRReg</span><span class="o">&lt;</span><span class="n">bits</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span> <span class="n">Enc</span><span class="p">,</span> <span class="n">string</span> <span class="n">n</span><span class="o">&gt;</span> <span class="p">:</span> <span class="n">Cpu0Reg</span><span class="o">&lt;</span><span class="n">Enc</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Co</span><span class="o">-</span><span class="n">processor</span> <span class="mi">0</span> <span class="n">Registers</span>
<span class="k">class</span> <span class="nc">Cpu0C0Reg</span><span class="o">&lt;</span><span class="n">bits</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span> <span class="n">Enc</span><span class="p">,</span> <span class="n">string</span> <span class="n">n</span><span class="o">&gt;</span> <span class="p">:</span> <span class="n">Cpu0Reg</span><span class="o">&lt;</span><span class="n">Enc</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;</span><span class="p">;</span>

<span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">//</span><span class="nd">@Registers</span>
<span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">//</span> <span class="n">The</span> <span class="n">register</span> <span class="n">string</span><span class="p">,</span> <span class="n">such</span> <span class="k">as</span> <span class="s2">&quot;9&quot;</span> <span class="ow">or</span> <span class="s2">&quot;gp&quot;</span> <span class="n">will</span> <span class="n">show</span> <span class="n">on</span> <span class="s2">&quot;llvm-objdump -d&quot;</span>
<span class="o">//@</span> <span class="n">All</span> <span class="n">registers</span> <span class="n">definition</span>
<span class="n">let</span> <span class="n">Namespace</span> <span class="o">=</span> <span class="s2">&quot;Cpu0&quot;</span> <span class="ow">in</span> <span class="p">{</span>
  <span class="o">//@</span> <span class="n">General</span> <span class="n">Purpose</span> <span class="n">Registers</span>
  <span class="k">def</span> <span class="nf">ZERO</span> <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span>  <span class="s2">&quot;zero&quot;</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">AT</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span>  <span class="s2">&quot;1&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">V0</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span>  <span class="s2">&quot;2&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">V1</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span>  <span class="s2">&quot;3&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">A0</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">,</span>  <span class="s2">&quot;4&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">A1</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">,</span>  <span class="s2">&quot;5&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">T9</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">,</span>  <span class="s2">&quot;t9&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">T0</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">7</span><span class="p">,</span>  <span class="s2">&quot;7&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">T1</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span>  <span class="s2">&quot;8&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">S0</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">9</span><span class="p">,</span>  <span class="s2">&quot;9&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">S1</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">GP</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">11</span><span class="p">,</span> <span class="s2">&quot;gp&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">FP</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">12</span><span class="p">,</span> <span class="s2">&quot;fp&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">SP</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">13</span><span class="p">,</span> <span class="s2">&quot;sp&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">LR</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">14</span><span class="p">,</span> <span class="s2">&quot;lr&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">SW</span>   <span class="p">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">15</span><span class="p">,</span> <span class="s2">&quot;sw&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="o">//</span>  <span class="k">def</span> <span class="nf">MAR</span>  <span class="p">:</span> <span class="n">Register</span><span class="o">&lt;</span> <span class="mi">16</span><span class="p">,</span> <span class="s2">&quot;mar&quot;</span><span class="o">&gt;</span><span class="p">,</span>  <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="o">//</span>  <span class="k">def</span> <span class="nf">MDR</span>  <span class="p">:</span> <span class="n">Register</span><span class="o">&lt;</span> <span class="mi">17</span><span class="p">,</span> <span class="s2">&quot;mdr&quot;</span><span class="o">&gt;</span><span class="p">,</span>  <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>

  <span class="k">def</span> <span class="nf">PC</span>   <span class="p">:</span> <span class="n">Cpu0C0Reg</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;pc&quot;</span><span class="o">&gt;</span><span class="p">,</span>  <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">EPC</span>  <span class="p">:</span> <span class="n">Cpu0C0Reg</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;epc&quot;</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">21</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">//</span><span class="nd">@Register</span> <span class="n">Classes</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="k">def</span> <span class="nf">CPURegs</span> <span class="p">:</span> <span class="n">RegisterClass</span><span class="o">&lt;</span><span class="s2">&quot;Cpu0&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">i32</span><span class="p">],</span> <span class="mi">32</span><span class="p">,</span> <span class="p">(</span><span class="n">add</span>
  <span class="o">//</span> <span class="n">Reserved</span>
  <span class="n">ZERO</span><span class="p">,</span> <span class="n">AT</span><span class="p">,</span> 
  <span class="o">//</span> <span class="n">Return</span> <span class="n">Values</span> <span class="ow">and</span> <span class="n">Arguments</span>
  <span class="n">V0</span><span class="p">,</span> <span class="n">V1</span><span class="p">,</span> <span class="n">A0</span><span class="p">,</span> <span class="n">A1</span><span class="p">,</span> 
  <span class="o">//</span> <span class="n">Not</span> <span class="n">preserved</span> <span class="n">across</span> <span class="n">procedure</span> <span class="n">calls</span>
  <span class="n">T9</span><span class="p">,</span> <span class="n">T0</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span>
  <span class="o">//</span> <span class="n">Callee</span> <span class="n">save</span>
  <span class="n">S0</span><span class="p">,</span> <span class="n">S1</span><span class="p">,</span>
  <span class="o">//</span> <span class="n">Reserved</span>
  <span class="n">GP</span><span class="p">,</span> <span class="n">FP</span><span class="p">,</span> 
  <span class="n">SP</span><span class="p">,</span> <span class="n">LR</span><span class="p">,</span> <span class="n">SW</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>

<span class="o">//</span><span class="nd">@Status</span> <span class="n">Registers</span> <span class="k">class</span>
<span class="nc">def</span> <span class="n">SR</span>     <span class="p">:</span> <span class="n">RegisterClass</span><span class="o">&lt;</span><span class="s2">&quot;Cpu0&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">i32</span><span class="p">],</span> <span class="mi">32</span><span class="p">,</span> <span class="p">(</span><span class="n">add</span> <span class="n">SW</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>

<span class="o">//</span><span class="nd">@Co</span><span class="o">-</span><span class="n">processor</span> <span class="mi">0</span> <span class="n">Registers</span> <span class="k">class</span>
<span class="nc">def</span> <span class="n">C0Regs</span> <span class="p">:</span> <span class="n">RegisterClass</span><span class="o">&lt;</span><span class="s2">&quot;Cpu0&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">i32</span><span class="p">],</span> <span class="mi">32</span><span class="p">,</span> <span class="p">(</span><span class="n">add</span> <span class="n">PC</span><span class="p">,</span> <span class="n">EPC</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>

</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter2/Cpu0RegisterInfoGPROutForOther.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">//</span> <span class="n">Register</span> <span class="n">Classes</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="k">def</span> <span class="nf">GPROut</span> <span class="p">:</span> <span class="n">RegisterClass</span><span class="o">&lt;</span><span class="s2">&quot;Cpu0&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">i32</span><span class="p">],</span> <span class="mi">32</span><span class="p">,</span> <span class="p">(</span><span class="n">add</span> <span class="p">(</span><span class="n">sub</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="n">SW</span><span class="p">))</span><span class="o">&gt;</span><span class="p">;</span>

</pre></div>
</div>
<p>In C++, class typically provides a structure to lay out some data and functions,
while definitions are used to allocate memory for specific instances of a class.
For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Date</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// declare Date</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">year</span><span class="p">,</span><span class="w"> </span><span class="n">month</span><span class="p">,</span><span class="w"> </span><span class="n">day</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="n">Date</span><span class="w"> </span><span class="n">birthday</span><span class="p">;</span><span class="w">  </span><span class="c1">// define birthday, an instance of Date</span>
</pre></div>
</div>
<p>The class <strong>Date</strong> has the members <strong>year</strong>, <strong>month</strong>, and <strong>day</strong>, but
these do not yet belong to an actual object.
By defining an instance of <strong>Date</strong> called <strong>birthday</strong>, you have allocated
memory for a specific object, and can set the <strong>year</strong>, <strong>month</strong>, and
<strong>day</strong> of this instance of the class.</p>
<p>In .td files, class describes the structure of how data is laid out, while
definitions act as the specific instances of the class.
If you look back at the Cpu0RegisterInfo.td file, you will see a class called
<strong>Cpu0Reg</strong> which is derived from the <strong>Register</strong> class provided
by LLVM.  <strong>Cpu0Reg</strong> inherits all the fields that exist
in the <strong>Register</strong> class. The “let HWEncoding = Enc” which means assign field
HWEncoding from parameter Enc. Since Cpu0 reserve 4 bits for 16 registers in
instruction format, the assigned value range is from 0 to 15.
Once assigning the 0 to 15 to HWEncoding, the backend register number will be
got from the function of llvm register class since TableGen will set this
number automatically.</p>
<p>The <strong>def</strong> keyword is used to create instances of class.
In the following line, the ZERO register is defined as a member of the
<strong>Cpu0GPRReg</strong> class:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">def</span><span class="w"> </span><span class="n">ZERO</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ZERO&quot;</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>The <strong>def ZERO</strong> indicates the name of this register.  <strong>&lt;0, “ZERO”&gt;</strong> are the
parameters used when creating this specific instance of the <strong>Cpu0GPRReg</strong>
class, thus the field <strong>Enc</strong> is set to 0, and the string <strong>n</strong> is set
to <strong>ZERO</strong>.</p>
<p>As the register lives in the <strong>Cpu0</strong> namespace, you can refer to the ZERO
register in backend C++ code by using <strong>Cpu0::ZERO</strong>.</p>
<p>Notice the use of the <strong>let</strong> expressions: these allow you to override values
that are initially defined in a superclass.
For example, <strong>let Namespace = “Cpu0”</strong> in the <strong>Cpu0Reg</strong> class will override
the default namespace declared in <strong>Register</strong> class.
The Cpu0RegisterInfo.td also defines that <strong>CPURegs</strong> is an instance of the
class <strong>RegisterClass</strong>, which is an built-in LLVM class.
A <strong>RegisterClass</strong> is a set of <strong>Register</strong> instances, thus <strong>CPURegs</strong> can be
described as a set of registers.</p>
<p>The Cpu0 instructions td is named to Cpu0InstrInfo.td which contents as follows,</p>
<p class="rubric">lbdex/chapters/Chapter2/Cpu0InstrInfo.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>//===- Cpu0InstrInfo.td - Target Description for Cpu0 Target -*- tablegen -*-=//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file contains the Cpu0 implementation of the TargetInstrInfo class.
//
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// Cpu0 profiles and nodes
//===----------------------------------------------------------------------===//

def SDT_Cpu0Ret          : SDTypeProfile&lt;0, 1, [SDTCisInt&lt;0&gt;]&gt;;

// Return
def Cpu0Ret : SDNode&lt;&quot;Cpu0ISD::Ret&quot;, SDTNone,
                     [SDNPHasChain, SDNPOptInGlue, SDNPVariadic]&gt;;

//===----------------------------------------------------------------------===//
// Instruction format superclass
//===----------------------------------------------------------------------===//

include &quot;Cpu0InstrFormats.td&quot;

//===----------------------------------------------------------------------===//
// Cpu0 Operand, Complex Patterns and Transformations Definitions.
//===----------------------------------------------------------------------===//
// Instruction operand types

// Signed Operand
def simm16      : Operand&lt;i32&gt; {
  let DecoderMethod= &quot;DecodeSimm16&quot;;
}

// Address operand
def mem : Operand&lt;iPTR&gt; {
  let PrintMethod = &quot;printMemOperand&quot;;
  let MIOperandInfo = (ops GPROut, simm16);
  let EncoderMethod = &quot;getMemEncoding&quot;;
}

// Node immediate fits as 16-bit sign extended on target immediate.
// e.g. addi, andi
def immSExt16  : PatLeaf&lt;(imm), [{ return isInt&lt;16&gt;(N-&gt;getSExtValue()); }]&gt;;

// Cpu0 Address Mode! SDNode frameindex could possibily be a match
// since load and store instructions from stack used it.
def addr : 
  ComplexPattern&lt;iPTR, 2, &quot;SelectAddr&quot;, [frameindex], [SDNPWantParent]&gt;;

//===----------------------------------------------------------------------===//
// Pattern fragment for load/store
//===----------------------------------------------------------------------===//

class AlignedLoad&lt;PatFrag Node&gt; :
  PatFrag&lt;(ops node:$ptr), (Node node:$ptr), [{
  LoadSDNode *LD = cast&lt;LoadSDNode&gt;(N);
  return LD-&gt;getMemoryVT().getSizeInBits()/8 &lt;= LD-&gt;getAlignment();
}]&gt;;

class AlignedStore&lt;PatFrag Node&gt; :
  PatFrag&lt;(ops node:$val, node:$ptr), (Node node:$val, node:$ptr), [{
  StoreSDNode *SD = cast&lt;StoreSDNode&gt;(N);
  return SD-&gt;getMemoryVT().getSizeInBits()/8 &lt;= SD-&gt;getAlignment();
}]&gt;;

// Load/Store PatFrags.
def load_a          : AlignedLoad&lt;load&gt;;
def store_a         : AlignedStore&lt;store&gt;;

//===----------------------------------------------------------------------===//
// Instructions specific format
//===----------------------------------------------------------------------===//

// Arithmetic and logical instructions with 2 register operands.
class ArithLogicI&lt;bits&lt;8&gt; op, string instr_asm, SDNode OpNode,
                  Operand Od, PatLeaf imm_type, RegisterClass RC&gt; :
  FL&lt;op, (outs GPROut:$ra), (ins RC:$rb, Od:$imm16),
     !strconcat(instr_asm, &quot;\t$ra, $rb, $imm16&quot;),
     [(set GPROut:$ra, (OpNode RC:$rb, imm_type:$imm16))], IIAlu&gt; {
  let isReMaterializable = 1;
}

class FMem&lt;bits&lt;8&gt; op, dag outs, dag ins, string asmstr, list&lt;dag&gt; pattern,
          InstrItinClass itin&gt;: FL&lt;op, outs, ins, asmstr, pattern, itin&gt; {
  bits&lt;20&gt; addr;
  let Inst{19-16} = addr{19-16};
  let Inst{15-0}  = addr{15-0};
  let DecoderMethod = &quot;DecodeMem&quot;;
}

// Memory Load/Store
let canFoldAsLoad = 1 in
class LoadM&lt;bits&lt;8&gt; op, string instr_asm, PatFrag OpNode, RegisterClass RC,
            Operand MemOpnd, bit Pseudo&gt;:
  FMem&lt;op, (outs RC:$ra), (ins MemOpnd:$addr),
     !strconcat(instr_asm, &quot;\t$ra, $addr&quot;),
     [(set RC:$ra, (OpNode addr:$addr))], IILoad&gt; {
  let isPseudo = Pseudo;
}

class StoreM&lt;bits&lt;8&gt; op, string instr_asm, PatFrag OpNode, RegisterClass RC,
             Operand MemOpnd, bit Pseudo&gt;:
  FMem&lt;op, (outs), (ins RC:$ra, MemOpnd:$addr),
     !strconcat(instr_asm, &quot;\t$ra, $addr&quot;),
     [(OpNode RC:$ra, addr:$addr)], IIStore&gt; {
  let isPseudo = Pseudo;
}

//@ 32-bit load.
class LoadM32&lt;bits&lt;8&gt; op, string instr_asm, PatFrag OpNode,
                   bit Pseudo = 0&gt;
  : LoadM&lt;op, instr_asm, OpNode, GPROut, mem, Pseudo&gt; {
}

// 32-bit store.
class StoreM32&lt;bits&lt;8&gt; op, string instr_asm, PatFrag OpNode,
                    bit Pseudo = 0&gt;
  : StoreM&lt;op, instr_asm, OpNode, GPROut, mem, Pseudo&gt; {
}

//@JumpFR {
let isBranch=1, isTerminator=1, isBarrier=1, imm16=0, hasDelaySlot = 1,
    isIndirectBranch = 1 in
class JumpFR&lt;bits&lt;8&gt; op, string instr_asm, RegisterClass RC&gt;:
  FL&lt;op, (outs), (ins RC:$ra),
     !strconcat(instr_asm, &quot;\t$ra&quot;), [(brind RC:$ra)], IIBranch&gt; {
  let rb = 0;
  let imm16 = 0;
}
//@JumpFR }

// Return instruction
class RetBase&lt;RegisterClass RC&gt;: JumpFR&lt;0x3c, &quot;ret&quot;, RC&gt; {
  let isReturn = 1;
  let isCodeGenOnly = 1;
  let hasCtrlDep = 1;
  let hasExtraSrcRegAllocReq = 1;
}

  
//===----------------------------------------------------------------------===//
// Instruction definition
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// Cpu0 Instructions
//===----------------------------------------------------------------------===//

/// Load and Store Instructions
///  aligned
def LD     : LoadM32&lt;0x01,  &quot;ld&quot;,  load_a&gt;;
def ST     : StoreM32&lt;0x02, &quot;st&quot;,  store_a&gt;;

/// Arithmetic Instructions (ALU Immediate)
// IR &quot;add&quot; defined in include/llvm/Target/TargetSelectionDAG.td, line 315 (def add).
def ADDiu   : ArithLogicI&lt;0x09, &quot;addiu&quot;, add, simm16, immSExt16, CPURegs&gt;;

/// Arithmetic Instructions (3-Operand, R-Type)

/// Shift Instructions

def JR      : JumpFR&lt;0x3c, &quot;jr&quot;, GPROut&gt;;

def RET     : RetBase&lt;GPROut&gt;;

/// No operation
let addr=0 in
  def NOP   : FJ&lt;0, (outs), (ins), &quot;nop&quot;, [], IIAlu&gt;;

//===----------------------------------------------------------------------===//
//  Arbitrary patterns that map to one or more instructions
//===----------------------------------------------------------------------===//

// Small immediates
def : Pat&lt;(i32 immSExt16:$in),
          (ADDiu ZERO, imm:$in)&gt;;

</pre></div>
</div>
<p>The Cpu0InstrFormats.td is included by Cpu0InstInfo.td as follows,</p>
<p class="rubric">lbdex/chapters/Chapter2/Cpu0InstrFormats.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//===--</span> <span class="n">Cpu0InstrFormats</span><span class="o">.</span><span class="n">td</span> <span class="o">-</span> <span class="n">Cpu0</span> <span class="n">Instruction</span> <span class="n">Formats</span> <span class="o">-----*-</span> <span class="n">tablegen</span> <span class="o">-*-===//</span>
<span class="o">//</span>
<span class="o">//</span>                     <span class="n">The</span> <span class="n">LLVM</span> <span class="n">Compiler</span> <span class="n">Infrastructure</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">This</span> <span class="n">file</span> <span class="ow">is</span> <span class="n">distributed</span> <span class="n">under</span> <span class="n">the</span> <span class="n">University</span> <span class="n">of</span> <span class="n">Illinois</span> <span class="n">Open</span> <span class="n">Source</span>
<span class="o">//</span> <span class="n">License</span><span class="o">.</span> <span class="n">See</span> <span class="n">LICENSE</span><span class="o">.</span><span class="n">TXT</span> <span class="k">for</span> <span class="n">details</span><span class="o">.</span>
<span class="o">//</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">//</span>  <span class="n">Describe</span> <span class="n">CPU0</span> <span class="n">instructions</span> <span class="nb">format</span>
<span class="o">//</span>
<span class="o">//</span>  <span class="n">CPU</span> <span class="n">INSTRUCTION</span> <span class="n">FORMATS</span>
<span class="o">//</span>
<span class="o">//</span>  <span class="n">opcode</span>  <span class="o">-</span> <span class="n">operation</span> <span class="n">code</span><span class="o">.</span>
<span class="o">//</span>  <span class="n">ra</span>      <span class="o">-</span> <span class="n">dst</span> <span class="n">reg</span><span class="p">,</span> <span class="n">only</span> <span class="n">used</span> <span class="n">on</span> <span class="mi">3</span> <span class="n">regs</span> <span class="n">instr</span><span class="o">.</span>
<span class="o">//</span>  <span class="n">rb</span>      <span class="o">-</span> <span class="n">src</span> <span class="n">reg</span><span class="o">.</span>
<span class="o">//</span>  <span class="n">rc</span>      <span class="o">-</span> <span class="n">src</span> <span class="n">reg</span> <span class="p">(</span><span class="n">on</span> <span class="n">a</span> <span class="mi">3</span> <span class="n">reg</span> <span class="n">instr</span><span class="p">)</span><span class="o">.</span>
<span class="o">//</span>  <span class="n">cx</span>      <span class="o">-</span> <span class="n">immediate</span>
<span class="o">//</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="o">//</span> <span class="n">Format</span> <span class="n">specifies</span> <span class="n">the</span> <span class="n">encoding</span> <span class="n">used</span> <span class="n">by</span> <span class="n">the</span> <span class="n">instruction</span><span class="o">.</span>  <span class="n">This</span> <span class="ow">is</span> <span class="n">part</span> <span class="n">of</span> <span class="n">the</span>
<span class="o">//</span> <span class="n">ad</span><span class="o">-</span><span class="n">hoc</span> <span class="n">solution</span> <span class="n">used</span> <span class="n">to</span> <span class="n">emit</span> <span class="n">machine</span> <span class="n">instruction</span> <span class="n">encodings</span> <span class="n">by</span> <span class="n">our</span> <span class="n">machine</span>
<span class="o">//</span> <span class="n">code</span> <span class="n">emitter</span><span class="o">.</span>
<span class="k">class</span> <span class="nc">Format</span><span class="o">&lt;</span><span class="n">bits</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span> <span class="n">val</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">bits</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span> <span class="n">Value</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">def</span> <span class="nf">Pseudo</span>    <span class="p">:</span> <span class="n">Format</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">FrmA</span>      <span class="p">:</span> <span class="n">Format</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">FrmL</span>      <span class="p">:</span> <span class="n">Format</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">FrmJ</span>      <span class="p">:</span> <span class="n">Format</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">FrmOther</span>  <span class="p">:</span> <span class="n">Format</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">;</span> <span class="o">//</span> <span class="n">Instruction</span> <span class="n">w</span><span class="o">/</span> <span class="n">a</span> <span class="n">custom</span> <span class="nb">format</span>

<span class="o">//</span> <span class="n">Generic</span> <span class="n">Cpu0</span> <span class="n">Format</span>
<span class="k">class</span> <span class="nc">Cpu0Inst</span><span class="o">&lt;</span><span class="n">dag</span> <span class="n">outs</span><span class="p">,</span> <span class="n">dag</span> <span class="n">ins</span><span class="p">,</span> <span class="n">string</span> <span class="n">asmstr</span><span class="p">,</span> <span class="nb">list</span><span class="o">&lt;</span><span class="n">dag</span><span class="o">&gt;</span> <span class="n">pattern</span><span class="p">,</span>
               <span class="n">InstrItinClass</span> <span class="n">itin</span><span class="p">,</span> <span class="n">Format</span> <span class="n">f</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">Instruction</span>
<span class="p">{</span>
  <span class="o">//</span> <span class="n">Inst</span> <span class="ow">and</span> <span class="n">Size</span><span class="p">:</span> <span class="k">for</span> <span class="n">tablegen</span><span class="p">(</span><span class="o">...</span> <span class="o">-</span><span class="n">gen</span><span class="o">-</span><span class="n">emitter</span><span class="p">)</span> <span class="ow">and</span> 
  <span class="o">//</span> <span class="n">tablegen</span><span class="p">(</span><span class="o">...</span> <span class="o">-</span><span class="n">gen</span><span class="o">-</span><span class="n">disassembler</span><span class="p">)</span> <span class="ow">in</span> <span class="n">CMakeLists</span><span class="o">.</span><span class="n">txt</span>
  <span class="n">field</span> <span class="n">bits</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span> <span class="n">Inst</span><span class="p">;</span>
  <span class="n">Format</span> <span class="n">Form</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span>

  <span class="n">let</span> <span class="n">Namespace</span> <span class="o">=</span> <span class="s2">&quot;Cpu0&quot;</span><span class="p">;</span>

  <span class="n">let</span> <span class="n">Size</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

  <span class="n">bits</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span> <span class="n">Opcode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="o">//</span> <span class="n">Top</span> <span class="mi">8</span> <span class="n">bits</span> <span class="n">are</span> <span class="n">the</span> <span class="s1">&#39;opcode&#39;</span> <span class="n">field</span>
  <span class="n">let</span> <span class="n">Inst</span><span class="p">{</span><span class="mi">31</span><span class="o">-</span><span class="mi">24</span><span class="p">}</span> <span class="o">=</span> <span class="n">Opcode</span><span class="p">;</span>

  <span class="n">let</span> <span class="n">OutOperandList</span> <span class="o">=</span> <span class="n">outs</span><span class="p">;</span>
  <span class="n">let</span> <span class="n">InOperandList</span>  <span class="o">=</span> <span class="n">ins</span><span class="p">;</span>

  <span class="n">let</span> <span class="n">AsmString</span>   <span class="o">=</span> <span class="n">asmstr</span><span class="p">;</span>
  <span class="n">let</span> <span class="n">Pattern</span>     <span class="o">=</span> <span class="n">pattern</span><span class="p">;</span>
  <span class="n">let</span> <span class="n">Itinerary</span>   <span class="o">=</span> <span class="n">itin</span><span class="p">;</span>

  <span class="o">//</span>
  <span class="o">//</span> <span class="n">Attributes</span> <span class="n">specific</span> <span class="n">to</span> <span class="n">Cpu0</span> <span class="n">instructions</span><span class="o">...</span>
  <span class="o">//</span>
  <span class="n">bits</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span> <span class="n">FormBits</span> <span class="o">=</span> <span class="n">Form</span><span class="o">.</span><span class="n">Value</span><span class="p">;</span>

  <span class="o">//</span> <span class="n">TSFlags</span> <span class="n">layout</span> <span class="n">should</span> <span class="n">be</span> <span class="n">kept</span> <span class="ow">in</span> <span class="n">sync</span> <span class="k">with</span> <span class="n">Cpu0InstrInfo</span><span class="o">.</span><span class="n">h</span><span class="o">.</span>
  <span class="n">let</span> <span class="n">TSFlags</span><span class="p">{</span><span class="mi">3</span><span class="o">-</span><span class="mi">0</span><span class="p">}</span>   <span class="o">=</span> <span class="n">FormBits</span><span class="p">;</span>

  <span class="n">let</span> <span class="n">DecoderNamespace</span> <span class="o">=</span> <span class="s2">&quot;Cpu0&quot;</span><span class="p">;</span>

  <span class="n">field</span> <span class="n">bits</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span> <span class="n">SoftFail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">//</span> <span class="n">Format</span> <span class="n">A</span> <span class="n">instruction</span> <span class="k">class</span> <span class="nc">in</span> <span class="n">Cpu0</span> <span class="p">:</span> <span class="o">&lt;|</span><span class="n">opcode</span><span class="o">|</span><span class="n">ra</span><span class="o">|</span><span class="n">rb</span><span class="o">|</span><span class="n">rc</span><span class="o">|</span><span class="n">cx</span><span class="o">|&gt;</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="k">class</span> <span class="nc">FA</span><span class="o">&lt;</span><span class="n">bits</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span> <span class="n">op</span><span class="p">,</span> <span class="n">dag</span> <span class="n">outs</span><span class="p">,</span> <span class="n">dag</span> <span class="n">ins</span><span class="p">,</span> <span class="n">string</span> <span class="n">asmstr</span><span class="p">,</span>
         <span class="nb">list</span><span class="o">&lt;</span><span class="n">dag</span><span class="o">&gt;</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">InstrItinClass</span> <span class="n">itin</span><span class="o">&gt;</span><span class="p">:</span>
      <span class="n">Cpu0Inst</span><span class="o">&lt;</span><span class="n">outs</span><span class="p">,</span> <span class="n">ins</span><span class="p">,</span> <span class="n">asmstr</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">itin</span><span class="p">,</span> <span class="n">FrmA</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="n">bits</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span>  <span class="n">ra</span><span class="p">;</span>
  <span class="n">bits</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span>  <span class="n">rb</span><span class="p">;</span>
  <span class="n">bits</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span>  <span class="n">rc</span><span class="p">;</span>
  <span class="n">bits</span><span class="o">&lt;</span><span class="mi">12</span><span class="o">&gt;</span> <span class="n">shamt</span><span class="p">;</span>

  <span class="n">let</span> <span class="n">Opcode</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span>

  <span class="n">let</span> <span class="n">Inst</span><span class="p">{</span><span class="mi">23</span><span class="o">-</span><span class="mi">20</span><span class="p">}</span> <span class="o">=</span> <span class="n">ra</span><span class="p">;</span>
  <span class="n">let</span> <span class="n">Inst</span><span class="p">{</span><span class="mi">19</span><span class="o">-</span><span class="mi">16</span><span class="p">}</span> <span class="o">=</span> <span class="n">rb</span><span class="p">;</span>
  <span class="n">let</span> <span class="n">Inst</span><span class="p">{</span><span class="mi">15</span><span class="o">-</span><span class="mi">12</span><span class="p">}</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
  <span class="n">let</span> <span class="n">Inst</span><span class="p">{</span><span class="mi">11</span><span class="o">-</span><span class="mi">0</span><span class="p">}</span>  <span class="o">=</span> <span class="n">shamt</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">//</span><span class="nd">@class</span> <span class="n">FL</span> <span class="p">{</span>
<span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">//</span> <span class="n">Format</span> <span class="n">L</span> <span class="n">instruction</span> <span class="k">class</span> <span class="nc">in</span> <span class="n">Cpu0</span> <span class="p">:</span> <span class="o">&lt;|</span><span class="n">opcode</span><span class="o">|</span><span class="n">ra</span><span class="o">|</span><span class="n">rb</span><span class="o">|</span><span class="n">cx</span><span class="o">|&gt;</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="k">class</span> <span class="nc">FL</span><span class="o">&lt;</span><span class="n">bits</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span> <span class="n">op</span><span class="p">,</span> <span class="n">dag</span> <span class="n">outs</span><span class="p">,</span> <span class="n">dag</span> <span class="n">ins</span><span class="p">,</span> <span class="n">string</span> <span class="n">asmstr</span><span class="p">,</span> <span class="nb">list</span><span class="o">&lt;</span><span class="n">dag</span><span class="o">&gt;</span> <span class="n">pattern</span><span class="p">,</span>
         <span class="n">InstrItinClass</span> <span class="n">itin</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">Cpu0Inst</span><span class="o">&lt;</span><span class="n">outs</span><span class="p">,</span> <span class="n">ins</span><span class="p">,</span> <span class="n">asmstr</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">itin</span><span class="p">,</span> <span class="n">FrmL</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="n">bits</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span>  <span class="n">ra</span><span class="p">;</span>
  <span class="n">bits</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span>  <span class="n">rb</span><span class="p">;</span>
  <span class="n">bits</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span> <span class="n">imm16</span><span class="p">;</span>

  <span class="n">let</span> <span class="n">Opcode</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span>

  <span class="n">let</span> <span class="n">Inst</span><span class="p">{</span><span class="mi">23</span><span class="o">-</span><span class="mi">20</span><span class="p">}</span> <span class="o">=</span> <span class="n">ra</span><span class="p">;</span>
  <span class="n">let</span> <span class="n">Inst</span><span class="p">{</span><span class="mi">19</span><span class="o">-</span><span class="mi">16</span><span class="p">}</span> <span class="o">=</span> <span class="n">rb</span><span class="p">;</span>
  <span class="n">let</span> <span class="n">Inst</span><span class="p">{</span><span class="mi">15</span><span class="o">-</span><span class="mi">0</span><span class="p">}</span>  <span class="o">=</span> <span class="n">imm16</span><span class="p">;</span>
<span class="p">}</span>
<span class="o">//</span><span class="nd">@class</span> <span class="n">FL</span> <span class="p">}</span>

<span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">//</span> <span class="n">Format</span> <span class="n">J</span> <span class="n">instruction</span> <span class="k">class</span> <span class="nc">in</span> <span class="n">Cpu0</span> <span class="p">:</span> <span class="o">&lt;|</span><span class="n">opcode</span><span class="o">|</span><span class="n">address</span><span class="o">|&gt;</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="k">class</span> <span class="nc">FJ</span><span class="o">&lt;</span><span class="n">bits</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span> <span class="n">op</span><span class="p">,</span> <span class="n">dag</span> <span class="n">outs</span><span class="p">,</span> <span class="n">dag</span> <span class="n">ins</span><span class="p">,</span> <span class="n">string</span> <span class="n">asmstr</span><span class="p">,</span> <span class="nb">list</span><span class="o">&lt;</span><span class="n">dag</span><span class="o">&gt;</span> <span class="n">pattern</span><span class="p">,</span>
         <span class="n">InstrItinClass</span> <span class="n">itin</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">Cpu0Inst</span><span class="o">&lt;</span><span class="n">outs</span><span class="p">,</span> <span class="n">ins</span><span class="p">,</span> <span class="n">asmstr</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">itin</span><span class="p">,</span> <span class="n">FrmJ</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="n">bits</span><span class="o">&lt;</span><span class="mi">24</span><span class="o">&gt;</span> <span class="n">addr</span><span class="p">;</span>

  <span class="n">let</span> <span class="n">Opcode</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span>

  <span class="n">let</span> <span class="n">Inst</span><span class="p">{</span><span class="mi">23</span><span class="o">-</span><span class="mi">0</span><span class="p">}</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>

</pre></div>
</div>
<p>ADDiu is a instance of class ArithLogicI inherited from FL, it can be
expanded and get member value further as follows,</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def ADDiu   : ArithLogicI&lt;0x09, &quot;addiu&quot;, add, simm16, immSExt16, CPURegs&gt;;

/// Arithmetic and logical instructions with 2 register operands.
class ArithLogicI&lt;bits&lt;8&gt; op, string instr_asm, SDNode OpNode,
          Operand Od, PatLeaf imm_type, RegisterClass RC&gt; :
  FL&lt;op, (outs GPROut:$ra), (ins RC:$rb, Od:$imm16),
   !strconcat(instr_asm, &quot;\t$ra, $rb, $imm16&quot;),
   [(set GPROut:$ra, (OpNode RC:$rb, imm_type:$imm16))], IIAlu&gt; {
  let isReMaterializable = 1;
}
</pre></div>
</div>
<p>So,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">op = 0x09</span>
<span class="go">instr_asm = “addiu”</span>
<span class="go">OpNode = add</span>
<span class="go">Od = simm16</span>
<span class="go">imm_type = immSExt16</span>
<span class="go">RC = CPURegs</span>
</pre></div>
</div>
<p>To expand the td, some principles are:</p>
<ul>
<li><p>let: meaning override the existed field from parent class.</p>
<p>For instance: let isReMaterializable = 1; override the isReMaterializable
from class instruction of Target.td.</p>
</li>
<li><p>declaration: meaning declare a new field for this class.</p>
<p>For instance: bits&lt;4&gt;  ra; declare ra field for class FL.</p>
</li>
</ul>
<p>The details of expanding as the following table:</p>
<table class="docutils align-default" id="id63">
<caption><span class="caption-number">Table 11 </span><span class="caption-text">ADDiu expand part I</span><a class="headerlink" href="#id63" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 10%" />
<col style="width: 25%" />
<col style="width: 64%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>ADDiu</p></th>
<th class="head"><p>ArithLogicI</p></th>
<th class="head"><p>FL</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x09</p></td>
<td><p>op = 0x09</p></td>
<td><p>Opcode = 0x09;</p></td>
</tr>
<tr class="row-odd"><td><p>addiu</p></td>
<td><p>instr_asm = “addiu”</p></td>
<td><p>(outs GPROut:$ra);
!strconcat(“addiu”, “t$ra, $rb, $imm16”);</p></td>
</tr>
<tr class="row-even"><td><p>add</p></td>
<td><p>OpNode = add</p></td>
<td><p>[(set GPROut:$ra, (add CPURegs:$rb, immSExt16:$imm16))]</p></td>
</tr>
<tr class="row-odd"><td><p>simm16</p></td>
<td><p>Od = simm16</p></td>
<td><p>(ins CPURegs:$rb, simm16:$imm16);</p></td>
</tr>
<tr class="row-even"><td><p>immSExt16</p></td>
<td><p>imm_type = immSExt16</p></td>
<td><p>Inst{15-0} = imm16;</p></td>
</tr>
<tr class="row-odd"><td><p>CPURegs</p></td>
<td><p>RC = CPURegs
isReMaterializable=1;</p></td>
<td><p>Inst{23-20} = ra;
Inst{19-16} = rb;</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="id64">
<caption><span class="caption-number">Table 12 </span><span class="caption-text">ADDiu expand part II</span><a class="headerlink" href="#id64" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 74%" />
<col style="width: 26%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Cpu0Inst</p></th>
<th class="head"><p>instruction</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Namespace = “Cpu0”</p></td>
<td><p>Uses = []; …</p></td>
</tr>
<tr class="row-odd"><td><p>Inst{31-24} = 0x09;</p></td>
<td><p>Size = 0; …</p></td>
</tr>
<tr class="row-even"><td><p>OutOperandList = GPROut:$ra;</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>InOperandList  = CPURegs:$rb,simm16:$imm16;</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>AsmString = “addiut$ra, $rb, $imm16”</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>pattern = [(set GPROut:$ra, (add RC:$rb, immSExt16:$imm16))]</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>Itinerary = IIAlu</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>TSFlags{3-0} = FrmL.value</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>DecoderNamespace = “Cpu0”</p></td>
<td></td>
</tr>
</tbody>
</table>
<p>The td expanding is a lousy process.
Similarly, LD and ST instruction definition can be expanded in this way.
Please notice the Pattern =
[(set GPROut:$ra, (add RC:$rb, immSExt16:$imm16))] which include keyword
<strong>“add”</strong>.
The ADDiu with <strong>“add”</strong> is used in sub-section Instruction Selection of last
section.</p>
<p>File Cpu0Schedule.td include the function units and pipeline stages information
as follows,</p>
<p class="rubric">lbdex/chapters/Chapter2/Cpu0Schedule.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//===--</span> <span class="n">Cpu0Schedule</span><span class="o">.</span><span class="n">td</span> <span class="o">-</span> <span class="n">Cpu0</span> <span class="n">Scheduling</span> <span class="n">Definitions</span> <span class="o">------*-</span> <span class="n">tablegen</span> <span class="o">-*-===//</span>
<span class="o">//</span>
<span class="o">//</span>                     <span class="n">The</span> <span class="n">LLVM</span> <span class="n">Compiler</span> <span class="n">Infrastructure</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">This</span> <span class="n">file</span> <span class="ow">is</span> <span class="n">distributed</span> <span class="n">under</span> <span class="n">the</span> <span class="n">University</span> <span class="n">of</span> <span class="n">Illinois</span> <span class="n">Open</span> <span class="n">Source</span>
<span class="o">//</span> <span class="n">License</span><span class="o">.</span> <span class="n">See</span> <span class="n">LICENSE</span><span class="o">.</span><span class="n">TXT</span> <span class="k">for</span> <span class="n">details</span><span class="o">.</span>
<span class="o">//</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">//</span> <span class="n">Functional</span> <span class="n">units</span> <span class="n">across</span> <span class="n">Cpu0</span> <span class="n">chips</span> <span class="n">sets</span><span class="o">.</span> <span class="n">Based</span> <span class="n">on</span> <span class="n">GCC</span><span class="o">/</span><span class="n">Cpu0</span> <span class="n">backend</span> <span class="n">files</span><span class="o">.</span>
<span class="o">//===----------------------------------------------------------------------===//</span>
<span class="k">def</span> <span class="nf">ALU</span>     <span class="p">:</span> <span class="n">FuncUnit</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">IMULDIV</span> <span class="p">:</span> <span class="n">FuncUnit</span><span class="p">;</span>

<span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">//</span> <span class="n">Instruction</span> <span class="n">Itinerary</span> <span class="n">classes</span> <span class="n">used</span> <span class="k">for</span> <span class="n">Cpu0</span>
<span class="o">//===----------------------------------------------------------------------===//</span>
<span class="k">def</span> <span class="nf">IIAlu</span>              <span class="p">:</span> <span class="n">InstrItinClass</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">II_CLO</span>             <span class="p">:</span> <span class="n">InstrItinClass</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">II_CLZ</span>             <span class="p">:</span> <span class="n">InstrItinClass</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">IILoad</span>             <span class="p">:</span> <span class="n">InstrItinClass</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">IIStore</span>            <span class="p">:</span> <span class="n">InstrItinClass</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">IIBranch</span>           <span class="p">:</span> <span class="n">InstrItinClass</span><span class="p">;</span>

<span class="k">def</span> <span class="nf">IIPseudo</span>           <span class="p">:</span> <span class="n">InstrItinClass</span><span class="p">;</span>

<span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">//</span> <span class="n">Cpu0</span> <span class="n">Generic</span> <span class="n">instruction</span> <span class="n">itineraries</span><span class="o">.</span>
<span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">//@</span> <span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">llvm</span><span class="o">.</span><span class="n">org</span><span class="o">/</span><span class="n">docs</span><span class="o">/</span><span class="n">doxygen</span><span class="o">/</span><span class="n">html</span><span class="o">/</span><span class="n">structllvm_1_1InstrStage</span><span class="o">.</span><span class="n">html</span>
<span class="k">def</span> <span class="nf">Cpu0GenericItineraries</span> <span class="p">:</span> <span class="n">ProcessorItineraries</span><span class="o">&lt;</span><span class="p">[</span><span class="n">ALU</span><span class="p">,</span> <span class="n">IMULDIV</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[</span>
<span class="o">//@</span><span class="mi">2</span>
  <span class="n">InstrItinData</span><span class="o">&lt;</span><span class="n">IIAlu</span>              <span class="p">,</span> <span class="p">[</span><span class="n">InstrStage</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span>  <span class="p">[</span><span class="n">ALU</span><span class="p">]</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">InstrItinData</span><span class="o">&lt;</span><span class="n">II_CLO</span>             <span class="p">,</span> <span class="p">[</span><span class="n">InstrStage</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span>  <span class="p">[</span><span class="n">ALU</span><span class="p">]</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">InstrItinData</span><span class="o">&lt;</span><span class="n">II_CLZ</span>             <span class="p">,</span> <span class="p">[</span><span class="n">InstrStage</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span>  <span class="p">[</span><span class="n">ALU</span><span class="p">]</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">InstrItinData</span><span class="o">&lt;</span><span class="n">IILoad</span>             <span class="p">,</span> <span class="p">[</span><span class="n">InstrStage</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span>  <span class="p">[</span><span class="n">ALU</span><span class="p">]</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">InstrItinData</span><span class="o">&lt;</span><span class="n">IIStore</span>            <span class="p">,</span> <span class="p">[</span><span class="n">InstrStage</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span>  <span class="p">[</span><span class="n">ALU</span><span class="p">]</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">InstrItinData</span><span class="o">&lt;</span><span class="n">IIBranch</span>           <span class="p">,</span> <span class="p">[</span><span class="n">InstrStage</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span>  <span class="p">[</span><span class="n">ALU</span><span class="p">]</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span>
<span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>

</pre></div>
</div>
</section>
<section id="write-cmake-file">
<h3><a class="toc-backref" href="#id87">Write cmake file</a><a class="headerlink" href="#write-cmake-file" title="Permalink to this headline">¶</a></h3>
<p>Target/Cpu0 directory has two files CMakeLists.txt,
contents as follows,</p>
<p class="rubric">lbdex/chapters/Chapter2/CMakeLists.txt</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">add_llvm_component_group</span><span class="p">(</span><span class="n">Cpu0</span><span class="p">)</span>

<span class="nb">set</span><span class="p">(</span><span class="n">LLVM_TARGET_DEFINITIONS</span> <span class="n">Cpu0Other</span><span class="o">.</span><span class="n">td</span><span class="p">)</span>

<span class="c1"># Generate Cpu0GenRegisterInfo.inc and Cpu0GenInstrInfo.inc which included by </span>
<span class="c1">#  your hand code C++ files. </span>
<span class="c1"># Cpu0GenRegisterInfo.inc came from Cpu0RegisterInfo.td, Cpu0GenInstrInfo.inc </span>
<span class="c1">#  came from Cpu0InstrInfo.td.</span>
<span class="n">tablegen</span><span class="p">(</span><span class="n">LLVM</span> <span class="n">Cpu0GenRegisterInfo</span><span class="o">.</span><span class="n">inc</span> <span class="o">-</span><span class="n">gen</span><span class="o">-</span><span class="n">register</span><span class="o">-</span><span class="n">info</span><span class="p">)</span>
<span class="n">tablegen</span><span class="p">(</span><span class="n">LLVM</span> <span class="n">Cpu0GenInstrInfo</span><span class="o">.</span><span class="n">inc</span> <span class="o">-</span><span class="n">gen</span><span class="o">-</span><span class="n">instr</span><span class="o">-</span><span class="n">info</span><span class="p">)</span>
<span class="n">tablegen</span><span class="p">(</span><span class="n">LLVM</span> <span class="n">Cpu0GenSubtargetInfo</span><span class="o">.</span><span class="n">inc</span> <span class="o">-</span><span class="n">gen</span><span class="o">-</span><span class="n">subtarget</span><span class="p">)</span>
<span class="n">tablegen</span><span class="p">(</span><span class="n">LLVM</span> <span class="n">Cpu0GenMCPseudoLowering</span><span class="o">.</span><span class="n">inc</span> <span class="o">-</span><span class="n">gen</span><span class="o">-</span><span class="n">pseudo</span><span class="o">-</span><span class="n">lowering</span><span class="p">)</span>

<span class="c1"># Cpu0CommonTableGen must be defined</span>
<span class="n">add_public_tablegen_target</span><span class="p">(</span><span class="n">Cpu0CommonTableGen</span><span class="p">)</span>

<span class="c1"># Cpu0CodeGen should match with LLVMBuild.txt Cpu0CodeGen</span>
<span class="n">add_llvm_target</span><span class="p">(</span><span class="n">Cpu0CodeGen</span>
  <span class="n">Cpu0TargetMachine</span><span class="o">.</span><span class="n">cpp</span>

  <span class="n">LINK_COMPONENTS</span>
  <span class="n">Analysis</span>
  <span class="n">AsmPrinter</span>
  <span class="n">CodeGen</span>
  <span class="n">Core</span>
  <span class="n">MC</span>
  <span class="n">Cpu0Desc</span>
  <span class="n">Cpu0Info</span>
  <span class="n">SelectionDAG</span>
  <span class="n">Support</span>
  <span class="n">Target</span>
  <span class="n">GlobalISel</span>

  <span class="n">ADD_TO_COMPONENT</span>
  <span class="n">Cpu0</span>
  <span class="p">)</span>

<span class="c1"># Should match with &quot;subdirectories =  MCTargetDesc TargetInfo&quot; in LLVMBuild.txt</span>
<span class="n">add_subdirectory</span><span class="p">(</span><span class="n">TargetInfo</span><span class="p">)</span>
<span class="n">add_subdirectory</span><span class="p">(</span><span class="n">MCTargetDesc</span><span class="p">)</span>

</pre></div>
</div>
<p>CMakeLists.txt is the make information for cmake and # is comment.
Comments are prefixed by <strong>#</strong> in both files.
The “tablegen(” in above CMakeLists.txt is defined in
cmake/modules/TableGen.cmake as below,</p>
<p class="rubric">llvm/cmake/modules/TableGen.cmake</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>function(tablegen project ofn)
  ...
  add_custom_command(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/${ofn}.tmp
    # Generate tablegen output in a temporary file.
    COMMAND ${${project}_TABLEGEN_EXE} ${ARGN} -I ${CMAKE_CURRENT_SOURCE_DIR}
  ...
endfunction()
...
macro(add_tablegen target project)
  ...
  if(LLVM_USE_HOST_TOOLS)
    if( ${${project}_TABLEGEN} STREQUAL &quot;${target}&quot; )
      if (NOT CMAKE_CONFIGURATION_TYPES)
        set(${project}_TABLEGEN_EXE &quot;${LLVM_NATIVE_BUILD}/bin/${target}&quot;)
      else()
        set(${project}_TABLEGEN_EXE &quot;${LLVM_NATIVE_BUILD}/Release/bin/${target}&quot;)
      endif()
  ...
endmacro()
</pre></div>
</div>
<p class="rubric">llvm/utils/TableGen/CMakeLists.txt</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">add_tablegen</span><span class="p">(</span><span class="s">llvm-tblgen</span><span class="w"> </span><span class="s">LLVM</span>
<span class="w">  </span><span class="s">...</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Above “add_tablegen” in llvm/utils/TableGen/CMakeLists.txt makes the
“tablegen(” written in Cpu0 CMakeLists.txt an alias of llvm-tblgen
(${project} = LLVM and ${project}_TABLEGEN_EXE = llvm-tblgen).
The “tablegen(”, “add_public_tablegen_target(Cpu0CommonTableGen)” in
lbdex/chapters/Chapter2/CMakeLists.txt and the following code define a target
“Cpu0CommonTableGen” with it’s output files “Cpu0Gen*.inc” as follows,</p>
<p class="rubric">llvm/cmake/modules/TableGen.cmake</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>function(tablegen project ofn)
  ...
  set(TABLEGEN_OUTPUT ${TABLEGEN_OUTPUT} ${CMAKE_CURRENT_BINARY_DIR}/${ofn} PARENT_SCOPE)
  ...
endfunction()

# Creates a target for publicly exporting tablegen dependencies.
function(add_public_tablegen_target target)
  ...
  add_custom_target(${target}
    DEPENDS ${TABLEGEN_OUTPUT})
  ...
endfunction()
</pre></div>
</div>
<p>Since execution file llvm-tblgen is built before compiling any llvm backend
source code during building llvm, the llvm-tblgen is always ready for backend’s
TableGen reguest.</p>
<p>This book breaks the whole backend source code by function, add code chapter
by chapter.
Don’t try to understand everything in the text of book, the code added in each
chapter is a reading material too.
To understand the computer related knowledge in concept, you can ignore source
code, but implementing based on an existed open software cannot.
In programming, documentation cannot replace the source code totally.
Reading source code is a big opportunity in the open source development.</p>
<p>CMakeLists.txt exists in sub-directories
<strong>MCTargetDesc</strong> and <strong>TargetInfo</strong>.
The contents of MakeLists.txt in these two directories
instruct llvm generating Cpu0Desc and Cpu0Info libraries, repectively.
After building, you will find three libraries: <strong>libLLVMCpu0CodeGen.a</strong>,
<strong>libLLVMCpu0Desc.a</strong> and <strong>libLLVMCpu0Info.a</strong> in lib/ of your build
directory.
For more details please see “Building LLVM with CMake” <a class="footnote-reference brackets" href="#cmake" id="id36">25</a>.</p>
</section>
<section id="target-registration">
<h3><a class="toc-backref" href="#id88">Target Registration</a><a class="headerlink" href="#target-registration" title="Permalink to this headline">¶</a></h3>
<p>You must also register your target with the TargetRegistry. After registration,
llvm tools are able to lookup and use your target at runtime.
The TargetRegistry can be used directly, but for most targets there are helper
templates which should take care of the work for you.</p>
<p>All targets should declare a global Target object which is used to represent
the target during registration.
Then, in the target’s TargetInfo library, the target should define that object
and use the RegisterTarget template to register the target.
For example, the file TargetInfo/Cpu0TargetInfo.cpp register TheCpu0Target for
big endian and TheCpu0elTarget for little endian, as follows.</p>
<p class="rubric">lbdex/chapters/Chapter2/Cpu0.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//===--</span> <span class="n">Cpu0</span><span class="o">.</span><span class="n">h</span> <span class="o">-</span> <span class="n">Top</span><span class="o">-</span><span class="n">level</span> <span class="n">interface</span> <span class="k">for</span> <span class="n">Cpu0</span> <span class="n">representation</span> <span class="o">----*-</span> <span class="n">C</span><span class="o">++</span> <span class="o">-*-===//</span>
<span class="o">//</span>
<span class="o">//</span>                     <span class="n">The</span> <span class="n">LLVM</span> <span class="n">Compiler</span> <span class="n">Infrastructure</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">This</span> <span class="n">file</span> <span class="ow">is</span> <span class="n">distributed</span> <span class="n">under</span> <span class="n">the</span> <span class="n">University</span> <span class="n">of</span> <span class="n">Illinois</span> <span class="n">Open</span> <span class="n">Source</span>
<span class="o">//</span> <span class="n">License</span><span class="o">.</span> <span class="n">See</span> <span class="n">LICENSE</span><span class="o">.</span><span class="n">TXT</span> <span class="k">for</span> <span class="n">details</span><span class="o">.</span>
<span class="o">//</span>
<span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">This</span> <span class="n">file</span> <span class="n">contains</span> <span class="n">the</span> <span class="n">entry</span> <span class="n">points</span> <span class="k">for</span> <span class="k">global</span> <span class="n">functions</span> <span class="n">defined</span> <span class="ow">in</span>
<span class="o">//</span> <span class="n">the</span> <span class="n">LLVM</span> <span class="n">Cpu0</span> <span class="n">back</span><span class="o">-</span><span class="n">end</span><span class="o">.</span>
<span class="o">//</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="c1">#ifndef LLVM_LIB_TARGET_CPU0_CPU0_H</span>
<span class="c1">#define LLVM_LIB_TARGET_CPU0_CPU0_H</span>

<span class="c1">#include &quot;Cpu0Config.h&quot;</span>
<span class="c1">#include &quot;MCTargetDesc/Cpu0MCTargetDesc.h&quot;</span>
<span class="c1">#include &quot;llvm/Target/TargetMachine.h&quot;</span>

<span class="n">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
  <span class="k">class</span> <span class="nc">Cpu0TargetMachine</span><span class="p">;</span>
  <span class="k">class</span> <span class="nc">FunctionPass</span><span class="p">;</span>

<span class="p">}</span> <span class="o">//</span> <span class="n">end</span> <span class="n">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="c1">#endif</span>

</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter2/TargetInfo/Cpu0TargetInfo.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//===--</span> <span class="n">Cpu0TargetInfo</span><span class="o">.</span><span class="n">cpp</span> <span class="o">-</span> <span class="n">Cpu0</span> <span class="n">Target</span> <span class="n">Implementation</span> <span class="o">-------------------===//</span>
<span class="o">//</span>
<span class="o">//</span>                     <span class="n">The</span> <span class="n">LLVM</span> <span class="n">Compiler</span> <span class="n">Infrastructure</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">This</span> <span class="n">file</span> <span class="ow">is</span> <span class="n">distributed</span> <span class="n">under</span> <span class="n">the</span> <span class="n">University</span> <span class="n">of</span> <span class="n">Illinois</span> <span class="n">Open</span> <span class="n">Source</span>
<span class="o">//</span> <span class="n">License</span><span class="o">.</span> <span class="n">See</span> <span class="n">LICENSE</span><span class="o">.</span><span class="n">TXT</span> <span class="k">for</span> <span class="n">details</span><span class="o">.</span>
<span class="o">//</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="c1">#include &quot;Cpu0.h&quot;</span>
<span class="c1">#include &quot;llvm/IR/Module.h&quot;</span>
<span class="c1">#include &quot;llvm/Support/TargetRegistry.h&quot;</span>
<span class="n">using</span> <span class="n">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="n">Target</span> <span class="n">llvm</span><span class="p">::</span><span class="n">TheCpu0Target</span><span class="p">,</span> <span class="n">llvm</span><span class="p">::</span><span class="n">TheCpu0elTarget</span><span class="p">;</span>

<span class="n">extern</span> <span class="s2">&quot;C&quot;</span> <span class="n">void</span> <span class="n">LLVMInitializeCpu0TargetInfo</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">RegisterTarget</span><span class="o">&lt;</span><span class="n">Triple</span><span class="p">::</span><span class="n">cpu0</span><span class="p">,</span>
        <span class="o">/*</span><span class="n">HasJIT</span><span class="o">=*/</span><span class="n">true</span><span class="o">&gt;</span> <span class="n">X</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">,</span> <span class="s2">&quot;cpu0&quot;</span><span class="p">,</span> <span class="s2">&quot;CPU0 (32-bit big endian)&quot;</span><span class="p">,</span> <span class="s2">&quot;Cpu0&quot;</span><span class="p">);</span>

  <span class="n">RegisterTarget</span><span class="o">&lt;</span><span class="n">Triple</span><span class="p">::</span><span class="n">cpu0el</span><span class="p">,</span>
        <span class="o">/*</span><span class="n">HasJIT</span><span class="o">=*/</span><span class="n">true</span><span class="o">&gt;</span> <span class="n">Y</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">,</span> <span class="s2">&quot;cpu0el&quot;</span><span class="p">,</span> <span class="s2">&quot;CPU0 (32-bit little endian)&quot;</span><span class="p">,</span> <span class="s2">&quot;Cpu0&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter2/TargetInfo/CMakeLists.txt</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># llvm 10.0.0 change from add_llvm_library to add_llvm_component_library</span>
<span class="n">add_llvm_component_library</span><span class="p">(</span><span class="n">LLVMCpu0Info</span>
  <span class="n">Cpu0TargetInfo</span><span class="o">.</span><span class="n">cpp</span>

  <span class="n">LINK_COMPONENTS</span>
  <span class="n">Support</span>

  <span class="n">ADD_TO_COMPONENT</span>
  <span class="n">Cpu0</span>
  <span class="p">)</span>
</pre></div>
</div>
<p>Files Cpu0TargetMachine.cpp and MCTargetDesc/Cpu0MCTargetDesc.cpp just define
the empty initialize function since we register nothing for this moment.</p>
<p class="rubric">lbdex/chapters/Chapter2/Cpu0TargetMachine.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//===--</span> <span class="n">Cpu0TargetMachine</span><span class="o">.</span><span class="n">cpp</span> <span class="o">-</span> <span class="n">Define</span> <span class="n">TargetMachine</span> <span class="k">for</span> <span class="n">Cpu0</span> <span class="o">-------------===//</span>
<span class="o">//</span>
<span class="o">//</span>                     <span class="n">The</span> <span class="n">LLVM</span> <span class="n">Compiler</span> <span class="n">Infrastructure</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">This</span> <span class="n">file</span> <span class="ow">is</span> <span class="n">distributed</span> <span class="n">under</span> <span class="n">the</span> <span class="n">University</span> <span class="n">of</span> <span class="n">Illinois</span> <span class="n">Open</span> <span class="n">Source</span>
<span class="o">//</span> <span class="n">License</span><span class="o">.</span> <span class="n">See</span> <span class="n">LICENSE</span><span class="o">.</span><span class="n">TXT</span> <span class="k">for</span> <span class="n">details</span><span class="o">.</span>
<span class="o">//</span>
<span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">Implements</span> <span class="n">the</span> <span class="n">info</span> <span class="n">about</span> <span class="n">Cpu0</span> <span class="n">target</span> <span class="n">spec</span><span class="o">.</span>
<span class="o">//</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="c1">#include &quot;Cpu0TargetMachine.h&quot;</span>
<span class="c1">#include &quot;Cpu0.h&quot;</span>

<span class="c1">#include &quot;llvm/IR/Attributes.h&quot;</span>
<span class="c1">#include &quot;llvm/IR/Function.h&quot;</span>
<span class="c1">#include &quot;llvm/Support/CodeGen.h&quot;</span>
<span class="c1">#include &quot;llvm/CodeGen/Passes.h&quot;</span>
<span class="c1">#include &quot;llvm/CodeGen/TargetPassConfig.h&quot;</span>
<span class="c1">#include &quot;llvm/Support/TargetRegistry.h&quot;</span>
<span class="c1">#include &quot;llvm/Target/TargetOptions.h&quot;</span>

<span class="n">using</span> <span class="n">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="c1">#define DEBUG_TYPE &quot;cpu0&quot;</span>

<span class="n">extern</span> <span class="s2">&quot;C&quot;</span> <span class="n">void</span> <span class="n">LLVMInitializeCpu0Target</span><span class="p">()</span> <span class="p">{</span>
<span class="p">}</span>

</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter2/MCTargetDesc/Cpu0MCTargetDesc.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//===--</span> <span class="n">Cpu0MCTargetDesc</span><span class="o">.</span><span class="n">h</span> <span class="o">-</span> <span class="n">Cpu0</span> <span class="n">Target</span> <span class="n">Descriptions</span> <span class="o">-----------*-</span> <span class="n">C</span><span class="o">++</span> <span class="o">-*-===//</span>
<span class="o">//</span>
<span class="o">//</span>                     <span class="n">The</span> <span class="n">LLVM</span> <span class="n">Compiler</span> <span class="n">Infrastructure</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">This</span> <span class="n">file</span> <span class="ow">is</span> <span class="n">distributed</span> <span class="n">under</span> <span class="n">the</span> <span class="n">University</span> <span class="n">of</span> <span class="n">Illinois</span> <span class="n">Open</span> <span class="n">Source</span>
<span class="o">//</span> <span class="n">License</span><span class="o">.</span> <span class="n">See</span> <span class="n">LICENSE</span><span class="o">.</span><span class="n">TXT</span> <span class="k">for</span> <span class="n">details</span><span class="o">.</span>
<span class="o">//</span>
<span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">This</span> <span class="n">file</span> <span class="n">provides</span> <span class="n">Cpu0</span> <span class="n">specific</span> <span class="n">target</span> <span class="n">descriptions</span><span class="o">.</span>
<span class="o">//</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="c1">#ifndef LLVM_LIB_TARGET_CPU0_MCTARGETDESC_CPU0MCTARGETDESC_H</span>
<span class="c1">#define LLVM_LIB_TARGET_CPU0_MCTARGETDESC_CPU0MCTARGETDESC_H</span>

<span class="c1">#include &quot;Cpu0Config.h&quot;</span>
<span class="c1">#include &quot;llvm/Support/DataTypes.h&quot;</span>

<span class="c1">#include &lt;memory&gt;</span>

<span class="n">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
<span class="k">class</span> <span class="nc">Target</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">Triple</span><span class="p">;</span>

<span class="n">extern</span> <span class="n">Target</span> <span class="n">TheCpu0Target</span><span class="p">;</span>
<span class="n">extern</span> <span class="n">Target</span> <span class="n">TheCpu0elTarget</span><span class="p">;</span>

<span class="p">}</span> <span class="o">//</span> <span class="n">End</span> <span class="n">llvm</span> <span class="n">namespace</span>

<span class="o">//</span> <span class="n">Defines</span> <span class="n">symbolic</span> <span class="n">names</span> <span class="k">for</span> <span class="n">Cpu0</span> <span class="n">registers</span><span class="o">.</span>  <span class="n">This</span> <span class="n">defines</span> <span class="n">a</span> <span class="n">mapping</span> <span class="kn">from</span>
<span class="o">//</span> <span class="n">register</span> <span class="n">name</span> <span class="n">to</span> <span class="n">register</span> <span class="n">number</span><span class="o">.</span>
<span class="c1">#define GET_REGINFO_ENUM</span>
<span class="c1">#include &quot;Cpu0GenRegisterInfo.inc&quot;</span>

<span class="o">//</span> <span class="n">Defines</span> <span class="n">symbolic</span> <span class="n">names</span> <span class="k">for</span> <span class="n">the</span> <span class="n">Cpu0</span> <span class="n">instructions</span><span class="o">.</span>
<span class="c1">#define GET_INSTRINFO_ENUM</span>
<span class="c1">#include &quot;Cpu0GenInstrInfo.inc&quot;</span>

<span class="c1">#define GET_SUBTARGETINFO_ENUM</span>
<span class="c1">#include &quot;Cpu0GenSubtargetInfo.inc&quot;</span>

<span class="c1">#endif</span>

</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter2/MCTargetDesc/Cpu0MCTargetDesc.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//===--</span> <span class="n">Cpu0MCTargetDesc</span><span class="o">.</span><span class="n">cpp</span> <span class="o">-</span> <span class="n">Cpu0</span> <span class="n">Target</span> <span class="n">Descriptions</span> <span class="o">-------------------===//</span>
<span class="o">//</span>
<span class="o">//</span>                     <span class="n">The</span> <span class="n">LLVM</span> <span class="n">Compiler</span> <span class="n">Infrastructure</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">This</span> <span class="n">file</span> <span class="ow">is</span> <span class="n">distributed</span> <span class="n">under</span> <span class="n">the</span> <span class="n">University</span> <span class="n">of</span> <span class="n">Illinois</span> <span class="n">Open</span> <span class="n">Source</span>
<span class="o">//</span> <span class="n">License</span><span class="o">.</span> <span class="n">See</span> <span class="n">LICENSE</span><span class="o">.</span><span class="n">TXT</span> <span class="k">for</span> <span class="n">details</span><span class="o">.</span>
<span class="o">//</span>
<span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">This</span> <span class="n">file</span> <span class="n">provides</span> <span class="n">Cpu0</span> <span class="n">specific</span> <span class="n">target</span> <span class="n">descriptions</span><span class="o">.</span>
<span class="o">//</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="c1">#include &quot;Cpu0MCTargetDesc.h&quot;</span>
<span class="c1">#include &quot;llvm/MC/MachineLocation.h&quot;</span>
<span class="c1">#include &quot;llvm/MC/MCELFStreamer.h&quot;</span>
<span class="c1">#include &quot;llvm/MC/MCInstrAnalysis.h&quot;</span>
<span class="c1">#include &quot;llvm/MC/MCInstPrinter.h&quot;</span>
<span class="c1">#include &quot;llvm/MC/MCInstrInfo.h&quot;</span>
<span class="c1">#include &quot;llvm/MC/MCRegisterInfo.h&quot;</span>
<span class="c1">#include &quot;llvm/MC/MCSubtargetInfo.h&quot;</span>
<span class="c1">#include &quot;llvm/MC/MCSymbol.h&quot;</span>
<span class="c1">#include &quot;llvm/Support/CommandLine.h&quot;</span>
<span class="c1">#include &quot;llvm/Support/ErrorHandling.h&quot;</span>
<span class="c1">#include &quot;llvm/Support/FormattedStream.h&quot;</span>
<span class="c1">#include &quot;llvm/Support/TargetRegistry.h&quot;</span>

<span class="n">using</span> <span class="n">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="c1">#define GET_INSTRINFO_MC_DESC</span>
<span class="c1">#include &quot;Cpu0GenInstrInfo.inc&quot;</span>

<span class="c1">#define GET_SUBTARGETINFO_MC_DESC</span>
<span class="c1">#include &quot;Cpu0GenSubtargetInfo.inc&quot;</span>

<span class="c1">#define GET_REGINFO_MC_DESC</span>
<span class="c1">#include &quot;Cpu0GenRegisterInfo.inc&quot;</span>

<span class="o">//@</span><span class="mi">2</span> <span class="p">{</span>
<span class="n">extern</span> <span class="s2">&quot;C&quot;</span> <span class="n">void</span> <span class="n">LLVMInitializeCpu0TargetMC</span><span class="p">()</span> <span class="p">{</span>

<span class="p">}</span>
<span class="o">//@</span><span class="mi">2</span> <span class="p">}</span>

</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter2/MCTargetDesc/CMakeLists.txt</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># MCTargetDesc/CMakeLists.txt</span>
<span class="n">add_llvm_component_library</span><span class="p">(</span><span class="n">LLVMCpu0Desc</span>
  <span class="n">Cpu0MCTargetDesc</span><span class="o">.</span><span class="n">cpp</span>

  <span class="n">LINK_COMPONENTS</span>
  <span class="n">MC</span>
  <span class="n">Cpu0Info</span>
  <span class="n">Support</span>

  <span class="n">ADD_TO_COMPONENT</span>
  <span class="n">Cpu0</span>
  <span class="p">)</span>

</pre></div>
</div>
<p>Please see “Target Registration” <a class="footnote-reference brackets" href="#target-reg" id="id37">26</a> for reference.</p>
</section>
<section id="build-libraries-and-td">
<h3><a class="toc-backref" href="#id89">Build libraries and td</a><a class="headerlink" href="#build-libraries-and-td" title="Permalink to this headline">¶</a></h3>
<p>Build steps <a class="reference external" href="https://github.com/Jonathan2251/lbd/blob/master/README.md">https://github.com/Jonathan2251/lbd/blob/master/README.md</a>.
We set llvm source code in /Users/Jonathan/llvm/release/llvm and have llvm
release-build in /Users/Jonathan/llvm/release/build.
About how to build llvm, please refer here <a class="footnote-reference brackets" href="#clang" id="id38">27</a>.
In appendix A, we made a copy from /Users/Jonathan/llvm/release/llvm to
/Users/Jonathan/llvm/test/llvm for working with my Cpu0 target backend.
Sub-directories llvm is for source code and build is for debug
build directory.</p>
<p>Beside directory llvm/lib/Target/Cpu0, there are a couple of files modified to
support cpu0 new Target, which includes both the ID and name of machine and
relocation records listed in the early sub-section.
You can update your llvm working copy and find the modified files by
commands, cp -rf lbdex/llvm/modify/llvm/* &lt;yourllvm/workingcopy/sourcedir&gt;/.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-78-230:lbd Jonathan$ </span><span class="nb">pwd</span>
<span class="go">/Users/Jonathan/git/lbd</span>
<span class="gp">118-165-78-230:lbd Jonathan$ </span>cp -rf lbdex/llvm/modify/llvm/* ~/llvm/test/llvm/.
<span class="gp">118-165-78-230:lbd Jonathan$ </span>grep -R <span class="s2">&quot;cpu0&quot;</span> ~/llvm/test/llvm/include
<span class="go">llvm/cmake/config-ix.cmake:elseif (LLVM_NATIVE_ARCH MATCHES &quot;cpu0&quot;)</span>
<span class="go">llvm/include/llvm/ADT/Triple.h:#undef cpu0</span>
<span class="go">llvm/include/llvm/ADT/Triple.h:    cpu0,       // For Tutorial Backend Cpu0</span>
<span class="go">llvm/include/llvm/ADT/Triple.h:    cpu0el,</span>
<span class="go">llvm/include/llvm/Support/ELF.h:  EF_CPU0_ARCH_32R2 = 0x70000000, // cpu032r2</span>
<span class="go">llvm/include/llvm/Support/ELF.h:  EF_CPU0_ARCH_64R2 = 0x80000000, // cpu064r2</span>
<span class="go">...</span>
</pre></div>
</div>
<p>Next configure the Cpu0 example code to chapter2 as follows,</p>
<p class="rubric">~/llvm/test/llvm/lib/Target/Cpu0/Cpu0SetChapter.h</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define CH       CH2</span>
</pre></div>
</div>
<p>Beside configure chapter as above, I provide gen-chapters.sh that you
can get each chapter code as follows,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-78-230:lbdex Jonathan$ </span><span class="nb">pwd</span>
<span class="go">/Users/Jonathan/git/lbd/lbdex</span>
<span class="gp">118-165-78-230:lbdex Jonathan$ </span>bash gen-chapters.sh
<span class="gp">118-165-78-230:lbdex Jonathan$ </span>ls chapters
<span class="go">Chapter10_1   Chapter11_2     Chapter2        Chapter3_2...</span>
<span class="go">Chapter11_1   Chapter12_1     Chapter3_1      Chapter3_3...</span>
</pre></div>
</div>
<p>Now, run the <code class="docutils literal notranslate"><span class="pre">cmake</span> <span class="pre">and</span> <span class="pre">make</span></code> command to build td (the following cmake
command is for my setting),</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-78-230:build Jonathan$ </span>cmake -DCMAKE_CXX_COMPILER<span class="o">=</span>clang++
<span class="go">-DCMAKE_C_COMPILER=clang -DCMAKE_BUILD_TYPE=Debug -G &quot;Unix Makefiles&quot; ../llvm/</span>

<span class="go">-- Targeting Cpu0</span>
<span class="go">...</span>
<span class="go">-- Targeting XCore</span>
<span class="go">-- Configuring done</span>
<span class="go">-- Generating done</span>
<span class="go">-- Build files have been written to: /Users/Jonathan/llvm/test/build</span>

<span class="gp">118-165-78-230:build Jonathan$ </span>make -j4

<span class="gp">118-165-78-230:build Jonathan$</span>
</pre></div>
</div>
<p>After build, you can type command <code class="docutils literal notranslate"><span class="pre">llc</span> <span class="pre">–version</span></code> to find the cpu0 backend,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-78-230:build Jonathan$ </span>/Users/Jonathan/llvm/test/
<span class="go">build/bin/llc --version</span>
<span class="go">LLVM (http://llvm.org/):</span>
<span class="go">...</span>
<span class="go">  Registered Targets:</span>
<span class="go">  arm      - ARM</span>
<span class="go">  ...</span>
<span class="go">  cpp      - C++ backend</span>
<span class="go">  cpu0     - Cpu0</span>
<span class="go">  cpu0el   - Cpu0el</span>
<span class="go">...</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">llc</span> <span class="pre">-version</span></code> can display Registered Targets <strong>“cpu0”</strong> and <strong>“cpu0el”</strong>,
because the code in file TargetInfo/Cpu0TargetInfo.cpp we made in last
sub-section “Target Registration” <a class="footnote-reference brackets" href="#asadasd" id="id39">28</a>.</p>
<p>Let’s build lbdex/chapters/Chapter2 code as follows,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-75-57:test Jonathan$ </span><span class="nb">pwd</span>
<span class="go">/Users/Jonathan/test</span>
<span class="gp">118-165-75-57:test Jonathan$ </span>cp -rf lbdex/Cpu0 ~/llvm/test/llvm/lib/Target/.

<span class="gp">118-165-75-57:test Jonathan$ </span><span class="nb">cd</span> ~/llvm/test/build
<span class="gp">118-165-75-57:build Jonathan$ </span><span class="nb">pwd</span>
<span class="go">/Users/Jonathan/llvm/test/build</span>
<span class="gp">118-165-75-57:build Jonathan$ </span>rm -rf *
<span class="gp">118-165-75-57:build Jonathan$ </span>cmake -DCMAKE_CXX_COMPILER<span class="o">=</span>clang++
<span class="go">-DCMAKE_C_COMPILER=clang -DCMAKE_BUILD_TYPE=Debug -DLLVM_TARGETS_TO_BUILD=Cpu0</span>
<span class="go">-G &quot;Unix Makefiles&quot; ../llvm/</span>
<span class="go">...</span>
<span class="go">-- Targeting Cpu0</span>
<span class="go">...</span>
<span class="go">-- Configuring done</span>
<span class="go">-- Generating done</span>
<span class="go">-- Build files have been written to: /Users/Jonathan/llvm/test/build</span>
</pre></div>
</div>
<p>In order to save time, we build Cpu0 target only by option
-DLLVM_TARGETS_TO_BUILD=Cpu0.
After that, you can find the *.inc files in directory
/Users/Jonathan/llvm/test/build/lib/Target/Cpu0 as follows,</p>
<p class="rubric">build/lib/Target/Cpu0/Cpu0GenRegisterInfo.inc</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">Cpu0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">NoRegister</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">AT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">EPC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">FP</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">GP</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">HI</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">LO</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">LR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">PC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">SP</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">SW</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">ZERO</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">11</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">A0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">A1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">13</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">S0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">14</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">S1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">15</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">T0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">T1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">17</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">T9</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">18</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">V0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">19</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">V1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">NUM_TARGET_REGS</span><span class="w">     </span><span class="c1">// 21</span>
<span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
</pre></div>
</div>
<p>These *.inc are generated by llvm-tblgen at directory
build/lib/Target/Cpu0 where their input files are the Cpu0 backend
*.td files.
The llvm-tblgen is invoked by <strong>tablegen</strong> of
/Users/Jonathan/llvm/test/llvm/lib/Target/Cpu0/CMakeLists.txt.
These *.inc files will be included by Cpu0 backend *.cpp or *.h files and
compile into *.o further.
TableGen is the important tool illustrated in the early sub-section
“.td: LLVM’s Target Description Files” of this chapter.
List it again as follows,</p>
<p>“The “mix and match” approach allows target authors to choose what makes sense
for their architecture and permits a large amount of code reuse across
different targets”.</p>
<p>Details about TableGen are here <a class="footnote-reference brackets" href="#tblgen" id="id40">29</a> <a class="footnote-reference brackets" href="#tblgen-langintro" id="id41">30</a>
<a class="footnote-reference brackets" href="#tblgen-langref" id="id42">31</a>.</p>
<p>Now try to run  command <code class="docutils literal notranslate"><span class="pre">llc</span></code> to compile input file ch3.cpp as follows,</p>
<p class="rubric">lbdex/input/ch3.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div>
</div>
<p>First step, compile it with clang and get output ch3.bc as follows,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-78-230:input Jonathan$ </span><span class="nb">pwd</span>
<span class="go">/Users/Jonathan/git/lbd/lbdex/input</span>
<span class="gp">118-165-78-230:input Jonathan$ </span>clang -target mips-unknown-linux-gnu -c
<span class="go">ch3.cpp -emit-llvm -o ch3.bc</span>
</pre></div>
</div>
<p>As above, compile C to .bc by <code class="docutils literal notranslate"><span class="pre">clang</span> <span class="pre">-target</span> <span class="pre">mips-unknown-linux-gnu</span></code> because
Cpu0 borrows the ABI from Mips.
Next step, transfer bitcode .bc to human readable text format as follows,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-78-230:test Jonathan$ </span>llvm-dis ch3.bc -o -

<span class="go">// ch3.ll</span>
<span class="go">; ModuleID = &#39;ch3.bc&#39;</span>
<span class="go">target datalayout = &quot;e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f3</span>
<span class="go">2:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:6</span>
<span class="go">4-S128&quot;</span>
<span class="go">target triple = &quot;mips-unknown-linux-gnu&quot;</span>

<span class="go">define i32 @main() nounwind uwtable {</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> alloca i32, align <span class="m">4</span>
<span class="go">  store i32 0, i32* %1</span>
<span class="go">  ret i32 0</span>
<span class="go">}</span>
</pre></div>
</div>
<p>Now, when compiling ch3.bc will get the error message as follows,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-78-230:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llc -march=cpu0 -relocation-model=pic -filetype=asm ch3.bc -o</span>
<span class="go">ch3.cpu0.s</span>
<span class="go">...</span>
<span class="go">... Assertion `target.get() &amp;&amp; &quot;Could not allocate target machine!&quot;&#39; failed</span>
<span class="go">...</span>
</pre></div>
</div>
<p>At this point, we finish the Target Registration for Cpu0 backend.
The backend compiler command <code class="docutils literal notranslate"><span class="pre">llc</span></code> can recognize Cpu0 backend now.
Currently we just define target td files (Cpu0.td, Cpu0Other.td,
Cpu0RegisterInfo.td, …).
According to LLVM structure, we need to define our target machine and include
those td related files.
The error message says we didn’t define our target machine.
This book is a step-by-step backend delvelopment.
You can review the houndreds lines of Chapter2 example code to see how to do
the Target Registration.</p>
<dl class="footnote brackets">
<dt class="label" id="cpu0-chinese"><span class="brackets"><a class="fn-backref" href="#id2">1</a></span></dt>
<dd><p>Original Cpu0 architecture and ISA details (Chinese). <a class="reference external" href="http://ccckmit.wikidot.com/ocs:cpu0">http://ccckmit.wikidot.com/ocs:cpu0</a></p>
</dd>
<dt class="label" id="cpu0-english"><span class="brackets"><a class="fn-backref" href="#id3">2</a></span></dt>
<dd><p>English translation of Cpu0 description. <a class="reference external" href="http://translate.google.com.tw/translate?js=n&amp;prev=_t&amp;hl=zh-TW&amp;ie=UTF-8&amp;layout=2&amp;eotf=1&amp;sl=zh-CN&amp;tl=en&amp;u=http://ccckmit.wikidot.com/ocs:cpu0">http://translate.google.com.tw/translate?js=n&amp;prev=_t&amp;hl=zh-TW&amp;ie=UTF-8&amp;layout=2&amp;eotf=1&amp;sl=zh-CN&amp;tl=en&amp;u=http://ccckmit.wikidot.com/ocs:cpu0</a></p>
</dd>
<dt class="label" id="lb-note"><span class="brackets">3</span><span class="fn-backref">(<a href="#id4">1</a>,<a href="#id5">2</a>,<a href="#id6">3</a>,<a href="#id7">4</a>)</span></dt>
<dd><p>The difference between LB and LBu is signed and unsigned byte value expand to a word size. For example, After LB Ra, [Rb+Cx], Ra is 0xffffff80(= -128) if byte [Rb+Cx] is 0x80; Ra is 0x0000007f(= 127) if byte [Rb+Cx] is 0x7f. After LBu Ra, [Rb+Cx], Ra is 0x00000080(= 128) if byte [Rb+Cx] is 0x80; Ra is 0x0000007f(= 127) if byte [Rb+Cx] is 0x7f. Difference between LH and LHu is similar.</p>
</dd>
<dt class="label" id="u-note"><span class="brackets">4</span><span class="fn-backref">(<a href="#id8">1</a>,<a href="#id9">2</a>,<a href="#id10">3</a>,<a href="#id11">4</a>)</span></dt>
<dd><p>The only difference between ADDu instruction and the ADD instruction is that the ADDU instruction never causes an Integer Overflow exception. SUBu and SUB is similar.</p>
</dd>
<dt class="label" id="cond-note"><span class="brackets">5</span><span class="fn-backref">(<a href="#id14">1</a>,<a href="#id15">2</a>)</span></dt>
<dd><p>CMP is signed-compare while CMPu is unsigned. Conditions include the following comparisons: &gt;, &gt;=, ==, !=, &lt;=, &lt;. SW is actually set by the subtraction of the two register operands, and the flags indicate which conditions are present.</p>
</dd>
<dt class="label" id="sra-note"><span class="brackets">6</span><span class="fn-backref">(<a href="#id12">1</a>,<a href="#id13">2</a>)</span></dt>
<dd><p>Rb ‘&gt;&gt; Cx, Rb ‘&gt;&gt; Rc: Shift with signed bit remain.</p>
</dd>
<dt class="label" id="call-note"><span class="brackets"><a class="fn-backref" href="#id16">7</a></span></dt>
<dd><p>jsub cx is direct call for 24 bits value of cx while jalr $rb is indirect call for 32 bits value of register $rb.</p>
</dd>
<dt class="label" id="jr-note"><span class="brackets"><a class="fn-backref" href="#id17">8</a></span></dt>
<dd><p>Both JR and RET has same opcode (actually they are the same instruction for Cpu0 hardware). When user writes “jr $t9” meaning it jumps to address of register $t9; when user writes “jr $lr” meaning it jump back to the caller function (since $lr is the return address). For user read ability, Cpu0 prints “ret $lr” instead of “jr $lr”.</p>
</dd>
<dt class="label" id="java-cpp"><span class="brackets"><a class="fn-backref" href="#id19">9</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Comparison_of_Java_and_C%2B%2B">https://en.wikipedia.org/wiki/Comparison_of_Java_and_C%2B%2B</a></p>
</dd>
<dt class="label" id="aosa-book"><span class="brackets">10</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id18">2</a>)</span></dt>
<dd><p>Chris Lattner, <strong>LLVM</strong>. Published in The Architecture of Open Source Applications. <a class="reference external" href="http://www.aosabook.org/en/llvm.html">http://www.aosabook.org/en/llvm.html</a></p>
</dd>
<dt class="label" id="chapters-ex"><span class="brackets"><a class="fn-backref" href="#id34">11</a></span></dt>
<dd><p><a class="reference external" href="http://jonathan2251.github.io/lbd/doc.html#generate-cpu0-document">http://jonathan2251.github.io/lbd/doc.html#generate-cpu0-document</a></p>
</dd>
<dt class="label" id="codegen"><span class="brackets"><a class="fn-backref" href="#id20">12</a></span></dt>
<dd><p><a class="reference external" href="http://llvm.org/docs/CodeGenerator.html">http://llvm.org/docs/CodeGenerator.html</a></p>
</dd>
<dt class="label" id="langref"><span class="brackets"><a class="fn-backref" href="#id21">13</a></span></dt>
<dd><p><a class="reference external" href="http://llvm.org/docs/LangRef.html">http://llvm.org/docs/LangRef.html</a></p>
</dd>
<dt class="label" id="dragonbooks-10-2-3"><span class="brackets"><a class="fn-backref" href="#id22">14</a></span></dt>
<dd><p>Refer section 10.2.3 of book Compilers: Principles,
Techniques, and Tools (2nd Edition)</p>
</dd>
<dt class="label" id="gnu"><span class="brackets"><a class="fn-backref" href="#id23">15</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection">https://en.wikipedia.org/wiki/GNU_Compiler_Collection</a></p>
</dd>
<dt class="label" id="gcc-frontend"><span class="brackets"><a class="fn-backref" href="#id24">16</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection#Front_ends">https://en.wikipedia.org/wiki/GNU_Compiler_Collection#Front_ends</a></p>
</dd>
<dt class="label" id="generic"><span class="brackets"><a class="fn-backref" href="#id25">17</a></span></dt>
<dd><p><a class="reference external" href="https://gcc.gnu.org/onlinedocs/gccint/GENERIC.html">https://gcc.gnu.org/onlinedocs/gccint/GENERIC.html</a></p>
</dd>
<dt class="label" id="gimple"><span class="brackets"><a class="fn-backref" href="#id26">18</a></span></dt>
<dd><p><a class="reference external" href="https://gcc.gnu.org/onlinedocs/gccint/GIMPLE.html">https://gcc.gnu.org/onlinedocs/gccint/GIMPLE.html</a></p>
</dd>
<dt class="label" id="rtl"><span class="brackets"><a class="fn-backref" href="#id27">19</a></span></dt>
<dd><p><a class="reference external" href="https://gcc.gnu.org/onlinedocs/gccint/RTL.html">https://gcc.gnu.org/onlinedocs/gccint/RTL.html</a></p>
</dd>
<dt class="label" id="md"><span class="brackets"><a class="fn-backref" href="#id28">20</a></span></dt>
<dd><p><a class="reference external" href="https://gcc.gnu.org/onlinedocs/gccint/Machine-Desc.html#Machine-Desc">https://gcc.gnu.org/onlinedocs/gccint/Machine-Desc.html#Machine-Desc</a></p>
</dd>
<dt class="label" id="llvm-ir-vs-gimple"><span class="brackets"><a class="fn-backref" href="#id29">21</a></span></dt>
<dd><p><a class="reference external" href="https://stackoverflow.com/questions/40799696/how-is-gcc-ir-different-from-llvm-ir/40802063">https://stackoverflow.com/questions/40799696/how-is-gcc-ir-different-from-llvm-ir/40802063</a></p>
</dd>
<dt class="label" id="null-pointer-ex"><span class="brackets"><a class="fn-backref" href="#id30">22</a></span></dt>
<dd><p><a class="reference external" href="https://github.com/Jonathan2251/note/blob/master/null_pointer.cpp">https://github.com/Jonathan2251/note/blob/master/null_pointer.cpp</a> is an example.</p>
</dd>
<dt class="label" id="null-pointer"><span class="brackets"><a class="fn-backref" href="#id31">23</a></span></dt>
<dd><p>Dereferencing a NULL Pointer:
contrary to popular belief, dereferencing a null pointer in C is undefined.
It is not defined to trap, and if you mmap a page at 0, it is not defined to access that page.
This falls out of the rules that forbid dereferencing wild pointers and the use of NULL as a sentinel,
from <a class="reference external" href="http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html">http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html</a>.
As link, <a class="reference external" href="https://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html">https://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html</a>.
In this case, the developer forgot to call “set”, did not crash with a null pointer dereference,
and their code broke when someone else did a debug build.</p>
</dd>
<dt class="label" id="dragonbooks-8-5"><span class="brackets">24</span><span class="fn-backref">(<a href="#id32">1</a>,<a href="#id33">2</a>)</span></dt>
<dd><p>Refer section 8.5 of book Compilers: Principles,
Techniques, and Tools (2nd Edition)</p>
</dd>
<dt class="label" id="cmake"><span class="brackets"><a class="fn-backref" href="#id36">25</a></span></dt>
<dd><p><a class="reference external" href="http://llvm.org/docs/CMake.html">http://llvm.org/docs/CMake.html</a></p>
</dd>
<dt class="label" id="target-reg"><span class="brackets"><a class="fn-backref" href="#id37">26</a></span></dt>
<dd><p><a class="reference external" href="http://llvm.org/docs/WritingAnLLVMBackend.html#target-registration">http://llvm.org/docs/WritingAnLLVMBackend.html#target-registration</a></p>
</dd>
<dt class="label" id="clang"><span class="brackets"><a class="fn-backref" href="#id38">27</a></span></dt>
<dd><p><a class="reference external" href="http://clang.llvm.org/get_started.html">http://clang.llvm.org/get_started.html</a></p>
</dd>
<dt class="label" id="asadasd"><span class="brackets"><a class="fn-backref" href="#id39">28</a></span></dt>
<dd><p><a class="reference external" href="http://jonathan2251.github.io/lbd/llvmstructure.html#target-registration">http://jonathan2251.github.io/lbd/llvmstructure.html#target-registration</a></p>
</dd>
<dt class="label" id="tblgen"><span class="brackets">29</span><span class="fn-backref">(<a href="#id35">1</a>,<a href="#id40">2</a>)</span></dt>
<dd><p><a class="reference external" href="http://llvm.org/docs/TableGen/index.html">http://llvm.org/docs/TableGen/index.html</a></p>
</dd>
<dt class="label" id="tblgen-langintro"><span class="brackets"><a class="fn-backref" href="#id41">30</a></span></dt>
<dd><p><a class="reference external" href="http://llvm.org/docs/TableGen/LangIntro.html">http://llvm.org/docs/TableGen/LangIntro.html</a></p>
</dd>
<dt class="label" id="tblgen-langref"><span class="brackets"><a class="fn-backref" href="#id42">31</a></span></dt>
<dd><p><a class="reference external" href="http://llvm.org/docs/TableGen/LangRef.html">http://llvm.org/docs/TableGen/LangRef.html</a></p>
</dd>
</dl>
</section>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="about.html">About</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="backendstructure.html">Backend structure</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Chen Chung-Shu.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.4.0.
    </div>
  </body>
</html>