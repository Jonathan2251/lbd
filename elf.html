
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>ELF Support &#8212; Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</title>
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Assembler" href="asm.html" />
    <link rel="prev" title="Function call" href="funccall.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</span></a></h1>
        <h2 class="heading"><span>ELF Support</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="funccall.html">Function call</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="asm.html">Assembler</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="elf-support">
<span id="sec-elf"></span><h1>ELF Support<a class="headerlink" href="#elf-support" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#elf-format" id="id14">ELF format</a><ul>
<li><a class="reference internal" href="#elf-header-and-section-header-table" id="id15">ELF header and Section header table</a></li>
<li><a class="reference internal" href="#relocation-record" id="id16">Relocation Record</a></li>
<li><a class="reference internal" href="#cpu0-elf-related-files" id="id17">Cpu0 ELF related files</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-objdump" id="id18">llvm-objdump</a><ul>
<li><a class="reference internal" href="#llvm-objdump-t-r" id="id19">llvm-objdump -t -r</a></li>
<li><a class="reference internal" href="#llvm-objdump-d" id="id20">llvm-objdump -d</a></li>
</ul>
</li>
</ul>
</div>
<p>Cpu0 backend generated the ELF format of obj.
The ELF (Executable and Linkable Format) is a common standard file format for
executables, object code, shared libraries and core dumps.
First published in the System V Application Binary Interface specification,
and later in the Tool Interface Standard, it was quickly accepted among
different vendors of Unixsystems.
In 1999 it was chosen as the standard binary file format for Unix and
Unix-like systems on x86 by the x86open project.
Please reference <a class="footnote-reference" href="#id7" id="id1">[1]</a>.</p>
<p>The binary encode of Cpu0 instruction set in obj has been checked in the
previous chapters.
But we didn’t dig into the ELF file format like elf header and relocation
record at that time.
This chapter will use the binutils which has been installed in
“sub-section Install other tools on iMac” of Appendix A: “Installing LLVM”
<a class="footnote-reference" href="#id8" id="id2">[2]</a> to check the generated cpu0 ELF file.
You will learn the objdump, readelf, …, tools and understand the ELF file
format itself through using these tools to analyze the cpu0 generated obj in
this chapter.
LLVM has the llvm-objdump tool which like objdump. We will make cpu0 support
llvm-objdump tool further in this chapter.
The binutils is a cross compiler tool chains include a couple of CPU ELF dump
function support.
Linux platform has binutils already and no need to install it further.
The reason we use Linux binutils in this chapter just because my iMac will
display Chinese text.
The iMac corresponding binutils have no problem except it add g in command name
and and display with your area language instead of pure English on iMac.
For example, when using gobjdump instead of objdump, I have the result of
Chinese language unicode display instead of pure English on my iMac.</p>
<p>The binutils tool we use is not a part of llvm tools, but it’s a powerful tool
in ELF analysis.
This chapter introduce the tool to readers since we think it is a valuable
knowledge in this popular ELF format and the ELF binutils analysis tool.
An LLVM compiler engineer has the responsibility to make sure his backend
has generated a right obj since the obj is needed to be handled by linker or
loader later.
With this tool, you can verify your generated ELF format.</p>
<p>The cpu0 author has published a “System Software” book which introduces the
topics
of assembler, linker, loader, compiler and OS in concept, and at same time
demonstrates how to use binutils and gcc to analysis ELF through the example
code in his book.
It’s a Chinese book of “System Software” in concept and practice.
This book does the real analysis through binutils.
The “System Software” <a class="footnote-reference" href="#id9" id="id3">[3]</a> written by Beck is a famous book in concept of
telling readers what about the compiler output, what about the linker output,
what about the loader output, and how they work together.
But it covers the concept only.
You can reference it to understand how the <strong>“Relocation Record”</strong> works if you
need to refresh or learning this knowledge for this chapter.</p>
<p><a class="footnote-reference" href="#id10" id="id4">[4]</a>, <a class="footnote-reference" href="#id11" id="id5">[5]</a>, <a class="footnote-reference" href="#id12" id="id6">[6]</a> are the Chinese documents available from the cpu0 author on
web site.</p>
<div class="section" id="elf-format">
<h2><a class="toc-backref" href="#id14">ELF format</a><a class="headerlink" href="#elf-format" title="Permalink to this headline">¶</a></h2>
<p>ELF is a format used in both obj and executable file.
So, there are two views in it as <a class="reference internal" href="#elf-f1"><span class="std std-numref">Fig. 28</span></a>.</p>
<div class="figure align-center" id="id13">
<span id="elf-f1"></span><a class="reference internal image-reference" href="_images/12.png"><img alt="_images/12.png" src="_images/12.png" style="width: 213.0px; height: 320.0px;" /></a>
<p class="caption"><span class="caption-number">Fig. 28 </span><span class="caption-text">ELF file format overview</span></p>
</div>
<p>As <a class="reference internal" href="#elf-f1"><span class="std std-numref">Fig. 28</span></a>, the “Section header table” include sections .text,
.rodata, …, .data which are sections layout for code, read only data, …,
and read/write data, respectively.
“Program header table” include segments for run time code and data.
The definition of segments is the run time layout for code and data while
sections is the link time layout for code and data.</p>
<div class="section" id="elf-header-and-section-header-table">
<h3><a class="toc-backref" href="#id15">ELF header and Section header table</a><a class="headerlink" href="#elf-header-and-section-header-table" title="Permalink to this headline">¶</a></h3>
<p>Let’s run Chapter9_3/ with ch6_1.cpp, and dump ELF header information by
<code class="docutils literal notranslate"><span class="pre">readelf</span> <span class="pre">-h</span></code> to see what information the ELF header contains.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">[Gamma@localhost input]$</span> ~/llvm/test/cmake_debug_build/bin/llc -march<span class="o">=</span>cpu0
<span class="go">-relocation-model=pic -filetype=obj ch6_1.bc -o ch6_1.cpu0.o</span>

<span class="gp">[Gamma@localhost input]$</span> readelf -h ch6_1.cpu0.o
<span class="go">  Magic:   7f 45 4c 46 01 02 01 03 00 00 00 00 00 00 00 00</span>
<span class="go">  Class:                             ELF32</span>
<span class="go">  Data:                              2&#39;s complement, big endian</span>
<span class="go">  Version:                           1 (current)</span>
<span class="go">  OS/ABI:                            UNIX - GNU</span>
<span class="go">  ABI Version:                       0</span>
<span class="go">  Type:                              REL (Relocatable file)</span>
<span class="go">  Machine:                           &lt;unknown&gt;: 0xc9</span>
<span class="go">  Version:                           0x1</span>
<span class="go">  Entry point address:               0x0</span>
<span class="go">  Start of program headers:          0 (bytes into file)</span>
<span class="go">  Start of section headers:          176 (bytes into file)</span>
<span class="go">  Flags:                             0x0</span>
<span class="go">  Size of this header:               52 (bytes)</span>
<span class="go">  Size of program headers:           0 (bytes)</span>
<span class="go">  Number of program headers:         0</span>
<span class="go">  Size of section headers:           40 (bytes)</span>
<span class="go">  Number of section headers:         8</span>
<span class="go">  Section header string table index: 5</span>
<span class="gp">[Gamma@localhost input]$</span>

<span class="gp">[Gamma@localhost input]$</span> ~/llvm/test/cmake_debug_build/bin/llc
<span class="go">-march=mips -relocation-model=pic -filetype=obj ch6_1.bc -o ch6_1.mips.o</span>

<span class="gp">[Gamma@localhost input]$</span> readelf -h ch6_1.mips.o
<span class="go">ELF Header:</span>
<span class="go">  Magic:   7f 45 4c 46 01 02 01 03 00 00 00 00 00 00 00 00</span>
<span class="go">  Class:                             ELF32</span>
<span class="go">  Data:                              2&#39;s complement, big endian</span>
<span class="go">  Version:                           1 (current)</span>
<span class="go">  OS/ABI:                            UNIX - GNU</span>
<span class="go">  ABI Version:                       0</span>
<span class="go">  Type:                              REL (Relocatable file)</span>
<span class="go">  Machine:                           MIPS R3000</span>
<span class="go">  Version:                           0x1</span>
<span class="go">  Entry point address:               0x0</span>
<span class="go">  Start of program headers:          0 (bytes into file)</span>
<span class="go">  Start of section headers:          200 (bytes into file)</span>
<span class="go">  Flags:                             0x50001007, noreorder, pic, cpic, o32, mips32</span>
<span class="go">  Size of this header:               52 (bytes)</span>
<span class="go">  Size of program headers:           0 (bytes)</span>
<span class="go">  Number of program headers:         0</span>
<span class="go">  Size of section headers:           40 (bytes)</span>
<span class="go">  Number of section headers:         9</span>
<span class="go">  Section header string table index: 6</span>
<span class="gp">[Gamma@localhost input]$</span>
</pre></div>
</div>
<p>As above ELF header display, it contains information of magic number, version,
ABI, …, . The Machine field of cpu0 is unknown while mips is known as
MIPSR3000.
It is unknown because cpu0 is not a popular CPU recognized by utility readelf.
Let’s check ELF segments information as follows,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">[Gamma@localhost input]$</span> readelf -l ch6_1.cpu0.o

<span class="go">There are no program headers in this file.</span>
<span class="gp">[Gamma@localhost input]$</span>
</pre></div>
</div>
<p>The result is in expectation because cpu0 obj is for link only, not for
execution.
So, the segments is empty.
Check ELF sections information as follows.
Every section contains offset and size information.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">[Gamma@localhost input]$</span> readelf -S ch6_1.cpu0.o
<span class="go">There are 10 section headers, starting at offset 0xd4:</span>

<span class="go">Section Headers:</span>
<span class="go">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span>
<span class="go">  [ 0]                   NULL            00000000 000000 000000 00      0   0  0</span>
<span class="go">  [ 1] .text             PROGBITS        00000000 000034 000034 00  AX  0   0  4</span>
<span class="go">  [ 2] .rel.text         REL             00000000 000310 000018 08      8   1  4</span>
<span class="go">  [ 3] .data             PROGBITS        00000000 000068 000004 00  WA  0   0  4</span>
<span class="go">  [ 4] .bss              NOBITS          00000000 00006c 000000 00  WA  0   0  4</span>
<span class="go">  [ 5] .eh_frame         PROGBITS        00000000 00006c 000028 00   A  0   0  4</span>
<span class="go">  [ 6] .rel.eh_frame     REL             00000000 000328 000008 08      8   5  4</span>
<span class="go">  [ 7] .shstrtab         STRTAB          00000000 000094 00003e 00      0   0  1</span>
<span class="go">  [ 8] .symtab           SYMTAB          00000000 000264 000090 10      9   6  4</span>
<span class="go">  [ 9] .strtab           STRTAB          00000000 0002f4 00001b 00      0   0  1</span>
<span class="go">Key to Flags:</span>
<span class="go">  W (write), A (alloc), X (execute), M (merge), S (strings)</span>
<span class="go">  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)</span>
<span class="go">  O (extra OS processing required) o (OS specific), p (processor specific)</span>
<span class="gp">[Gamma@localhost input]$</span>
</pre></div>
</div>
</div>
<div class="section" id="relocation-record">
<h3><a class="toc-backref" href="#id16">Relocation Record</a><a class="headerlink" href="#relocation-record" title="Permalink to this headline">¶</a></h3>
<p>Cpu0 backend translate global variable as follows,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">[Gamma@localhost input]$</span> clang -target mips-unknown-linux-gnu -c ch6_1.cpp
<span class="go">-emit-llvm -o ch6_1.bc</span>
<span class="gp">[Gamma@localhost input]$</span> ~/llvm/test/cmake_debug_build/
<span class="go">bin/llc -march=cpu0 -relocation-model=pic -filetype=asm ch6_1.bc -o ch6_1.cpu0.s</span>
<span class="gp">[Gamma@localhost input]$</span> cat ch6_1.cpu0.s
<span class="go">  .section .mdebug.abi32</span>
<span class="go">  .previous</span>
<span class="go">  .file &quot;ch6_1.bc&quot;</span>
<span class="go">  .text</span>
<span class="go">  ...</span>
<span class="go">  .cfi_startproc</span>
<span class="go">  .frame  $sp,8,$lr</span>
<span class="go">  .mask   0x00000000,0</span>
<span class="go">  .set  noreorder</span>
<span class="go">  .cpload $t9</span>
<span class="go">  ...</span>
<span class="go">  lui $2, %got_hi(gI)</span>
<span class="go">  addu $2, $2, $gp</span>
<span class="go">  ld $2, %got_lo(gI)($2)</span>
<span class="go">  ...</span>
<span class="go">  .type gI,@object              # @gI</span>
<span class="go">  .data</span>
<span class="go">  .globl  gI</span>
<span class="go">  .align  2</span>
<span class="go">gI:</span>
<span class="go">  .4byte  100                     # 0x64</span>
<span class="go">  .size gI, 4</span>


<span class="gp">[Gamma@localhost input]$</span> ~/llvm/test/cmake_debug_build/
<span class="go">bin/llc -march=cpu0 -relocation-model=pic -filetype=obj ch6_1.bc -o ch6_1.cpu0.o</span>
<span class="gp">[Gamma@localhost input]$</span> objdump -s ch6_1.cpu0.o

<span class="go">ch6_1.cpu0.o:     file format elf32-big</span>

<span class="go">Contents of section .text:</span>
<span class="go">// .cpload machine instruction</span>
<span class="go"> 0000 0fa00000 0daa0000 13aa6000 ........  ..............`.</span>
<span class="go"> ...</span>
<span class="go"> 0020 002a0000 00220000 012d0000 0ddd0008  .*...&quot;...-......</span>
<span class="go"> ...</span>
<span class="gp">[Gamma@localhost input]$</span> Jonathan$

<span class="gp">[Gamma@localhost input]$</span> readelf -tr ch6_1.cpu0.o
<span class="go">There are 8 section headers, starting at offset 0xb0:</span>

<span class="go">Section Headers:</span>
<span class="go">  [Nr] Name</span>
<span class="go">       Type            Addr     Off    Size   ES   Lk Inf Al</span>
<span class="go">       Flags</span>
<span class="go">  [ 0]</span>
<span class="go">       NULL            00000000 000000 000000 00   0   0  0</span>
<span class="go">       [00000000]:</span>
<span class="go">  [ 1] .text</span>
<span class="go">       PROGBITS        00000000 000034 000044 00   0   0  4</span>
<span class="go">       [00000006]: ALLOC, EXEC</span>
<span class="go">  [ 2] .rel.text</span>
<span class="go">       REL             00000000 0002a8 000020 08   6   1  4</span>
<span class="go">       [00000000]:</span>
<span class="go">  [ 3] .data</span>
<span class="go">       PROGBITS        00000000 000078 000008 00   0   0  4</span>
<span class="go">       [00000003]: WRITE, ALLOC</span>
<span class="go">  [ 4] .bss</span>
<span class="go">       NOBITS          00000000 000080 000000 00   0   0  4</span>
<span class="go">       [00000003]: WRITE, ALLOC</span>
<span class="go">  [ 5] .shstrtab</span>
<span class="go">       STRTAB          00000000 000080 000030 00   0   0  1</span>
<span class="go">       [00000000]:</span>
<span class="go">  [ 6] .symtab</span>
<span class="go">       SYMTAB          00000000 0001f0 000090 10   7   5  4</span>
<span class="go">       [00000000]:</span>
<span class="go">  [ 7] .strtab</span>
<span class="go">       STRTAB          00000000 000280 000025 00   0   0  1</span>
<span class="go">       [00000000]:</span>

<span class="go">Relocation section &#39;.rel.text&#39; at offset 0x2a8 contains 4 entries:</span>
<span class="go"> Offset     Info    Type            Sym.Value  Sym. Name</span>
<span class="go">00000000  00000805 unrecognized: 5       00000000   _gp_disp</span>
<span class="go">00000004  00000806 unrecognized: 6       00000000   _gp_disp</span>
<span class="go">00000020  00000616 unrecognized: 16      00000004   gI</span>
<span class="go">00000028  00000617 unrecognized: 17      00000004   gI</span>


<span class="gp">[Gamma@localhost input]$</span> readelf -tr ch6_1.mips.o
<span class="go">There are 9 section headers, starting at offset 0xc8:</span>

<span class="go">Section Headers:</span>
<span class="go">  [Nr] Name</span>
<span class="go">       Type            Addr     Off    Size   ES   Lk Inf Al</span>
<span class="go">       Flags</span>
<span class="go">  [ 0]</span>
<span class="go">       NULL            00000000 000000 000000 00   0   0  0</span>
<span class="go">       [00000000]:</span>
<span class="go">  [ 1] .text</span>
<span class="go">       PROGBITS        00000000 000034 000038 00   0   0  4</span>
<span class="go">       [00000006]: ALLOC, EXEC</span>
<span class="go">  [ 2] .rel.text</span>
<span class="go">       REL             00000000 0002f8 000018 08   7   1  4</span>
<span class="go">       [00000000]:</span>
<span class="go">  [ 3] .data</span>
<span class="go">       PROGBITS        00000000 00006c 000008 00   0   0  4</span>
<span class="go">       [00000003]: WRITE, ALLOC</span>
<span class="go">  [ 4] .bss</span>
<span class="go">       NOBITS          00000000 000074 000000 00   0   0  4</span>
<span class="go">       [00000003]: WRITE, ALLOC</span>
<span class="go">  [ 5] .reginfo</span>
<span class="go">       MIPS_REGINFO    00000000 000074 000018 00   0   0  1</span>
<span class="go">       [00000002]: ALLOC</span>
<span class="go">  [ 6] .shstrtab</span>
<span class="go">       STRTAB          00000000 00008c 000039 00   0   0  1</span>
<span class="go">       [00000000]:</span>
<span class="go">  [ 7] .symtab</span>
<span class="go">       SYMTAB          00000000 000230 0000a0 10   8   6  4</span>
<span class="go">       [00000000]:</span>
<span class="go">  [ 8] .strtab</span>
<span class="go">       STRTAB          00000000 0002d0 000025 00   0   0  1</span>
<span class="go">       [00000000]:</span>

<span class="go">Relocation section &#39;.rel.text&#39; at offset 0x2f8 contains 3 entries:</span>
<span class="go"> Offset     Info    Type            Sym.Value  Sym. Name</span>
<span class="go">00000000  00000905 R_MIPS_HI16       00000000   _gp_disp</span>
<span class="go">00000004  00000906 R_MIPS_LO16       00000000   _gp_disp</span>
<span class="go">0000001c  00000709 R_MIPS_GOT16      00000004   gI</span>
</pre></div>
</div>
<p>As depicted in <a class="reference external" href="http://jonathan2251.github.io/lbd/funccall.html#handle-gp-register-in-pic-addressing-mode">section Handle $gp register in PIC addressing mode</a>, it
translates <strong>“.cpload %reg”</strong> into the following.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Lower &quot;.cpload $reg&quot; to</span>
<span class="c1">//  &quot;lui   $gp, %hi(_gp_disp)&quot;</span>
<span class="c1">//  &quot;ori $gp, $gp, %lo(_gp_disp)&quot;</span>
<span class="c1">//  &quot;addu  $gp, $gp, $t9&quot;</span>
</pre></div>
</div>
<p>The _gp_disp value is determined by loader. So, it’s undefined in obj.
You can find both the Relocation Records for offset 0 and 4 of .text section
refer to _gp_disp value.
The offset 0 and 4 of .text section are instructions “lui $gp, %hi(_gp_disp)”
and “ori $gp, $gp, %lo(_gp_disp)” which their corresponding obj
encode are 0fa00000 and  0daa0000, respectively.
The obj translates the %hi(_gp_disp) and %lo(_gp_disp) into 0 since when loader
loads this obj into memory, loader will know the _gp_disp value at run time and
will update these two offset relocation records to the correct offset value.
You can check if the cpu0 of %hi(_gp_disp) and %lo(_gp_disp) are correct by
above mips Relocation Records of R_MIPS_HI(_gp_disp) and  R_MIPS_LO(_gp_disp)
even though the cpu0 is not a CPU recognized by readelf utilitly.
The instruction <strong>“ld $2, %got(gI)($gp)”</strong> is same since we don’t know what the
address of .data section variable will load to.
So, Cpu0 translate the address to 0 and made a relocation record on 0x00000020
of .text section.
Linker or Loader will change this address when this program is
linked or loaded depends on the program is static link or dynamic link.</p>
</div>
<div class="section" id="cpu0-elf-related-files">
<h3><a class="toc-backref" href="#id17">Cpu0 ELF related files</a><a class="headerlink" href="#cpu0-elf-related-files" title="Permalink to this headline">¶</a></h3>
<p>Files Cpu0ELFObjectWrite.cpp and Cpu0MC*.cpp are the files take care the obj
format.
Most obj code translation about specific instructions are defined by
Cpu0InstrInfo.td and Cpu0RegisterInfo.td.
With these td description, LLVM translate Cpu0 instructions into obj format
automatically.</p>
</div>
</div>
<div class="section" id="llvm-objdump">
<h2><a class="toc-backref" href="#id18">llvm-objdump</a><a class="headerlink" href="#llvm-objdump" title="Permalink to this headline">¶</a></h2>
<div class="section" id="llvm-objdump-t-r">
<h3><a class="toc-backref" href="#id19">llvm-objdump -t -r</a><a class="headerlink" href="#llvm-objdump-t-r" title="Permalink to this headline">¶</a></h3>
<p>In iMac, <code class="docutils literal notranslate"><span class="pre">gobjdump</span> <span class="pre">-tr</span></code> can display the information of relocation records
like <code class="docutils literal notranslate"><span class="pre">readelf</span> <span class="pre">-tr</span></code>. LLVM tool llvm-objdump is the same tool as objdump.
Let’s run gobjdump and llvm-objdump commands as follows to see the differences.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-83-12:input Jonathan$</span> clang -target mips-unknown-linux-gnu -c
<span class="go">ch9_3.cpp -emit-llvm -o ch9_3.bc</span>
<span class="gp">118-165-83-10:input Jonathan$</span> /Users/Jonathan/llvm/test/cmake_debug_build/
<span class="go">Debug/bin/llc -march=cpu0 -relocation-model=pic -filetype=obj ch9_3.bc -o</span>
<span class="go">ch9_3.cpu0.o</span>

<span class="gp">118-165-78-12:input Jonathan$</span> gobjdump -t -r ch9_3.cpu0.o

<span class="go">ch9_3.cpu0.o:     file format elf32-big</span>

<span class="go">SYMBOL TABLE:</span>
<span class="go">00000000 l    df *ABS*        00000000 ch9_3.bc</span>
<span class="go">00000000 l    d  .text        00000000 .text</span>
<span class="go">00000000 l    d  .data        00000000 .data</span>
<span class="go">00000000 l    d  .bss 00000000 .bss</span>
<span class="go">00000000 g     F .text        00000084 _Z5sum_iiz</span>
<span class="go">00000084 g     F .text        00000080 main</span>
<span class="go">00000000         *UND*        00000000 _gp_disp</span>


<span class="go">RELOCATION RECORDS FOR [.text]:</span>
<span class="go">OFFSET   TYPE              VALUE</span>
<span class="go">00000084 UNKNOWN           _gp_disp</span>
<span class="go">00000088 UNKNOWN           _gp_disp</span>
<span class="go">000000e0 UNKNOWN           _Z5sum_iiz</span>


<span class="gp">118-165-83-10:input Jonathan$</span> /Users/Jonathan/llvm/test/cmake_debug_build/
<span class="go">Debug/bin/llvm-objdump -t -r ch9_3.cpu0.o</span>

<span class="go">ch9_3.cpu0.o: file format ELF32-CPU0</span>

<span class="go">RELOCATION RECORDS FOR [.text]:</span>
<span class="go">132 R_CPU0_HI16 _gp_disp</span>
<span class="go">136 R_CPU0_LO16 _gp_disp</span>
<span class="go">224 R_CPU0_CALL16 _Z5sum_iiz</span>

<span class="go">SYMBOL TABLE:</span>
<span class="go">00000000 l    df *ABS*        00000000 ch9_3.bc</span>
<span class="go">00000000 l    d  .text        00000000 .text</span>
<span class="go">00000000 l    d  .data        00000000 .data</span>
<span class="go">00000000 l    d  .bss 00000000 .bss</span>
<span class="go">00000000 g     F .text        00000084 _Z5sum_iiz</span>
<span class="go">00000084 g     F .text        00000080 main</span>
<span class="go">00000000         *UND*        00000000 _gp_disp</span>
</pre></div>
</div>
<p>The llvm-objdump can display the file format and relocation records information
well while the objdump cannot since we add the relocation records information
in ELF.h as follows,</p>
<p class="rubric">include/llvm/support/ELF.h</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Machine architectures</span>
<span class="k">enum</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="n">EM_CPU0</span>          <span class="o">=</span> <span class="mi">998</span><span class="p">,</span> <span class="c1">// Document LLVM Backend Tutorial Cpu0</span>
  <span class="n">EM_CPU0_LE</span>       <span class="o">=</span> <span class="mi">999</span>  <span class="c1">// EM_CPU0_LE: little endian; EM_CPU0: big endian</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lib/object/ELF.cpp</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>

<span class="n">StringRef</span> <span class="n">getELFRelocationTypeName</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">Machine</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">Type</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">Machine</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">case</span> <span class="n">ELF</span><span class="o">::</span><span class="nl">EM_CPU0</span><span class="p">:</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">Type</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#include</span> <span class="cpf">&quot;llvm/Support/ELFRelocs/Cpu0.def&quot;</span><span class="cp"></span>
    <span class="k">default</span><span class="o">:</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">...</span>
  <span class="p">}</span>
</pre></div>
</div>
<p class="rubric">include/llvm/Support/ELFRelocs/Cpu0.def</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="c1">#ifndef ELF_RELOC</span>
<span class="c1">#error &quot;ELF_RELOC must be defined&quot;</span>
<span class="c1">#endif</span>

<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_NONE</span><span class="p">,</span>                <span class="mi">0</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_32</span><span class="p">,</span>                  <span class="mi">2</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_HI16</span><span class="p">,</span>                <span class="mi">5</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_LO16</span><span class="p">,</span>                <span class="mi">6</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_GPREL16</span><span class="p">,</span>             <span class="mi">7</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_LITERAL</span><span class="p">,</span>             <span class="mi">8</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_GOT16</span><span class="p">,</span>               <span class="mi">9</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_PC16</span><span class="p">,</span>               <span class="mi">10</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_CALL16</span><span class="p">,</span>             <span class="mi">11</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_GPREL32</span><span class="p">,</span>            <span class="mi">12</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_PC24</span><span class="p">,</span>               <span class="mi">13</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_GOT_HI16</span><span class="p">,</span>           <span class="mi">22</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_GOT_LO16</span><span class="p">,</span>           <span class="mi">23</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_RELGOT</span><span class="p">,</span>             <span class="mi">36</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_TLS_GD</span><span class="p">,</span>             <span class="mi">42</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_TLS_LDM</span><span class="p">,</span>            <span class="mi">43</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_TLS_DTP_HI16</span><span class="p">,</span>       <span class="mi">44</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_TLS_DTP_LO16</span><span class="p">,</span>       <span class="mi">45</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_TLS_GOTTPREL</span><span class="p">,</span>       <span class="mi">46</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_TLS_TPREL32</span><span class="p">,</span>        <span class="mi">47</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_TLS_TP_HI16</span><span class="p">,</span>        <span class="mi">49</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_TLS_TP_LO16</span><span class="p">,</span>        <span class="mi">50</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_GLOB_DAT</span><span class="p">,</span>           <span class="mi">51</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_JUMP_SLOT</span><span class="p">,</span>          <span class="mi">127</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">include/llvm/Object/ELFObjectFile.h</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="n">support</span><span class="o">::</span><span class="n">endianness</span> <span class="n">target_endianness</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">is64Bits</span><span class="o">&gt;</span>
<span class="n">error_code</span> <span class="n">ELFObjectFile</span><span class="o">&lt;</span><span class="n">target_endianness</span><span class="p">,</span> <span class="n">is64Bits</span><span class="o">&gt;</span>
            <span class="o">::</span><span class="n">getRelocationValueString</span><span class="p">(</span><span class="n">DataRefImpl</span> <span class="n">Rel</span><span class="p">,</span>
                      <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Result</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">case</span> <span class="n">ELF</span><span class="o">::</span><span class="nl">EM_CPU0</span><span class="p">:</span>  <span class="c1">// llvm-objdump -t -r</span>
  <span class="n">res</span> <span class="o">=</span> <span class="n">symname</span><span class="p">;</span>
  <span class="k">break</span><span class="p">;</span>
  <span class="p">...</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="n">support</span><span class="o">::</span><span class="n">endianness</span> <span class="n">target_endianness</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">is64Bits</span><span class="o">&gt;</span>
<span class="n">StringRef</span> <span class="n">ELFObjectFile</span><span class="o">&lt;</span><span class="n">target_endianness</span><span class="p">,</span> <span class="n">is64Bits</span><span class="o">&gt;</span>
             <span class="o">::</span><span class="n">getFileFormatName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">switch</span><span class="p">(</span><span class="n">Header</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">[</span><span class="n">ELF</span><span class="o">::</span><span class="n">EI_CLASS</span><span class="p">])</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">ELF</span><span class="o">::</span><span class="nl">ELFCLASS32</span><span class="p">:</span>
  <span class="k">switch</span><span class="p">(</span><span class="n">Header</span><span class="o">-&gt;</span><span class="n">e_machine</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">case</span> <span class="n">ELF</span><span class="o">::</span><span class="nl">EM_CPU0</span><span class="p">:</span>  <span class="c1">// llvm-objdump -t -r</span>
    <span class="k">return</span> <span class="s">&quot;ELF32-CPU0&quot;</span><span class="p">;</span>
  <span class="p">...</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="n">support</span><span class="o">::</span><span class="n">endianness</span> <span class="n">target_endianness</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">is64Bits</span><span class="o">&gt;</span>
<span class="kt">unsigned</span> <span class="n">ELFObjectFile</span><span class="o">&lt;</span><span class="n">target_endianness</span><span class="p">,</span> <span class="n">is64Bits</span><span class="o">&gt;::</span><span class="n">getArch</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">switch</span><span class="p">(</span><span class="n">Header</span><span class="o">-&gt;</span><span class="n">e_machine</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">case</span> <span class="n">ELF</span><span class="o">::</span><span class="nl">EM_CPU0</span><span class="p">:</span>  <span class="c1">// llvm-objdump -t -r</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">target_endianness</span> <span class="o">==</span> <span class="n">support</span><span class="o">::</span><span class="n">little</span><span class="p">)</span> <span class="o">?</span>
       <span class="n">Triple</span><span class="o">::</span><span class="nl">cpu0el</span> <span class="p">:</span> <span class="n">Triple</span><span class="o">::</span><span class="n">cpu0</span><span class="p">;</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In addition to <code class="docutils literal notranslate"><span class="pre">llvm-objdump</span> <span class="pre">-t</span> <span class="pre">-r</span></code>, the <code class="docutils literal notranslate"><span class="pre">llvm-readobj</span> <span class="pre">-h</span></code> can display the
Cpu0 elf header information with above EM_CPU0 defined.</p>
</div>
<div class="section" id="llvm-objdump-d">
<h3><a class="toc-backref" href="#id20">llvm-objdump -d</a><a class="headerlink" href="#llvm-objdump-d" title="Permalink to this headline">¶</a></h3>
<p>Run the last Chapter example code with command <code class="docutils literal notranslate"><span class="pre">llvm-objdump</span> <span class="pre">-d</span></code> for dumping
file from elf to hex as follows,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$</span> clang -target mips-unknown-linux-gnu -c
<span class="go">ch8_1_1.cpp -emit-llvm -o ch8_1_1.bc</span>
<span class="gp">JonathantekiiMac:input Jonathan$</span> /Users/Jonathan/llvm/test/cmake_debug_
<span class="go">build/Debug/bin/llc -march=cpu0 -relocation-model=pic -filetype=obj ch8_1_1.bc</span>
<span class="go">-o ch8_1_1.cpu0.o</span>
<span class="gp">JonathantekiiMac:input Jonathan$</span> /Users/Jonathan/llvm/test/cmake_debug_
<span class="go">build/Debug/bin/llvm-objdump -d ch8_1_1.cpu0.o</span>

<span class="go">ch8_1_1.cpu0.o: file format ELF32-unknown</span>

<span class="go">Disassembly of section .text:error: no disassembler for target cpu0-unknown-</span>
<span class="go">unknown</span>
</pre></div>
</div>
<p>To support llvm-objdump, the following code added to Chapter10_1/
(the DecoderMethod for brtarget24 has been added in previous chapter).</p>
<p class="rubric">lbdex/chapters/Chapter10_1/CMakeLists.txt</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tablegen</span><span class="p">(</span><span class="n">LLVM</span> <span class="n">Cpu0GenDisassemblerTables</span><span class="o">.</span><span class="n">inc</span> <span class="o">-</span><span class="n">gen</span><span class="o">-</span><span class="n">disassembler</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">add_subdirectory</span><span class="p">(</span><span class="n">Disassembler</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter10_1/LLVMBuild.txt</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">subdirectories</span> <span class="o">=</span> 
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">Disassembler</span> 
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">has_disassembler</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter10_1/Cpu0InstrInfo.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>let isBranch=1, isTerminator=1, isBarrier=1, imm16=0, hasDelaySlot = 1,
    isIndirectBranch = 1 in
class JumpFR&lt;bits&lt;8&gt; op, string instr_asm, RegisterClass RC&gt;:
  FL&lt;op, (outs), (ins RC:$ra),
     !strconcat(instr_asm, &quot;\t$ra&quot;), [(brind RC:$ra)], IIBranch&gt; {
  let rb = 0;
  let imm16 = 0;
//#if CH &gt;= CH10_1 1.5
  let DecoderMethod = &quot;DecodeJumpFR&quot;;
//#endif
}
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  class JumpLink&lt;bits&lt;8&gt; op, string instr_asm&gt;:
    FJ&lt;op, (outs), (ins calltarget:$target, variable_ops),
       !strconcat(instr_asm, &quot;\t$target&quot;), [(Cpu0JmpLink imm:$target)],
       IIBranch&gt; {
//#if CH &gt;= CH10_1 2
       let DecoderMethod = &quot;DecodeJumpTarget&quot;;
//#endif
       }
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter10_1/Disassembler/CMakeLists.txt</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">add_llvm_library</span><span class="p">(</span><span class="n">LLVMCpu0Disassembler</span>
  <span class="n">Cpu0Disassembler</span><span class="o">.</span><span class="n">cpp</span>
  <span class="p">)</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter10_1/Disassembler/LLVMBuild.txt</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">;</span><span class="o">===-</span> <span class="o">./</span><span class="n">lib</span><span class="o">/</span><span class="n">Target</span><span class="o">/</span><span class="n">Cpu0</span><span class="o">/</span><span class="n">Disassembler</span><span class="o">/</span><span class="n">LLVMBuild</span><span class="o">.</span><span class="n">txt</span> <span class="o">--------------*-</span> <span class="n">Conf</span> <span class="o">-*--===</span><span class="p">;</span>
<span class="p">;</span>
<span class="p">;</span>                     <span class="n">The</span> <span class="n">LLVM</span> <span class="n">Compiler</span> <span class="n">Infrastructure</span>
<span class="p">;</span>
<span class="p">;</span> <span class="n">This</span> <span class="n">file</span> <span class="ow">is</span> <span class="n">distributed</span> <span class="n">under</span> <span class="n">the</span> <span class="n">University</span> <span class="n">of</span> <span class="n">Illinois</span> <span class="n">Open</span> <span class="n">Source</span>
<span class="p">;</span> <span class="n">License</span><span class="o">.</span> <span class="n">See</span> <span class="n">LICENSE</span><span class="o">.</span><span class="n">TXT</span> <span class="k">for</span> <span class="n">details</span><span class="o">.</span>
<span class="p">;</span>
<span class="p">;</span><span class="o">===------------------------------------------------------------------------===</span><span class="p">;</span>
<span class="p">;</span>
<span class="p">;</span> <span class="n">This</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">LLVMBuild</span> <span class="n">description</span> <span class="n">file</span> <span class="k">for</span> <span class="n">the</span> <span class="n">components</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">subdirectory</span><span class="o">.</span>
<span class="p">;</span>
<span class="p">;</span> <span class="n">For</span> <span class="n">more</span> <span class="n">information</span> <span class="n">on</span> <span class="n">the</span> <span class="n">LLVMBuild</span> <span class="n">system</span><span class="p">,</span> <span class="n">please</span> <span class="n">see</span><span class="p">:</span>
<span class="p">;</span>
<span class="p">;</span>   <span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">llvm</span><span class="o">.</span><span class="n">org</span><span class="o">/</span><span class="n">docs</span><span class="o">/</span><span class="n">LLVMBuild</span><span class="o">.</span><span class="n">html</span>
<span class="p">;</span>
<span class="p">;</span><span class="o">===------------------------------------------------------------------------===</span><span class="p">;</span>

<span class="p">[</span><span class="n">component_0</span><span class="p">]</span>
<span class="nb">type</span> <span class="o">=</span> <span class="n">Library</span>
<span class="n">name</span> <span class="o">=</span> <span class="n">Cpu0Disassembler</span>
<span class="n">parent</span> <span class="o">=</span> <span class="n">Cpu0</span>
<span class="n">required_libraries</span> <span class="o">=</span> <span class="n">MCDisassembler</span> <span class="n">Support</span> <span class="n">Cpu0Info</span>
<span class="n">add_to_library_groups</span> <span class="o">=</span> <span class="n">Cpu0</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter10_1/Disassembler/Cpu0Disassembler.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>//===- Cpu0Disassembler.cpp - Disassembler for Cpu0 -------------*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file is part of the Cpu0 Disassembler.
//
//===----------------------------------------------------------------------===//

#include &quot;Cpu0.h&quot;

#include &quot;Cpu0RegisterInfo.h&quot;
#include &quot;Cpu0Subtarget.h&quot;
#include &quot;llvm/MC/MCDisassembler/MCDisassembler.h&quot;
#include &quot;llvm/MC/MCFixedLenDisassembler.h&quot;
#include &quot;llvm/MC/MCInst.h&quot;
#include &quot;llvm/MC/MCSubtargetInfo.h&quot;
#include &quot;llvm/Support/MathExtras.h&quot;
#include &quot;llvm/Support/TargetRegistry.h&quot;

using namespace llvm;

#define DEBUG_TYPE &quot;cpu0-disassembler&quot;

typedef MCDisassembler::DecodeStatus DecodeStatus;

namespace {

/// Cpu0DisassemblerBase - a disasembler class for Cpu0.
class Cpu0DisassemblerBase : public MCDisassembler {
public:
  /// Constructor     - Initializes the disassembler.
  ///
  Cpu0DisassemblerBase(const MCSubtargetInfo &amp;STI, MCContext &amp;Ctx,
                       bool bigEndian) :
    MCDisassembler(STI, Ctx),
    IsBigEndian(bigEndian) {}

  virtual ~Cpu0DisassemblerBase() {}

protected:
  bool IsBigEndian;
};

/// Cpu0Disassembler - a disasembler class for Cpu032.
class Cpu0Disassembler : public Cpu0DisassemblerBase {
public:
  /// Constructor     - Initializes the disassembler.
  ///
  Cpu0Disassembler(const MCSubtargetInfo &amp;STI, MCContext &amp;Ctx, bool bigEndian)
      : Cpu0DisassemblerBase(STI, Ctx, bigEndian) {
  }

  /// getInstruction - See MCDisassembler.
  DecodeStatus getInstruction(MCInst &amp;Instr, uint64_t &amp;Size,
                              ArrayRef&lt;uint8_t&gt; Bytes, uint64_t Address,
                              raw_ostream &amp;VStream,
                              raw_ostream &amp;CStream) const override;
};

} // end anonymous namespace

// Decoder tables for GPR register
static const unsigned CPURegsTable[] = {
  Cpu0::ZERO, Cpu0::AT, Cpu0::V0, Cpu0::V1,
  Cpu0::A0, Cpu0::A1, Cpu0::T9, Cpu0::T0, 
  Cpu0::T1, Cpu0::S0, Cpu0::S1, Cpu0::GP, 
  Cpu0::FP, Cpu0::SP, Cpu0::LR, Cpu0::SW
};

// Decoder tables for co-processor 0 register
static const unsigned C0RegsTable[] = {
  Cpu0::PC, Cpu0::EPC
};

static DecodeStatus DecodeCPURegsRegisterClass(MCInst &amp;Inst,
                                               unsigned RegNo,
                                               uint64_t Address,
                                               const void *Decoder);
static DecodeStatus DecodeGPROutRegisterClass(MCInst &amp;Inst,
                                               unsigned RegNo,
                                               uint64_t Address,
                                               const void *Decoder);
static DecodeStatus DecodeSRRegisterClass(MCInst &amp;Inst,
                                               unsigned RegNo,
                                               uint64_t Address,
                                               const void *Decoder);
static DecodeStatus DecodeC0RegsRegisterClass(MCInst &amp;Inst,
                                              unsigned RegNo,
                                              uint64_t Address,
                                              const void *Decoder);
static DecodeStatus DecodeBranch16Target(MCInst &amp;Inst,
                                       unsigned Insn,
                                       uint64_t Address,
                                       const void *Decoder);
static DecodeStatus DecodeBranch24Target(MCInst &amp;Inst,
                                       unsigned Insn,
                                       uint64_t Address,
                                       const void *Decoder);
static DecodeStatus DecodeJumpTarget(MCInst &amp;Inst,
                                     unsigned Insn,
                                     uint64_t Address,
                                     const void *Decoder);
static DecodeStatus DecodeJumpFR(MCInst &amp;Inst,
                                 unsigned Insn,
                                 uint64_t Address,
                                 const void *Decoder);

static DecodeStatus DecodeMem(MCInst &amp;Inst,
                              unsigned Insn,
                              uint64_t Address,
                              const void *Decoder);
static DecodeStatus DecodeSimm16(MCInst &amp;Inst,
                                 unsigned Insn,
                                 uint64_t Address,
                                 const void *Decoder);

namespace llvm {
extern Target TheCpu0elTarget, TheCpu0Target, TheCpu064Target,
              TheCpu064elTarget;
}

static MCDisassembler *createCpu0Disassembler(
                       const Target &amp;T,
                       const MCSubtargetInfo &amp;STI,
                       MCContext &amp;Ctx) {
  return new Cpu0Disassembler(STI, Ctx, true);
}

static MCDisassembler *createCpu0elDisassembler(
                       const Target &amp;T,
                       const MCSubtargetInfo &amp;STI,
                       MCContext &amp;Ctx) {
  return new Cpu0Disassembler(STI, Ctx, false);
}

extern &quot;C&quot; void LLVMInitializeCpu0Disassembler() {
  // Register the disassembler.
  TargetRegistry::RegisterMCDisassembler(TheCpu0Target,
                                         createCpu0Disassembler);
  TargetRegistry::RegisterMCDisassembler(TheCpu0elTarget,
                                         createCpu0elDisassembler);
}

#include &quot;Cpu0GenDisassemblerTables.inc&quot;

/// Read four bytes from the ArrayRef and return 32 bit word sorted
/// according to the given endianess
static DecodeStatus readInstruction32(ArrayRef&lt;uint8_t&gt; Bytes, uint64_t Address,
                                      uint64_t &amp;Size, uint32_t &amp;Insn,
                                      bool IsBigEndian) {
  // We want to read exactly 4 Bytes of data.
  if (Bytes.size() &lt; 4) {
    Size = 0;
    return MCDisassembler::Fail;
  }

  if (IsBigEndian) {
    // Encoded as a big-endian 32-bit word in the stream.
    Insn = (Bytes[3] &lt;&lt;  0) |
           (Bytes[2] &lt;&lt;  8) |
           (Bytes[1] &lt;&lt; 16) |
           (Bytes[0] &lt;&lt; 24);
  }
  else {
    // Encoded as a small-endian 32-bit word in the stream.
    Insn = (Bytes[0] &lt;&lt;  0) |
           (Bytes[1] &lt;&lt;  8) |
           (Bytes[2] &lt;&lt; 16) |
           (Bytes[3] &lt;&lt; 24);
  }

  return MCDisassembler::Success;
}

DecodeStatus
Cpu0Disassembler::getInstruction(MCInst &amp;Instr, uint64_t &amp;Size,
                                              ArrayRef&lt;uint8_t&gt; Bytes,
                                              uint64_t Address,
                                              raw_ostream &amp;VStream,
                                              raw_ostream &amp;CStream) const {
  uint32_t Insn;

  DecodeStatus Result;

  Result = readInstruction32(Bytes, Address, Size, Insn, IsBigEndian);

  if (Result == MCDisassembler::Fail)
    return MCDisassembler::Fail;

  // Calling the auto-generated decoder function.
  Result = decodeInstruction(DecoderTableCpu032, Instr, Insn, Address,
                             this, STI);
  if (Result != MCDisassembler::Fail) {
    Size = 4;
    return Result;
  }

  return MCDisassembler::Fail;
}

static DecodeStatus DecodeCPURegsRegisterClass(MCInst &amp;Inst,
                                               unsigned RegNo,
                                               uint64_t Address,
                                               const void *Decoder) {
  if (RegNo &gt; 15)
    return MCDisassembler::Fail;

  Inst.addOperand(MCOperand::createReg(CPURegsTable[RegNo]));
  return MCDisassembler::Success;
}

static DecodeStatus DecodeGPROutRegisterClass(MCInst &amp;Inst,
                                               unsigned RegNo,
                                               uint64_t Address,
                                               const void *Decoder) {
  return DecodeCPURegsRegisterClass(Inst, RegNo, Address, Decoder);
}

static DecodeStatus DecodeSRRegisterClass(MCInst &amp;Inst,
                                               unsigned RegNo,
                                               uint64_t Address,
                                               const void *Decoder) {
  return DecodeCPURegsRegisterClass(Inst, RegNo, Address, Decoder);
}

static DecodeStatus DecodeC0RegsRegisterClass(MCInst &amp;Inst,
                                              unsigned RegNo,
                                              uint64_t Address,
                                              const void *Decoder) {
  if (RegNo &gt; 1)
    return MCDisassembler::Fail;

  Inst.addOperand(MCOperand::createReg(C0RegsTable[RegNo]));
  return MCDisassembler::Success;
}

//@DecodeMem {
static DecodeStatus DecodeMem(MCInst &amp;Inst,
                              unsigned Insn,
                              uint64_t Address,
                              const void *Decoder) {
//@DecodeMem body {
  int Offset = SignExtend32&lt;16&gt;(Insn &amp; 0xffff);
  int Reg = (int)fieldFromInstruction(Insn, 20, 4);
  int Base = (int)fieldFromInstruction(Insn, 16, 4);

  Inst.addOperand(MCOperand::createReg(CPURegsTable[Reg]));
  Inst.addOperand(MCOperand::createReg(CPURegsTable[Base]));
  Inst.addOperand(MCOperand::createImm(Offset));

  return MCDisassembler::Success;
}

static DecodeStatus DecodeBranch16Target(MCInst &amp;Inst,
                                       unsigned Insn,
                                       uint64_t Address,
                                       const void *Decoder) {
  int BranchOffset = fieldFromInstruction(Insn, 0, 16);
  if (BranchOffset &gt; 0x8fff)
  	BranchOffset = -1*(0x10000 - BranchOffset);
  Inst.addOperand(MCOperand::createImm(BranchOffset));
  return MCDisassembler::Success;
}

/* CBranch instruction define $ra and then imm24; The printOperand() print 
operand 1 (operand 0 is $ra and operand 1 is imm24), so we Create register 
operand first and create imm24 next, as follows,

// Cpu0InstrInfo.td
class CBranch&lt;bits&lt;8&gt; op, string instr_asm, RegisterClass RC,
                   list&lt;Register&gt; UseRegs&gt;:
  FJ&lt;op, (outs), (ins RC:$ra, brtarget:$addr),
             !strconcat(instr_asm, &quot;\t$addr&quot;),
             [(brcond RC:$ra, bb:$addr)], IIBranch&gt; {

// Cpu0AsmWriter.inc
void Cpu0InstPrinter::printInstruction(const MCInst *MI, raw_ostream &amp;O) {
...
  case 3:
    // CMP, JEQ, JGE, JGT, JLE, JLT, JNE
    printOperand(MI, 1, O); 
    break;
*/
static DecodeStatus DecodeBranch24Target(MCInst &amp;Inst,
                                       unsigned Insn,
                                       uint64_t Address,
                                       const void *Decoder) {
  int BranchOffset = fieldFromInstruction(Insn, 0, 24);
  if (BranchOffset &gt; 0x8fffff)
  	BranchOffset = -1*(0x1000000 - BranchOffset);
  Inst.addOperand(MCOperand::createReg(Cpu0::SW));
  Inst.addOperand(MCOperand::createImm(BranchOffset));
  return MCDisassembler::Success;
}

static DecodeStatus DecodeJumpTarget(MCInst &amp;Inst,
                                     unsigned Insn,
                                     uint64_t Address,
                                     const void *Decoder) {

  unsigned JumpOffset = fieldFromInstruction(Insn, 0, 24);
  Inst.addOperand(MCOperand::createImm(JumpOffset));
  return MCDisassembler::Success;
}

static DecodeStatus DecodeJumpFR(MCInst &amp;Inst,
                                     unsigned Insn,
                                     uint64_t Address,
                                     const void *Decoder) {
  int Reg_a = (int)fieldFromInstruction(Insn, 20, 4);
  Inst.addOperand(MCOperand::createReg(CPURegsTable[Reg_a]));
// exapin in http://jonathan2251.github.io/lbd/llvmstructure.html#jr-note
  if (CPURegsTable[Reg_a] == Cpu0::LR)
    Inst.setOpcode(Cpu0::RET);
  else
    Inst.setOpcode(Cpu0::JR);
  return MCDisassembler::Success;
}

static DecodeStatus DecodeSimm16(MCInst &amp;Inst,
                                 unsigned Insn,
                                 uint64_t Address,
                                 const void *Decoder) {
  Inst.addOperand(MCOperand::createImm(SignExtend32&lt;16&gt;(Insn)));
  return MCDisassembler::Success;
}

</pre></div>
</div>
<p>As above code, it adds directory Disassembler to handle the reverse translation
from obj to assembly. So, add Disassembler/Cpu0Disassembler.cpp and modify
the CMakeList.txt and LLVMBuild.txt to build directory Disassembler, and
enable the disassembler table generated by “has_disassembler = 1”.
Most of code is handled by the table defined in *.td files.
Not every instruction in *.td can be disassembled without trouble even though
they can be translated into assembly and obj successfully.
For those cannot be disassembled, LLVM supply the <strong>“let DecoderMethod”</strong>
keyword to allow programmers implement their decode function.
For example in Cpu0, we define functions DecodeBranch24Target(),
DecodeJumpTarget() and DecodeJumpFR() in
Cpu0Disassembler.cpp and tell the llvm-tblgen by writing
<strong>“let DecoderMethod = …”</strong> in the corresponding instruction definitions or
ISD node of Cpu0InstrInfo.td.
LLVM will call these DecodeMethod when user uses Disassembler tools, such
as <code class="docutils literal notranslate"><span class="pre">llvm-objdump</span> <span class="pre">-d</span></code>.</p>
<p>Finally cpu032II include all cpu032I instruction set and adds some instrucitons.
When <code class="docutils literal notranslate"><span class="pre">llvm-objdump</span> <span class="pre">-d</span></code> is invoked, function selectCpu0ArchFeature() as
the following will be called through createCpu0MCSubtargetInfo().
The llvm-objdump cannot set cpu option like llc as <code class="docutils literal notranslate"><span class="pre">llc</span> <span class="pre">-mcpu=cpu032I</span></code>,
so the varaible CPU in selectCpu0ArchFeature() is empty when invoked by
<code class="docutils literal notranslate"><span class="pre">llvm-objdump</span> <span class="pre">-d</span></code>. Set Cpu0ArchFeature to “+cpu032II” than it can disassemble
all instructions (cpu032II include all cpu032I instructions and add some new
instructions).</p>
<p class="rubric">lbdex/chapters/Chapter10_1/MCTargetDesc/Cpu0MCTargetDesc.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">///</span> <span class="n">Select</span> <span class="n">the</span> <span class="n">Cpu0</span> <span class="n">Architecture</span> <span class="n">Feature</span> <span class="k">for</span> <span class="n">the</span> <span class="n">given</span> <span class="n">triple</span> <span class="ow">and</span> <span class="n">cpu</span> <span class="n">name</span><span class="o">.</span>
<span class="o">///</span> <span class="n">The</span> <span class="n">function</span> <span class="n">will</span> <span class="n">be</span> <span class="n">called</span> <span class="n">at</span> <span class="n">command</span> <span class="s1">&#39;llvm-objdump -d&#39;</span> <span class="k">for</span> <span class="n">Cpu0</span> <span class="n">elf</span> <span class="nb">input</span><span class="o">.</span>
<span class="n">static</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">selectCpu0ArchFeature</span><span class="p">(</span><span class="n">const</span> <span class="n">Triple</span> <span class="o">&amp;</span><span class="n">TT</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">Cpu0ArchFeature</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">CPU</span><span class="o">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="n">CPU</span> <span class="o">==</span> <span class="s2">&quot;generic&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">TT</span><span class="o">.</span><span class="n">getArch</span><span class="p">()</span> <span class="o">==</span> <span class="n">Triple</span><span class="p">::</span><span class="n">cpu0</span> <span class="o">||</span> <span class="n">TT</span><span class="o">.</span><span class="n">getArch</span><span class="p">()</span> <span class="o">==</span> <span class="n">Triple</span><span class="p">::</span><span class="n">cpu0el</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">CPU</span><span class="o">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="n">CPU</span> <span class="o">==</span> <span class="s2">&quot;cpu032II&quot;</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Cpu0ArchFeature</span> <span class="o">=</span> <span class="s2">&quot;+cpu032II&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">CPU</span> <span class="o">==</span> <span class="s2">&quot;cpu032I&quot;</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">Cpu0ArchFeature</span> <span class="o">=</span> <span class="s2">&quot;+cpu032I&quot;</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">Cpu0ArchFeature</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now, run Chapter10_1/ with command <code class="docutils literal notranslate"><span class="pre">llvm-objdump</span> <span class="pre">-d</span> <span class="pre">ch8_1_1.cpu0.o</span></code> will get
the following result.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$</span> /Users/Jonathan/llvm/test/cmake_debug_
<span class="go">build/Debug/bin/llc -march=cpu0 -relocation-model=pic -filetype=obj</span>
<span class="go">ch8_1_1.bc -o ch8_1_1.cpu0.o</span>
<span class="gp">JonathantekiiMac:input Jonathan$</span> /Users/Jonathan/llvm/test/cmake_debug_
<span class="go">build/Debug/bin/llvm-objdump -d ch8_1_1.cpu0.o</span>

<span class="go">ch8_1_1.cpu0.o:       file format ELF32-CPU0</span>

<span class="go">Disassembly of section .text:</span>
<span class="go">_Z13test_control1v:</span>
<span class="go">       0: 09 dd ff d8                                   addiu $sp, $sp, -40</span>
<span class="go">       4: 09 30 00 00                                   addiu $3, $zero, 0</span>
<span class="go">       8: 02 3d 00 24                                   st  $3, 36($sp)</span>
<span class="go">       c: 09 20 00 01                                   addiu $2, $zero, 1</span>
<span class="go">      10: 02 2d 00 20                                   st  $2, 32($sp)</span>
<span class="go">      14: 09 40 00 02                                   addiu $4, $zero, 2</span>
<span class="go">      18: 02 4d 00 1c                                   st  $4, 28($sp)</span>
<span class="go">      ...</span>
</pre></div>
</div>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Executable_and_Linkable_Format">http://en.wikipedia.org/wiki/Executable_and_Linkable_Format</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><a class="reference external" href="http://jonathan2251.github.io/lbd/install.html#install-other-tools-on-imac">http://jonathan2251.github.io/lbd/install.html#install-other-tools-on-imac</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>Leland Beck, System Software: An Introduction to Systems Programming.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td><a class="reference external" href="http://ccckmit.wikidot.com/lk:aout">http://ccckmit.wikidot.com/lk:aout</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td><a class="reference external" href="http://ccckmit.wikidot.com/lk:objfile">http://ccckmit.wikidot.com/lk:objfile</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[6]</a></td><td><a class="reference external" href="http://ccckmit.wikidot.com/lk:elf">http://ccckmit.wikidot.com/lk:elf</a></td></tr>
</tbody>
</table>
</div>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="funccall.html">Function call</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="asm.html">Assembler</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Chen Chung-Shu.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
  </body>
</html>