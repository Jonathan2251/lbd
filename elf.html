
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>ELF Support &#8212; Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Assembler" href="asm.html" />
    <link rel="prev" title="Function call" href="funccall.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</span></a></h1>
        <h2 class="heading"><span>ELF Support</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="funccall.html">Function call</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="asm.html">Assembler</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="elf-support">
<span id="sec-elf"></span><h1>ELF Support<a class="headerlink" href="#elf-support" title="Permalink to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#elf-format" id="id9">ELF format</a></p>
<ul>
<li><p><a class="reference internal" href="#elf-header-and-section-header-table" id="id10">ELF header and Section header table</a></p></li>
<li><p><a class="reference internal" href="#relocation-record" id="id11">Relocation Record</a></p></li>
<li><p><a class="reference internal" href="#cpu0-elf-related-files" id="id12">Cpu0 ELF related files</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#llvm-objdump" id="id13">llvm-objdump</a></p>
<ul>
<li><p><a class="reference internal" href="#llvm-objdump-t-r" id="id14">llvm-objdump -t -r</a></p></li>
<li><p><a class="reference internal" href="#llvm-objdump-d" id="id15">llvm-objdump -d</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#disassembler-structure" id="id16">Disassembler Structure</a></p></li>
</ul>
</nav>
<p>Cpu0 backend generated the ELF format of object files.</p>
<p>The ELF (Executable and Linkable Format) is a common standard file format for
executables, object code, shared libraries and core dumps.
First published in the System V Application Binary Interface specification,
and later in the Tool Interface Standard, it was quickly accepted among
different vendors of Unixsystems.
In 1999 it was chosen as the standard binary file format for Unix and
Unix-like systems on x86 by the x86open project.
Please reference <a class="footnote-reference brackets" href="#wiki-elf" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>.</p>
<p>The binary encoding of the Cpu0 instruction set in object files has been
verified in previous chapters. However, we did not delve into the ELF file
format, such as the ELF header and relocation records, at that time.</p>
<p>In this chapter, you will learn how to use tools such as <code class="docutils literal notranslate"><span class="pre">llvm-objdump</span></code>,
<code class="docutils literal notranslate"><span class="pre">llvm-readelf</span></code>, and others to analyze ELF files generated by Cpu0. Through
these tools, you will also understand the ELF file format itself.</p>
<p>This chapter introduces these tools to readers because understanding the popular
ELF format and analysis tools is valuable. An LLVM compiler engineer is
responsible for ensuring that their backend generates correct object files.</p>
<p>With these tools, you can verify the correctness of the generated ELF format.</p>
<p>The Cpu0 author has published a book titled “System Software,” which introduces
topics such as assemblers, linkers, loaders, compilers, and operating systems in
both concept and practice. It demonstrates how to analyze ELF files using
binutils and gcc, and includes example code. This is a Chinese-language book on
“System Software.”</p>
<p>The book “System Software” <a class="footnote-reference brackets" href="#beck" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> written by Beck is a well-known resource for
explaining what the compiler, linker, and loader produce, and how they work
together conceptually. You may refer to it to understand how <strong>Relocation
Records</strong> work if you need a refresher or are learning this topic for the first
time.</p>
<p><a class="footnote-reference brackets" href="#lk-out" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>, <a class="footnote-reference brackets" href="#lk-obj" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a>, <a class="footnote-reference brackets" href="#lk-elf" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a> are Chinese documents about this topic,
available on the Cpu0 author’s website.</p>
<section id="elf-format">
<h2><a class="toc-backref" href="#id9" role="doc-backlink">ELF format</a><a class="headerlink" href="#elf-format" title="Permalink to this heading">¶</a></h2>
<p>ELF is a format used in both object and executable files. Therefore, there are
two views of it, as shown in <a class="reference internal" href="#elf-f1"><span class="std std-numref">Fig. 50</span></a>.</p>
<figure class="align-center" id="id6">
<span id="elf-f1"></span><a class="reference internal image-reference" href="_images/12.png"><img alt="_images/12.png" src="_images/12.png" style="width: 213.0px; height: 320.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 50 </span><span class="caption-text">ELF file format overview</span><a class="headerlink" href="#id6" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>As shown in <a class="reference internal" href="#elf-f1"><span class="std std-numref">Fig. 50</span></a>, the “Section header table” includes sections
.text, .rodata, …, .data, which are used for code, read-only data, and
read/write data, respectively. The “Program header table” includes segments
used at run time for code and data.</p>
<p>The definition of segments describes the run-time layout of code and data,
while sections describe the link-time layout.</p>
<section id="elf-header-and-section-header-table">
<h3><a class="toc-backref" href="#id10" role="doc-backlink">ELF header and Section header table</a><a class="headerlink" href="#elf-header-and-section-header-table" title="Permalink to this heading">¶</a></h3>
<p>Let’s run Chapter9_3/ with ch6_1.cpp, and dump ELF header information using
<code class="docutils literal notranslate"><span class="pre">llvm-readelf</span> <span class="pre">-h</span></code> to see what the ELF header contains.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">input$ ~/llvm/test/build/bin/llc -march=cpu0</span>
<span class="go">-relocation-model=pic -filetype=obj ch6_1.bc -o ch6_1.cpu0.o</span>

<span class="go">input$ llvm-readelf -h ch6_1.cpu0.o</span>
<span class="go">  Magic:   7f 45 4c 46 01 02 01 03 00 00 00 00 00 00 00 00</span>
<span class="go">  Class:                             ELF32</span>
<span class="go">  Data:                              2&#39;s complement, big endian</span>
<span class="go">  Version:                           1 (current)</span>
<span class="go">  OS/ABI:                            UNIX - GNU</span>
<span class="go">  ABI Version:                       0</span>
<span class="go">  Type:                              REL (Relocatable file)</span>
<span class="go">  Machine:                           &lt;unknown&gt;: 0xc9</span>
<span class="go">  Version:                           0x1</span>
<span class="go">  Entry point address:               0x0</span>
<span class="go">  Start of program headers:          0 (bytes into file)</span>
<span class="go">  Start of section headers:          176 (bytes into file)</span>
<span class="go">  Flags:                             0x0</span>
<span class="go">  Size of this header:               52 (bytes)</span>
<span class="go">  Size of program headers:           0 (bytes)</span>
<span class="go">  Number of program headers:         0</span>
<span class="go">  Size of section headers:           40 (bytes)</span>
<span class="go">  Number of section headers:         8</span>
<span class="go">  Section header string table index: 5</span>
<span class="go">input$</span>

<span class="go">input$ ~/llvm/test/build/bin/llc</span>
<span class="go">-march=mips -relocation-model=pic -filetype=obj ch6_1.bc -o ch6_1.mips.o</span>

<span class="go">input$ llvm-readelf -h ch6_1.mips.o</span>
<span class="go">ELF Header:</span>
<span class="go">  Magic:   7f 45 4c 46 01 02 01 03 00 00 00 00 00 00 00 00</span>
<span class="go">  Class:                             ELF32</span>
<span class="go">  Data:                              2&#39;s complement, big endian</span>
<span class="go">  Version:                           1 (current)</span>
<span class="go">  OS/ABI:                            UNIX - GNU</span>
<span class="go">  ABI Version:                       0</span>
<span class="go">  Type:                              REL (Relocatable file)</span>
<span class="go">  Machine:                           MIPS R3000</span>
<span class="go">  Version:                           0x1</span>
<span class="go">  Entry point address:               0x0</span>
<span class="go">  Start of program headers:          0 (bytes into file)</span>
<span class="go">  Start of section headers:          200 (bytes into file)</span>
<span class="go">  Flags:                             0x50001007, noreorder, pic, cpic, o32, mips32</span>
<span class="go">  Size of this header:               52 (bytes)</span>
<span class="go">  Size of program headers:           0 (bytes)</span>
<span class="go">  Number of program headers:         0</span>
<span class="go">  Size of section headers:           40 (bytes)</span>
<span class="go">  Number of section headers:         9</span>
<span class="go">  Section header string table index: 6</span>
<span class="go">input$</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">input$ llvm-readelf -l ch6_1.cpu0.o</span>

<span class="go">There are no program headers in this file.</span>
<span class="go">input$</span>
</pre></div>
</div>
<p>As shown in the ELF header above, it contains information such as the magic
number, version, ABI, and more. The <cite>Machine</cite> field for Cpu0 is listed as
unknown, whereas MIPS is recognized as <cite>MIPSR3000</cite>.</p>
<p>This happens because Cpu0 is a unknown CPU supported by the
<cite>llvm-readelf</cite> utility.</p>
<p>Let’s check the ELF segments information with the following command:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">input$ llvm-readelf -l ch6_1.cpu0.o</span>

<span class="go">There are no program headers in this file.</span>
<span class="go">input$</span>
</pre></div>
</div>
<p>This result is expected because the Cpu0 object file is meant for linking only,
not execution because we don’t implement linker at this point yet.
Therefore, the segment table is empty.</p>
<p>Next, let’s check the ELF sections. Each section includes offset and size
information.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">input$ llvm-readelf -S ch6_1.cpu0.o</span>
<span class="go">There are 10 section headers, starting at offset 0xd4:</span>

<span class="go">Section Headers:</span>
<span class="go">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span>
<span class="go">  [ 0]                   NULL            00000000 000000 000000 00      0   0  0</span>
<span class="go">  [ 1] .text             PROGBITS        00000000 000034 000034 00  AX  0   0  4</span>
<span class="go">  [ 2] .rel.text         REL             00000000 000310 000018 08      8   1  4</span>
<span class="go">  [ 3] .data             PROGBITS        00000000 000068 000004 00  WA  0   0  4</span>
<span class="go">  [ 4] .bss              NOBITS          00000000 00006c 000000 00  WA  0   0  4</span>
<span class="go">  [ 5] .eh_frame         PROGBITS        00000000 00006c 000028 00   A  0   0  4</span>
<span class="go">  [ 6] .rel.eh_frame     REL             00000000 000328 000008 08      8   5  4</span>
<span class="go">  [ 7] .shstrtab         STRTAB          00000000 000094 00003e 00      0   0  1</span>
<span class="go">  [ 8] .symtab           SYMTAB          00000000 000264 000090 10      9   6  4</span>
<span class="go">  [ 9] .strtab           STRTAB          00000000 0002f4 00001b 00      0   0  1</span>
<span class="go">Key to Flags:</span>
<span class="go">  W (write), A (alloc), X (execute), M (merge), S (strings)</span>
<span class="go">  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)</span>
<span class="go">  O (extra OS processing required) o (OS specific), p (processor specific)</span>
<span class="go">input$</span>
</pre></div>
</div>
</section>
<section id="relocation-record">
<h3><a class="toc-backref" href="#id11" role="doc-backlink">Relocation Record</a><a class="headerlink" href="#relocation-record" title="Permalink to this heading">¶</a></h3>
<p>Cpu0 backend translates global variables as follows:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">input$ clang -target mips-unknown-linux-gnu -c ch6_1.cpp</span>
<span class="go">-emit-llvm -o ch6_1.bc</span>
<span class="go">input$ ~/llvm/test/build/</span>
<span class="go">bin/llc -march=cpu0 -relocation-model=pic -filetype=asm ch6_1.bc -o ch6_1.cpu0.s</span>
<span class="go">input$ cat ch6_1.cpu0.s</span>
<span class="go">  .section .mdebug.abi32</span>
<span class="go">  .previous</span>
<span class="go">  .file &quot;ch6_1.bc&quot;</span>
<span class="go">  .text</span>
<span class="go">  ...</span>
<span class="go">  .cfi_startproc</span>
<span class="go">  .frame  $sp,8,$lr</span>
<span class="go">  .mask   0x00000000,0</span>
<span class="go">  .set  noreorder</span>
<span class="go">  .cpload $t9</span>
<span class="go">  ...</span>
<span class="go">  lui $2, %got_hi(gI)</span>
<span class="go">  addu $2, $2, $gp</span>
<span class="go">  ld $2, %got_lo(gI)($2)</span>
<span class="go">  ...</span>
<span class="go">  .type gI,@object              # @gI</span>
<span class="go">  .data</span>
<span class="go">  .globl  gI</span>
<span class="go">  .align  2</span>
<span class="go">gI:</span>
<span class="go">  .4byte  100                     # 0x64</span>
<span class="go">  .size gI, 4</span>


<span class="go">input$ ~/llvm/test/build/</span>
<span class="go">bin/llc -march=cpu0 -relocation-model=pic -filetype=obj ch6_1.bc -o ch6_1.cpu0.o</span>
<span class="go">input$ llvm-objdump -s ch6_1.cpu0.o</span>

<span class="go">ch6_1.cpu0.o:     file format elf32-big</span>

<span class="go">Contents of section .text:</span>
<span class="go">// .cpload machine instruction</span>
<span class="go"> 0000 0fa00000 0daa0000 13aa6000 ........  ..............`.</span>
<span class="go"> ...</span>
<span class="go"> 0020 002a0000 00220000 012d0000 0ddd0008  .*...&quot;...-......</span>
<span class="go"> ...</span>
<span class="go">input$</span>

<span class="go">input$ llvm-readelf -tr ch6_1.cpu0.o</span>
<span class="go">There are 8 section headers, starting at offset 0xb0:</span>

<span class="go">Section Headers:</span>
<span class="go">  [Nr] Name</span>
<span class="go">       Type            Addr     Off    Size   ES   Lk Inf Al</span>
<span class="go">       Flags</span>
<span class="go">  [ 0]</span>
<span class="go">       NULL            00000000 000000 000000 00   0   0  0</span>
<span class="go">       [00000000]:</span>
<span class="go">  [ 1] .text</span>
<span class="go">       PROGBITS        00000000 000034 000044 00   0   0  4</span>
<span class="go">       [00000006]: ALLOC, EXEC</span>
<span class="go">  [ 2] .rel.text</span>
<span class="go">       REL             00000000 0002a8 000020 08   6   1  4</span>
<span class="go">       [00000000]:</span>
<span class="go">  [ 3] .data</span>
<span class="go">       PROGBITS        00000000 000078 000008 00   0   0  4</span>
<span class="go">       [00000003]: WRITE, ALLOC</span>
<span class="go">  [ 4] .bss</span>
<span class="go">       NOBITS          00000000 000080 000000 00   0   0  4</span>
<span class="go">       [00000003]: WRITE, ALLOC</span>
<span class="go">  [ 5] .shstrtab</span>
<span class="go">       STRTAB          00000000 000080 000030 00   0   0  1</span>
<span class="go">       [00000000]:</span>
<span class="go">  [ 6] .symtab</span>
<span class="go">       SYMTAB          00000000 0001f0 000090 10   7   5  4</span>
<span class="go">       [00000000]:</span>
<span class="go">  [ 7] .strtab</span>
<span class="go">       STRTAB          00000000 000280 000025 00   0   0  1</span>
<span class="go">       [00000000]:</span>

<span class="go">Relocation section &#39;.rel.text&#39; at offset 0x2a8 contains 4 entries:</span>
<span class="go"> Offset     Info    Type            Sym.Value  Sym. Name</span>
<span class="go">00000000  00000805 unrecognized: 5       00000000   _gp_disp</span>
<span class="go">00000004  00000806 unrecognized: 6       00000000   _gp_disp</span>
<span class="go">00000020  00000616 unrecognized: 16      00000004   gI</span>
<span class="go">00000028  00000617 unrecognized: 17      00000004   gI</span>


<span class="go">input$ llvm-readelf -tr ch6_1.mips.o</span>
<span class="go">There are 9 section headers, starting at offset 0xc8:</span>

<span class="go">Section Headers:</span>
<span class="go">  [Nr] Name</span>
<span class="go">       Type            Addr     Off    Size   ES   Lk Inf Al</span>
<span class="go">       Flags</span>
<span class="go">  [ 0]</span>
<span class="go">       NULL            00000000 000000 000000 00   0   0  0</span>
<span class="go">       [00000000]:</span>
<span class="go">  [ 1] .text</span>
<span class="go">       PROGBITS        00000000 000034 000038 00   0   0  4</span>
<span class="go">       [00000006]: ALLOC, EXEC</span>
<span class="go">  [ 2] .rel.text</span>
<span class="go">       REL             00000000 0002f8 000018 08   7   1  4</span>
<span class="go">       [00000000]:</span>
<span class="go">  [ 3] .data</span>
<span class="go">       PROGBITS        00000000 00006c 000008 00   0   0  4</span>
<span class="go">       [00000003]: WRITE, ALLOC</span>
<span class="go">  [ 4] .bss</span>
<span class="go">       NOBITS          00000000 000074 000000 00   0   0  4</span>
<span class="go">       [00000003]: WRITE, ALLOC</span>
<span class="go">  [ 5] .reginfo</span>
<span class="go">       MIPS_REGINFO    00000000 000074 000018 00   0   0  1</span>
<span class="go">       [00000002]: ALLOC</span>
<span class="go">  [ 6] .shstrtab</span>
<span class="go">       STRTAB          00000000 00008c 000039 00   0   0  1</span>
<span class="go">       [00000000]:</span>
<span class="go">  [ 7] .symtab</span>
<span class="go">       SYMTAB          00000000 000230 0000a0 10   8   6  4</span>
<span class="go">       [00000000]:</span>
<span class="go">  [ 8] .strtab</span>
<span class="go">       STRTAB          00000000 0002d0 000025 00   0   0  1</span>
<span class="go">       [00000000]:</span>

<span class="go">Relocation section &#39;.rel.text&#39; at offset 0x2f8 contains 3 entries:</span>
<span class="go"> Offset     Info    Type            Sym.Value  Sym. Name</span>
<span class="go">00000000  00000905 R_MIPS_HI16       00000000   _gp_disp</span>
<span class="go">00000004  00000906 R_MIPS_LO16       00000000   _gp_disp</span>
<span class="go">0000001c  00000709 R_MIPS_GOT16      00000004   gI</span>
</pre></div>
</div>
<p>As depicted in <a class="reference external" href="http://jonathan2251.github.io/lbd/funccall.html#handle-gp-register-in-pic-addressing-mode">section Handle $gp register in PIC addressing mode</a>, it
translates <strong>“.cpload %reg”</strong> into the following.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Lower &quot;.cpload $reg&quot; to</span>
<span class="c1">//  &quot;lui   $gp, %hi(_gp_disp)&quot;</span>
<span class="c1">//  &quot;ori $gp, $gp, %lo(_gp_disp)&quot;</span>
<span class="c1">//  &quot;addu  $gp, $gp, $t9&quot;</span>
</pre></div>
</div>
<p>The _gp_disp value is determined by the loader, so it’s undefined in the obj
file. You can find both the relocation records for offset 0 and 4 of the <cite>.text</cite>
section referring to the _gp_disp symbol.</p>
<p>The offset 0 and 4 of the <cite>.text</cite> section correspond to the instructions
<code class="docutils literal notranslate"><span class="pre">lui</span> <span class="pre">$gp,</span> <span class="pre">%hi(_gp_disp)</span></code> and <code class="docutils literal notranslate"><span class="pre">ori</span> <span class="pre">$gp,</span> <span class="pre">$gp,</span> <span class="pre">%lo(_gp_disp)</span></code>, whose encoded
object representations are <cite>0fa00000</cite> and <cite>0daa0000</cite>, respectively.</p>
<p>The object file sets the <cite>%hi(_gp_disp)</cite> and <cite>%lo(_gp_disp)</cite> fields to zero,
since the loader will determine the actual _gp_disp value at runtime and patch
these two relocation entries accordingly.</p>
<p>You can verify the correctness of Cpu0’s handling of <cite>%hi(_gp_disp)</cite> and
<cite>%lo(_gp_disp)</cite> by comparing them to the MIPS relocation records
<cite>R_MIPS_HI(_gp_disp)</cite> and <cite>R_MIPS_LO(_gp_disp)</cite>, even though Cpu0 is not a
recognized CPU target by the <cite>llvm-readelf</cite> utility.</p>
<p>The instruction <code class="docutils literal notranslate"><span class="pre">ld</span> <span class="pre">$2,</span> <span class="pre">%got(gI)($gp)</span></code> behaves similarly. Because the actual
address of the <cite>.data</cite> section variable <cite>gI</cite> is unknown at compile time, Cpu0
sets its address to 0 and creates a relocation record at offset 0x00000020 of
the <cite>.text</cite> section.</p>
<p>The linker or loader will patch this address at link time (for static linking)
or load time (for dynamic linking), depending on how the program is built.</p>
</section>
<section id="cpu0-elf-related-files">
<h3><a class="toc-backref" href="#id12" role="doc-backlink">Cpu0 ELF related files</a><a class="headerlink" href="#cpu0-elf-related-files" title="Permalink to this heading">¶</a></h3>
<p>The files <cite>Cpu0ELFObjectWriter.cpp</cite> and <cite>Cpu0MC*.cpp</cite> are responsible for
generating object files (<cite>.o</cite>) in ELF format for the Cpu0 backend.</p>
<p>Most instruction-specific encoding logic is defined in the <cite>Cpu0InstrInfo.td</cite>
and <cite>Cpu0RegisterInfo.td</cite> TableGen files. Based on these <cite>.td</cite> descriptions,
LLVM automatically translates Cpu0 instructions into the correct binary format
for object files.</p>
</section>
</section>
<section id="llvm-objdump">
<h2><a class="toc-backref" href="#id13" role="doc-backlink">llvm-objdump</a><a class="headerlink" href="#llvm-objdump" title="Permalink to this heading">¶</a></h2>
<section id="llvm-objdump-t-r">
<h3><a class="toc-backref" href="#id14" role="doc-backlink">llvm-objdump -t -r</a><a class="headerlink" href="#llvm-objdump-t-r" title="Permalink to this heading">¶</a></h3>
<p>The <cite>llvm-objdump -tr</cite> command displays symbol table and relocation record
information, similar to the output of <cite>llvm-readelf -tr</cite>.</p>
<p>To examine the differences, try running <cite>llvm-objdump</cite> with and without enabling
the Cpu0 backend, as shown in the following example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-83-12:input Jonathan$ </span>clang -target mips-unknown-linux-gnu -c
<span class="go">ch9_3.cpp -emit-llvm -o ch9_3.bc</span>
<span class="gp">118-165-83-10:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llc -march=cpu0 -relocation-model=pic -filetype=obj ch9_3.bc -o</span>
<span class="go">ch9_3.cpu0.o</span>

<span class="gp">118-165-78-12:input Jonathan$ </span>objdump -t -r ch9_3.cpu0.o

<span class="go">ch9_3.cpu0.o:     file format elf32-big</span>

<span class="go">SYMBOL TABLE:</span>
<span class="go">00000000 l    df *ABS*        00000000 ch9_3.bc</span>
<span class="go">00000000 l    d  .text        00000000 .text</span>
<span class="go">00000000 l    d  .data        00000000 .data</span>
<span class="go">00000000 l    d  .bss 00000000 .bss</span>
<span class="go">00000000 g     F .text        00000084 _Z5sum_iiz</span>
<span class="go">00000084 g     F .text        00000080 main</span>
<span class="go">00000000         *UND*        00000000 _gp_disp</span>


<span class="go">RELOCATION RECORDS FOR [.text]:</span>
<span class="go">OFFSET   TYPE              VALUE</span>
<span class="go">00000084 UNKNOWN           _gp_disp</span>
<span class="go">00000088 UNKNOWN           _gp_disp</span>
<span class="go">000000e0 UNKNOWN           _Z5sum_iiz</span>


<span class="gp">118-165-83-10:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llvm-objdump -t -r ch9_3.cpu0.o</span>

<span class="go">ch9_3.cpu0.o: file format ELF32-CPU0</span>

<span class="go">RELOCATION RECORDS FOR [.text]:</span>
<span class="go">132 R_CPU0_HI16 _gp_disp</span>
<span class="go">136 R_CPU0_LO16 _gp_disp</span>
<span class="go">224 R_CPU0_CALL16 _Z5sum_iiz</span>

<span class="go">SYMBOL TABLE:</span>
<span class="go">00000000 l    df *ABS*        00000000 ch9_3.bc</span>
<span class="go">00000000 l    d  .text        00000000 .text</span>
<span class="go">00000000 l    d  .data        00000000 .data</span>
<span class="go">00000000 l    d  .bss 00000000 .bss</span>
<span class="go">00000000 g     F .text        00000084 _Z5sum_iiz</span>
<span class="go">00000084 g     F .text        00000080 main</span>
<span class="go">00000000         *UND*        00000000 _gp_disp</span>
</pre></div>
</div>
<p>The <cite>llvm-objdump</cite> tool can correctly display the file format and relocation
record information, whereas the GNU <cite>objdump</cite> cannot. This is because the
Cpu0-specific relocation record definitions have been added to <cite>ELF.h</cite> within
LLVM’s source code, enabling <cite>llvm-objdump</cite> to recognize and interpret them
properly.</p>
<p class="rubric">include/llvm/support/ELF.h</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Machine architectures</span>
<span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="n">EM_CPU0</span><span class="w">          </span><span class="o">=</span><span class="w"> </span><span class="mi">998</span><span class="p">,</span><span class="w"> </span><span class="c1">// Document LLVM Backend Tutorial Cpu0</span>
<span class="w">  </span><span class="n">EM_CPU0_LE</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="mi">999</span><span class="w">  </span><span class="c1">// EM_CPU0_LE: little endian; EM_CPU0: big endian</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lib/object/ELF.cpp</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">...</span><span class="w"></span>

<span class="n">StringRef</span><span class="w"> </span><span class="n">getELFRelocationTypeName</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">Machine</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">Type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">Machine</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">ELF</span><span class="o">::</span><span class="no">EM_CPU0</span><span class="p">:</span><span class="w"></span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">Type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;llvm/Support/ELFRelocs/Cpu0.def&quot;</span><span class="cp"></span>
<span class="w">    </span><span class="k">default</span><span class="o">:</span><span class="w"></span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">include/llvm/Support/ELFRelocs/Cpu0.def</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="c1">#ifndef ELF_RELOC</span>
<span class="c1">#error &quot;ELF_RELOC must be defined&quot;</span>
<span class="c1">#endif</span>

<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_NONE</span><span class="p">,</span>                <span class="mi">0</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_32</span><span class="p">,</span>                  <span class="mi">2</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_HI16</span><span class="p">,</span>                <span class="mi">5</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_LO16</span><span class="p">,</span>                <span class="mi">6</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_GPREL16</span><span class="p">,</span>             <span class="mi">7</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_LITERAL</span><span class="p">,</span>             <span class="mi">8</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_GOT16</span><span class="p">,</span>               <span class="mi">9</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_PC16</span><span class="p">,</span>               <span class="mi">10</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_CALL16</span><span class="p">,</span>             <span class="mi">11</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_GPREL32</span><span class="p">,</span>            <span class="mi">12</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_PC24</span><span class="p">,</span>               <span class="mi">13</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_GOT_HI16</span><span class="p">,</span>           <span class="mi">22</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_GOT_LO16</span><span class="p">,</span>           <span class="mi">23</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_RELGOT</span><span class="p">,</span>             <span class="mi">36</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_TLS_GD</span><span class="p">,</span>             <span class="mi">42</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_TLS_LDM</span><span class="p">,</span>            <span class="mi">43</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_TLS_DTP_HI16</span><span class="p">,</span>       <span class="mi">44</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_TLS_DTP_LO16</span><span class="p">,</span>       <span class="mi">45</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_TLS_GOTTPREL</span><span class="p">,</span>       <span class="mi">46</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_TLS_TPREL32</span><span class="p">,</span>        <span class="mi">47</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_TLS_TP_HI16</span><span class="p">,</span>        <span class="mi">49</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_TLS_TP_LO16</span><span class="p">,</span>        <span class="mi">50</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_GLOB_DAT</span><span class="p">,</span>           <span class="mi">51</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_JUMP_SLOT</span><span class="p">,</span>          <span class="mi">127</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">include/llvm/Object/ELFObjectFile.h</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="n">support</span><span class="o">::</span><span class="n">endianness</span><span class="w"> </span><span class="n">target_endianness</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">is64Bits</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">error_code</span><span class="w"> </span><span class="n">ELFObjectFile</span><span class="o">&lt;</span><span class="n">target_endianness</span><span class="p">,</span><span class="w"> </span><span class="n">is64Bits</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">            </span><span class="o">::</span><span class="n">getRelocationValueString</span><span class="p">(</span><span class="n">DataRefImpl</span><span class="w"> </span><span class="n">Rel</span><span class="p">,</span><span class="w"></span>
<span class="w">                      </span><span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Result</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">ELF</span><span class="o">::</span><span class="no">EM_CPU0</span><span class="p">:</span><span class="w">  </span><span class="c1">// llvm-objdump -t -r</span>
<span class="w">  </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">symname</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="o">&lt;</span><span class="n">support</span><span class="o">::</span><span class="n">endianness</span><span class="w"> </span><span class="n">target_endianness</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">is64Bits</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">StringRef</span><span class="w"> </span><span class="n">ELFObjectFile</span><span class="o">&lt;</span><span class="n">target_endianness</span><span class="p">,</span><span class="w"> </span><span class="n">is64Bits</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">             </span><span class="o">::</span><span class="n">getFileFormatName</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">switch</span><span class="p">(</span><span class="n">Header</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">[</span><span class="n">ELF</span><span class="o">::</span><span class="n">EI_CLASS</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">ELF</span><span class="o">::</span><span class="no">ELFCLASS32</span><span class="p">:</span><span class="w"></span>
<span class="w">  </span><span class="k">switch</span><span class="p">(</span><span class="n">Header</span><span class="o">-&gt;</span><span class="n">e_machine</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">ELF</span><span class="o">::</span><span class="no">EM_CPU0</span><span class="p">:</span><span class="w">  </span><span class="c1">// llvm-objdump -t -r</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;ELF32-CPU0&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="o">&lt;</span><span class="n">support</span><span class="o">::</span><span class="n">endianness</span><span class="w"> </span><span class="n">target_endianness</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">is64Bits</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="n">ELFObjectFile</span><span class="o">&lt;</span><span class="n">target_endianness</span><span class="p">,</span><span class="w"> </span><span class="n">is64Bits</span><span class="o">&gt;::</span><span class="n">getArch</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">switch</span><span class="p">(</span><span class="n">Header</span><span class="o">-&gt;</span><span class="n">e_machine</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">ELF</span><span class="o">::</span><span class="no">EM_CPU0</span><span class="p">:</span><span class="w">  </span><span class="c1">// llvm-objdump -t -r</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">target_endianness</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">support</span><span class="o">::</span><span class="n">little</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"></span>
<span class="w">       </span><span class="n">Triple</span><span class="o">::</span><span class="n">cpu0el</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Triple</span><span class="o">::</span><span class="n">cpu0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>In addition to <code class="docutils literal notranslate"><span class="pre">llvm-objdump</span> <span class="pre">-t</span> <span class="pre">-r</span></code>, the <code class="docutils literal notranslate"><span class="pre">llvm-readobj</span> <span class="pre">-h</span></code> command can be
used to display the Cpu0 ELF header information, thanks to the <cite>EM_CPU0</cite>
definition added earlier.</p>
</section>
<section id="llvm-objdump-d">
<h3><a class="toc-backref" href="#id15" role="doc-backlink">llvm-objdump -d</a><a class="headerlink" href="#llvm-objdump-d" title="Permalink to this heading">¶</a></h3>
<p>Run the example code from the previous chapter using the command
<code class="docutils literal notranslate"><span class="pre">llvm-objdump</span> <span class="pre">-d</span></code> to disassemble the ELF file and view its contents in
hexadecimal format as shown below:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>clang -target mips-unknown-linux-gnu -c
<span class="go">ch8_1_1.cpp -emit-llvm -o ch8_1_1.bc</span>
<span class="gp">JonathantekiiMac:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llc -march=cpu0 -relocation-model=pic -filetype=obj ch8_1_1.bc</span>
<span class="go">-o ch8_1_1.cpu0.o</span>
<span class="gp">JonathantekiiMac:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llvm-objdump -d ch8_1_1.cpu0.o</span>

<span class="go">ch8_1_1.cpu0.o: file format ELF32-unknown</span>

<span class="go">Disassembly of section .text:error: no disassembler for target cpu0-unknown-</span>
<span class="go">unknown</span>
</pre></div>
</div>
<p>To support <code class="docutils literal notranslate"><span class="pre">llvm-objdump</span></code>, the following code is added in Chapter10_1/.
(Note: The <code class="docutils literal notranslate"><span class="pre">DecoderMethod</span></code> for <code class="docutils literal notranslate"><span class="pre">brtarget24</span></code> was added in a previous chapter.)</p>
<p class="rubric">lbdex/chapters/Chapter10_1/CMakeLists.txt</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tablegen</span><span class="p">(</span><span class="n">LLVM</span> <span class="n">Cpu0GenDisassemblerTables</span><span class="o">.</span><span class="n">inc</span> <span class="o">-</span><span class="n">gen</span><span class="o">-</span><span class="n">disassembler</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">Cpu0Disassembler</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">add_subdirectory</span><span class="p">(</span><span class="n">Disassembler</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter10_1/Cpu0InstrInfo.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>let isBranch=1, isTerminator=1, isBarrier=1, imm16=0, hasDelaySlot = 1,
    isIndirectBranch = 1 in
class JumpFR&lt;bits&lt;8&gt; op, string instr_asm, RegisterClass RC&gt;:
  FL&lt;op, (outs), (ins RC:$ra),
     !strconcat(instr_asm, &quot;\t$ra&quot;), [(brind RC:$ra)], IIBranch&gt; {
  let rb = 0;
  let imm16 = 0;
//#if CH &gt;= CH10_1 1.5
  let DecoderMethod = &quot;DecodeJumpFR&quot;;
//#endif
}
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  class JumpLink&lt;bits&lt;8&gt; op, string instr_asm&gt;:
    FJ&lt;op, (outs), (ins calltarget:$target, variable_ops),
       !strconcat(instr_asm, &quot;\t$target&quot;), [(Cpu0JmpLink imm:$target)],
       IIBranch&gt; {
//#if CH &gt;= CH10_1 2
       let DecoderMethod = &quot;DecodeJumpTarget&quot;;
//#endif
       }
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter10_1/Disassembler/CMakeLists.txt</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">add_llvm_component_library</span><span class="p">(</span><span class="n">LLVMCpu0Disassembler</span>
  <span class="n">Cpu0Disassembler</span><span class="o">.</span><span class="n">cpp</span>

  <span class="n">LINK_COMPONENTS</span>
  <span class="n">MCDisassembler</span>
  <span class="n">Cpu0Info</span>
  <span class="n">Support</span>

  <span class="n">ADD_TO_COMPONENT</span>
  <span class="n">Cpu0</span>
  <span class="p">)</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter10_1/Disassembler/Cpu0Disassembler.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>//===- Cpu0Disassembler.cpp - Disassembler for Cpu0 -------------*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file is part of the Cpu0 Disassembler.
//
//===----------------------------------------------------------------------===//

#include &quot;Cpu0.h&quot;

#include &quot;Cpu0RegisterInfo.h&quot;
#include &quot;Cpu0Subtarget.h&quot;
#include &quot;llvm/MC/MCDisassembler/MCDisassembler.h&quot;
#include &quot;llvm/MC/MCFixedLenDisassembler.h&quot;
#include &quot;llvm/MC/MCInst.h&quot;
#include &quot;llvm/MC/MCSubtargetInfo.h&quot;
#include &quot;llvm/Support/MathExtras.h&quot;
#include &quot;llvm/Support/TargetRegistry.h&quot;

using namespace llvm;

#define DEBUG_TYPE &quot;cpu0-disassembler&quot;

typedef MCDisassembler::DecodeStatus DecodeStatus;

namespace {

/// Cpu0DisassemblerBase - a disasembler class for Cpu0.
class Cpu0DisassemblerBase : public MCDisassembler {
public:
  /// Constructor     - Initializes the disassembler.
  ///
  Cpu0DisassemblerBase(const MCSubtargetInfo &amp;STI, MCContext &amp;Ctx,
                       bool bigEndian) :
    MCDisassembler(STI, Ctx),
    IsBigEndian(bigEndian) {}

  virtual ~Cpu0DisassemblerBase() {}

protected:
  bool IsBigEndian;
};

/// Cpu0Disassembler - a disasembler class for Cpu032.
class Cpu0Disassembler : public Cpu0DisassemblerBase {
public:
  /// Constructor     - Initializes the disassembler.
  ///
  Cpu0Disassembler(const MCSubtargetInfo &amp;STI, MCContext &amp;Ctx, bool bigEndian)
      : Cpu0DisassemblerBase(STI, Ctx, bigEndian) {
  }

  /// getInstruction - See MCDisassembler.
  DecodeStatus getInstruction(MCInst &amp;Instr, uint64_t &amp;Size,
                              ArrayRef&lt;uint8_t&gt; Bytes, uint64_t Address,
                              raw_ostream &amp;CStream) const override;
};

} // end anonymous namespace

// Decoder tables for GPR register
static const unsigned CPURegsTable[] = {
  Cpu0::ZERO, Cpu0::AT, Cpu0::V0, Cpu0::V1,
  Cpu0::A0, Cpu0::A1, Cpu0::T9, Cpu0::T0, 
  Cpu0::T1, Cpu0::S0, Cpu0::S1, Cpu0::GP, 
  Cpu0::FP, Cpu0::SP, Cpu0::LR, Cpu0::SW
};

// Decoder tables for co-processor 0 register
static const unsigned C0RegsTable[] = {
  Cpu0::PC, Cpu0::EPC
};

static DecodeStatus DecodeCPURegsRegisterClass(MCInst &amp;Inst,
                                               unsigned RegNo,
                                               uint64_t Address,
                                               const void *Decoder);
static DecodeStatus DecodeGPROutRegisterClass(MCInst &amp;Inst,
                                               unsigned RegNo,
                                               uint64_t Address,
                                               const void *Decoder);
static DecodeStatus DecodeSRRegisterClass(MCInst &amp;Inst,
                                               unsigned RegNo,
                                               uint64_t Address,
                                               const void *Decoder);
static DecodeStatus DecodeC0RegsRegisterClass(MCInst &amp;Inst,
                                              unsigned RegNo,
                                              uint64_t Address,
                                              const void *Decoder);
static DecodeStatus DecodeBranch16Target(MCInst &amp;Inst,
                                       unsigned Insn,
                                       uint64_t Address,
                                       const void *Decoder);
static DecodeStatus DecodeBranch24Target(MCInst &amp;Inst,
                                       unsigned Insn,
                                       uint64_t Address,
                                       const void *Decoder);
static DecodeStatus DecodeJumpTarget(MCInst &amp;Inst,
                                     unsigned Insn,
                                     uint64_t Address,
                                     const void *Decoder);
static DecodeStatus DecodeJumpFR(MCInst &amp;Inst,
                                 unsigned Insn,
                                 uint64_t Address,
                                 const void *Decoder);

static DecodeStatus DecodeMem(MCInst &amp;Inst,
                              unsigned Insn,
                              uint64_t Address,
                              const void *Decoder);
static DecodeStatus DecodeSimm16(MCInst &amp;Inst,
                                 unsigned Insn,
                                 uint64_t Address,
                                 const void *Decoder);

namespace llvm {
extern Target TheCpu0elTarget, TheCpu0Target, TheCpu064Target,
              TheCpu064elTarget;
}

static MCDisassembler *createCpu0Disassembler(
                       const Target &amp;T,
                       const MCSubtargetInfo &amp;STI,
                       MCContext &amp;Ctx) {
  return new Cpu0Disassembler(STI, Ctx, true);
}

static MCDisassembler *createCpu0elDisassembler(
                       const Target &amp;T,
                       const MCSubtargetInfo &amp;STI,
                       MCContext &amp;Ctx) {
  return new Cpu0Disassembler(STI, Ctx, false);
}

extern &quot;C&quot; void LLVMInitializeCpu0Disassembler() {
  // Register the disassembler.
  TargetRegistry::RegisterMCDisassembler(TheCpu0Target,
                                         createCpu0Disassembler);
  TargetRegistry::RegisterMCDisassembler(TheCpu0elTarget,
                                         createCpu0elDisassembler);
}

#if 0
#undef LLVM_DEBUG
#define LLVM_DEBUG(X) X
#endif
#include &quot;Cpu0GenDisassemblerTables.inc&quot;

/// Read four bytes from the ArrayRef and return 32 bit word sorted
/// according to the given endianess
static DecodeStatus readInstruction32(ArrayRef&lt;uint8_t&gt; Bytes, uint64_t Address,
                                      uint64_t &amp;Size, uint32_t &amp;Insn,
                                      bool IsBigEndian) {
  // We want to read exactly 4 Bytes of data.
  if (Bytes.size() &lt; 4) {
    Size = 0;
    return MCDisassembler::Fail;
  }

  if (IsBigEndian) {
    // Encoded as a big-endian 32-bit word in the stream.
    Insn = (Bytes[3] &lt;&lt;  0) |
           (Bytes[2] &lt;&lt;  8) |
           (Bytes[1] &lt;&lt; 16) |
           (Bytes[0] &lt;&lt; 24);
  }
  else {
    // Encoded as a small-endian 32-bit word in the stream.
    Insn = (Bytes[0] &lt;&lt;  0) |
           (Bytes[1] &lt;&lt;  8) |
           (Bytes[2] &lt;&lt; 16) |
           (Bytes[3] &lt;&lt; 24);
  }

  return MCDisassembler::Success;
}

DecodeStatus
Cpu0Disassembler::getInstruction(MCInst &amp;Instr, uint64_t &amp;Size,
                                              ArrayRef&lt;uint8_t&gt; Bytes,
                                              uint64_t Address,
                                              raw_ostream &amp;CStream) const {
  uint32_t Insn;

  DecodeStatus Result;

  Result = readInstruction32(Bytes, Address, Size, Insn, IsBigEndian);

  if (Result == MCDisassembler::Fail)
    return MCDisassembler::Fail;

  // Calling the auto-generated decoder function.
  Result = decodeInstruction(DecoderTableCpu032, Instr, Insn, Address,
                             this, STI);
  if (Result != MCDisassembler::Fail) {
    Size = 4;
    return Result;
  }

  return MCDisassembler::Fail;
}

static DecodeStatus DecodeCPURegsRegisterClass(MCInst &amp;Inst,
                                               unsigned RegNo,
                                               uint64_t Address,
                                               const void *Decoder) {
  if (RegNo &gt; 15)
    return MCDisassembler::Fail;

  Inst.addOperand(MCOperand::createReg(CPURegsTable[RegNo]));
  return MCDisassembler::Success;
}

static DecodeStatus DecodeGPROutRegisterClass(MCInst &amp;Inst,
                                               unsigned RegNo,
                                               uint64_t Address,
                                               const void *Decoder) {
  return DecodeCPURegsRegisterClass(Inst, RegNo, Address, Decoder);
}

static DecodeStatus DecodeSRRegisterClass(MCInst &amp;Inst,
                                               unsigned RegNo,
                                               uint64_t Address,
                                               const void *Decoder) {
  return DecodeCPURegsRegisterClass(Inst, RegNo, Address, Decoder);
}

static DecodeStatus DecodeC0RegsRegisterClass(MCInst &amp;Inst,
                                              unsigned RegNo,
                                              uint64_t Address,
                                              const void *Decoder) {
  if (RegNo &gt; 1)
    return MCDisassembler::Fail;

  Inst.addOperand(MCOperand::createReg(C0RegsTable[RegNo]));
  return MCDisassembler::Success;
}

//@DecodeMem {
static DecodeStatus DecodeMem(MCInst &amp;Inst,
                              unsigned Insn,
                              uint64_t Address,
                              const void *Decoder) {
//@DecodeMem body {
  int Offset = SignExtend32&lt;16&gt;(Insn &amp; 0xffff);
  int Reg = (int)fieldFromInstruction(Insn, 20, 4);
  int Base = (int)fieldFromInstruction(Insn, 16, 4);

  Inst.addOperand(MCOperand::createReg(CPURegsTable[Reg]));
  Inst.addOperand(MCOperand::createReg(CPURegsTable[Base]));
  Inst.addOperand(MCOperand::createImm(Offset));

  return MCDisassembler::Success;
}

static DecodeStatus DecodeBranch16Target(MCInst &amp;Inst,
                                       unsigned Insn,
                                       uint64_t Address,
                                       const void *Decoder) {
  int BranchOffset = fieldFromInstruction(Insn, 0, 16);
  if (BranchOffset &gt; 0x8fff)
  	BranchOffset = -1*(0x10000 - BranchOffset);
  Inst.addOperand(MCOperand::createImm(BranchOffset));
  return MCDisassembler::Success;
}

/* CBranch instruction define $ra and then imm24; The printOperand() print 
operand 1 (operand 0 is $ra and operand 1 is imm24), so we Create register 
operand first and create imm24 next, as follows,

// Cpu0InstrInfo.td
class CBranch&lt;bits&lt;8&gt; op, string instr_asm, RegisterClass RC,
                   list&lt;Register&gt; UseRegs&gt;:
  FJ&lt;op, (outs), (ins RC:$ra, brtarget:$addr),
             !strconcat(instr_asm, &quot;\t$addr&quot;),
             [(brcond RC:$ra, bb:$addr)], IIBranch&gt; {

// Cpu0AsmWriter.inc
void Cpu0InstPrinter::printInstruction(const MCInst *MI, raw_ostream &amp;O) {
...
  case 3:
    // CMP, JEQ, JGE, JGT, JLE, JLT, JNE
    printOperand(MI, 1, O); 
    break;
*/
static DecodeStatus DecodeBranch24Target(MCInst &amp;Inst,
                                       unsigned Insn,
                                       uint64_t Address,
                                       const void *Decoder) {
  int BranchOffset = fieldFromInstruction(Insn, 0, 24);
  if (BranchOffset &gt; 0x8fffff)
  	BranchOffset = -1*(0x1000000 - BranchOffset);
  Inst.addOperand(MCOperand::createReg(Cpu0::SW));
  Inst.addOperand(MCOperand::createImm(BranchOffset));
  return MCDisassembler::Success;
}

static DecodeStatus DecodeJumpTarget(MCInst &amp;Inst,
                                     unsigned Insn,
                                     uint64_t Address,
                                     const void *Decoder) {

  unsigned JumpOffset = fieldFromInstruction(Insn, 0, 24);
  Inst.addOperand(MCOperand::createImm(JumpOffset));
  return MCDisassembler::Success;
}

static DecodeStatus DecodeJumpFR(MCInst &amp;Inst,
                                     unsigned Insn,
                                     uint64_t Address,
                                     const void *Decoder) {
  int Reg_a = (int)fieldFromInstruction(Insn, 20, 4);
  Inst.addOperand(MCOperand::createReg(CPURegsTable[Reg_a]));
// exapin in http://jonathan2251.github.io/lbd/llvmstructure.html#jr-note
  if (CPURegsTable[Reg_a] == Cpu0::LR)
    Inst.setOpcode(Cpu0::RET);
  else
    Inst.setOpcode(Cpu0::JR);
  return MCDisassembler::Success;
}

static DecodeStatus DecodeSimm16(MCInst &amp;Inst,
                                 unsigned Insn,
                                 uint64_t Address,
                                 const void *Decoder) {
  Inst.addOperand(MCOperand::createImm(SignExtend32&lt;16&gt;(Insn)));
  return MCDisassembler::Success;
}

</pre></div>
</div>
<p>As shown in the above code, it adds the <code class="docutils literal notranslate"><span class="pre">Disassembler</span></code> directory to handle
the reverse translation from obj to assembly. Therefore, <code class="docutils literal notranslate"><span class="pre">Disassembler/Cpu0Disassembler.cpp</span></code>
is added, and the <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> is modified to build the <code class="docutils literal notranslate"><span class="pre">Disassembler</span></code> directory
and enable the disassembler table generated by setting <code class="docutils literal notranslate"><span class="pre">has_disassembler</span> <span class="pre">=</span> <span class="pre">1</span></code>.
Most of the code is handled by the table defined in <code class="docutils literal notranslate"><span class="pre">*.td</span></code> files.</p>
<p>Not every instruction in the <code class="docutils literal notranslate"><span class="pre">*.td</span></code> files can be disassembled without trouble,
even though they can be successfully translated into assembly and obj. For those
that cannot be disassembled, LLVM provides the <code class="docutils literal notranslate"><span class="pre">&quot;let</span> <span class="pre">DecoderMethod&quot;</span></code> keyword to
allow programmers to implement their own decode functions.</p>
<p>For example, in Cpu0, we define functions such as <code class="docutils literal notranslate"><span class="pre">DecodeBranch24Target()</span></code>,
<code class="docutils literal notranslate"><span class="pre">DecodeJumpTarget()</span></code>, and <code class="docutils literal notranslate"><span class="pre">DecodeJumpFR()</span></code> in <code class="docutils literal notranslate"><span class="pre">Cpu0Disassembler.cpp</span></code>. We
then inform <code class="docutils literal notranslate"><span class="pre">llvm-tblgen</span></code> by writing <code class="docutils literal notranslate"><span class="pre">&quot;let</span> <span class="pre">DecoderMethod</span> <span class="pre">=</span> <span class="pre">...&quot;</span></code> in the
corresponding instruction definitions or ISD nodes of <code class="docutils literal notranslate"><span class="pre">Cpu0InstrInfo.td</span></code>.</p>
<p>LLVM will call these <code class="docutils literal notranslate"><span class="pre">DecoderMethods</span></code> when the user uses disassembler tools,
such as <code class="docutils literal notranslate"><span class="pre">llvm-objdump</span> <span class="pre">-d</span></code>.</p>
<p>Finally, <code class="docutils literal notranslate"><span class="pre">cpu032II</span></code> includes all instructions from <code class="docutils literal notranslate"><span class="pre">cpu032I</span></code> and adds some new
instructions. When <code class="docutils literal notranslate"><span class="pre">llvm-objdump</span> <span class="pre">-d</span></code> is invoked, the function
<code class="docutils literal notranslate"><span class="pre">selectCpu0ArchFeature()</span></code> will be called through <code class="docutils literal notranslate"><span class="pre">createCpu0MCSubtargetInfo()</span></code>.
Since <code class="docutils literal notranslate"><span class="pre">llvm-objdump</span></code> cannot set CPU options like <code class="docutils literal notranslate"><span class="pre">llc</span> <span class="pre">-mcpu=cpu032I</span></code>, the
variable <code class="docutils literal notranslate"><span class="pre">CPU</span></code> in <code class="docutils literal notranslate"><span class="pre">selectCpu0ArchFeature()</span></code> is empty when invoked by
<code class="docutils literal notranslate"><span class="pre">llvm-objdump</span> <span class="pre">-d</span></code>. To ensure that all instructions are disassembled, we set
<code class="docutils literal notranslate"><span class="pre">Cpu0ArchFeature</span></code> to <code class="docutils literal notranslate"><span class="pre">&quot;+cpu032II&quot;</span></code> so that it can disassemble all instructions
from <code class="docutils literal notranslate"><span class="pre">cpu032II</span></code> (which includes all instructions from <code class="docutils literal notranslate"><span class="pre">cpu032I</span></code> and adds new ones).</p>
<p class="rubric">lbdex/chapters/Chapter10_1/MCTargetDesc/Cpu0MCTargetDesc.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">///</span> <span class="n">Select</span> <span class="n">the</span> <span class="n">Cpu0</span> <span class="n">Architecture</span> <span class="n">Feature</span> <span class="k">for</span> <span class="n">the</span> <span class="n">given</span> <span class="n">triple</span> <span class="ow">and</span> <span class="n">cpu</span> <span class="n">name</span><span class="o">.</span>
<span class="o">///</span> <span class="n">The</span> <span class="n">function</span> <span class="n">will</span> <span class="n">be</span> <span class="n">called</span> <span class="n">at</span> <span class="n">command</span> <span class="s1">&#39;llvm-objdump -d&#39;</span> <span class="k">for</span> <span class="n">Cpu0</span> <span class="n">elf</span> <span class="nb">input</span><span class="o">.</span>
<span class="n">static</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">selectCpu0ArchFeature</span><span class="p">(</span><span class="n">const</span> <span class="n">Triple</span> <span class="o">&amp;</span><span class="n">TT</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">Cpu0ArchFeature</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">CPU</span><span class="o">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="n">CPU</span> <span class="o">==</span> <span class="s2">&quot;generic&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">TT</span><span class="o">.</span><span class="n">getArch</span><span class="p">()</span> <span class="o">==</span> <span class="n">Triple</span><span class="p">::</span><span class="n">cpu0</span> <span class="o">||</span> <span class="n">TT</span><span class="o">.</span><span class="n">getArch</span><span class="p">()</span> <span class="o">==</span> <span class="n">Triple</span><span class="p">::</span><span class="n">cpu0el</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">CPU</span><span class="o">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="n">CPU</span> <span class="o">==</span> <span class="s2">&quot;cpu032II&quot;</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Cpu0ArchFeature</span> <span class="o">=</span> <span class="s2">&quot;+cpu032II&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">CPU</span> <span class="o">==</span> <span class="s2">&quot;cpu032I&quot;</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">Cpu0ArchFeature</span> <span class="o">=</span> <span class="s2">&quot;+cpu032I&quot;</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">Cpu0ArchFeature</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now, run Chapter10_1/ with command <code class="docutils literal notranslate"><span class="pre">llvm-objdump</span> <span class="pre">-d</span> <span class="pre">ch8_1_1.cpu0.o</span></code> will get
the following result.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llc -march=cpu0 -relocation-model=pic -filetype=obj</span>
<span class="go">ch8_1_1.bc -o ch8_1_1.cpu0.o</span>
<span class="gp">JonathantekiiMac:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llvm-objdump -d ch8_1_1.cpu0.o</span>

<span class="go">ch8_1_1.cpu0.o:       file format ELF32-CPU0</span>

<span class="go">Disassembly of section .text:</span>
<span class="go">_Z13test_control1v:</span>
<span class="go">       0: 09 dd ff d8                                   addiu $sp, $sp, -40</span>
<span class="go">       4: 09 30 00 00                                   addiu $3, $zero, 0</span>
<span class="go">       8: 02 3d 00 24                                   st  $3, 36($sp)</span>
<span class="go">       c: 09 20 00 01                                   addiu $2, $zero, 1</span>
<span class="go">      10: 02 2d 00 20                                   st  $2, 32($sp)</span>
<span class="go">      14: 09 40 00 02                                   addiu $4, $zero, 2</span>
<span class="go">      18: 02 4d 00 1c                                   st  $4, 28($sp)</span>
<span class="go">      ...</span>
</pre></div>
</div>
</section>
</section>
<section id="disassembler-structure">
<h2><a class="toc-backref" href="#id16" role="doc-backlink">Disassembler Structure</a><a class="headerlink" href="#disassembler-structure" title="Permalink to this heading">¶</a></h2>
<p>The flow of disassembly is shown in <a class="reference internal" href="#disas"><span class="std std-numref">Fig. 51</span></a>.</p>
<figure class="align-default" id="id7">
<span id="disas"></span><div class="graphviz"><img src="_images/graphviz-34c1cf1d12b4b9b3ad02a3cd788246d9155a4c9d.png" alt="digraph G {
  rankdir=TD;
  &quot;disassembleObject()&quot; -&gt; &quot;getInstruction()&quot; [label=&quot;1. [AsmPrinter::llvm-objdump -d]\nBytes&quot;];
  &quot;disassembleObject()&quot; -&gt; &quot;PrettyPrinter::printInst()&quot; [label=&quot;2. MCInst,Address&quot;];
  &quot;getInstruction()&quot; -&gt; &quot;disassembleObject()&quot; [label=&quot;MCInst&quot;];
  &quot;PrettyPrinter::printInst()&quot; -&gt; &quot;printInst()&quot; [label=&quot;MCInst,Address&quot;];
  &quot;getInstruction()&quot; -&gt; &quot;decodeInstruction()&quot; [label=&quot;(DecoderTableCpu032,insn,Address)&quot;];
  &quot;decodeInstruction()&quot; -&gt; &quot;getInstruction()&quot; [label=&quot;MCInst&quot;];
  &quot;decodeInstruction()&quot; -&gt; &quot;fieldFromInstruction()&quot;;
  &quot;decodeInstruction()&quot; -&gt; &quot;checkDecoderPredicate()&quot;;
  &quot;decodeInstruction()&quot; -&gt; &quot;decodeToMCInst()&quot;;
  &quot;decodeToMCInst()&quot; -&gt; &quot;DecodeMem()&quot;;
  &quot;decodeToMCInst()&quot; -&gt; &quot;DecodeBranch16Target()&quot;;
  &quot;decodeToMCInst()&quot; -&gt; &quot;DecodeBranch24Target()&quot;;
  &quot;decodeToMCInst()&quot; -&gt; &quot;DecodeJumpTarget()&quot;;
  &quot;decodeToMCInst()&quot; -&gt; &quot;DecodeJumpFR()&quot;;
  &quot;decodeToMCInst()&quot; -&gt; &quot;DecodeSimm16()&quot;;
  subgraph clusterObjdump {
    label = &quot;llvm-objdump.cpp&quot;;
    &quot;disassembleObject()&quot;;
    &quot;PrettyPrinter::printInst()&quot;;
  }
  subgraph clusterCpu0Dis1 {
    label = &quot;Cpu0Disassembler.cpp&quot;;
    &quot;getInstruction()&quot;;
    &quot;readInstruction32()&quot;;
    &quot;getInstruction()&quot; -&gt; &quot;readInstruction32()&quot; [label=&quot;Bytes&quot;];
    &quot;readInstruction32()&quot; -&gt; &quot;getInstruction()&quot; [label=&quot;insn&quot;];
  }
  subgraph clusterCpu0Dis2 {
    label = &quot;Cpu0Disassembler.cpp\n These functions specified in Cpu0InstrInfo.td&quot;;
    &quot;DecodeMem()&quot;;
    &quot;DecodeBranch16Target()&quot;;
    &quot;DecodeBranch24Target()&quot;;
    &quot;DecodeJumpTarget()&quot;;
    &quot;DecodeJumpFR()&quot;;
    &quot;DecodeSimm16()&quot;;
  }
  subgraph clusterInc {
    label = &quot;Cpu0GenDisassemblerTables.inc&quot;;
    &quot;fieldFromInstruction()&quot;;
    &quot;checkDecoderPredicate()&quot;;
    &quot;decodeToMCInst()&quot;;
    &quot;decodeInstruction()&quot;;
  }
  subgraph clusterCpu0InstPrinter {
    label = &quot;Cpu0InstPrinter&quot;;
    &quot;printInst()&quot;;
  }
//  label = &quot;Figure: The flow of disassembly&quot;;
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 51 </span><span class="caption-text">The flow of disassembly.</span><a class="headerlink" href="#id7" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<ul class="simple">
<li><p>After getInstruction() of Cpu0Disassembler.cpp, disassembleObject() of
llvm-objdump.cpp call printInst() of Cpu0InstPrinter.cpp to print
(address: binary assembly) for the instruction, for example
“(4: 09 30 00 00 addiu $3, $zero, 0)”.</p>
<ul>
<li><p>printInst() of Cpu0InstPrinter.cpp: reference <a class="reference internal" href="backendstructure.html#print-asm"><span class="std std-numref">Fig. 24</span></a>.</p></li>
</ul>
</li>
<li><p>Bytes: 4-byte (32-bits) for Cpu0. insn: Convert Bytes to big or little endian
of 32-bit (unsigned int) binary instruction.</p></li>
</ul>
<p>List <cite>DecoderTableCpu032</cite> and <cite>decodeInstruction()</cite> as follows:</p>
<p class="rubric">build/lib/Target/Cpu0/Cpu0GenDisassemblerTables.inc</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">static</span> <span class="n">const</span> <span class="n">uint8_t</span> <span class="n">DecoderTableCpu032</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="o">/*</span> <span class="mi">0</span> <span class="o">*/</span>       <span class="n">MCD</span><span class="p">::</span><span class="n">OPC_ExtractField</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span>  <span class="o">//</span> <span class="n">Inst</span><span class="p">{</span><span class="mi">31</span><span class="o">-</span><span class="mi">24</span><span class="p">}</span> <span class="o">...</span>
<span class="o">/*</span> <span class="mi">3</span> <span class="o">*/</span>       <span class="n">MCD</span><span class="p">::</span><span class="n">OPC_FilterValue</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">//</span> <span class="n">Skip</span> <span class="n">to</span><span class="p">:</span> <span class="mi">19</span>
<span class="o">/*</span> <span class="mi">8</span> <span class="o">*/</span>       <span class="n">MCD</span><span class="p">::</span><span class="n">OPC_CheckField</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">149</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">//</span> <span class="n">Skip</span> <span class="n">to</span><span class="p">:</span> <span class="mi">1188</span>
<span class="o">/*</span> <span class="mi">15</span> <span class="o">*/</span>      <span class="n">MCD</span><span class="p">::</span><span class="n">OPC_Decode</span><span class="p">,</span> <span class="mi">178</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">//</span> <span class="n">Opcode</span><span class="p">:</span> <span class="n">NOP</span>
<span class="o">/*</span> <span class="mi">19</span> <span class="o">*/</span>      <span class="n">MCD</span><span class="p">::</span><span class="n">OPC_FilterValue</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">//</span> <span class="n">Skip</span> <span class="n">to</span><span class="p">:</span> <span class="mi">28</span>
<span class="o">/*</span> <span class="mi">24</span> <span class="o">*/</span>      <span class="n">MCD</span><span class="p">::</span><span class="n">OPC_Decode</span><span class="p">,</span> <span class="mi">161</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">//</span> <span class="n">Opcode</span><span class="p">:</span> <span class="n">LD</span>
<span class="o">/*</span> <span class="mi">28</span> <span class="o">*/</span>      <span class="n">MCD</span><span class="p">::</span><span class="n">OPC_FilterValue</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">//</span> <span class="n">Skip</span> <span class="n">to</span><span class="p">:</span> <span class="mi">37</span>
<span class="o">/*</span> <span class="mi">33</span> <span class="o">*/</span>      <span class="n">MCD</span><span class="p">::</span><span class="n">OPC_Decode</span><span class="p">,</span> <span class="mi">201</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">//</span> <span class="n">Opcode</span><span class="p">:</span> <span class="n">ST</span>
<span class="o">/*</span> <span class="mi">37</span> <span class="o">*/</span>      <span class="n">MCD</span><span class="p">::</span><span class="n">OPC_FilterValue</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">//</span> <span class="n">Skip</span> <span class="n">to</span><span class="p">:</span> <span class="mi">51</span>
<span class="o">/*</span> <span class="mi">42</span> <span class="o">*/</span>      <span class="n">MCD</span><span class="p">::</span><span class="n">OPC_CheckPredicate</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">117</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">//</span> <span class="n">Skip</span> <span class="n">to</span><span class="p">:</span> <span class="mi">1188</span>
<span class="o">/*</span> <span class="mi">47</span> <span class="o">*/</span>      <span class="n">MCD</span><span class="p">::</span><span class="n">OPC_Decode</span><span class="p">,</span> <span class="mi">159</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">//</span> <span class="n">Opcode</span><span class="p">:</span> <span class="n">LB</span>
<span class="o">/*</span> <span class="mi">51</span> <span class="o">*/</span>      <span class="n">MCD</span><span class="p">::</span><span class="n">OPC_FilterValue</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">//</span> <span class="n">Skip</span> <span class="n">to</span><span class="p">:</span> <span class="mi">65</span>
<span class="o">/*</span> <span class="mi">56</span> <span class="o">*/</span>      <span class="n">MCD</span><span class="p">::</span><span class="n">OPC_CheckPredicate</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">103</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">//</span> <span class="n">Skip</span> <span class="n">to</span><span class="p">:</span> <span class="mi">1188</span>
<span class="o">/*</span> <span class="mi">61</span> <span class="o">*/</span>      <span class="n">MCD</span><span class="p">::</span><span class="n">OPC_Decode</span><span class="p">,</span> <span class="mi">160</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">//</span> <span class="n">Opcode</span><span class="p">:</span> <span class="n">LBu</span>
<span class="o">/*</span> <span class="mi">65</span> <span class="o">*/</span>      <span class="n">MCD</span><span class="p">::</span><span class="n">OPC_FilterValue</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">//</span> <span class="n">Skip</span> <span class="n">to</span><span class="p">:</span> <span class="mi">79</span>
<span class="o">/*</span> <span class="mi">70</span> <span class="o">*/</span>      <span class="n">MCD</span><span class="p">::</span><span class="n">OPC_CheckPredicate</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">//</span> <span class="n">Skip</span> <span class="n">to</span><span class="p">:</span> <span class="mi">1188</span>
<span class="o">/*</span> <span class="mi">75</span> <span class="o">*/</span>      <span class="n">MCD</span><span class="p">::</span><span class="n">OPC_Decode</span><span class="p">,</span> <span class="mi">187</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">//</span> <span class="n">Opcode</span><span class="p">:</span> <span class="n">SB</span>
<span class="o">/*</span> <span class="mi">79</span> <span class="o">*/</span>      <span class="n">MCD</span><span class="p">::</span><span class="n">OPC_FilterValue</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">//</span> <span class="n">Skip</span> <span class="n">to</span><span class="p">:</span> <span class="mi">93</span>
<span class="o">/*</span> <span class="mi">84</span> <span class="o">*/</span>      <span class="n">MCD</span><span class="p">::</span><span class="n">OPC_CheckPredicate</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">//</span> <span class="n">Skip</span> <span class="n">to</span><span class="p">:</span> <span class="mi">1188</span>
<span class="o">/*</span> <span class="mi">89</span> <span class="o">*/</span>      <span class="n">MCD</span><span class="p">::</span><span class="n">OPC_Decode</span><span class="p">,</span> <span class="mi">163</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">//</span> <span class="n">Opcode</span><span class="p">:</span> <span class="n">LH</span>
<span class="o">/*</span> <span class="mi">93</span> <span class="o">*/</span>      <span class="n">MCD</span><span class="p">::</span><span class="n">OPC_FilterValue</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">//</span> <span class="n">Skip</span> <span class="n">to</span><span class="p">:</span> <span class="mi">107</span>
<span class="o">/*</span> <span class="mi">98</span> <span class="o">*/</span>      <span class="n">MCD</span><span class="p">::</span><span class="n">OPC_CheckPredicate</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">61</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">//</span> <span class="n">Skip</span> <span class="n">to</span><span class="p">:</span> <span class="mi">1188</span>
<span class="o">/*</span> <span class="mi">103</span> <span class="o">*/</span>     <span class="n">MCD</span><span class="p">::</span><span class="n">OPC_Decode</span><span class="p">,</span> <span class="mi">164</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">//</span> <span class="n">Opcode</span><span class="p">:</span> <span class="n">LHu</span>
<span class="o">/*</span> <span class="mi">107</span> <span class="o">*/</span>     <span class="n">MCD</span><span class="p">::</span><span class="n">OPC_FilterValue</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">//</span> <span class="n">Skip</span> <span class="n">to</span><span class="p">:</span> <span class="mi">121</span>
<span class="o">/*</span> <span class="mi">112</span> <span class="o">*/</span>     <span class="n">MCD</span><span class="p">::</span><span class="n">OPC_CheckPredicate</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">47</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">//</span> <span class="n">Skip</span> <span class="n">to</span><span class="p">:</span> <span class="mi">1188</span>
<span class="o">...</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>template &lt;typename InsnType&gt;
static DecodeStatus decodeInstruction(const uint8_t DecodeTable[], MCInst &amp;MI,
                                      InsnType insn, uint64_t Address,
                                      const void *DisAsm,
                                      const MCSubtargetInfo &amp;STI) {
  const FeatureBitset &amp;Bits = STI.getFeatureBits();

  const uint8_t *Ptr = DecodeTable;
  InsnType CurFieldValue = 0;
  DecodeStatus S = MCDisassembler::Success;
  while (true) {
    ptrdiff_t Loc = Ptr - DecodeTable;
    switch (*Ptr) {
    default:
      errs() &lt;&lt; Loc &lt;&lt; &quot;: Unexpected decode table opcode!\n&quot;;
      return MCDisassembler::Fail;
    case MCD::OPC_ExtractField: {
      unsigned Start = *++Ptr;
      unsigned Len = *++Ptr;
      ++Ptr;
      CurFieldValue = fieldFromInstruction(insn, Start, Len);
      LLVM_DEBUG(dbgs() &lt;&lt; Loc &lt;&lt; &quot;: OPC_ExtractField(&quot; &lt;&lt; Start &lt;&lt; &quot;, &quot;
                   &lt;&lt; Len &lt;&lt; &quot;): &quot; &lt;&lt; CurFieldValue &lt;&lt; &quot;\n&quot;);
      break;
    }
    case MCD::OPC_FilterValue: {
      // Decode the field value.
      unsigned Len;
      InsnType Val = decodeULEB128(++Ptr, &amp;Len);
      Ptr += Len;
      // NumToSkip is a plain 24-bit integer.
      unsigned NumToSkip = *Ptr++;
      NumToSkip |= (*Ptr++) &lt;&lt; 8;
      NumToSkip |= (*Ptr++) &lt;&lt; 16;

      // Perform the filter operation.
      if (Val != CurFieldValue)
        Ptr += NumToSkip;
      LLVM_DEBUG(dbgs() &lt;&lt; Loc &lt;&lt; &quot;: OPC_FilterValue(&quot; &lt;&lt; Val &lt;&lt; &quot;, &quot; &lt;&lt; NumToSkip
                   &lt;&lt; &quot;): &quot; &lt;&lt; ((Val != CurFieldValue) ? &quot;FAIL:&quot; : &quot;PASS:&quot;)
                   &lt;&lt; &quot; continuing at &quot; &lt;&lt; (Ptr - DecodeTable) &lt;&lt; &quot;\n&quot;);

      break;
    }
    case MCD::OPC_CheckField: {
      unsigned Start = *++Ptr;
      unsigned Len = *++Ptr;
      InsnType FieldValue = fieldFromInstruction(insn, Start, Len);
      // Decode the field value.
      InsnType ExpectedValue = decodeULEB128(++Ptr, &amp;Len);
      Ptr += Len;
      // NumToSkip is a plain 24-bit integer.
      unsigned NumToSkip = *Ptr++;
      NumToSkip |= (*Ptr++) &lt;&lt; 8;
      NumToSkip |= (*Ptr++) &lt;&lt; 16;

      // If the actual and expected values don&#39;t match, skip.
      if (ExpectedValue != FieldValue)
        Ptr += NumToSkip;
      LLVM_DEBUG(dbgs() &lt;&lt; Loc &lt;&lt; &quot;: OPC_CheckField(&quot; &lt;&lt; Start &lt;&lt; &quot;, &quot;
                   &lt;&lt; Len &lt;&lt; &quot;, &quot; &lt;&lt; ExpectedValue &lt;&lt; &quot;, &quot; &lt;&lt; NumToSkip
                   &lt;&lt; &quot;): FieldValue = &quot; &lt;&lt; FieldValue &lt;&lt; &quot;, ExpectedValue = &quot;
                   &lt;&lt; ExpectedValue &lt;&lt; &quot;: &quot;
                   &lt;&lt; ((ExpectedValue == FieldValue) ? &quot;PASS\n&quot; : &quot;FAIL\n&quot;));
      break;
    }
    case MCD::OPC_CheckPredicate: {
      unsigned Len;
      // Decode the Predicate Index value.
      unsigned PIdx = decodeULEB128(++Ptr, &amp;Len);
      Ptr += Len;
      // NumToSkip is a plain 24-bit integer.
      unsigned NumToSkip = *Ptr++;
      NumToSkip |= (*Ptr++) &lt;&lt; 8;
      NumToSkip |= (*Ptr++) &lt;&lt; 16;
      // Check the predicate.
      bool Pred;
      if (!(Pred = checkDecoderPredicate(PIdx, Bits)))
        Ptr += NumToSkip;
      (void)Pred;
      LLVM_DEBUG(dbgs() &lt;&lt; Loc &lt;&lt; &quot;: OPC_CheckPredicate(&quot; &lt;&lt; PIdx &lt;&lt; &quot;): &quot;
            &lt;&lt; (Pred ? &quot;PASS\n&quot; : &quot;FAIL\n&quot;));

      break;
    }
    case MCD::OPC_Decode: {
      unsigned Len;
      // Decode the Opcode value.
      unsigned Opc = decodeULEB128(++Ptr, &amp;Len);
      Ptr += Len;
      unsigned DecodeIdx = decodeULEB128(Ptr, &amp;Len);
      Ptr += Len;

      MI.clear();
      MI.setOpcode(Opc);
      bool DecodeComplete;
      S = decodeToMCInst(S, DecodeIdx, insn, MI, Address, DisAsm, DecodeComplete);
      assert(DecodeComplete);

      LLVM_DEBUG(dbgs() &lt;&lt; Loc &lt;&lt; &quot;: OPC_Decode: opcode &quot; &lt;&lt; Opc
                   &lt;&lt; &quot;, using decoder &quot; &lt;&lt; DecodeIdx &lt;&lt; &quot;: &quot;
                   &lt;&lt; (S != MCDisassembler::Fail ? &quot;PASS&quot; : &quot;FAIL&quot;) &lt;&lt; &quot;\n&quot;);
      return S;
    }
    case MCD::OPC_TryDecode: {
      unsigned Len;
      // Decode the Opcode value.
      unsigned Opc = decodeULEB128(++Ptr, &amp;Len);
      Ptr += Len;
      unsigned DecodeIdx = decodeULEB128(Ptr, &amp;Len);
      Ptr += Len;
      // NumToSkip is a plain 24-bit integer.
      unsigned NumToSkip = *Ptr++;
      NumToSkip |= (*Ptr++) &lt;&lt; 8;
      NumToSkip |= (*Ptr++) &lt;&lt; 16;

      // Perform the decode operation.
      MCInst TmpMI;
      TmpMI.setOpcode(Opc);
      bool DecodeComplete;
      S = decodeToMCInst(S, DecodeIdx, insn, TmpMI, Address, DisAsm, DecodeComplete);
      LLVM_DEBUG(dbgs() &lt;&lt; Loc &lt;&lt; &quot;: OPC_TryDecode: opcode &quot; &lt;&lt; Opc
                   &lt;&lt; &quot;, using decoder &quot; &lt;&lt; DecodeIdx &lt;&lt; &quot;: &quot;);

      if (DecodeComplete) {
        // Decoding complete.
        LLVM_DEBUG(dbgs() &lt;&lt; (S != MCDisassembler::Fail ? &quot;PASS&quot; : &quot;FAIL&quot;) &lt;&lt; &quot;\n&quot;);
        MI = TmpMI;
        return S;
      } else {
        assert(S == MCDisassembler::Fail);
        // If the decoding was incomplete, skip.
        Ptr += NumToSkip;
        LLVM_DEBUG(dbgs() &lt;&lt; &quot;FAIL: continuing at &quot; &lt;&lt; (Ptr - DecodeTable) &lt;&lt; &quot;\n&quot;);
        // Reset decode status. This also drops a SoftFail status that could be
        // set before the decode attempt.
        S = MCDisassembler::Success;
      }
      break;
    }
    case MCD::OPC_SoftFail: {
      // Decode the mask values.
      unsigned Len;
      InsnType PositiveMask = decodeULEB128(++Ptr, &amp;Len);
      Ptr += Len;
      InsnType NegativeMask = decodeULEB128(Ptr, &amp;Len);
      Ptr += Len;
      bool Fail = (insn &amp; PositiveMask) || (~insn &amp; NegativeMask);
      if (Fail)
        S = MCDisassembler::SoftFail;
      LLVM_DEBUG(dbgs() &lt;&lt; Loc &lt;&lt; &quot;: OPC_SoftFail: &quot; &lt;&lt; (Fail ? &quot;FAIL\n&quot; : &quot;PASS\n&quot;));
      break;
    }
    case MCD::OPC_Fail: {
      LLVM_DEBUG(dbgs() &lt;&lt; Loc &lt;&lt; &quot;: OPC_Fail\n&quot;);
      return MCDisassembler::Fail;
    }
    }
  }
  llvm_unreachable(&quot;bogosity detected in disassembler state machine!&quot;);
}


</pre></div>
</div>
<p>List the tracing of <cite>decodeInstruction()</cite> by enabling “#if 1” in
<cite>Cpu0Disassembler.cpp</cite> and running <cite>llvm-objdump</cite> as follows:</p>
<p class="rubric">lbdex/chapters/Chapter10_1/Disassembler/Cpu0Disassembler.cpp</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#if 1</span>
<span class="cp">#undef LLVM_DEBUG(X)</span>
<span class="cp">#define LLVM_DEBUG(X) X</span>
<span class="cp">#endif</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;Cpu0GenDisassemblerTables.inc&quot;</span><span class="cp"></span>
</pre></div>
</div>
<p>Based on the debug log above, pick the example “addiu $sp, $sp, -8”,
which has an opcode of 9, to explain <cite>decodeInstruction()</cite> as shown in the
table and explanation below:</p>
<table class="docutils align-default" id="id8">
<caption><span class="caption-number">Table 37 </span><span class="caption-text">The state transformation of decodeInstruction() for “addiu $sp, $sp, -8”</span><a class="headerlink" href="#id8" title="Permalink to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>state</p></th>
<th class="head"><p>result</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>OPC_ExtractField</p></td>
<td><p>CurFieldValue &lt;- Opcode:9</p></td>
</tr>
<tr class="row-odd"><td><p>OPC_FilterValue</p></td>
<td><p>Match entries of DecodeTable == CurFieldValue</p></td>
</tr>
<tr class="row-even"><td><p>OPC_Decode</p></td>
<td><p>setOpcode(9) and decode operands by calling decodeToMCInst()</p></td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><p>For “move $fp, $sp” and “ret $lr”, they have state OPC_CheckField before
OPC_Decode since they are R type of Cpu0 instruction format and
“let shamt = 0;” is set in “class ArithLogic” of Cpu0InstrInfo.td.</p>
<ul>
<li><p>For “move $fp, $sp”, fieldFromInstruction(0x11cd0000, 0, 12) = (0x11cd0000
&amp; 0x00000fff). Check bits(20..31) is 0.</p></li>
</ul>
</li>
<li><p>DecodeBranch16Target() and DecodeBranch24Target(): decode immediate value
to MCInst.operand and set the type of MCInst.operand to immediate type,
with value being either positive or negative. Operand of MCInst can be
either immediate or register type.</p></li>
</ul>
<aside class="footnote brackets" id="wiki-elf" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://en.wikipedia.org/wiki/Executable_and_Linkable_Format">http://en.wikipedia.org/wiki/Executable_and_Linkable_Format</a></p>
</aside>
<aside class="footnote brackets" id="beck" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p>Leland Beck, System Software: An Introduction to Systems Programming.</p>
</aside>
<aside class="footnote brackets" id="lk-out" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">3</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://ccckmit.wikidot.com/lk:aout">http://ccckmit.wikidot.com/lk:aout</a></p>
</aside>
<aside class="footnote brackets" id="lk-obj" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">4</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://ccckmit.wikidot.com/lk:objfile">http://ccckmit.wikidot.com/lk:objfile</a></p>
</aside>
<aside class="footnote brackets" id="lk-elf" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">5</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://ccckmit.wikidot.com/lk:elffile">http://ccckmit.wikidot.com/lk:elffile</a></p>
</aside>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="funccall.html">Function call</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="asm.html">Assembler</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Chen Chung-Shu.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.0.2.
    </div>
  </body>
</html>