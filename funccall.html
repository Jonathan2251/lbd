
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Function call &#8212; Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="ELF Support" href="elf.html" />
    <link rel="prev" title="Control flow statements" href="ctrlflow.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</span></a></h1>
        <h2 class="heading"><span>Function call</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="ctrlflow.html">Control flow statements</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="elf.html">ELF Support</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="function-call">
<span id="sec-funccall"></span><h1>Function call<a class="headerlink" href="#function-call" title="Permalink to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#mips-stack-frame" id="id32">MIPS Stack Frame</a></p></li>
<li><p><a class="reference internal" href="#load-incoming-arguments-from-stack-frame" id="id33">Load Incoming Arguments from Stack Frame</a></p></li>
<li><p><a class="reference internal" href="#store-outgoing-arguments-to-stack-frame" id="id34">Store Outgoing Arguments to Stack Frame</a></p>
<ul>
<li><p><a class="reference internal" href="#pseudo-hook-instructions-adjcallstackdown-and-adjcallstackup" id="id35">Pseudo Hook Instructions ADJCALLSTACKDOWN and ADJCALLSTACKUP</a></p></li>
<li><p><a class="reference internal" href="#read-lowercall-with-graphviz-s-help" id="id36">Read LowerCall() with Graphviz’s Help</a></p></li>
<li><p><a class="reference internal" href="#long-and-short-string-initialization" id="id37">Long and Short String Initialization</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#structure-type-support" id="id38">Structure Type Support</a></p>
<ul>
<li><p><a class="reference internal" href="#ordinary-struct-type" id="id39">Ordinary Struct Type</a></p></li>
<li><p><a class="reference internal" href="#byval-struct-type" id="id40">Byval Struct Type</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#function-call-optimization" id="id41">Function Call Optimization</a></p>
<ul>
<li><p><a class="reference internal" href="#tail-call-optimization" id="id42">Tail Call Optimization</a></p></li>
<li><p><a class="reference internal" href="#recursion-optimization" id="id43">Recursion optimization</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#other-features-supported" id="id44">Other Features Supported</a></p>
<ul>
<li><p><a class="reference internal" href="#the-gp-register-caller-saved-register-in-pic-addressing-mode" id="id45">The $gp Register Caller Saved Register in PIC Addressing Mode</a></p></li>
<li><p><a class="reference internal" href="#variable-number-of-arguments" id="id46">Variable number of arguments</a></p></li>
<li><p><a class="reference internal" href="#dynamic-stack-allocation-support" id="id47">Dynamic stack allocation support</a></p></li>
<li><p><a class="reference internal" href="#variable-sized-array-support" id="id48">Variable sized array support</a></p></li>
<li><p><a class="reference internal" href="#function-related-intrinsics-support" id="id49">Function related Intrinsics support</a></p>
<ul>
<li><p><a class="reference internal" href="#frameaddress-and-returnaddress-intrinsics" id="id50">frameaddress and returnaddress intrinsics</a></p></li>
<li><p><a class="reference internal" href="#eh-return-intrinsic" id="id51">eh.return intrinsic</a></p></li>
<li><p><a class="reference internal" href="#eh-dwarf-intrinsic" id="id52">eh.dwarf intrinsic</a></p></li>
<li><p><a class="reference internal" href="#bswap-intrinsic" id="id53">bswap intrinsic</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#add-specific-backend-intrinsic-function" id="id54">Add specific backend intrinsic function</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#summary" id="id55">Summary</a></p></li>
</ul>
</nav>
<p>This chapter introduces support for subroutine and function calls in backend
translation. A significant amount of code is required to support function
calls, and it is organized using LLVM-supplied interfaces for clarity.</p>
<p>The chapter begins by introducing the MIPS stack frame structure, as many
parts of the ABI are borrowed from it. Although each CPU has its own ABI,
most RISC CPU ABIs share similar characteristics.</p>
<p>Section “4.5 DAG Lowering” of <em>tricore_llvm.pdf</em> provides insight into the
lowering process. Section “4.5.1 Calling Conventions” in the same document is
also a helpful reference for further understanding.</p>
<p>If you have difficulty understanding the stack frame illustrated in the first
three sections of this chapter, you may consult the following resources:
Appendix B, “Procedure Call Convention,” in <em>Computer Organization and Design,
1st Edition</em> <a class="footnote-reference brackets" href="#computer-arch-interface" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>; “Run Time Memory” in a compiler
textbook; or “Function Call Sequence” and “Stack Frame” in the MIPS ABI
<a class="footnote-reference brackets" href="#abi" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>.</p>
<section id="mips-stack-frame">
<h2><a class="toc-backref" href="#id32" role="doc-backlink">MIPS Stack Frame</a><a class="headerlink" href="#mips-stack-frame" title="Permalink to this heading">¶</a></h2>
<p>The first step in designing Cpu0 function calls is deciding how to pass
arguments. There are two options:</p>
<ol class="arabic simple">
<li><p>Pass all arguments on the stack.</p></li>
<li><p>Pass arguments using registers reserved for function arguments, and place
any remaining arguments on the stack once the registers are full.</p></li>
</ol>
<p>For example, MIPS passes the first four arguments in registers <cite>$a0</cite>, <cite>$a1</cite>,
<cite>$a2</cite>, and <cite>$a3</cite>. Any additional arguments are passed on the stack.
<a class="reference internal" href="#funccall-f1"><span class="std std-numref">Fig. 41</span></a> illustrates the MIPS stack frame.</p>
<figure class="align-center" id="id20">
<span id="funccall-f1"></span><a class="reference internal image-reference" href="_images/13.png"><img alt="_images/13.png" src="_images/13.png" style="width: 344.0px; height: 265.5px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 41 </span><span class="caption-text">Mips stack frame</span><a class="headerlink" href="#id20" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>Run <code class="docutils literal notranslate"><span class="pre">llc</span> <span class="pre">-march=mips</span></code> on <code class="docutils literal notranslate"><span class="pre">ch9_1.bc</span></code>, and you will get the following result.
See the comments marked with <strong>“//”</strong>.</p>
<p class="rubric">lbdex/input/ch9_1.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">gI</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

<span class="nb">int</span> <span class="n">sum_i</span><span class="p">(</span><span class="nb">int</span> <span class="n">x1</span><span class="p">,</span> <span class="nb">int</span> <span class="n">x2</span><span class="p">,</span> <span class="nb">int</span> <span class="n">x3</span><span class="p">,</span> <span class="nb">int</span> <span class="n">x4</span><span class="p">,</span> <span class="nb">int</span> <span class="n">x5</span><span class="p">,</span> <span class="nb">int</span> <span class="n">x6</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="nb">sum</span> <span class="o">=</span> <span class="n">gI</span> <span class="o">+</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span> <span class="o">+</span> <span class="n">x3</span> <span class="o">+</span> <span class="n">x4</span> <span class="o">+</span> <span class="n">x5</span> <span class="o">+</span> <span class="n">x6</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="nb">sum</span><span class="p">;</span> 
<span class="p">}</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span> 
  <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">sum_i</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>  
  
  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-78-230:input Jonathan$ </span>clang -target mips-unknown-linux-gnu -c
<span class="go">ch9_1.cpp -emit-llvm -o ch9_1.bc</span>
<span class="gp">118-165-78-230:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llc -march=mips -relocation-model=pic -filetype=asm ch9_1.bc -o</span>
<span class="go">ch9_1.mips.s</span>
<span class="gp">118-165-78-230:input Jonathan$ </span>cat ch9_1.mips.s
<span class="go">  .section .mdebug.abi32</span>
<span class="go">  .previous</span>
<span class="go">  .file &quot;ch9_1.bc&quot;</span>
<span class="go">  .text</span>
<span class="go">  .globl  _Z5sum_iiiiiii</span>
<span class="go">  .align  2</span>
<span class="go">  .type _Z5sum_iiiiiii,@function</span>
<span class="go">  .set  nomips16                # @_Z5sum_iiiiiii</span>
<span class="go">  .ent  _Z5sum_iiiiiii</span>
<span class="go">_Z5sum_iiiiiii:</span>
<span class="go">  .cfi_startproc</span>
<span class="go">  .frame  $sp,32,$ra</span>
<span class="go">  .mask   0x00000000,0</span>
<span class="go">  .fmask  0x00000000,0</span>
<span class="go">  .set  noreorder</span>
<span class="go">  .set  nomacro</span>
<span class="go">  .set  noat</span>
<span class="gp"># </span>BB#0:
<span class="go">  addiu $sp, $sp, -32</span>
<span class="gp">$</span>tmp1:
<span class="go">  .cfi_def_cfa_offset 32</span>
<span class="go">  sw  $4, 28($sp)</span>
<span class="go">  sw  $5, 24($sp)</span>
<span class="go">  sw  $t9, 20($sp)</span>
<span class="go">  sw  $7, 16($sp)</span>
<span class="go">  lw  $1, 48($sp) // load argument 5</span>
<span class="go">  sw  $1, 12($sp)</span>
<span class="go">  lw  $1, 52($sp) // load argument 6</span>
<span class="go">  sw  $1, 8($sp)</span>
<span class="go">  lw  $2, 24($sp)</span>
<span class="go">  lw  $3, 28($sp)</span>
<span class="go">  addu  $2, $3, $2</span>
<span class="go">  lw  $3, 20($sp)</span>
<span class="go">  addu  $2, $2, $3</span>
<span class="go">  lw  $3, 16($sp)</span>
<span class="go">  addu  $2, $2, $3</span>
<span class="go">  lw  $3, 12($sp)</span>
<span class="go">  addu  $2, $2, $3</span>
<span class="go">  addu  $2, $2, $1</span>
<span class="go">  sw  $2, 4($sp)</span>
<span class="go">  jr  $ra</span>
<span class="go">  addiu $sp, $sp, 32</span>
<span class="go">  .set  at</span>
<span class="go">  .set  macro</span>
<span class="go">  .set  reorder</span>
<span class="go">  .end  _Z5sum_iiiiiii</span>
<span class="gp">$</span>tmp2:
<span class="go">  .size _Z5sum_iiiiiii, ($tmp2)-_Z5sum_iiiiiii</span>
<span class="go">  .cfi_endproc</span>

<span class="go">  .globl  main</span>
<span class="go">  .align  2</span>
<span class="go">  .type main,@function</span>
<span class="go">  .set  nomips16                # @main</span>
<span class="go">  .ent  main</span>
<span class="go">main:</span>
<span class="go">  .cfi_startproc</span>
<span class="go">  .frame  $sp,40,$ra</span>
<span class="go">  .mask   0x80000000,-4</span>
<span class="go">  .fmask  0x00000000,0</span>
<span class="go">  .set  noreorder</span>
<span class="go">  .set  nomacro</span>
<span class="go">  .set  noat</span>
<span class="gp"># </span>BB#0:
<span class="go">  lui $2, %hi(_gp_disp)</span>
<span class="go">  ori $2, $2, %lo(_gp_disp)</span>
<span class="go">  addiu $sp, $sp, -40</span>
<span class="gp">$</span>tmp5:
<span class="go">  .cfi_def_cfa_offset 40</span>
<span class="go">  sw  $ra, 36($sp)            # 4-byte Folded Spill</span>
<span class="gp">$</span>tmp6:
<span class="go">  .cfi_offset 31, -4</span>
<span class="go">  addu  $gp, $2, $25</span>
<span class="go">  sw  $zero, 32($sp)</span>
<span class="go">  addiu $1, $zero, 6</span>
<span class="go">  sw  $1, 20($sp) // Save argument 6 to 20($sp)</span>
<span class="go">  addiu $1, $zero, 5</span>
<span class="go">  sw  $1, 16($sp) // Save argument 5 to 16($sp)</span>
<span class="go">  lw  $25, %call16(_Z5sum_iiiiiii)($gp)</span>
<span class="go">  addiu $4, $zero, 1    // Pass argument 1 to $4 (=$a0)</span>
<span class="go">  addiu $5, $zero, 2    // Pass argument 2 to $5 (=$a1)</span>
<span class="go">  addiu $t9, $zero, 3</span>
<span class="go">  jalr  $25</span>
<span class="go">  addiu $7, $zero, 4</span>
<span class="go">  sw  $2, 28($sp)</span>
<span class="go">  lw  $ra, 36($sp)            # 4-byte Folded Reload</span>
<span class="go">  jr  $ra</span>
<span class="go">  addiu $sp, $sp, 40</span>
<span class="go">  .set  at</span>
<span class="go">  .set  macro</span>
<span class="go">  .set  reorder</span>
<span class="go">  .end  main</span>
<span class="gp">$</span>tmp7:
<span class="go">  .size main, ($tmp7)-main</span>
<span class="go">  .cfi_endproc</span>
</pre></div>
</div>
<p>From the MIPS assembly code generated above, we can see that the first four
arguments are saved in registers <cite>$a0</cite> to <cite>$a3</cite>, and the last two arguments
are saved at memory locations <cite>16($sp)</cite> and <cite>20($sp)</cite>.</p>
<p><a class="reference internal" href="#funccall-f2"><span class="std std-numref">Fig. 42</span></a> shows the location of the arguments in the example code
<cite>ch9_1.cpp</cite>.</p>
<p>In the <cite>sum_i()</cite> function, argument 5 is loaded from <cite>48($sp)</cite> because it was
stored at <cite>16($sp)</cite> in the <cite>main()</cite> function. Since the stack size of
<cite>sum_i()</cite> is 32, the address of the incoming argument 5 is calculated as
<cite>16 + 32 = 48($sp)</cite>.</p>
<figure class="align-center" id="id21">
<span id="funccall-f2"></span><a class="reference internal image-reference" href="_images/21.png"><img alt="_images/21.png" src="_images/21.png" style="width: 370.0px; height: 288.5px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 42 </span><span class="caption-text">Mips arguments location in stack frame</span><a class="headerlink" href="#id21" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>The document <em>007-2418-003.pdf</em> referenced in <a class="footnote-reference brackets" href="#mipsasm" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> is the MIPS assembly
language manual. The MIPS Application Binary Interface, referenced in <a class="footnote-reference brackets" href="#abi" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>,
includes the diagram shown in <a class="reference internal" href="#funccall-f1"><span class="std std-numref">Fig. 41</span></a>.</p>
</section>
<section id="load-incoming-arguments-from-stack-frame">
<h2><a class="toc-backref" href="#id33" role="doc-backlink">Load Incoming Arguments from Stack Frame</a><a class="headerlink" href="#load-incoming-arguments-from-stack-frame" title="Permalink to this heading">¶</a></h2>
<p>As discussed in the previous section, supporting function calls requires
implementing an argument-passing mechanism using the stack frame.</p>
<p>Before proceeding with the implementation, let’s run the old version of the
code in <cite>Chapter8_2/</cite> with <cite>ch9_1.cpp</cite> and observe what happens.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-79-31:input Jonathan$ </span>/Users/Jonathan/llvm/test/
<span class="go">build/bin/llc -march=cpu0 -relocation-model=pic -filetype=asm</span>
<span class="go">ch9_1.bc -o ch9_1.cpu0.s</span>
<span class="go">Assertion failed: (InVals.size() == Ins.size() &amp;&amp; &quot;LowerFormalArguments didn&#39;t</span>
<span class="go">emit the correct number of values!&quot;), function LowerArguments, file /Users/</span>
<span class="go">Jonathan/llvm/test/llvm/lib/CodeGen/SelectionDAG/</span>
<span class="go">SelectionDAGBuilder.cpp, ...</span>
<span class="go">...</span>
<span class="go">0.  Program arguments: /Users/Jonathan/llvm/test/build/</span>
<span class="go">bin/llc -march=cpu0 -relocation-model=pic -filetype=asm ch9_1.bc -o</span>
<span class="go">ch9_1.cpu0.s</span>
<span class="go">1.  Running pass &#39;Function Pass Manager&#39; on module &#39;ch9_1.bc&#39;.</span>
<span class="go">2.  Running pass &#39;CPU0 DAG-&gt;DAG Pattern Instruction Selection&#39; on function</span>
<span class="go">&#39;@_Z5sum_iiiiiii&#39;</span>
<span class="go">Illegal instruction: 4</span>
</pre></div>
</div>
<p>Since <cite>Chapter8_2/</cite> defines <cite>LowerFormalArguments()</cite> with an empty body, we
receive the error messages shown above.</p>
<p>Before implementing <cite>LowerFormalArguments()</cite>, we must first decide how to pass
arguments in a function call.</p>
<p>For demonstration purposes, Cpu0 passes the first two arguments in registers by
default, which corresponds to the setting <code class="docutils literal notranslate"><span class="pre">llc</span> <span class="pre">-cpu0-s32-calls=false</span></code>.</p>
<p>When using <code class="docutils literal notranslate"><span class="pre">llc</span> <span class="pre">-cpu0-s32-calls=true</span></code>, Cpu0 passes all its arguments on the
stack.</p>
<p>The function <cite>LowerFormalArguments()</cite> is responsible for creating the incoming
arguments. We define it as follows:</p>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0ISelLowering.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">class</span> <span class="nc">Cpu0TargetLowering</span> <span class="p">:</span> <span class="n">public</span> <span class="n">TargetLowering</span>  <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="o">///</span> <span class="n">Cpu0CC</span> <span class="o">-</span> <span class="n">This</span> <span class="k">class</span> <span class="nc">provides</span> <span class="n">methods</span> <span class="n">used</span> <span class="n">to</span> <span class="n">analyze</span> <span class="n">formal</span> <span class="ow">and</span> <span class="n">call</span>
    <span class="o">///</span> <span class="n">arguments</span> <span class="ow">and</span> <span class="n">inquire</span> <span class="n">about</span> <span class="n">calling</span> <span class="n">convention</span> <span class="n">information</span><span class="o">.</span>
    <span class="k">class</span> <span class="nc">Cpu0CC</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>      <span class="n">void</span> <span class="n">analyzeFormalArguments</span><span class="p">(</span><span class="n">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="p">::</span><span class="n">InputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ins</span><span class="p">,</span>
                                  <span class="nb">bool</span> <span class="n">IsSoftFloat</span><span class="p">,</span>
                                  <span class="n">Function</span><span class="p">::</span><span class="n">const_arg_iterator</span> <span class="n">FuncArg</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>      /// regSize - Size (in number of bits) of integer registers.
      unsigned regSize() const { return IsO32 ? 4 : 4; }
      /// numIntArgRegs - Number of integer registers available for calls.
      unsigned numIntArgRegs() const;
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>      <span class="o">///</span> <span class="n">Return</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">array</span> <span class="n">of</span> <span class="n">integer</span> <span class="n">argument</span> <span class="n">registers</span><span class="o">.</span>
      <span class="n">const</span> <span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">MCPhysReg</span><span class="o">&gt;</span> <span class="n">intArgRegs</span><span class="p">()</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>      <span class="n">void</span> <span class="n">handleByValArg</span><span class="p">(</span><span class="n">unsigned</span> <span class="n">ValNo</span><span class="p">,</span> <span class="n">MVT</span> <span class="n">ValVT</span><span class="p">,</span> <span class="n">MVT</span> <span class="n">LocVT</span><span class="p">,</span>
                          <span class="n">CCValAssign</span><span class="p">::</span><span class="n">LocInfo</span> <span class="n">LocInfo</span><span class="p">,</span>
                          <span class="n">ISD</span><span class="p">::</span><span class="n">ArgFlagsTy</span> <span class="n">ArgFlags</span><span class="p">);</span>

      <span class="o">///</span> <span class="n">useRegsForByval</span> <span class="o">-</span> <span class="n">Returns</span> <span class="n">true</span> <span class="k">if</span> <span class="n">the</span> <span class="n">calling</span> <span class="n">convention</span> <span class="n">allows</span> <span class="n">the</span>
      <span class="o">///</span> <span class="n">use</span> <span class="n">of</span> <span class="n">registers</span> <span class="n">to</span> <span class="k">pass</span> <span class="n">byval</span> <span class="n">arguments</span><span class="o">.</span>
      <span class="nb">bool</span> <span class="n">useRegsForByval</span><span class="p">()</span> <span class="n">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">CallConv</span> <span class="o">!=</span> <span class="n">CallingConv</span><span class="p">::</span><span class="n">Fast</span><span class="p">;</span> <span class="p">}</span>

      <span class="o">///</span> <span class="n">Return</span> <span class="n">the</span> <span class="n">function</span> <span class="n">that</span> <span class="n">analyzes</span> <span class="n">fixed</span> <span class="n">argument</span> <span class="nb">list</span> <span class="n">functions</span><span class="o">.</span>
      <span class="n">llvm</span><span class="p">::</span><span class="n">CCAssignFn</span> <span class="o">*</span><span class="n">fixedArgFn</span><span class="p">()</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>      <span class="n">void</span> <span class="n">allocateRegs</span><span class="p">(</span><span class="n">ByValArgInfo</span> <span class="o">&amp;</span><span class="n">ByVal</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">ByValSize</span><span class="p">,</span>
                        <span class="n">unsigned</span> <span class="n">Align</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">};</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="o">///</span> <span class="n">isEligibleForTailCallOptimization</span> <span class="o">-</span> <span class="n">Check</span> <span class="n">whether</span> <span class="n">the</span> <span class="n">call</span> <span class="ow">is</span> <span class="n">eligible</span>
    <span class="o">///</span> <span class="k">for</span> <span class="n">tail</span> <span class="n">call</span> <span class="n">optimization</span><span class="o">.</span>
    <span class="n">virtual</span> <span class="nb">bool</span>
    <span class="n">isEligibleForTailCallOptimization</span><span class="p">(</span><span class="n">const</span> <span class="n">Cpu0CC</span> <span class="o">&amp;</span><span class="n">Cpu0CCInfo</span><span class="p">,</span>
                                      <span class="n">unsigned</span> <span class="n">NextStackOffset</span><span class="p">,</span>
                                      <span class="n">const</span> <span class="n">Cpu0FunctionInfo</span><span class="o">&amp;</span> <span class="n">FI</span><span class="p">)</span> <span class="n">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="o">///</span> <span class="n">copyByValArg</span> <span class="o">-</span> <span class="n">Copy</span> <span class="n">argument</span> <span class="n">registers</span> <span class="n">which</span> <span class="n">were</span> <span class="n">used</span> <span class="n">to</span> <span class="k">pass</span> <span class="n">a</span> <span class="n">byval</span>
    <span class="o">///</span> <span class="n">argument</span> <span class="n">to</span> <span class="n">the</span> <span class="n">stack</span><span class="o">.</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">stack</span> <span class="n">frame</span> <span class="nb">object</span> <span class="k">for</span> <span class="n">the</span> <span class="n">byval</span>
    <span class="o">///</span> <span class="n">argument</span><span class="o">.</span>
    <span class="n">void</span> <span class="n">copyByValRegs</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">const</span> <span class="n">SDLoc</span> <span class="o">&amp;</span><span class="n">DL</span><span class="p">,</span>
                       <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">OutChains</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span>
                       <span class="n">const</span> <span class="n">ISD</span><span class="p">::</span><span class="n">ArgFlagsTy</span> <span class="o">&amp;</span><span class="n">Flags</span><span class="p">,</span>
                       <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">,</span>
                       <span class="n">const</span> <span class="n">Argument</span> <span class="o">*</span><span class="n">FuncArg</span><span class="p">,</span>
                       <span class="n">const</span> <span class="n">Cpu0CC</span> <span class="o">&amp;</span><span class="n">CC</span><span class="p">,</span> <span class="n">const</span> <span class="n">ByValArgInfo</span> <span class="o">&amp;</span><span class="n">ByVal</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">SDValue</span> <span class="n">LowerCall</span><span class="p">(</span><span class="n">TargetLowering</span><span class="p">::</span><span class="n">CallLoweringInfo</span> <span class="o">&amp;</span><span class="n">CLI</span><span class="p">,</span>
                      <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0ISelLowering.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">addLiveIn</span> <span class="o">-</span> <span class="n">This</span> <span class="n">helper</span> <span class="n">function</span> <span class="n">adds</span> <span class="n">the</span> <span class="n">specified</span> <span class="n">physical</span> <span class="n">register</span> <span class="n">to</span> <span class="n">the</span>
<span class="o">//</span> <span class="n">MachineFunction</span> <span class="k">as</span> <span class="n">a</span> <span class="n">live</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span>  <span class="n">It</span> <span class="n">also</span> <span class="n">creates</span> <span class="n">a</span> <span class="n">corresponding</span>
<span class="o">//</span> <span class="n">virtual</span> <span class="n">register</span> <span class="k">for</span> <span class="n">it</span><span class="o">.</span>
<span class="n">static</span> <span class="n">unsigned</span>
<span class="n">addLiveIn</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">PReg</span><span class="p">,</span> <span class="n">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span><span class="n">RC</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">unsigned</span> <span class="n">VReg</span> <span class="o">=</span> <span class="n">MF</span><span class="o">.</span><span class="n">getRegInfo</span><span class="p">()</span><span class="o">.</span><span class="n">createVirtualRegister</span><span class="p">(</span><span class="n">RC</span><span class="p">);</span>
  <span class="n">MF</span><span class="o">.</span><span class="n">getRegInfo</span><span class="p">()</span><span class="o">.</span><span class="n">addLiveIn</span><span class="p">(</span><span class="n">PReg</span><span class="p">,</span> <span class="n">VReg</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">VReg</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>//===----------------------------------------------------------------------===//
// TODO: Implement a generic logic using tblgen that can support this.
// Cpu0 32 ABI rules:
// ---
//===----------------------------------------------------------------------===//

// Passed in stack only.
static bool CC_Cpu0S32(unsigned ValNo, MVT ValVT, MVT LocVT,
                       CCValAssign::LocInfo LocInfo, ISD::ArgFlagsTy ArgFlags,
                       CCState &amp;State) {
  // Do not process byval args here.
  if (ArgFlags.isByVal())
    return true;

  // Promote i8 and i16
  if (LocVT == MVT::i8 || LocVT == MVT::i16) {
    LocVT = MVT::i32;
    if (ArgFlags.isSExt())
      LocInfo = CCValAssign::SExt;
    else if (ArgFlags.isZExt())
      LocInfo = CCValAssign::ZExt;
    else
      LocInfo = CCValAssign::AExt;
  }

  Align OrigAlign = ArgFlags.getNonZeroOrigAlign();
  unsigned Offset = State.AllocateStack(ValVT.getSizeInBits() &gt;&gt; 3,
                                        OrigAlign);
  State.addLoc(CCValAssign::getMem(ValNo, ValVT, Offset, LocVT, LocInfo));
  return false;
}

// Passed first two i32 arguments in registers and others in stack.
static bool CC_Cpu0O32(unsigned ValNo, MVT ValVT, MVT LocVT,
                       CCValAssign::LocInfo LocInfo, ISD::ArgFlagsTy ArgFlags,
                       CCState &amp;State) {
  static const MCPhysReg IntRegs[] = { Cpu0::A0, Cpu0::A1 };

  // Do not process byval args here.
  if (ArgFlags.isByVal())
    return true;

  // Promote i8 and i16
  if (LocVT == MVT::i8 || LocVT == MVT::i16) {
    LocVT = MVT::i32;
    if (ArgFlags.isSExt())
      LocInfo = CCValAssign::SExt;
    else if (ArgFlags.isZExt())
      LocInfo = CCValAssign::ZExt;
    else
      LocInfo = CCValAssign::AExt;
  }

  unsigned Reg;

  // f32 and f64 are allocated in A0, A1 when either of the following
  // is true: function is vararg, argument is 3rd or higher, there is previous
  // argument which is not f32 or f64.
  bool AllocateFloatsInIntReg = true;
  Align OrigAlign = ArgFlags.getNonZeroOrigAlign();
  bool isI64 = (ValVT == MVT::i32 &amp;&amp; OrigAlign == 8);

  if (ValVT == MVT::i32 || (ValVT == MVT::f32 &amp;&amp; AllocateFloatsInIntReg)) {
    Reg = State.AllocateReg(IntRegs);
    // If this is the first part of an i64 arg,
    // the allocated register must be A0.
    if (isI64 &amp;&amp; (Reg == Cpu0::A1))
      Reg = State.AllocateReg(IntRegs);
    LocVT = MVT::i32;
  } else if (ValVT == MVT::f64 &amp;&amp; AllocateFloatsInIntReg) {
    // Allocate int register. If first
    // available register is Cpu0::A1, shadow it too.
    Reg = State.AllocateReg(IntRegs);
    if (Reg == Cpu0::A1)
      Reg = State.AllocateReg(IntRegs);
    State.AllocateReg(IntRegs);
    LocVT = MVT::i32;
  } else
    llvm_unreachable(&quot;Cannot handle this ValVT.&quot;);

  if (!Reg) {
    unsigned Offset = State.AllocateStack(ValVT.getSizeInBits() &gt;&gt; 3,
                                          Align(OrigAlign));
    State.addLoc(CCValAssign::getMem(ValNo, ValVT, Offset, LocVT, LocInfo));
  } else
    State.addLoc(CCValAssign::getReg(ValNo, ValVT, Reg, LocVT, LocInfo));

  return false;
}
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">//</span>                  <span class="n">Call</span> <span class="n">Calling</span> <span class="n">Convention</span> <span class="n">Implementation</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="n">static</span> <span class="n">const</span> <span class="n">MCPhysReg</span> <span class="n">O32IntRegs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="n">Cpu0</span><span class="p">::</span><span class="n">A0</span><span class="p">,</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">A1</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span><span class="nd">@LowerCall</span> <span class="p">{</span>
<span class="o">///</span> <span class="n">LowerCall</span> <span class="o">-</span> <span class="n">functions</span> <span class="n">arguments</span> <span class="n">are</span> <span class="n">copied</span> <span class="kn">from</span> <span class="nn">virtual</span> <span class="n">regs</span> <span class="n">to</span>
<span class="o">///</span> <span class="p">(</span><span class="n">physical</span> <span class="n">regs</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">stack</span> <span class="n">frame</span><span class="p">),</span> <span class="n">CALLSEQ_START</span> <span class="ow">and</span> <span class="n">CALLSEQ_END</span> <span class="n">are</span> <span class="n">emitted</span><span class="o">.</span>
<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">LowerCall</span><span class="p">(</span><span class="n">TargetLowering</span><span class="p">::</span><span class="n">CallLoweringInfo</span> <span class="o">&amp;</span><span class="n">CLI</span><span class="p">,</span>
                              <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span><span class="nd">@LowerCall</span> <span class="p">{</span>
<span class="o">///</span> <span class="n">LowerCall</span> <span class="o">-</span> <span class="n">functions</span> <span class="n">arguments</span> <span class="n">are</span> <span class="n">copied</span> <span class="kn">from</span> <span class="nn">virtual</span> <span class="n">regs</span> <span class="n">to</span>
<span class="o">///</span> <span class="p">(</span><span class="n">physical</span> <span class="n">regs</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">stack</span> <span class="n">frame</span><span class="p">),</span> <span class="n">CALLSEQ_START</span> <span class="ow">and</span> <span class="n">CALLSEQ_END</span> <span class="n">are</span> <span class="n">emitted</span><span class="o">.</span>
<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">LowerCall</span><span class="p">(</span><span class="n">TargetLowering</span><span class="p">::</span><span class="n">CallLoweringInfo</span> <span class="o">&amp;</span><span class="n">CLI</span><span class="p">,</span>
                              <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">return</span> <span class="n">CLI</span><span class="o">.</span><span class="n">Chain</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>//===----------------------------------------------------------------------===//

//@LowerFormalArguments {
/// LowerFormalArguments - transform physical registers into virtual registers
/// and generate load operations for arguments places on the stack.
SDValue
Cpu0TargetLowering::LowerFormalArguments(SDValue Chain,
                                         CallingConv::ID CallConv,
                                         bool IsVarArg,
                                         const SmallVectorImpl&lt;ISD::InputArg&gt; &amp;Ins,
                                         const SDLoc &amp;DL, SelectionDAG &amp;DAG,
                                         SmallVectorImpl&lt;SDValue&gt; &amp;InVals)
                                          const {
  MachineFunction &amp;MF = DAG.getMachineFunction();
  MachineFrameInfo &amp;MFI = MF.getFrameInfo();
  Cpu0FunctionInfo *Cpu0FI = MF.getInfo&lt;Cpu0FunctionInfo&gt;();

  Cpu0FI-&gt;setVarArgsFrameIndex(0);

  // Assign locations to all of the incoming arguments.
  SmallVector&lt;CCValAssign, 16&gt; ArgLocs;
  CCState CCInfo(CallConv, IsVarArg, DAG.getMachineFunction(),
                 ArgLocs, *DAG.getContext());
  Cpu0CC Cpu0CCInfo(CallConv, ABI.IsO32(), 
                    CCInfo);

  const Function &amp;Func = DAG.getMachineFunction().getFunction();
  Function::const_arg_iterator FuncArg = Func.arg_begin();

  bool UseSoftFloat = Subtarget.abiUsesSoftFloat();

  Cpu0CCInfo.analyzeFormalArguments(Ins, UseSoftFloat, FuncArg);
  Cpu0FI-&gt;setFormalArgInfo(CCInfo.getNextStackOffset(),
                           Cpu0CCInfo.hasByValArg());

  // Used with vargs to acumulate store chains.
  std::vector&lt;SDValue&gt; OutChains;

  unsigned CurArgIdx = 0;
  Cpu0CC::byval_iterator ByValArg = Cpu0CCInfo.byval_begin();

  //@2 {
  for (unsigned i = 0, e = ArgLocs.size(); i != e; ++i) {
  //@2 }
    CCValAssign &amp;VA = ArgLocs[i];
    if (Ins[i].isOrigArg()) {
      std::advance(FuncArg, Ins[i].getOrigArgIndex() - CurArgIdx);
      CurArgIdx = Ins[i].getOrigArgIndex();
    }
    EVT ValVT = VA.getValVT();
    ISD::ArgFlagsTy Flags = Ins[i].Flags;
    bool IsRegLoc = VA.isRegLoc();

    //@byval pass {
    if (Flags.isByVal()) {
      assert(Flags.getByValSize() &amp;&amp;
             &quot;ByVal args of size 0 should have been ignored by front-end.&quot;);
      assert(ByValArg != Cpu0CCInfo.byval_end());
      copyByValRegs(Chain, DL, OutChains, DAG, Flags, InVals, &amp;*FuncArg,
                    Cpu0CCInfo, *ByValArg);
      ++ByValArg;
      continue;
    }
    //@byval pass }
    // Arguments stored on registers
    if (ABI.IsO32() &amp;&amp; IsRegLoc) {
      MVT RegVT = VA.getLocVT();
      unsigned ArgReg = VA.getLocReg();
      const TargetRegisterClass *RC = getRegClassFor(RegVT);

      // Transform the arguments stored on
      // physical registers into virtual ones
      unsigned Reg = addLiveIn(DAG.getMachineFunction(), ArgReg, RC);
      SDValue ArgValue = DAG.getCopyFromReg(Chain, DL, Reg, RegVT);

      // If this is an 8 or 16-bit value, it has been passed promoted
      // to 32 bits.  Insert an assert[sz]ext to capture this, then
      // truncate to the right size.
      if (VA.getLocInfo() != CCValAssign::Full) {
        unsigned Opcode = 0;
        if (VA.getLocInfo() == CCValAssign::SExt)
          Opcode = ISD::AssertSext;
        else if (VA.getLocInfo() == CCValAssign::ZExt)
          Opcode = ISD::AssertZext;
        if (Opcode)
          ArgValue = DAG.getNode(Opcode, DL, RegVT, ArgValue,
                                 DAG.getValueType(ValVT));
        ArgValue = DAG.getNode(ISD::TRUNCATE, DL, ValVT, ArgValue);
      }

      // Handle floating point arguments passed in integer registers.
      if ((RegVT == MVT::i32 &amp;&amp; ValVT == MVT::f32) ||
          (RegVT == MVT::i64 &amp;&amp; ValVT == MVT::f64))
        ArgValue = DAG.getNode(ISD::BITCAST, DL, ValVT, ArgValue);
      InVals.push_back(ArgValue);
    } else { // VA.isRegLoc()
      MVT LocVT = VA.getLocVT();

      // sanity check
      assert(VA.isMemLoc());

      // The stack pointer offset is relative to the caller stack frame.
      int FI = MFI.CreateFixedObject(ValVT.getSizeInBits()/8,
                                      VA.getLocMemOffset(), true);

      // Create load nodes to retrieve arguments from the stack
      SDValue FIN = DAG.getFrameIndex(FI, getPointerTy(DAG.getDataLayout()));
      SDValue Load = DAG.getLoad(
          LocVT, DL, Chain, FIN,
          MachinePointerInfo::getFixedStack(DAG.getMachineFunction(), FI));
      InVals.push_back(Load);
      OutChains.push_back(Load.getValue(1));
    }
  }

//@Ordinary struct type: 1 {
  for (unsigned i = 0, e = ArgLocs.size(); i != e; ++i) {
    // The cpu0 ABIs for returning structs by value requires that we copy
    // the sret argument into $v0 for the return. Save the argument into
    // a virtual register so that we can access it from the return points.
    if (Ins[i].Flags.isSRet()) {
      unsigned Reg = Cpu0FI-&gt;getSRetReturnReg();
      if (!Reg) {
        Reg = MF.getRegInfo().createVirtualRegister(
            getRegClassFor(MVT::i32));
        Cpu0FI-&gt;setSRetReturnReg(Reg);
      }
      SDValue Copy = DAG.getCopyToReg(DAG.getEntryNode(), DL, Reg, InVals[i]);
      Chain = DAG.getNode(ISD::TokenFactor, DL, MVT::Other, Copy, Chain);
      break;
    }
  }
//@Ordinary struct type: 1 }

  // All stores are grouped in one node to allow the matching between
  // the size of Ins and InVals. This only happens when on varg functions
  if (!OutChains.empty()) {
    OutChains.push_back(Chain);
    Chain = DAG.getNode(ISD::TokenFactor, DL, MVT::Other, OutChains);
  }

  return Chain;
}
// @LowerFormalArguments }

//===----------------------------------------------------------------------===//
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>void Cpu0TargetLowering::Cpu0CC::
analyzeFormalArguments(const SmallVectorImpl&lt;ISD::InputArg&gt; &amp;Args,
                       bool IsSoftFloat, Function::const_arg_iterator FuncArg) {
  unsigned NumArgs = Args.size();
  llvm::CCAssignFn *FixedFn = fixedArgFn();
  unsigned CurArgIdx = 0;

  for (unsigned I = 0; I != NumArgs; ++I) {
    MVT ArgVT = Args[I].VT;
    ISD::ArgFlagsTy ArgFlags = Args[I].Flags;
    if (Args[I].isOrigArg()) {
      std::advance(FuncArg, Args[I].getOrigArgIndex() - CurArgIdx);
      CurArgIdx = Args[I].getOrigArgIndex();
    }
    CurArgIdx = Args[I].OrigArgIndex;

    if (ArgFlags.isByVal()) {
      handleByValArg(I, ArgVT, ArgVT, CCValAssign::Full, ArgFlags);
      continue;
    }

    MVT RegVT = getRegVT(ArgVT, IsSoftFloat);

    if (!FixedFn(I, ArgVT, RegVT, CCValAssign::Full, ArgFlags, CCInfo))
      continue;

#ifndef NDEBUG
    dbgs() &lt;&lt; &quot;Formal Arg #&quot; &lt;&lt; I &lt;&lt; &quot; has unhandled type &quot;
           &lt;&lt; EVT(ArgVT).getEVTString();
#endif
    llvm_unreachable(nullptr);
  }
}
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>void Cpu0TargetLowering::Cpu0CC::handleByValArg(unsigned ValNo, MVT ValVT,
                                                MVT LocVT,
                                                CCValAssign::LocInfo LocInfo,
                                                ISD::ArgFlagsTy ArgFlags) {
  assert(ArgFlags.getByValSize() &amp;&amp; &quot;Byval argument&#39;s size shouldn&#39;t be 0.&quot;);

  struct ByValArgInfo ByVal;
  unsigned RegSize = regSize();
  unsigned ByValSize = alignTo(ArgFlags.getByValSize(), RegSize);
  Align Alignment = std::min(std::max(ArgFlags.getNonZeroByValAlign(), Align(RegSize)),
                            Align(RegSize * 2));

  if (useRegsForByval())
    allocateRegs(ByVal, ByValSize, Alignment.value());

  // Allocate space on caller&#39;s stack.
  ByVal.Address = CCInfo.AllocateStack(ByValSize - RegSize * ByVal.NumRegs,
                                       Alignment);
  CCInfo.addLoc(CCValAssign::getMem(ValNo, ValVT, ByVal.Address, LocVT,
                                    LocInfo));
  ByValArgs.push_back(ByVal);
}

unsigned Cpu0TargetLowering::Cpu0CC::numIntArgRegs() const {
  return IsO32 ? array_lengthof(O32IntRegs) : 0;
}
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">MCPhysReg</span><span class="o">&gt;</span> <span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">Cpu0CC</span><span class="p">::</span><span class="n">intArgRegs</span><span class="p">()</span> <span class="n">const</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">makeArrayRef</span><span class="p">(</span><span class="n">O32IntRegs</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">llvm</span><span class="p">::</span><span class="n">CCAssignFn</span> <span class="o">*</span><span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">Cpu0CC</span><span class="p">::</span><span class="n">fixedArgFn</span><span class="p">()</span> <span class="n">const</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">IsO32</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">CC_Cpu0O32</span><span class="p">;</span>
  <span class="k">else</span> <span class="o">//</span> <span class="n">IsS32</span>
    <span class="k">return</span> <span class="n">CC_Cpu0S32</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>void Cpu0TargetLowering::Cpu0CC::allocateRegs(ByValArgInfo &amp;ByVal,
                                              unsigned ByValSize,
                                              unsigned Align) {
  unsigned RegSize = regSize(), NumIntArgRegs = numIntArgRegs();
  const ArrayRef&lt;MCPhysReg&gt; IntArgRegs = intArgRegs();
  assert(!(ByValSize % RegSize) &amp;&amp; !(Align % RegSize) &amp;&amp;
         &quot;Byval argument&#39;s size and alignment should be a multiple of&quot;
         &quot;RegSize.&quot;);

  ByVal.FirstIdx = CCInfo.getFirstUnallocated(IntArgRegs);

  // If Align &gt; RegSize, the first arg register must be even.
  if ((Align &gt; RegSize) &amp;&amp; (ByVal.FirstIdx % 2)) {
    CCInfo.AllocateReg(IntArgRegs[ByVal.FirstIdx]);
    ++ByVal.FirstIdx;
  }

  // Mark the registers allocated.
  for (unsigned I = ByVal.FirstIdx; ByValSize &amp;&amp; (I &lt; NumIntArgRegs);
       ByValSize -= RegSize, ++I, ++ByVal.NumRegs)
    CCInfo.AllocateReg(IntArgRegs[I]);
}
</pre></div>
</div>
<p>As reviewed in the section “Global variable” <a class="footnote-reference brackets" href="#secglobal" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a>, we handled global
variable translation by first creating the IR DAG in <cite>LowerGlobalAddress()</cite>,
and then completing instruction selection based on the corresponding machine
instruction DAGs in <cite>Cpu0InstrInfo.td</cite>.</p>
<p><cite>LowerGlobalAddress()</cite> is called when <cite>llc</cite> encounters a global variable
access. Similarly, <cite>LowerFormalArguments()</cite> is called when entering a function.</p>
<p>Before entering the <strong>“for loop”</strong>, it gathers incoming argument information
using <cite>CCInfo(CallConv, …, ArgLocs, …)</cite>.</p>
<p>In <cite>ch9_1.cpp</cite>, the function <cite>sum_i(…)</cite> has 6 arguments. Thus,
<cite>ArgLocs.size()</cite> is 6, with each argument’s information stored in <cite>ArgLocs[i]</cite>.</p>
<ul class="simple">
<li><p>If <cite>VA.isRegLoc()</cite> returns true, the argument is passed via register.</p></li>
<li><p>If <cite>VA.isMemLoc()</cite> returns true, the argument is passed via memory stack.</p></li>
</ul>
<p>For register-passed arguments, the register is marked as “live-in”, and the
value is copied directly from the register.</p>
<p>For stack-passed arguments, a stack offset is created for the frame index
object. A load node is then created using this offset and added to the <cite>InVals</cite>
vector.</p>
<p>When using <code class="docutils literal notranslate"><span class="pre">llc</span> <span class="pre">-cpu0-s32-calls=false</span></code>, the first two arguments are passed in
registers, and the remaining arguments are passed in the stack frame.</p>
<p>When using <code class="docutils literal notranslate"><span class="pre">llc</span> <span class="pre">-cpu0-s32-calls=true</span></code>, all arguments are passed in the stack
frame.</p>
<p>Before handling arguments, <cite>analyzeFormalArguments()</cite> is called. Inside it,
<cite>fixedArgFn()</cite> is used to return the function pointer to either
<cite>CC_Cpu0O32()</cite> or <cite>CC_Cpu0S32()</cite>.</p>
<p><cite>ArgFlags.isByVal()</cite> will be true for “struct pointer byval” arguments, such as
<cite>%struct.S* byval</cite> in <cite>tailcall.ll</cite>.</p>
<p>With <code class="docutils literal notranslate"><span class="pre">llc</span> <span class="pre">-cpu0-s32-calls=false</span></code>, the stack offset begins at 8 (to allow space
in case argument registers are spilled). With <code class="docutils literal notranslate"><span class="pre">llc</span> <span class="pre">-cpu0-s32-calls=true</span></code>, the
stack offset begins at 0.</p>
<p>For example, when running <cite>ch9_1.cpp</cite> with <code class="docutils literal notranslate"><span class="pre">llc</span> <span class="pre">-cpu0-s32-calls=true</span></code>
(memory stack only), <cite>LowerFormalArguments()</cite> will be called twice:</p>
<ul class="simple">
<li><p>First, for <cite>sum_i()</cite>, it will create six load DAGs for the six incoming
arguments.</p></li>
<li><p>Second, for <cite>main()</cite>, no load DAG is created, as there are no incoming
arguments.</p></li>
</ul>
<p>In addition to <cite>LowerFormalArguments()</cite>, we use
<cite>loadRegFromStackSlot()</cite> (defined in an earlier chapter) to generate the
machine instruction <strong>“ld $r, offset($sp)”</strong>, which loads arguments from the
stack frame.</p>
<p><cite>GetMemOperand(…, FI, …)</cite> returns the memory location of the frame index
variable, representing the offset.</p>
<p>For the input <cite>ch9_incoming.cpp</cite> shown below, <cite>LowerFormalArguments()</cite> will
generate the red-boxed DAG nodes illustrated in <a class="reference internal" href="#funccall-f-incoming-arg1"><span class="std std-numref">Fig. 43</span></a>
and <a class="reference internal" href="#funccall-f-incoming-arg2"><span class="std std-numref">Fig. 44</span></a>, corresponding to
<code class="docutils literal notranslate"><span class="pre">llc</span> <span class="pre">-cpu0-s32-calls=true</span></code> and <code class="docutils literal notranslate"><span class="pre">llc</span> <span class="pre">-cpu0-s32-calls=false</span></code>, respectively.</p>
<p>The root node at the bottom is created by:</p>
<p class="rubric">lbdex/input/ch9_incoming.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">sum_i</span><span class="p">(</span><span class="nb">int</span> <span class="n">x1</span><span class="p">,</span> <span class="nb">int</span> <span class="n">x2</span><span class="p">,</span> <span class="nb">int</span> <span class="n">x3</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="nb">sum</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span> <span class="o">+</span> <span class="n">x3</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="nb">sum</span><span class="p">;</span> 
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>clang -O3 -target mips-unknown-linux-gnu -c
<span class="go">ch9_incoming.cpp -emit-llvm -o ch9_incoming.bc</span>
<span class="gp">JonathantekiiMac:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llvm-dis ch9_incoming.bc -o -</span>
<span class="go">...</span>
<span class="go">define i32 @_Z5sum_iiii(i32 %x1, i32 %x2, i32 %x3) #0 {</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> add nsw i32 %x2, %x1
<span class="gp">  %</span><span class="nv">2</span> <span class="o">=</span> add nsw i32 %1, %x3
<span class="go">  ret i32 %2</span>
<span class="go">}</span>
</pre></div>
</div>
<figure class="align-default" id="id22">
<span id="funccall-f-incoming-arg1"></span><div class="graphviz"><img src="_images/graphviz-ab08690ee159b82795ec88285ab620a0d7581136.png" alt="digraph &quot;dag-combine1 input for _Z5sum_iiii:&quot; {
	rankdir=&quot;BT&quot;;
//	label=&quot;Incoming arguments DAG created for ch9_incoming.cpp with -cpu0-s32-calls=true&quot;;

  subgraph cluster_0 {
    fontcolor=red;
    fontsize=24;
    label = &quot;LowerFormalArguments&quot;;
	Node0x102f0dbe0 [shape=record,shape=Mrecord,label=&quot;{EntryToken|t0|{&lt;d0&gt;ch}}&quot;];
	Node0x10304e800 [shape=record,shape=Mrecord,label=&quot;{FrameIndex\&lt;-1\&gt;|t1|{&lt;d0&gt;i32}}&quot;];
	Node0x10304e870 [shape=record,shape=Mrecord,label=&quot;{undef|t2|{&lt;d0&gt;i32}}&quot;];
	Node0x10304e8e0 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1|&lt;s2&gt;2}|load\&lt;LD4[FixedStack-1]\&gt;|t3|{&lt;d0&gt;i32|&lt;d1&gt;ch}}&quot;];
	Node0x10304e8e0:s0 -&gt; Node0x102f0dbe0:d0[color=blue,style=dashed];
	Node0x10304e8e0:s1 -&gt; Node0x10304e800:d0;
	Node0x10304e8e0:s2 -&gt; Node0x10304e870:d0;
	Node0x10304e950 [shape=record,shape=Mrecord,label=&quot;{FrameIndex\&lt;-2\&gt;|t4|{&lt;d0&gt;i32}}&quot;];
	Node0x10304e9c0 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1|&lt;s2&gt;2}|load\&lt;LD4[FixedStack-2]\&gt;|t5|{&lt;d0&gt;i32|&lt;d1&gt;ch}}&quot;];
	Node0x10304e9c0:s0 -&gt; Node0x102f0dbe0:d0[color=blue,style=dashed];
	Node0x10304e9c0:s1 -&gt; Node0x10304e950:d0;
	Node0x10304e9c0:s2 -&gt; Node0x10304e870:d0;
	Node0x10304ea30 [shape=record,shape=Mrecord,label=&quot;{FrameIndex\&lt;-3\&gt;|t6|{&lt;d0&gt;i32}}&quot;];
	Node0x10304eaa0 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1|&lt;s2&gt;2}|load\&lt;LD4[FixedStack-3]\&gt;|t7|{&lt;d0&gt;i32|&lt;d1&gt;ch}}&quot;];
	Node0x10304eaa0:s0 -&gt; Node0x102f0dbe0:d0[color=blue,style=dashed];
	Node0x10304eaa0:s1 -&gt; Node0x10304ea30:d0;
	Node0x10304eaa0:s2 -&gt; Node0x10304e870:d0;
	Node0x10304eb10 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1|&lt;s2&gt;2|&lt;s3&gt;3}|TokenFactor|t8|{&lt;d0&gt;ch}}&quot;];
	Node0x10304eb10:s0 -&gt; Node0x10304e8e0:d1[color=blue,style=dashed];
	Node0x10304eb10:s1 -&gt; Node0x10304e9c0:d1[color=blue,style=dashed];
	Node0x10304eb10:s2 -&gt; Node0x10304eaa0:d1[color=blue,style=dashed];
	Node0x10304eb10:s3 -&gt; Node0x102f0dbe0:d0[color=blue,style=dashed];
	Node0x10304eb80 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1}|add|t9|{&lt;d0&gt;i32}}&quot;];
	Node0x10304eb80:s0 -&gt; Node0x10304e9c0:d0;
	Node0x10304eb80:s1 -&gt; Node0x10304e8e0:d0;
	Node0x10304ebf0 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1}|add|t10|{&lt;d0&gt;i32}}&quot;];
	Node0x10304ebf0:s0 -&gt; Node0x10304eb80:d0;
	Node0x10304ebf0:s1 -&gt; Node0x10304eaa0:d0;
	Node0x10304ec60 [shape=record,shape=Mrecord,label=&quot;{Register %V0|t11|{&lt;d0&gt;i32}}&quot;];
  }
  subgraph cluster_1 {
    fontcolor=red;
    fontsize=24;
    label = &quot;LowerReturn&quot;;
	Node0x10304ecd0 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1|&lt;s2&gt;2}|CopyToReg|t12|{&lt;d0&gt;ch|&lt;d1&gt;glue}}&quot;];
	Node0x10304ecd0:s0 -&gt; Node0x10304eb10:d0[color=blue,style=dashed];
	Node0x10304ecd0:s1 -&gt; Node0x10304ec60:d0;
	Node0x10304ecd0:s2 -&gt; Node0x10304ebf0:d0;
	Node0x10304ed40 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1|&lt;s2&gt;2}|Cpu0ISD::Ret|t13|{&lt;d0&gt;ch}}&quot;];
	Node0x10304ed40:s0 -&gt; Node0x10304ecd0:d0[color=blue,style=dashed];
	Node0x10304ed40:s1 -&gt; Node0x10304ec60:d0;
	Node0x10304ed40:s2 -&gt; Node0x10304ecd0:d1[color=red,style=bold];
  }
	Node0x0[ plaintext=circle, label =&quot;GraphRoot&quot;];
	Node0x0 -&gt; Node0x10304ed40:d0[color=blue,style=dashed];
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 43 </span><span class="caption-text">Incoming arguments DAG created for ch9_incoming.cpp with -cpu0-s32-calls=true</span><a class="headerlink" href="#id22" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-default" id="id23">
<span id="funccall-f-incoming-arg2"></span><div class="graphviz"><img src="_images/graphviz-69da813b9be83f9864f7db7e0ab16d5483c9ac3f.png" alt="digraph &quot;dag-combine1 input for _Z5sum_iiii:&quot; {
	rankdir=&quot;BT&quot;;
//	label=&quot;Figure: Incoming arguments DAG created for ch9_incoming.cpp with -cpu0-s32-calls=false&quot;;

  subgraph cluster_0 {
    fontcolor=red;
    fontsize=24;
    label = &quot;LowerFormalArguments&quot;;
	Node0x102f0e0f0 [shape=record,shape=Mrecord,label=&quot;{EntryToken|t0|{&lt;d0&gt;ch}}&quot;];
	Node0x10305c200 [shape=record,shape=Mrecord,label=&quot;{Register %vreg0|t1|{&lt;d0&gt;i32}}&quot;];
	Node0x10305c270 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1}|CopyFromReg|t2|{&lt;d0&gt;i32|&lt;d1&gt;ch}}&quot;];
	Node0x10305c270:s0 -&gt; Node0x102f0e0f0:d0[color=blue,style=dashed];
	Node0x10305c270:s1 -&gt; Node0x10305c200:d0;
	Node0x10305c2e0 [shape=record,shape=Mrecord,label=&quot;{Register %vreg1|t3|{&lt;d0&gt;i32}}&quot;];
	Node0x10305c350 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1}|CopyFromReg|t4|{&lt;d0&gt;i32|&lt;d1&gt;ch}}&quot;];
	Node0x10305c350:s0 -&gt; Node0x102f0e0f0:d0[color=blue,style=dashed];
	Node0x10305c350:s1 -&gt; Node0x10305c2e0:d0;
	Node0x10305c3c0 [shape=record,shape=Mrecord,label=&quot;{FrameIndex\&lt;-1\&gt;|t5|{&lt;d0&gt;i32}}&quot;];
	Node0x10305c430 [shape=record,shape=Mrecord,label=&quot;{undef|t6|{&lt;d0&gt;i32}}&quot;];
	Node0x10305c4a0 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1|&lt;s2&gt;2}|load\&lt;LD4[FixedStack-1]\&gt;|t7|{&lt;d0&gt;i32|&lt;d1&gt;ch}}&quot;];
	Node0x10305c4a0:s0 -&gt; Node0x102f0e0f0:d0[color=blue,style=dashed];
	Node0x10305c4a0:s1 -&gt; Node0x10305c3c0:d0;
	Node0x10305c4a0:s2 -&gt; Node0x10305c430:d0;
	Node0x10305c510 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1}|add|t8|{&lt;d0&gt;i32}}&quot;];
	Node0x10305c510:s0 -&gt; Node0x10305c350:d0;
	Node0x10305c510:s1 -&gt; Node0x10305c270:d0;
	Node0x10305c580 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1}|add|t9|{&lt;d0&gt;i32}}&quot;];
	Node0x10305c580:s0 -&gt; Node0x10305c510:d0;
	Node0x10305c580:s1 -&gt; Node0x10305c4a0:d0;
	Node0x10305c5f0 [shape=record,shape=Mrecord,label=&quot;{Register %V0|t10|{&lt;d0&gt;i32}}&quot;];
  }
  subgraph cluster_1 {
    fontcolor=red;
    fontsize=24;
    label = &quot;LowerReturn&quot;;
	Node0x10305c660 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1|&lt;s2&gt;2}|CopyToReg|t11|{&lt;d0&gt;ch|&lt;d1&gt;glue}}&quot;];
	Node0x10305c660:s0 -&gt; Node0x10305c4a0:d1[color=blue,style=dashed];
	Node0x10305c660:s1 -&gt; Node0x10305c5f0:d0;
	Node0x10305c660:s2 -&gt; Node0x10305c580:d0;
	Node0x10305c6d0 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1|&lt;s2&gt;2}|Cpu0ISD::Ret|t12|{&lt;d0&gt;ch}}&quot;];
	Node0x10305c6d0:s0 -&gt; Node0x10305c660:d0[color=blue,style=dashed];
	Node0x10305c6d0:s1 -&gt; Node0x10305c5f0:d0;
	Node0x10305c6d0:s2 -&gt; Node0x10305c660:d1[color=red,style=bold];
  }
	Node0x0[ plaintext=circle, label =&quot;GraphRoot&quot;];
	Node0x0 -&gt; Node0x10305c6d0:d0[color=blue,style=dashed];
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 44 </span><span class="caption-text">Incoming arguments DAG created for ch9_incoming.cpp with -cpu0-s32-calls=false</span><a class="headerlink" href="#id23" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>In addition to the calling convention and <cite>LowerFormalArguments()</cite>,
<cite>Chapter9_1/</cite> adds support for instruction selection and printing of the Cpu0
instructions <strong>swi</strong> (software interrupt), <strong>jsub</strong>, and <strong>jalr</strong> (function call).</p>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0InstrInfo.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">SDT_Cpu0JmpLink</span>      <span class="p">:</span> <span class="n">SDTypeProfile</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="n">SDTCisVT</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">iPTR</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Call</span>
<span class="k">def</span> <span class="nf">Cpu0JmpLink</span> <span class="p">:</span> <span class="n">SDNode</span><span class="o">&lt;</span><span class="s2">&quot;Cpu0ISD::JmpLink&quot;</span><span class="p">,</span><span class="n">SDT_Cpu0JmpLink</span><span class="p">,</span>
                         <span class="p">[</span><span class="n">SDNPHasChain</span><span class="p">,</span> <span class="n">SDNPOutGlue</span><span class="p">,</span> <span class="n">SDNPOptInGlue</span><span class="p">,</span>
                          <span class="n">SDNPVariadic</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">IsTailCall</span> <span class="p">{</span>
  <span class="n">bit</span> <span class="n">isCall</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">bit</span> <span class="n">isTerminator</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">bit</span> <span class="n">isReturn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">bit</span> <span class="n">isBarrier</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">bit</span> <span class="n">hasExtraSrcRegAllocReq</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">bit</span> <span class="n">isCodeGenOnly</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">calltarget</span>  <span class="p">:</span> <span class="n">Operand</span><span class="o">&lt;</span><span class="n">iPTR</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">let</span> <span class="n">EncoderMethod</span> <span class="o">=</span> <span class="s2">&quot;getJumpTargetOpValue&quot;</span><span class="p">;</span>
  <span class="n">let</span> <span class="n">OperandType</span> <span class="o">=</span> <span class="s2">&quot;OPERAND_PCREL&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>let Predicates = [Ch9_1] in {
// Jump and Link (Call)
let isCall=1, hasDelaySlot=1 in {
  //@JumpLink {
  class JumpLink&lt;bits&lt;8&gt; op, string instr_asm&gt;:
    FJ&lt;op, (outs), (ins calltarget:$target, variable_ops),
       !strconcat(instr_asm, &quot;\t$target&quot;), [(Cpu0JmpLink imm:$target)],
       IIBranch&gt; {
//#if CH &gt;= CH10_1 2
       let DecoderMethod = &quot;DecodeJumpTarget&quot;;
//#endif
       }
  //@JumpLink }

  class JumpLinkReg&lt;bits&lt;8&gt; op, string instr_asm,
                    RegisterClass RC&gt;:
    FA&lt;op, (outs), (ins RC:$rb, variable_ops),
       !strconcat(instr_asm, &quot;\t$rb&quot;), [(Cpu0JmpLink RC:$rb)], IIBranch&gt; {
    let rc = 0;
    let ra = 14;
    let shamt = 0;
  }
}

</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">///</span> <span class="n">Jump</span> <span class="o">&amp;</span> <span class="n">link</span> <span class="ow">and</span> <span class="n">Return</span> <span class="n">Instructions</span>
<span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ch9_1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">{</span>
<span class="k">def</span> <span class="nf">JSUB</span>    <span class="p">:</span> <span class="n">JumpLink</span><span class="o">&lt;</span><span class="mh">0x3b</span><span class="p">,</span> <span class="s2">&quot;jsub&quot;</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ch9_1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">{</span>
<span class="k">def</span> <span class="nf">JALR</span>    <span class="p">:</span> <span class="n">JumpLinkReg</span><span class="o">&lt;</span><span class="mh">0x39</span><span class="p">,</span> <span class="s2">&quot;jalr&quot;</span><span class="p">,</span> <span class="n">GPROut</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>let Predicates = [Ch9_1] in {
def : Pat&lt;(Cpu0JmpLink (i32 tglobaladdr:$dst)),
          (JSUB tglobaladdr:$dst)&gt;;
def : Pat&lt;(Cpu0JmpLink (i32 texternalsym:$dst)),
          (JSUB texternalsym:$dst)&gt;;

</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0MCInstLower.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MCOperand</span> <span class="n">Cpu0MCInstLower</span><span class="p">::</span><span class="n">LowerSymbolOperand</span><span class="p">(</span><span class="n">const</span> <span class="n">MachineOperand</span> <span class="o">&amp;</span><span class="n">MO</span><span class="p">,</span>
                                              <span class="n">MachineOperandType</span> <span class="n">MOTy</span><span class="p">,</span>
                                              <span class="n">unsigned</span> <span class="n">Offset</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VariantKind</span> <span class="n">Kind</span> <span class="o">=</span> <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VK_None</span><span class="p">;</span>
  <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">Cpu0ExprKind</span> <span class="n">TargetKind</span> <span class="o">=</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_None</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">MCSymbol</span> <span class="o">*</span><span class="n">Symbol</span><span class="p">;</span>

  <span class="n">switch</span><span class="p">(</span><span class="n">MO</span><span class="o">.</span><span class="n">getTargetFlags</span><span class="p">())</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">case</span> <span class="n">Cpu0II</span><span class="p">::</span><span class="n">MO_GOT_CALL</span><span class="p">:</span>
    <span class="n">TargetKind</span> <span class="o">=</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_GOT_CALL</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">MOTy</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="p">.</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">case</span> <span class="n">MachineOperand</span><span class="p">::</span><span class="n">MO_ExternalSymbol</span><span class="p">:</span>
    <span class="n">Symbol</span> <span class="o">=</span> <span class="n">AsmPrinter</span><span class="o">.</span><span class="n">GetExternalSymbolSymbol</span><span class="p">(</span><span class="n">MO</span><span class="o">.</span><span class="n">getSymbolName</span><span class="p">());</span>
    <span class="n">Offset</span> <span class="o">+=</span> <span class="n">MO</span><span class="o">.</span><span class="n">getOffset</span><span class="p">();</span>
    <span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MCOperand</span> <span class="n">Cpu0MCInstLower</span><span class="p">::</span><span class="n">LowerOperand</span><span class="p">(</span><span class="n">const</span> <span class="n">MachineOperand</span><span class="o">&amp;</span> <span class="n">MO</span><span class="p">,</span>
                                        <span class="n">unsigned</span> <span class="n">offset</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="n">MachineOperandType</span> <span class="n">MOTy</span> <span class="o">=</span> <span class="n">MO</span><span class="o">.</span><span class="n">getType</span><span class="p">();</span>

  <span class="n">switch</span> <span class="p">(</span><span class="n">MOTy</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">//@</span><span class="mi">2</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">case</span> <span class="n">MachineOperand</span><span class="p">::</span><span class="n">MO_ExternalSymbol</span><span class="p">:</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="k">return</span> <span class="n">LowerSymbolOperand</span><span class="p">(</span><span class="n">MO</span><span class="p">,</span> <span class="n">MOTy</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_1/MCTargetDesc/Cpu0AsmBackend.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Prepare</span> <span class="n">value</span> <span class="k">for</span> <span class="n">the</span> <span class="n">target</span> <span class="n">space</span> <span class="k">for</span> <span class="n">it</span>
<span class="n">static</span> <span class="n">unsigned</span> <span class="n">adjustFixupValue</span><span class="p">(</span><span class="n">const</span> <span class="n">MCFixup</span> <span class="o">&amp;</span><span class="n">Fixup</span><span class="p">,</span> <span class="n">uint64_t</span> <span class="n">Value</span><span class="p">,</span>
                                 <span class="n">MCContext</span> <span class="o">&amp;</span><span class="n">Ctx</span><span class="p">)</span> <span class="p">{</span>

  <span class="n">unsigned</span> <span class="n">Kind</span> <span class="o">=</span> <span class="n">Fixup</span><span class="o">.</span><span class="n">getKind</span><span class="p">();</span>

  <span class="o">//</span> <span class="n">Add</span><span class="o">/</span><span class="n">subtract</span> <span class="ow">and</span> <span class="n">shift</span>
  <span class="n">switch</span> <span class="p">(</span><span class="n">Kind</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">case</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_CALL16</span><span class="p">:</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_1/MCTargetDesc/Cpu0ELFObjectWriter.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">unsigned</span> <span class="n">Cpu0ELFObjectWriter</span><span class="p">::</span><span class="n">getRelocType</span><span class="p">(</span><span class="n">MCContext</span> <span class="o">&amp;</span><span class="n">Ctx</span><span class="p">,</span>
                                           <span class="n">const</span> <span class="n">MCValue</span> <span class="o">&amp;</span><span class="n">Target</span><span class="p">,</span>
                                           <span class="n">const</span> <span class="n">MCFixup</span> <span class="o">&amp;</span><span class="n">Fixup</span><span class="p">,</span>
                                           <span class="nb">bool</span> <span class="n">IsPCRel</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="o">//</span> <span class="n">determine</span> <span class="n">the</span> <span class="nb">type</span> <span class="n">of</span> <span class="n">the</span> <span class="n">relocation</span>
  <span class="n">unsigned</span> <span class="n">Type</span> <span class="o">=</span> <span class="p">(</span><span class="n">unsigned</span><span class="p">)</span><span class="n">ELF</span><span class="p">::</span><span class="n">R_CPU0_NONE</span><span class="p">;</span>
  <span class="n">unsigned</span> <span class="n">Kind</span> <span class="o">=</span> <span class="p">(</span><span class="n">unsigned</span><span class="p">)</span><span class="n">Fixup</span><span class="o">.</span><span class="n">getKind</span><span class="p">();</span>

  <span class="n">switch</span> <span class="p">(</span><span class="n">Kind</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">case</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_CALL16</span><span class="p">:</span>
    <span class="n">Type</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">::</span><span class="n">R_CPU0_CALL16</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_1/MCTargetDesc/Cpu0FixupKinds.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">enum</span> <span class="n">Fixups</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="o">//</span> <span class="n">resulting</span> <span class="ow">in</span> <span class="o">-</span> <span class="n">R_CPU0_CALL16</span><span class="o">.</span>
    <span class="n">fixup_Cpu0_CALL16</span><span class="p">,</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">.</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_1/MCTargetDesc/Cpu0MCCodeEmitter.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">unsigned</span> <span class="n">Cpu0MCCodeEmitter</span><span class="p">::</span>
<span class="n">getJumpTargetOpValue</span><span class="p">(</span><span class="n">const</span> <span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">OpNo</span><span class="p">,</span>
                     <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCFixup</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Fixups</span><span class="p">,</span>
                     <span class="n">const</span> <span class="n">MCSubtargetInfo</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">if</span> <span class="p">(</span><span class="n">Opcode</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">JSUB</span> <span class="o">||</span> <span class="n">Opcode</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">JMP</span> <span class="o">||</span> <span class="n">Opcode</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">BAL</span><span class="p">)</span>
<span class="c1">#elif CH &gt;= CH8_2 //1</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Opcode</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">JMP</span> <span class="o">||</span> <span class="n">Opcode</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">BAL</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">Fixups</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">MCFixup</span><span class="p">::</span><span class="n">create</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Expr</span><span class="p">,</span>
                                     <span class="n">MCFixupKind</span><span class="p">(</span><span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_PC24</span><span class="p">)));</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">unsigned</span> <span class="n">Cpu0MCCodeEmitter</span><span class="p">::</span>
<span class="n">getExprOpValue</span><span class="p">(</span><span class="n">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">Expr</span><span class="p">,</span><span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCFixup</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Fixups</span><span class="p">,</span>
               <span class="n">const</span> <span class="n">MCSubtargetInfo</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span>    <span class="n">switch</span><span class="p">(</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">MCSymbolRefExpr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Expr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">getKind</span><span class="p">())</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="k">case</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_GOT_CALL</span><span class="p">:</span>
      <span class="n">FixupKind</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_CALL16</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0MachineFunction.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">///</span> <span class="n">Cpu0FunctionInfo</span> <span class="o">-</span> <span class="n">This</span> <span class="k">class</span> <span class="nc">is</span> <span class="n">derived</span> <span class="kn">from</span> <span class="nn">MachineFunction</span> <span class="n">private</span>
<span class="o">///</span> <span class="n">Cpu0</span> <span class="n">target</span><span class="o">-</span><span class="n">specific</span> <span class="n">information</span> <span class="k">for</span> <span class="n">each</span> <span class="n">MachineFunction</span><span class="o">.</span>
<span class="k">class</span> <span class="nc">Cpu0FunctionInfo</span> <span class="p">:</span> <span class="n">public</span> <span class="n">MachineFunctionInfo</span> <span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
  <span class="n">Cpu0FunctionInfo</span><span class="p">(</span><span class="n">MachineFunction</span><span class="o">&amp;</span> <span class="n">MF</span><span class="p">)</span>
  <span class="p">:</span> <span class="n">MF</span><span class="p">(</span><span class="n">MF</span><span class="p">),</span> 
    <span class="n">VarArgsFrameIndex</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> 
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">InArgFIRange</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">make_pair</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span>
    <span class="n">OutArgFIRange</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">make_pair</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="n">GPFI</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">DynAllocFI</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="nb">bool</span> <span class="n">isInArgFI</span><span class="p">(</span><span class="nb">int</span> <span class="n">FI</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">FI</span> <span class="o">&lt;=</span> <span class="n">InArgFIRange</span><span class="o">.</span><span class="n">first</span> <span class="o">&amp;&amp;</span> <span class="n">FI</span> <span class="o">&gt;=</span> <span class="n">InArgFIRange</span><span class="o">.</span><span class="n">second</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">void</span> <span class="n">setLastInArgFI</span><span class="p">(</span><span class="nb">int</span> <span class="n">FI</span><span class="p">)</span> <span class="p">{</span> <span class="n">InArgFIRange</span><span class="o">.</span><span class="n">second</span> <span class="o">=</span> <span class="n">FI</span><span class="p">;</span> <span class="p">}</span>
  <span class="nb">bool</span> <span class="n">isOutArgFI</span><span class="p">(</span><span class="nb">int</span> <span class="n">FI</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">FI</span> <span class="o">&lt;=</span> <span class="n">OutArgFIRange</span><span class="o">.</span><span class="n">first</span> <span class="o">&amp;&amp;</span> <span class="n">FI</span> <span class="o">&gt;=</span> <span class="n">OutArgFIRange</span><span class="o">.</span><span class="n">second</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="nb">int</span> <span class="n">getGPFI</span><span class="p">()</span> <span class="n">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">GPFI</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">void</span> <span class="n">setGPFI</span><span class="p">(</span><span class="nb">int</span> <span class="n">FI</span><span class="p">)</span> <span class="p">{</span> <span class="n">GPFI</span> <span class="o">=</span> <span class="n">FI</span><span class="p">;</span> <span class="p">}</span>
  <span class="nb">bool</span> <span class="n">isGPFI</span><span class="p">(</span><span class="nb">int</span> <span class="n">FI</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">GPFI</span> <span class="o">&amp;&amp;</span> <span class="n">GPFI</span> <span class="o">==</span> <span class="n">FI</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
  <span class="nb">bool</span> <span class="n">isDynAllocFI</span><span class="p">(</span><span class="nb">int</span> <span class="n">FI</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">DynAllocFI</span> <span class="o">&amp;&amp;</span> <span class="n">DynAllocFI</span> <span class="o">==</span> <span class="n">FI</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  // Range of frame object indices.
  // InArgFIRange: Range of indices of all frame objects created during call to
  //               LowerFormalArguments.
  // OutArgFIRange: Range of indices of all frame objects created during call to
  //                LowerCall except for the frame object for restoring $gp.
  std::pair&lt;int, int&gt; InArgFIRange, OutArgFIRange;
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">mutable</span> <span class="nb">int</span> <span class="n">DynAllocFI</span><span class="p">;</span> <span class="o">//</span> <span class="n">Frame</span> <span class="n">index</span> <span class="n">of</span> <span class="n">dynamically</span> <span class="n">allocated</span> <span class="n">stack</span> <span class="n">area</span><span class="o">.</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0SEFrameLowering.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="nb">bool</span> <span class="n">spillCalleeSavedRegisters</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span>
                                 <span class="n">MachineBasicBlock</span><span class="p">::</span><span class="n">iterator</span> <span class="n">MI</span><span class="p">,</span>
                                 <span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">CalleeSavedInfo</span><span class="o">&gt;</span> <span class="n">CSI</span><span class="p">,</span>
                                 <span class="n">const</span> <span class="n">TargetRegisterInfo</span> <span class="o">*</span><span class="n">TRI</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0SEFrameLowering.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>bool Cpu0SEFrameLowering::
spillCalleeSavedRegisters(MachineBasicBlock &amp;MBB,
                          MachineBasicBlock::iterator MI,
                          ArrayRef&lt;CalleeSavedInfo&gt; CSI,
                          const TargetRegisterInfo *TRI) const {
  MachineFunction *MF = MBB.getParent();
  MachineBasicBlock *EntryBlock = &amp;MF-&gt;front();
  const TargetInstrInfo &amp;TII = *MF-&gt;getSubtarget().getInstrInfo();

  for (unsigned i = 0, e = CSI.size(); i != e; ++i) {
    // Add the callee-saved register as live-in. Do not add if the register is
    // LR and return address is taken, because it has already been added in
    // method Cpu0TargetLowering::LowerRETURNADDR.
    // It&#39;s killed at the spill, unless the register is LR and return address
    // is taken.
    unsigned Reg = CSI[i].getReg();
    bool IsRAAndRetAddrIsTaken = (Reg == Cpu0::LR)
        &amp;&amp; MF-&gt;getFrameInfo().isReturnAddressTaken();
    if (!IsRAAndRetAddrIsTaken)
      EntryBlock-&gt;addLiveIn(Reg);

    // Insert the spill to the stack frame.
    bool IsKill = !IsRAAndRetAddrIsTaken;
    const TargetRegisterClass *RC = TRI-&gt;getMinimalPhysRegClass(Reg);
    TII.storeRegToStackSlot(*EntryBlock, MI, Reg, IsKill,
                            CSI[i].getFrameIdx(), RC, TRI);
  }

  return true;
}
</pre></div>
</div>
<p>Both <cite>JSUB</cite> and <cite>JALR</cite>, defined in <cite>Cpu0InstrInfo.td</cite> as shown above, use the
<cite>Cpu0JmpLink</cite> node. They are distinguishable by their operand types: <cite>JSUB</cite>
uses an <cite>imm</cite> (immediate) operand, while <cite>JALR</cite> uses a register operand.</p>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0InstrInfo.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>let Predicates = [Ch9_1] in {
def : Pat&lt;(Cpu0JmpLink (i32 tglobaladdr:$dst)),
          (JSUB tglobaladdr:$dst)&gt;;
def : Pat&lt;(Cpu0JmpLink (i32 texternalsym:$dst)),
          (JSUB texternalsym:$dst)&gt;;

</pre></div>
</div>
<p>The code instructs TableGen to generate pattern-matching logic that first
matches the <cite>“imm”</cite> operand for the <cite>“tglobaladdr”</cite> pattern. If that match
fails, it then attempts to match the <cite>“texternalsym”</cite> pattern.</p>
<p>A user-defined function belongs to the <cite>“tglobaladdr”</cite> category. For example,
the function <cite>sum_i(…)</cite> defined in <cite>ch9_1.cpp</cite> falls under <cite>“tglobaladdr”</cite>.</p>
<p>On the other hand, functions implicitly used by LLVM, such as <cite>memcpy</cite>, belong
to <cite>“texternalsym”</cite>. The <cite>memcpy</cite> function is typically generated when defining
a long string. The file <cite>ch9_1_2.cpp</cite> is an example that triggers a call to
<cite>memcpy</cite>. This will be shown in the next section with the <cite>Chapter9_2</cite> example
code.</p>
<p>The file <cite>Cpu0GenDAGISel.inc</cite> contains the pattern-matching information for
<cite>JSUB</cite> and <cite>JALR</cite>, which is generated by TableGen as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">          </span><span class="cm">/*SwitchOpcode*/</span><span class="w"> </span><span class="mi">74</span><span class="p">,</span><span class="w">  </span><span class="n">TARGET_VAL</span><span class="p">(</span><span class="n">Cpu0ISD</span><span class="o">::</span><span class="n">JmpLink</span><span class="p">),</span><span class="c1">// -&gt;734</span>
<span class="cm">/*660*/</span><span class="w">     </span><span class="n">OPC_RecordNode</span><span class="p">,</span><span class="w">   </span><span class="c1">// #0 = &#39;Cpu0JmpLink&#39; chained node</span>
<span class="cm">/*661*/</span><span class="w">     </span><span class="n">OPC_CaptureGlueInput</span><span class="p">,</span><span class="w"></span>
<span class="cm">/*662*/</span><span class="w">     </span><span class="n">OPC_RecordChild1</span><span class="p">,</span><span class="w"> </span><span class="c1">// #1 = $target</span>
<span class="cm">/*663*/</span><span class="w">     </span><span class="n">OPC_Scope</span><span class="p">,</span><span class="w"> </span><span class="mi">57</span><span class="p">,</span><span class="w"> </span><span class="cm">/*-&gt;722*/</span><span class="w"> </span><span class="c1">// 2 children in Scope</span>
<span class="cm">/*665*/</span><span class="w">       </span><span class="n">OPC_MoveChild</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="cm">/*667*/</span><span class="w">       </span><span class="n">OPC_SwitchOpcode</span><span class="w"> </span><span class="cm">/*3 cases */</span><span class="p">,</span><span class="w"> </span><span class="mi">22</span><span class="p">,</span><span class="w">  </span><span class="n">TARGET_VAL</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">Constant</span><span class="p">),</span><span class="w"></span>
<span class="c1">// -&gt;693</span>
<span class="cm">/*671*/</span><span class="w">         </span><span class="n">OPC_MoveParent</span><span class="p">,</span><span class="w"></span>
<span class="cm">/*672*/</span><span class="w">         </span><span class="n">OPC_EmitMergeInputChains1_0</span><span class="p">,</span><span class="w"></span>
<span class="cm">/*673*/</span><span class="w">         </span><span class="n">OPC_EmitConvertToTarget</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="cm">/*675*/</span><span class="w">         </span><span class="n">OPC_Scope</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="cm">/*-&gt;684*/</span><span class="w"> </span><span class="c1">// 2 children in Scope</span>
<span class="cm">/*684*/</span><span class="w">         </span><span class="cm">/*Scope*/</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="cm">/*-&gt;692*/</span><span class="w"></span>
<span class="cm">/*685*/</span><span class="w">           </span><span class="n">OPC_MorphNodeTo</span><span class="p">,</span><span class="w"> </span><span class="n">TARGET_VAL</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">JSUB</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="o">|</span><span class="n">OPFL_Chain</span><span class="o">|</span><span class="w"></span>
<span class="n">OPFL_GlueInput</span><span class="o">|</span><span class="n">OPFL_GlueOutput</span><span class="o">|</span><span class="n">OPFL_Variadic1</span><span class="p">,</span><span class="w"></span>
<span class="w">                      </span><span class="mi">0</span><span class="cm">/*#VTs*/</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="cm">/*#Ops*/</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"></span>
<span class="w">                  </span><span class="c1">// Src: (Cpu0JmpLink (imm:iPTR):$target) - Complexity = 6</span>
<span class="w">                  </span><span class="c1">// Dst: (JSUB (imm:iPTR):$target)</span>
<span class="cm">/*692*/</span><span class="w">         </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="cm">/*End of Scope*/</span><span class="w"></span>
<span class="w">              </span><span class="cm">/*SwitchOpcode*/</span><span class="w"> </span><span class="mi">11</span><span class="p">,</span><span class="w">  </span><span class="n">TARGET_VAL</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">TargetGlobalAddress</span><span class="p">),</span><span class="c1">// -&gt;707</span>
<span class="cm">/*696*/</span><span class="w">         </span><span class="n">OPC_CheckType</span><span class="p">,</span><span class="w"> </span><span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span><span class="w"></span>
<span class="cm">/*698*/</span><span class="w">         </span><span class="n">OPC_MoveParent</span><span class="p">,</span><span class="w"></span>
<span class="cm">/*699*/</span><span class="w">         </span><span class="n">OPC_EmitMergeInputChains1_0</span><span class="p">,</span><span class="w"></span>
<span class="cm">/*700*/</span><span class="w">         </span><span class="n">OPC_MorphNodeTo</span><span class="p">,</span><span class="w"> </span><span class="n">TARGET_VAL</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">JSUB</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="o">|</span><span class="n">OPFL_Chain</span><span class="o">|</span><span class="w"></span>
<span class="n">OPFL_GlueInput</span><span class="o">|</span><span class="n">OPFL_GlueOutput</span><span class="o">|</span><span class="n">OPFL_Variadic1</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="mi">0</span><span class="cm">/*#VTs*/</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="cm">/*#Ops*/</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="c1">// Src: (Cpu0JmpLink (tglobaladdr:i32):$dst) - Complexity = 6</span>
<span class="w">                </span><span class="c1">// Dst: (JSUB (tglobaladdr:i32):$dst)</span>
<span class="w">              </span><span class="cm">/*SwitchOpcode*/</span><span class="w"> </span><span class="mi">11</span><span class="p">,</span><span class="w">  </span><span class="n">TARGET_VAL</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">TargetExternalSymbol</span><span class="p">),</span><span class="c1">// -&gt;721</span>
<span class="cm">/*710*/</span><span class="w">         </span><span class="n">OPC_CheckType</span><span class="p">,</span><span class="w"> </span><span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span><span class="w"></span>
<span class="cm">/*712*/</span><span class="w">         </span><span class="n">OPC_MoveParent</span><span class="p">,</span><span class="w"></span>
<span class="cm">/*713*/</span><span class="w">         </span><span class="n">OPC_EmitMergeInputChains1_0</span><span class="p">,</span><span class="w"></span>
<span class="cm">/*714*/</span><span class="w">         </span><span class="n">OPC_MorphNodeTo</span><span class="p">,</span><span class="w"> </span><span class="n">TARGET_VAL</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">JSUB</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="o">|</span><span class="n">OPFL_Chain</span><span class="o">|</span><span class="w"></span>
<span class="n">OPFL_GlueInput</span><span class="o">|</span><span class="n">OPFL_GlueOutput</span><span class="o">|</span><span class="n">OPFL_Variadic1</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="mi">0</span><span class="cm">/*#VTs*/</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="cm">/*#Ops*/</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="c1">// Src: (Cpu0JmpLink (texternalsym:i32):$dst) - Complexity = 6</span>
<span class="w">                </span><span class="c1">// Dst: (JSUB (texternalsym:i32):$dst)</span>
<span class="w">              </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="c1">// EndSwitchOpcode</span>
<span class="cm">/*722*/</span><span class="w">     </span><span class="cm">/*Scope*/</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="cm">/*-&gt;733*/</span><span class="w"></span>
<span class="cm">/*723*/</span><span class="w">       </span><span class="n">OPC_CheckChild1Type</span><span class="p">,</span><span class="w"> </span><span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span><span class="w"></span>
<span class="cm">/*725*/</span><span class="w">       </span><span class="n">OPC_EmitMergeInputChains1_0</span><span class="p">,</span><span class="w"></span>
<span class="cm">/*726*/</span><span class="w">       </span><span class="n">OPC_MorphNodeTo</span><span class="p">,</span><span class="w"> </span><span class="n">TARGET_VAL</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">JALR</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="o">|</span><span class="n">OPFL_Chain</span><span class="o">|</span><span class="w"></span>
<span class="n">OPFL_GlueInput</span><span class="o">|</span><span class="n">OPFL_GlueOutput</span><span class="o">|</span><span class="n">OPFL_Variadic1</span><span class="p">,</span><span class="w"></span>
<span class="w">                  </span><span class="mi">0</span><span class="cm">/*#VTs*/</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="cm">/*#Ops*/</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="c1">// Src: (Cpu0JmpLink CPURegs:i32:$rb) - Complexity = 3</span>
<span class="w">              </span><span class="c1">// Dst: (JALR CPURegs:i32:$rb)</span>
<span class="cm">/*733*/</span><span class="w">     </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="cm">/*End of Scope*/</span><span class="w"></span>
</pre></div>
</div>
<p>After applying the above changes, you can run <cite>Chapter9_1/</cite> with <cite>ch9_1.cpp</cite>
and observe the results as shown below:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-79-83:input Jonathan$ </span>/Users/Jonathan/llvm/test/
<span class="go">build/bin/llc -march=cpu0 -relocation-model=pic -filetype=asm</span>
<span class="go">ch9_1.bc -o ch9_1.cpu0.s</span>
<span class="go">Assertion failed: ((CLI.IsTailCall || InVals.size() == CLI.Ins.size()) &amp;&amp;</span>
<span class="go">&quot;LowerCall didn&#39;t emit the correct number of values!&quot;), function LowerCallTo,</span>
<span class="go">file /Users/Jonathan/llvm/test/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.</span>
<span class="go">cpp, ...</span>
<span class="go">...</span>
<span class="go">0.  Program arguments: /Users/Jonathan/llvm/test/build/</span>
<span class="go">bin/llc -march=cpu0 -relocation-model=pic -filetype=asm ch9_1.bc -o</span>
<span class="go">ch9_1.cpu0.s</span>
<span class="go">1.  Running pass &#39;Function Pass Manager&#39; on module &#39;ch9_1.bc&#39;.</span>
<span class="go">2.  Running pass &#39;CPU0 DAG-&gt;DAG Pattern Instruction Selection&#39; on function</span>
<span class="go">&#39;@main&#39;</span>
<span class="go">Illegal instruction: 4</span>
</pre></div>
</div>
<p>Now, the LowerFormalArguments() has the correct number, but LowerCall() has not
the correct number of values!</p>
</section>
<section id="store-outgoing-arguments-to-stack-frame">
<h2><a class="toc-backref" href="#id34" role="doc-backlink">Store Outgoing Arguments to Stack Frame</a><a class="headerlink" href="#store-outgoing-arguments-to-stack-frame" title="Permalink to this heading">¶</a></h2>
<p><a class="reference internal" href="#funccall-f2"><span class="std std-numref">Fig. 42</span></a> illustrates two steps involved in argument passing:</p>
<ol class="arabic simple">
<li><p>Storing outgoing arguments in the caller function.</p></li>
<li><p>Loading incoming arguments in the callee function.</p></li>
</ol>
<p>In the previous section, we implemented <cite>LowerFormalArguments()</cite> to handle
<strong>“loading incoming arguments”</strong> in the callee function.</p>
<p>Now, we will implement the part responsible for <strong>“storing outgoing arguments”</strong>
in the caller function.</p>
<p>This task is handled by the <cite>LowerCall()</cite> function. Its implementation is shown
below:</p>
<p class="rubric">lbdex/chapters/Chapter9_2/Cpu0MachineFunction.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="o">///</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">MachinePointerInfo</span> <span class="n">that</span> <span class="n">has</span> <span class="n">an</span> <span class="n">ExternalSymbolPseudoSourceValue</span>
  <span class="o">///</span> <span class="nb">object</span> <span class="n">representing</span> <span class="n">a</span> <span class="n">GOT</span> <span class="n">entry</span> <span class="k">for</span> <span class="n">an</span> <span class="n">external</span> <span class="n">function</span><span class="o">.</span>
  <span class="n">MachinePointerInfo</span> <span class="n">callPtrInfo</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">ES</span><span class="p">);</span>

  <span class="o">///</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">MachinePointerInfo</span> <span class="n">that</span> <span class="n">has</span> <span class="n">a</span> <span class="n">GlobalValuePseudoSourceValue</span> <span class="nb">object</span>
  <span class="o">///</span> <span class="n">representing</span> <span class="n">a</span> <span class="n">GOT</span> <span class="n">entry</span> <span class="k">for</span> <span class="n">a</span> <span class="k">global</span> <span class="n">function</span><span class="o">.</span>
  <span class="n">MachinePointerInfo</span> <span class="n">callPtrInfo</span><span class="p">(</span><span class="n">const</span> <span class="n">GlobalValue</span> <span class="o">*</span><span class="n">GV</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_2/Cpu0MachineFunction.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MachinePointerInfo</span> <span class="n">Cpu0FunctionInfo</span><span class="p">::</span><span class="n">callPtrInfo</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">ES</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">MachinePointerInfo</span><span class="p">(</span><span class="n">MF</span><span class="o">.</span><span class="n">getPSVManager</span><span class="p">()</span><span class="o">.</span><span class="n">getExternalSymbolCallEntry</span><span class="p">(</span><span class="n">ES</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">MachinePointerInfo</span> <span class="n">Cpu0FunctionInfo</span><span class="p">::</span><span class="n">callPtrInfo</span><span class="p">(</span><span class="n">const</span> <span class="n">GlobalValue</span> <span class="o">*</span><span class="n">GV</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">MachinePointerInfo</span><span class="p">(</span><span class="n">MF</span><span class="o">.</span><span class="n">getPSVManager</span><span class="p">()</span><span class="o">.</span><span class="n">getGlobalValueCallEntry</span><span class="p">(</span><span class="n">GV</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_2/Cpu0ISelLowering.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="o">///</span> <span class="n">This</span> <span class="n">function</span> <span class="n">fills</span> <span class="n">Ops</span><span class="p">,</span> <span class="n">which</span> <span class="ow">is</span> <span class="n">the</span> <span class="nb">list</span> <span class="n">of</span> <span class="n">operands</span> <span class="n">that</span> <span class="n">will</span> <span class="n">later</span>
    <span class="o">///</span> <span class="n">be</span> <span class="n">used</span> <span class="n">when</span> <span class="n">a</span> <span class="n">function</span> <span class="n">call</span> <span class="n">node</span> <span class="ow">is</span> <span class="n">created</span><span class="o">.</span> <span class="n">It</span> <span class="n">also</span> <span class="n">generates</span>
    <span class="o">///</span> <span class="n">copyToReg</span> <span class="n">nodes</span> <span class="n">to</span> <span class="nb">set</span> <span class="n">up</span> <span class="n">argument</span> <span class="n">registers</span><span class="o">.</span>
    <span class="n">virtual</span> <span class="n">void</span>
    <span class="n">getOpndList</span><span class="p">(</span><span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ops</span><span class="p">,</span>
                <span class="n">std</span><span class="p">::</span><span class="n">deque</span><span class="o">&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">unsigned</span><span class="p">,</span> <span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">RegsToPass</span><span class="p">,</span>
                <span class="nb">bool</span> <span class="n">IsPICCall</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">GlobalOrExternal</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">InternalLinkage</span><span class="p">,</span>
                <span class="n">CallLoweringInfo</span> <span class="o">&amp;</span><span class="n">CLI</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">Callee</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">Chain</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="o">///</span> <span class="n">Cpu0CC</span> <span class="o">-</span> <span class="n">This</span> <span class="k">class</span> <span class="nc">provides</span> <span class="n">methods</span> <span class="n">used</span> <span class="n">to</span> <span class="n">analyze</span> <span class="n">formal</span> <span class="ow">and</span> <span class="n">call</span>
    <span class="o">///</span> <span class="n">arguments</span> <span class="ow">and</span> <span class="n">inquire</span> <span class="n">about</span> <span class="n">calling</span> <span class="n">convention</span> <span class="n">information</span><span class="o">.</span>
    <span class="k">class</span> <span class="nc">Cpu0CC</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>      <span class="n">void</span> <span class="n">analyzeCallOperands</span><span class="p">(</span><span class="n">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="p">::</span><span class="n">OutputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Outs</span><span class="p">,</span>
                               <span class="nb">bool</span> <span class="n">IsVarArg</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">IsSoftFloat</span><span class="p">,</span>
                               <span class="n">const</span> <span class="n">SDNode</span> <span class="o">*</span><span class="n">CallNode</span><span class="p">,</span>
                               <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ArgListEntry</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">FuncArgs</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="w">  </span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">Cpu0CC</span><span class="p">::</span><span class="n">SpecialCallingConvType</span> <span class="n">getSpecialCallingConv</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Callee</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="o">//</span> <span class="n">Lower</span> <span class="n">Operand</span> <span class="n">helpers</span>
    <span class="n">SDValue</span> <span class="n">LowerCallResult</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">InFlag</span><span class="p">,</span>
                            <span class="n">CallingConv</span><span class="p">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">isVarArg</span><span class="p">,</span>
                            <span class="n">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="p">::</span><span class="n">InputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ins</span><span class="p">,</span>
                            <span class="n">const</span> <span class="n">SDLoc</span> <span class="o">&amp;</span><span class="n">dl</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span>
                            <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">,</span>
                            <span class="n">const</span> <span class="n">SDNode</span> <span class="o">*</span><span class="n">CallNode</span><span class="p">,</span> <span class="n">const</span> <span class="n">Type</span> <span class="o">*</span><span class="n">RetTy</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="o">///</span> <span class="n">passByValArg</span> <span class="o">-</span> <span class="n">Pass</span> <span class="n">a</span> <span class="n">byval</span> <span class="n">argument</span> <span class="ow">in</span> <span class="n">registers</span> <span class="ow">or</span> <span class="n">on</span> <span class="n">stack</span><span class="o">.</span>
    <span class="n">void</span> <span class="n">passByValArg</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">const</span> <span class="n">SDLoc</span> <span class="o">&amp;</span><span class="n">DL</span><span class="p">,</span>
                      <span class="n">std</span><span class="p">::</span><span class="n">deque</span><span class="o">&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">unsigned</span><span class="p">,</span> <span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">RegsToPass</span><span class="p">,</span>
                      <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">MemOpChains</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">StackPtr</span><span class="p">,</span>
                      <span class="n">MachineFrameInfo</span> <span class="o">&amp;</span><span class="n">MFI</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">Arg</span><span class="p">,</span>
                      <span class="n">const</span> <span class="n">Cpu0CC</span> <span class="o">&amp;</span><span class="n">CC</span><span class="p">,</span> <span class="n">const</span> <span class="n">ByValArgInfo</span> <span class="o">&amp;</span><span class="n">ByVal</span><span class="p">,</span>
                      <span class="n">const</span> <span class="n">ISD</span><span class="p">::</span><span class="n">ArgFlagsTy</span> <span class="o">&amp;</span><span class="n">Flags</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">isLittle</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">SDValue</span> <span class="n">passArgOnStack</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">StackPtr</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">Offset</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span>
                           <span class="n">SDValue</span> <span class="n">Arg</span><span class="p">,</span> <span class="n">const</span> <span class="n">SDLoc</span> <span class="o">&amp;</span><span class="n">DL</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">IsTailCall</span><span class="p">,</span>
                           <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="nb">bool</span> <span class="n">CanLowerReturn</span><span class="p">(</span><span class="n">CallingConv</span><span class="p">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span> <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                        <span class="nb">bool</span> <span class="n">isVarArg</span><span class="p">,</span>
                        <span class="n">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="p">::</span><span class="n">OutputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Outs</span><span class="p">,</span>
                        <span class="n">LLVMContext</span> <span class="o">&amp;</span><span class="n">Context</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_2/Cpu0ISelLowering.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>SDValue
Cpu0TargetLowering::passArgOnStack(SDValue StackPtr, unsigned Offset,
                                   SDValue Chain, SDValue Arg, const SDLoc &amp;DL,
                                   bool IsTailCall, SelectionDAG &amp;DAG) const {
  if (!IsTailCall) {
    SDValue PtrOff =
        DAG.getNode(ISD::ADD, DL, getPointerTy(DAG.getDataLayout()), StackPtr,
                    DAG.getIntPtrConstant(Offset, DL));
    return DAG.getStore(Chain, DL, Arg, PtrOff, MachinePointerInfo());
  }

  MachineFrameInfo &amp;MFI = DAG.getMachineFunction().getFrameInfo();
  int FI = MFI.CreateFixedObject(Arg.getValueSizeInBits() / 8, Offset, false);
  SDValue FIN = DAG.getFrameIndex(FI, getPointerTy(DAG.getDataLayout()));
  return DAG.getStore(Chain, DL, Arg, FIN, MachinePointerInfo(),
                      /* Alignment = */ 0, MachineMemOperand::MOVolatile);
}

void Cpu0TargetLowering::
getOpndList(SmallVectorImpl&lt;SDValue&gt; &amp;Ops,
            std::deque&lt; std::pair&lt;unsigned, SDValue&gt; &gt; &amp;RegsToPass,
            bool IsPICCall, bool GlobalOrExternal, bool InternalLinkage,
            CallLoweringInfo &amp;CLI, SDValue Callee, SDValue Chain) const {
  // T9 should contain the address of the callee function if
  // -reloction-model=pic or it is an indirect call.
  if (IsPICCall || !GlobalOrExternal) {
    unsigned T9Reg = Cpu0::T9;
    RegsToPass.push_front(std::make_pair(T9Reg, Callee));
  } else
    Ops.push_back(Callee);

  // Insert node &quot;GP copy globalreg&quot; before call to function.
  //
  // R_CPU0_CALL* operators (emitted when non-internal functions are called
  // in PIC mode) allow symbols to be resolved via lazy binding.
  // The lazy binding stub requires GP to point to the GOT.
  if (IsPICCall &amp;&amp; !InternalLinkage) {
    unsigned GPReg = Cpu0::GP;
    EVT Ty = MVT::i32;
    RegsToPass.push_back(std::make_pair(GPReg, getGlobalReg(CLI.DAG, Ty)));
  }

  // Build a sequence of copy-to-reg nodes chained together with token
  // chain and flag operands which copy the outgoing args into registers.
  // The InFlag in necessary since all emitted instructions must be
  // stuck together.
  SDValue InFlag;

  for (unsigned i = 0, e = RegsToPass.size(); i != e; ++i) {
    Chain = CLI.DAG.getCopyToReg(Chain, CLI.DL, RegsToPass[i].first,
                                 RegsToPass[i].second, InFlag);
    InFlag = Chain.getValue(1);
  }

  // Add argument registers to the end of the list so that they are
  // known live into the call.
  for (unsigned i = 0, e = RegsToPass.size(); i != e; ++i)
    Ops.push_back(CLI.DAG.getRegister(RegsToPass[i].first,
                                      RegsToPass[i].second.getValueType()));

  // Add a register mask operand representing the call-preserved registers.
  const TargetRegisterInfo *TRI = Subtarget.getRegisterInfo();
  const uint32_t *Mask = 
      TRI-&gt;getCallPreservedMask(CLI.DAG.getMachineFunction(), CLI.CallConv);
  assert(Mask &amp;&amp; &quot;Missing call preserved mask for calling convention&quot;);
  Ops.push_back(CLI.DAG.getRegisterMask(Mask));

  if (InFlag.getNode())
    Ops.push_back(InFlag);
}
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>/// LowerCall - functions arguments are copied from virtual regs to
/// (physical regs)/(stack frame), CALLSEQ_START and CALLSEQ_END are emitted.
SDValue
Cpu0TargetLowering::LowerCall(TargetLowering::CallLoweringInfo &amp;CLI,
                              SmallVectorImpl&lt;SDValue&gt; &amp;InVals) const {
  SelectionDAG &amp;DAG                     = CLI.DAG;
  SDLoc DL                              = CLI.DL;
  SmallVectorImpl&lt;ISD::OutputArg&gt; &amp;Outs = CLI.Outs;
  SmallVectorImpl&lt;SDValue&gt; &amp;OutVals     = CLI.OutVals;
  SmallVectorImpl&lt;ISD::InputArg&gt; &amp;Ins   = CLI.Ins;
  SDValue Chain                         = CLI.Chain;
  SDValue Callee                        = CLI.Callee;
  bool &amp;IsTailCall                      = CLI.IsTailCall;
  CallingConv::ID CallConv              = CLI.CallConv;
  bool IsVarArg                         = CLI.IsVarArg;

  MachineFunction &amp;MF = DAG.getMachineFunction();
  MachineFrameInfo &amp;MFI = MF.getFrameInfo();
  const TargetFrameLowering *TFL = MF.getSubtarget().getFrameLowering();
  Cpu0FunctionInfo *FuncInfo = MF.getInfo&lt;Cpu0FunctionInfo&gt;();
  bool IsPIC = isPositionIndependent();
  Cpu0FunctionInfo *Cpu0FI = MF.getInfo&lt;Cpu0FunctionInfo&gt;();

  // Analyze operands of the call, assigning locations to each operand.
  SmallVector&lt;CCValAssign, 16&gt; ArgLocs;
  CCState CCInfo(CallConv, IsVarArg, DAG.getMachineFunction(),
                 ArgLocs, *DAG.getContext());
  Cpu0CC::SpecialCallingConvType SpecialCallingConv =
    getSpecialCallingConv(Callee);
  Cpu0CC Cpu0CCInfo(CallConv, ABI.IsO32(), 
                    CCInfo, SpecialCallingConv);

  Cpu0CCInfo.analyzeCallOperands(Outs, IsVarArg,
                                 Subtarget.abiUsesSoftFloat(),
                                 Callee.getNode(), CLI.getArgs());

  // Get a count of how many bytes are to be pushed on the stack.
  unsigned NextStackOffset = CCInfo.getNextStackOffset();

  //@TailCall 1 {
  // Check if it&#39;s really possible to do a tail call.
  if (IsTailCall)
    IsTailCall =
      isEligibleForTailCallOptimization(Cpu0CCInfo, NextStackOffset,
                                        *MF.getInfo&lt;Cpu0FunctionInfo&gt;());

  if (!IsTailCall &amp;&amp; CLI.CB &amp;&amp; CLI.CB-&gt;isMustTailCall())
    report_fatal_error(&quot;failed to perform tail call elimination on a call &quot;
                       &quot;site marked musttail&quot;);

  if (IsTailCall)
    ++NumTailCalls;
  //@TailCall 1 }

  // Chain is the output chain of the last Load/Store or CopyToReg node.
  // ByValChain is the output chain of the last Memcpy node created for copying
  // byval arguments to the stack.
  unsigned StackAlignment = TFL-&gt;getStackAlignment();
  NextStackOffset = alignTo(NextStackOffset, StackAlignment);
  SDValue NextStackOffsetVal = DAG.getIntPtrConstant(NextStackOffset, DL, true);

  //@TailCall 2 {
  if (!IsTailCall)
    Chain = DAG.getCALLSEQ_START(Chain, NextStackOffset, 0, DL);
  //@TailCall 2 }

  SDValue StackPtr =
      DAG.getCopyFromReg(Chain, DL, Cpu0::SP,
                         getPointerTy(DAG.getDataLayout()));

  // With EABI is it possible to have 16 args on registers.
  std::deque&lt; std::pair&lt;unsigned, SDValue&gt; &gt; RegsToPass;
  SmallVector&lt;SDValue, 8&gt; MemOpChains;
  Cpu0CC::byval_iterator ByValArg = Cpu0CCInfo.byval_begin();

  //@1 {
  // Walk the register/memloc assignments, inserting copies/loads.
  for (unsigned i = 0, e = ArgLocs.size(); i != e; ++i) {
  //@1 }
    SDValue Arg = OutVals[i];
    CCValAssign &amp;VA = ArgLocs[i];
    MVT LocVT = VA.getLocVT();
    ISD::ArgFlagsTy Flags = Outs[i].Flags;

    //@ByVal Arg {
    if (Flags.isByVal()) {
      assert(Flags.getByValSize() &amp;&amp;
             &quot;ByVal args of size 0 should have been ignored by front-end.&quot;);
      assert(ByValArg != Cpu0CCInfo.byval_end());
      assert(!IsTailCall &amp;&amp;
             &quot;Do not tail-call optimize if there is a byval argument.&quot;);
      passByValArg(Chain, DL, RegsToPass, MemOpChains, StackPtr, MFI, DAG, Arg,
                   Cpu0CCInfo, *ByValArg, Flags, Subtarget.isLittle());
      ++ByValArg;
      continue;
    }
    //@ByVal Arg }

    // Promote the value if needed.
    switch (VA.getLocInfo()) {
    default: llvm_unreachable(&quot;Unknown loc info!&quot;);
    case CCValAssign::Full:
      break;
    case CCValAssign::SExt:
      Arg = DAG.getNode(ISD::SIGN_EXTEND, DL, LocVT, Arg);
      break;
    case CCValAssign::ZExt:
      Arg = DAG.getNode(ISD::ZERO_EXTEND, DL, LocVT, Arg);
      break;
    case CCValAssign::AExt:
      Arg = DAG.getNode(ISD::ANY_EXTEND, DL, LocVT, Arg);
      break;
    }

    // Arguments that can be passed on register must be kept at
    // RegsToPass vector
    if (VA.isRegLoc()) {
      RegsToPass.push_back(std::make_pair(VA.getLocReg(), Arg));
      continue;
    }

    // Register can&#39;t get to this point...
    assert(VA.isMemLoc());

    // emit ISD::STORE whichs stores the
    // parameter value to a stack Location
    MemOpChains.push_back(passArgOnStack(StackPtr, VA.getLocMemOffset(),
                                         Chain, Arg, DL, IsTailCall, DAG));
  }

  // Transform all store nodes into one single node because all store
  // nodes are independent of each other.
  if (!MemOpChains.empty())
    Chain = DAG.getNode(ISD::TokenFactor, DL, MVT::Other, MemOpChains);

  // If the callee is a GlobalAddress/ExternalSymbol node (quite common, every
  // direct call is) turn it into a TargetGlobalAddress/TargetExternalSymbol
  // node so that legalize doesn&#39;t hack it.
  bool IsPICCall = IsPIC; // true if calls are translated to
                                         // jalr $t9
  bool GlobalOrExternal = false, InternalLinkage = false;
  EVT Ty = Callee.getValueType();

  if (GlobalAddressSDNode *G = dyn_cast&lt;GlobalAddressSDNode&gt;(Callee)) {
    if (IsPICCall) {
      const GlobalValue *Val = G-&gt;getGlobal();
      InternalLinkage = Val-&gt;hasInternalLinkage();

      if (InternalLinkage)
        Callee = getAddrLocal(G, Ty, DAG);
      else
        Callee = getAddrGlobal(G, Ty, DAG, Cpu0II::MO_GOT_CALL, Chain,
                               FuncInfo-&gt;callPtrInfo(Val));
    } else
      Callee = DAG.getTargetGlobalAddress(G-&gt;getGlobal(), DL,
                                          getPointerTy(DAG.getDataLayout()), 0,
                                          Cpu0II::MO_NO_FLAG);
    GlobalOrExternal = true;
  }
  else if (ExternalSymbolSDNode *S = dyn_cast&lt;ExternalSymbolSDNode&gt;(Callee)) {
    const char *Sym = S-&gt;getSymbol();

    if (!IsPIC) // static
      Callee = DAG.getTargetExternalSymbol(Sym,
                                           getPointerTy(DAG.getDataLayout()),
                                           Cpu0II::MO_NO_FLAG);
    else // PIC
      Callee = getAddrGlobal(S, Ty, DAG, Cpu0II::MO_GOT_CALL, Chain,
                             FuncInfo-&gt;callPtrInfo(Sym));

    GlobalOrExternal = true;
  }

  SmallVector&lt;SDValue, 8&gt; Ops(1, Chain);
  SDVTList NodeTys = DAG.getVTList(MVT::Other, MVT::Glue);

  getOpndList(Ops, RegsToPass, IsPICCall, GlobalOrExternal, InternalLinkage,
              CLI, Callee, Chain);

  //@TailCall 3 {
  if (IsTailCall)
    return DAG.getNode(Cpu0ISD::TailCall, DL, MVT::Other, Ops);
  //@TailCall 3 }

  Chain = DAG.getNode(Cpu0ISD::JmpLink, DL, NodeTys, Ops);
  SDValue InFlag = Chain.getValue(1);

  // Create the CALLSEQ_END node.
  Chain = DAG.getCALLSEQ_END(Chain, NextStackOffsetVal,
                             DAG.getIntPtrConstant(0, DL, true), InFlag, DL);
  InFlag = Chain.getValue(1);

  // Handle result values, copying them out of physregs into vregs that we
  // return.
  return LowerCallResult(Chain, InFlag, CallConv, IsVarArg,
                         Ins, DL, DAG, InVals, CLI.Callee.getNode(), CLI.RetTy);
}
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">///</span> <span class="n">LowerCallResult</span> <span class="o">-</span> <span class="n">Lower</span> <span class="n">the</span> <span class="n">result</span> <span class="n">values</span> <span class="n">of</span> <span class="n">a</span> <span class="n">call</span> <span class="n">into</span> <span class="n">the</span>
<span class="o">///</span> <span class="n">appropriate</span> <span class="n">copies</span> <span class="n">out</span> <span class="n">of</span> <span class="n">appropriate</span> <span class="n">physical</span> <span class="n">registers</span><span class="o">.</span>
<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">LowerCallResult</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">InFlag</span><span class="p">,</span>
                                    <span class="n">CallingConv</span><span class="p">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">IsVarArg</span><span class="p">,</span>
                                    <span class="n">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="p">::</span><span class="n">InputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ins</span><span class="p">,</span>
                                    <span class="n">const</span> <span class="n">SDLoc</span> <span class="o">&amp;</span><span class="n">DL</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span>
                                    <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">,</span>
                                    <span class="n">const</span> <span class="n">SDNode</span> <span class="o">*</span><span class="n">CallNode</span><span class="p">,</span>
                                    <span class="n">const</span> <span class="n">Type</span> <span class="o">*</span><span class="n">RetTy</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="o">//</span> <span class="n">Assign</span> <span class="n">locations</span> <span class="n">to</span> <span class="n">each</span> <span class="n">value</span> <span class="n">returned</span> <span class="n">by</span> <span class="n">this</span> <span class="n">call</span><span class="o">.</span>
  <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">CCValAssign</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">RVLocs</span><span class="p">;</span>
  <span class="n">CCState</span> <span class="n">CCInfo</span><span class="p">(</span><span class="n">CallConv</span><span class="p">,</span> <span class="n">IsVarArg</span><span class="p">,</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getMachineFunction</span><span class="p">(),</span>
		 <span class="n">RVLocs</span><span class="p">,</span> <span class="o">*</span><span class="n">DAG</span><span class="o">.</span><span class="n">getContext</span><span class="p">());</span>
		 
  <span class="n">Cpu0CC</span> <span class="n">Cpu0CCInfo</span><span class="p">(</span><span class="n">CallConv</span><span class="p">,</span> <span class="n">ABI</span><span class="o">.</span><span class="n">IsO32</span><span class="p">(),</span> <span class="n">CCInfo</span><span class="p">);</span>

  <span class="n">Cpu0CCInfo</span><span class="o">.</span><span class="n">analyzeCallResult</span><span class="p">(</span><span class="n">Ins</span><span class="p">,</span> <span class="n">Subtarget</span><span class="o">.</span><span class="n">abiUsesSoftFloat</span><span class="p">(),</span>
                               <span class="n">CallNode</span><span class="p">,</span> <span class="n">RetTy</span><span class="p">);</span>

  <span class="o">//</span> <span class="n">Copy</span> <span class="nb">all</span> <span class="n">of</span> <span class="n">the</span> <span class="n">result</span> <span class="n">registers</span> <span class="n">out</span> <span class="n">of</span> <span class="n">their</span> <span class="n">specified</span> <span class="n">physreg</span><span class="o">.</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">RVLocs</span><span class="o">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">SDValue</span> <span class="n">Val</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getCopyFromReg</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">RVLocs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">getLocReg</span><span class="p">(),</span>
                                     <span class="n">RVLocs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">getLocVT</span><span class="p">(),</span> <span class="n">InFlag</span><span class="p">);</span>
    <span class="n">Chain</span> <span class="o">=</span> <span class="n">Val</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">InFlag</span> <span class="o">=</span> <span class="n">Val</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">RVLocs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">getValVT</span><span class="p">()</span> <span class="o">!=</span> <span class="n">RVLocs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">getLocVT</span><span class="p">())</span>
      <span class="n">Val</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">BITCAST</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">RVLocs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">getValVT</span><span class="p">(),</span> <span class="n">Val</span><span class="p">);</span>

    <span class="n">InVals</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Val</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">Chain</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">bool</span>
<span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">CanLowerReturn</span><span class="p">(</span><span class="n">CallingConv</span><span class="p">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span>
                                   <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">IsVarArg</span><span class="p">,</span>
                                   <span class="n">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="p">::</span><span class="n">OutputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Outs</span><span class="p">,</span>
                                   <span class="n">LLVMContext</span> <span class="o">&amp;</span><span class="n">Context</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">CCValAssign</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">RVLocs</span><span class="p">;</span>
  <span class="n">CCState</span> <span class="n">CCInfo</span><span class="p">(</span><span class="n">CallConv</span><span class="p">,</span> <span class="n">IsVarArg</span><span class="p">,</span> <span class="n">MF</span><span class="p">,</span>
                 <span class="n">RVLocs</span><span class="p">,</span> <span class="n">Context</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">CCInfo</span><span class="o">.</span><span class="n">CheckReturn</span><span class="p">(</span><span class="n">Outs</span><span class="p">,</span> <span class="n">RetCC_Cpu0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">Cpu0CC</span><span class="p">::</span><span class="n">SpecialCallingConvType</span>
  <span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">getSpecialCallingConv</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Callee</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="n">Cpu0CC</span><span class="p">::</span><span class="n">SpecialCallingConvType</span> <span class="n">SpecialCallingConv</span> <span class="o">=</span>
    <span class="n">Cpu0CC</span><span class="p">::</span><span class="n">NoSpecialCallingConv</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">SpecialCallingConv</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>void Cpu0TargetLowering::Cpu0CC::
analyzeCallOperands(const SmallVectorImpl&lt;ISD::OutputArg&gt; &amp;Args,
                    bool IsVarArg, bool IsSoftFloat, const SDNode *CallNode,
                    std::vector&lt;ArgListEntry&gt; &amp;FuncArgs) {
//@analyzeCallOperands body {
  assert((CallConv != CallingConv::Fast || !IsVarArg) &amp;&amp;
         &quot;CallingConv::Fast shouldn&#39;t be used for vararg functions.&quot;);

  unsigned NumOpnds = Args.size();
  llvm::CCAssignFn *FixedFn = fixedArgFn();

  //@3 {
  for (unsigned I = 0; I != NumOpnds; ++I) {
  //@3 }
    MVT ArgVT = Args[I].VT;
    ISD::ArgFlagsTy ArgFlags = Args[I].Flags;
    bool R;

    if (ArgFlags.isByVal()) {
      handleByValArg(I, ArgVT, ArgVT, CCValAssign::Full, ArgFlags);
      continue;
    }

    {
      MVT RegVT = getRegVT(ArgVT, IsSoftFloat);
      R = FixedFn(I, ArgVT, RegVT, CCValAssign::Full, ArgFlags, CCInfo);
    }

    if (R) {
#ifndef NDEBUG
      dbgs() &lt;&lt; &quot;Call operand #&quot; &lt;&lt; I &lt;&lt; &quot; has unhandled type &quot;
             &lt;&lt; EVT(ArgVT).getEVTString();
#endif
      llvm_unreachable(nullptr);
    }
  }
}
</pre></div>
</div>
<p>Just like loading incoming arguments from the stack frame, we call
<cite>CCInfo(CallConv, …, ArgLocs, …)</cite> to obtain outgoing argument information
before entering the <strong>“for loop”</strong>.</p>
<p>The loop structure is almost identical to that in <cite>LowerFormalArguments()</cite>,
except that <cite>LowerCall()</cite> creates a “store DAG vector” instead of a “load DAG
vector”.</p>
<p>After the <strong>“for loop”</strong>, it generates the instruction
<strong>`ld $t9, %call16(_Z5sum_iiiiiii)($gp)`</strong> followed by <cite>jalr $t9</cite> to call the
subroutine (where <cite>$6</cite> is <cite>$t9</cite>) in PIC (Position Independent Code) mode.</p>
<p>As with loading incoming arguments, we need to implement
<cite>storeRegToStackSlot()</cite> in an earlier chapter to handle storing outgoing
arguments.</p>
<section id="pseudo-hook-instructions-adjcallstackdown-and-adjcallstackup">
<h3><a class="toc-backref" href="#id35" role="doc-backlink">Pseudo Hook Instructions ADJCALLSTACKDOWN and ADJCALLSTACKUP</a><a class="headerlink" href="#pseudo-hook-instructions-adjcallstackdown-and-adjcallstackup" title="Permalink to this heading">¶</a></h3>
<p><cite>DAG.getCALLSEQ_START()</cite> and <cite>DAG.getCALLSEQ_END()</cite> are invoked before and
after the <strong>“for loop”</strong>, respectively. These insert <cite>CALLSEQ_START</cite> and
<cite>CALLSEQ_END</cite>, which are later translated into the pseudo machine instructions
<cite>ADJCALLSTACKDOWN</cite> and <cite>ADJCALLSTACKUP</cite>.</p>
<p>These pseudo instructions are defined in <cite>Cpu0InstrInfo.td</cite> as shown below:</p>
<p class="rubric">lbdex/chapters/Chapter9_2/Cpu0InstrInfo.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">SDT_Cpu0CallSeqStart</span> <span class="p">:</span> <span class="n">SDCallSeqStart</span><span class="o">&lt;</span><span class="p">[</span><span class="n">SDTCisVT</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">i32</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">SDT_Cpu0CallSeqEnd</span>   <span class="p">:</span> <span class="n">SDCallSeqEnd</span><span class="o">&lt;</span><span class="p">[</span><span class="n">SDTCisVT</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">i32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">SDTCisVT</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="n">i32</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">These</span> <span class="n">are</span> <span class="n">target</span><span class="o">-</span><span class="n">independent</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">but</span> <span class="n">have</span> <span class="n">target</span><span class="o">-</span><span class="n">specific</span> <span class="n">formats</span><span class="o">.</span>
<span class="k">def</span> <span class="nf">callseq_start</span> <span class="p">:</span> <span class="n">SDNode</span><span class="o">&lt;</span><span class="s2">&quot;ISD::CALLSEQ_START&quot;</span><span class="p">,</span> <span class="n">SDT_Cpu0CallSeqStart</span><span class="p">,</span>
                           <span class="p">[</span><span class="n">SDNPHasChain</span><span class="p">,</span> <span class="n">SDNPOutGlue</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">callseq_end</span>   <span class="p">:</span> <span class="n">SDNode</span><span class="o">&lt;</span><span class="s2">&quot;ISD::CALLSEQ_END&quot;</span><span class="p">,</span> <span class="n">SDT_Cpu0CallSeqEnd</span><span class="p">,</span>
                           <span class="p">[</span><span class="n">SDNPHasChain</span><span class="p">,</span> <span class="n">SDNPOptInGlue</span><span class="p">,</span> <span class="n">SDNPOutGlue</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>//===----------------------------------------------------------------------===//
// Pseudo instructions
//===----------------------------------------------------------------------===//

let Predicates = [Ch9_2] in {
// As stack alignment is always done with addiu, we need a 16-bit immediate
let Defs = [SP], Uses = [SP] in {
def ADJCALLSTACKDOWN : Cpu0Pseudo&lt;(outs), (ins uimm16:$amt1, uimm16:$amt2),
                                  &quot;!ADJCALLSTACKDOWN $amt1&quot;,
                                  [(callseq_start timm:$amt1, timm:$amt2)]&gt;;
def ADJCALLSTACKUP   : Cpu0Pseudo&lt;(outs), (ins uimm16:$amt1, uimm16:$amt2),
                                  &quot;!ADJCALLSTACKUP $amt1&quot;,
                                  [(callseq_end timm:$amt1, timm:$amt2)]&gt;;
}

//@def CPRESTORE {
// When handling PIC code the assembler needs .cpload and .cprestore
// directives. If the real instructions corresponding these directives
// are used, we have the same behavior, but get also a bunch of warnings
// from the assembler.
let hasSideEffects = 0 in
def CPRESTORE : Cpu0Pseudo&lt;(outs), (ins i32imm:$loc, CPURegs:$gp),
                           &quot;.cprestore\t$loc&quot;, []&gt;;
} // let Predicates = [Ch9_2]
</pre></div>
</div>
<p>With the definition below, <cite>eliminateCallFramePseudoInstr()</cite> will be called
when LLVM encounters the pseudo instructions <cite>ADJCALLSTACKDOWN</cite> and
<cite>ADJCALLSTACKUP</cite>.</p>
<p>This function simply discards these two pseudo instructions. LLVM will then
automatically adjust the stack offset as needed.</p>
<p class="rubric">lbdex/chapters/Chapter9_2/Cpu0InstrInfo.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Cpu0InstrInfo</span><span class="p">::</span><span class="n">Cpu0InstrInfo</span><span class="p">(</span><span class="n">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span>
    <span class="p">:</span> 
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>      <span class="n">Cpu0GenInstrInfo</span><span class="p">(</span><span class="n">Cpu0</span><span class="p">::</span><span class="n">ADJCALLSTACKDOWN</span><span class="p">,</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">ADJCALLSTACKUP</span><span class="p">),</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_2/Cpu0FrameLowering.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">MachineBasicBlock</span><span class="p">::</span><span class="n">iterator</span>
  <span class="n">eliminateCallFramePseudoInstr</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                  <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span>
                                  <span class="n">MachineBasicBlock</span><span class="p">::</span><span class="n">iterator</span> <span class="n">I</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_2/Cpu0FrameLowering.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Eliminate</span> <span class="n">ADJCALLSTACKDOWN</span><span class="p">,</span> <span class="n">ADJCALLSTACKUP</span> <span class="n">pseudo</span> <span class="n">instructions</span>
<span class="n">MachineBasicBlock</span><span class="p">::</span><span class="n">iterator</span> <span class="n">Cpu0FrameLowering</span><span class="p">::</span>
<span class="n">eliminateCallFramePseudoInstr</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span> <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span>
                              <span class="n">MachineBasicBlock</span><span class="p">::</span><span class="n">iterator</span> <span class="n">I</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
  <span class="k">return</span> <span class="n">MBB</span><span class="o">.</span><span class="n">erase</span><span class="p">(</span><span class="n">I</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="read-lowercall-with-graphviz-s-help">
<h3><a class="toc-backref" href="#id36" role="doc-backlink">Read LowerCall() with Graphviz’s Help</a><a class="headerlink" href="#read-lowercall-with-graphviz-s-help" title="Permalink to this heading">¶</a></h3>
<p>The complete DAGs created for outgoing arguments are shown in
<a class="reference internal" href="#funccall-f-outgoing-arg"><span class="std std-numref">Fig. 45</span></a> for <cite>ch9_outgoing.cpp</cite> with <cite>cpu032I</cite>.</p>
<p>The <cite>LowerCall()</cite> function (excluding the call to <cite>LowerCallResult()</cite>) will
generate the DAG nodes shown in <a class="reference internal" href="#funccall-f-outgoing-arg-lowercal"><span class="std std-numref">Fig. 46</span></a> for
<cite>ch9_outgoing.cpp</cite> with <cite>cpu032I</cite>.</p>
<p>The corresponding code for the DAG nodes <cite>Store</cite> and <cite>TargetGlobalAddress</cite> is
listed in the figures. Users can match other DAG nodes to the <cite>LowerCall()</cite>
function code accordingly.</p>
<p>By using the Graphviz tool with the <cite>llc</cite> option <cite>-view-dag-combine1-dags</cite>, you
can design a small input in C or LLVM IR, then inspect the DAGs to better
understand the behavior of <cite>LowerCall()</cite> and <cite>LowerFormalArguments()</cite>.</p>
<p>In the later sub-sections, “Variable Arguments” and “Dynamic Stack Allocation
Support”, you can create input examples that demonstrate these features. You
can then use the DAGs to confirm your understanding of the logic in these two
functions.</p>
<p>For more information about Graphviz, refer to the section
“Display LLVM IR Nodes with Graphviz” in Chapter 4, <em>Arithmetic and Logic
Instructions</em>.</p>
<p>The DAG diagrams can be generated using the <cite>llc</cite> option as shown below:</p>
<p class="rubric">lbdex/input/ch9_outgoing.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="nb">int</span> <span class="n">sum_i</span><span class="p">(</span><span class="nb">int</span> <span class="n">x1</span><span class="p">);</span>

<span class="nb">int</span> <span class="n">call_sum_i</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">sum_i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>clang -O3 -target mips-unknown-linux-gnu -c
<span class="go">ch9_outgoing.cpp -emit-llvm -o ch9_outgoing.bc</span>
<span class="gp">JonathantekiiMac:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llvm-dis ch9_outgoing.bc -o -</span>
<span class="go">...</span>
<span class="go">define i32 @_Z10call_sum_iv() #0 {</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> tail call i32 @_Z5sum_ii<span class="o">(</span>i32 <span class="m">1</span><span class="o">)</span>
<span class="go">  ret i32 %1</span>
<span class="go">}</span>
<span class="gp">JonathantekiiMac:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llc -march=cpu0 -mcpu=cpu032I -view-dag-combine1-dags -relocation-</span>
<span class="go">model=static -filetype=asm ch9_outgoing.bc -o -</span>
<span class="go">      .text</span>
<span class="go">      .section .mdebug.abiS32</span>
<span class="go">      .previous</span>
<span class="go">      .file   &quot;ch9_outgoing.bc&quot;</span>
<span class="go">Writing &#39;/var/folders/rf/8bgdgt9d6vgf5sn8h8_zycd00000gn/T/dag._Z10call_sum_iv-</span>
<span class="go">0dfaf1.dot&#39;...  done.</span>
<span class="go">Running &#39;Graphviz&#39; program...</span>
</pre></div>
</div>
<figure class="align-default" id="id24">
<span id="funccall-f-outgoing-arg"></span><div class="graphviz"><img src="_images/graphviz-4bab04056f0c8678f4ddca429fd5281c5cdf9e78.png" alt="digraph &quot;dag-combine1 input for _Z10call_sum_iv:&quot; {
	rankdir=&quot;BT&quot;;
//	label=&quot;Figure Outgoing arguments DAG (A) created for ch9_outgoing.cpp with -cpu0-s32-calls=true&quot;;

  subgraph cluster_0 {
    fontcolor=red;
    fontsize=24;
    label = &quot;LowerCall&quot;;
	Node0x102f0d060 [shape=record,shape=Mrecord,label=&quot;{EntryToken|t0|{&lt;d0&gt;ch}}&quot;];
	Node0x10304f200 [shape=record,shape=Mrecord,label=&quot;{GlobalAddress\&lt;i32 (i32)* &#64;_Z5sum_ii\&gt; 0|t1|{&lt;d0&gt;i32}}&quot;];
	Node0x10304f270 [shape=record,shape=Mrecord,label=&quot;{Constant\&lt;1\&gt;|t2|{&lt;d0&gt;i32}}&quot;];
	Node0x10304f2e0 [shape=record,shape=Mrecord,label=&quot;{TargetConstant\&lt;8\&gt;|t3|{&lt;d0&gt;i32}}&quot;];
	Node0x10304f350 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1}|callseq_start|t4|{&lt;d0&gt;ch|&lt;d1&gt;glue}}&quot;];
	Node0x10304f350:s0 -&gt; Node0x102f0d060:d0[color=blue,style=dashed];
	Node0x10304f350:s1 -&gt; Node0x10304f2e0:d0;
	Node0x10304f3c0 [shape=record,shape=Mrecord,label=&quot;{Register %SP|t5|{&lt;d0&gt;i32}}&quot;];
	Node0x10304f430 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1}|CopyFromReg|t6|{&lt;d0&gt;i32|&lt;d1&gt;ch}}&quot;];
	Node0x10304f430:s0 -&gt; Node0x10304f350:d0[color=blue,style=dashed];
	Node0x10304f430:s1 -&gt; Node0x10304f3c0:d0;
	Node0x10304f4a0 [shape=record,shape=Mrecord,label=&quot;{Constant\&lt;0\&gt;|t7|{&lt;d0&gt;i32}}&quot;];
	Node0x10304f510 [shape=record,shape=Mrecord,label=&quot;{undef|t8|{&lt;d0&gt;i32}}&quot;];
	Node0x10304f580 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1|&lt;s2&gt;2|&lt;s3&gt;3}|store\&lt;ST4[\&lt;unknown\&gt;]\&gt;|t9|{&lt;d0&gt;ch}}&quot;];
	Node0x10304f580:s0 -&gt; Node0x10304f350:d0[color=blue,style=dashed];
	Node0x10304f580:s1 -&gt; Node0x10304f270:d0;
	Node0x10304f580:s2 -&gt; Node0x10304f430:d0;
	Node0x10304f580:s3 -&gt; Node0x10304f510:d0;
	Node0x10304f5f0 [shape=record,shape=Mrecord,label=&quot;{TargetGlobalAddress\&lt;i32 (i32)* &#64;_Z5sum_ii\&gt; 0|t10|{&lt;d0&gt;i32}}&quot;];
	Node0x10304f660 [shape=record,shape=Mrecord,label=&quot;{RegisterMask|t11|{&lt;d0&gt;Untyped}}&quot;];
	Node0x10304f6d0 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1|&lt;s2&gt;2}|Cpu0ISD::JmpLink|t12|{&lt;d0&gt;ch|&lt;d1&gt;glue}}&quot;];
	Node0x10304f6d0:s0 -&gt; Node0x10304f580:d0[color=blue,style=dashed];
	Node0x10304f6d0:s1 -&gt; Node0x10304f5f0:d0;
	Node0x10304f6d0:s2 -&gt; Node0x10304f660:d0;
	Node0x10304f740 [shape=record,shape=Mrecord,label=&quot;{TargetConstant\&lt;0\&gt;|t13|{&lt;d0&gt;i32}}&quot;];
	Node0x10304f7b0 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1|&lt;s2&gt;2|&lt;s3&gt;3}|callseq_end|t14|{&lt;d0&gt;ch|&lt;d1&gt;glue}}&quot;];
	Node0x10304f7b0:s0 -&gt; Node0x10304f6d0:d0[color=blue,style=dashed];
	Node0x10304f7b0:s1 -&gt; Node0x10304f2e0:d0;
	Node0x10304f7b0:s2 -&gt; Node0x10304f740:d0;
	Node0x10304f7b0:s3 -&gt; Node0x10304f6d0:d1[color=red,style=bold];
  }
  subgraph cluster_1 {
    fontcolor=red;
    fontsize=24;
    label = &quot;LowerCallResult&quot;;
	Node0x10304f820 [shape=record,shape=Mrecord,label=&quot;{Register %V0|t15|{&lt;d0&gt;i32}}&quot;];
	Node0x10304f890 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1|&lt;s2&gt;2}|CopyFromReg|t16|{&lt;d0&gt;i32|&lt;d1&gt;ch|&lt;d2&gt;glue}}&quot;];
  }
  subgraph cluster_2 {
    fontcolor=red;
    fontsize=24;
    label = &quot;LowerReturn&quot;;
	Node0x10304f900 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1|&lt;s2&gt;2}|CopyToReg|t17|{&lt;d0&gt;ch|&lt;d1&gt;glue}}&quot;];
	Node0x10304f970 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1|&lt;s2&gt;2}|Cpu0ISD::Ret|t18|{&lt;d0&gt;ch}}&quot;];
  }
	Node0x10304f890:s0 -&gt; Node0x10304f7b0:d0[color=blue,style=dashed];
	Node0x10304f890:s1 -&gt; Node0x10304f820:d0;
	Node0x10304f890:s2 -&gt; Node0x10304f7b0:d1[color=red,style=bold];
	
	Node0x10304f900:s0 -&gt; Node0x10304f890:d1[color=blue,style=dashed];
	Node0x10304f900:s1 -&gt; Node0x10304f820:d0;
	Node0x10304f900:s2 -&gt; Node0x10304f890:d0;
	Node0x10304f970:s0 -&gt; Node0x10304f900:d0[color=blue,style=dashed];
	Node0x10304f970:s1 -&gt; Node0x10304f820:d0;
	Node0x10304f970:s2 -&gt; Node0x10304f900:d1[color=red,style=bold];
	
	Node0x0[ plaintext=circle, label =&quot;GraphRoot&quot;];
	Node0x0 -&gt; Node0x10304f970:d0[color=blue,style=dashed];
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 45 </span><span class="caption-text">Outgoing arguments DAG (A) created for ch9_outgoing.cpp with -cpu0-s32-calls=true</span><a class="headerlink" href="#id24" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-default" id="id25">
<span id="funccall-f-outgoing-arg-lowercal"></span><div class="graphviz"><img src="_images/graphviz-3f2cd9c911822e88656a7485f455c111dceec68e.png" alt="digraph &quot;isel input for _Z10call_sum_iv:&quot; {
	rankdir=&quot;BT&quot;;
//	label=&quot;Figure Outgoing arguments DAG (B) created by LowerCall() for ch9_outgoing.cpp with -cpu0-s32-calls=true&quot;;
	Node0x102f0d060 [shape=record,shape=Mrecord,label=&quot;{EntryToken|t0|{&lt;d0&gt;ch}}&quot;];
	Node0x10304f270 [shape=record,shape=Mrecord,label=&quot;{Constant\&lt;1\&gt;|t2|{&lt;d0&gt;i32}}&quot;];
	Node0x10304f2e0 [shape=record,shape=Mrecord,label=&quot;{TargetConstant\&lt;8\&gt;|t3|{&lt;d0&gt;i32}}&quot;];
	Node0x10304f350 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1}|callseq_start|t4|{&lt;d0&gt;ch|&lt;d1&gt;glue}}&quot;];
	Node0x10304f350:s0 -&gt; Node0x102f0d060:d0[color=blue,style=dashed];
	Node0x10304f350:s1 -&gt; Node0x10304f2e0:d0;
	Node0x10304f3c0 [shape=record,shape=Mrecord,label=&quot;{Register %SP|t5|{&lt;d0&gt;i32}}&quot;];
	Node0x10304f430 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1}|CopyFromReg|t6|{&lt;d0&gt;i32|&lt;d1&gt;ch}}&quot;];
	Node0x10304f430:s0 -&gt; Node0x10304f350:d0[color=blue,style=dashed];
	Node0x10304f430:s1 -&gt; Node0x10304f3c0:d0;
	Node0x10304f510 [shape=record,shape=Mrecord,label=&quot;{undef|t8|{&lt;d0&gt;i32}}&quot;];
	Node0x10304f580 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1|&lt;s2&gt;2|&lt;s3&gt;3}|store\&lt;ST4[\&lt;unknown\&gt;]\&gt;|t9|{&lt;d0&gt;ch}}&quot;];
	Node0x10304f580:s0 -&gt; Node0x10304f350:d0[color=blue,style=dashed];
	Node0x10304f580:s1 -&gt; Node0x10304f270:d0;
	Node0x10304f580:s2 -&gt; Node0x10304f430:d0;
	Node0x10304f580:s3 -&gt; Node0x10304f510:d0;
	Node0x10304f5f0 [shape=record,shape=Mrecord,label=&quot;{TargetGlobalAddress\&lt;i32 (i32)* &#64;_Z5sum_ii\&gt; 0|t10|{&lt;d0&gt;i32}}&quot;];
	Node0x10304f660 [shape=record,shape=Mrecord,label=&quot;{RegisterMask|t11|{&lt;d0&gt;Untyped}}&quot;];
	Node0x10304f6d0 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1|&lt;s2&gt;2}|Cpu0ISD::JmpLink|t12|{&lt;d0&gt;ch|&lt;d1&gt;glue}}&quot;];
	Node0x10304f6d0:s0 -&gt; Node0x10304f580:d0[color=blue,style=dashed];
	Node0x10304f6d0:s1 -&gt; Node0x10304f5f0:d0;
	Node0x10304f6d0:s2 -&gt; Node0x10304f660:d0;
	Node0x10304f740 [shape=record,shape=Mrecord,label=&quot;{TargetConstant\&lt;0\&gt;|t13|{&lt;d0&gt;i32}}&quot;];
	Node0x10304f7b0 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1|&lt;s2&gt;2|&lt;s3&gt;3}|callseq_end|t14|{&lt;d0&gt;ch|&lt;d1&gt;glue}}&quot;];
	Node0x10304f7b0:s0 -&gt; Node0x10304f6d0:d0[color=blue,style=dashed];
	Node0x10304f7b0:s1 -&gt; Node0x10304f2e0:d0;
	Node0x10304f7b0:s2 -&gt; Node0x10304f740:d0;
	Node0x10304f7b0:s3 -&gt; Node0x10304f6d0:d1[color=red,style=bold];
	
    NodeComment1 [ penwidth = 1, fontname = &quot;Courier New&quot;, shape = &quot;note&quot;, label =&lt;&lt;table border=&quot;0&quot; cellborder=&quot;0&quot; cellpadding=&quot;3&quot; bgcolor=&quot;gray&quot;&gt;
      &lt;tr&gt;&lt;td align=&quot;left&quot;&gt;// Transform all store nodes into one single node because all store&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td align=&quot;left&quot; port=&quot;f1&quot;&gt;// nodes are independent of each other.&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td align=&quot;left&quot; port=&quot;f2&quot;&gt;if (!MemOpChains.empty())&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td align=&quot;left&quot; port=&quot;f3&quot;&gt;  Chain = DAG.getNode(ISD::TokenFactor, DL, MVT::Other, MemOpChains);&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td align=&quot;left&quot;&gt;  ...&lt;/td&gt;&lt;/tr&gt;
      &lt;/table&gt;&gt; ];
      
    NodeComment2 [ penwidth = 1, fontname = &quot;Courier New&quot;, shape = &quot;note&quot;, label =&lt;&lt;table border=&quot;0&quot; cellborder=&quot;0&quot; cellpadding=&quot;3&quot; bgcolor=&quot;gray&quot;&gt;
      &lt;tr&gt;&lt;td align=&quot;left&quot;&gt;if (!IsPIC) // static&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td align=&quot;left&quot; port=&quot;f1&quot;&gt;  Callee = DAG.getTargetExternalSymbol(Sym,&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td align=&quot;left&quot; port=&quot;f2&quot;&gt;                                       getPointerTy(DAG.getDataLayout()),&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td align=&quot;left&quot; port=&quot;f3&quot;&gt;                                       Cpu0II::MO_NO_FLAG);&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td align=&quot;left&quot;&gt;  ...&lt;/td&gt;&lt;/tr&gt;
      &lt;/table&gt;&gt; ];
      
    Node0x10304f580 -&gt; NodeComment1[color=black,style=dashed];
    NodeComment2:n -&gt; Node0x10304f6d0:e[color=black,style=dashed];
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 46 </span><span class="caption-text">Outgoing arguments DAG (B) created by LowerCall() for ch9_outgoing.cpp with -cpu0-s32-calls=true</span><a class="headerlink" href="#id25" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>As mentioned in the previous section, the option <code class="docutils literal notranslate"><span class="pre">llc</span> <span class="pre">-cpu0-s32-calls=true</span></code>
uses the S32 calling convention, which passes all arguments in registers.</p>
<p>In contrast, the option <code class="docutils literal notranslate"><span class="pre">llc</span> <span class="pre">-cpu0-s32-calls=false</span></code> uses the O32 convention,
which passes the first two arguments in registers and the remaining arguments
on the stack.</p>
<p>The resulting behavior is shown as follows:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-78-230:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llc -march=cpu0 -mcpu=cpu032I -cpu0-s32-calls=true</span>
<span class="go">-relocation-model=pic -filetype=asm ch9_1.bc -o -</span>
<span class="go">        .text</span>
<span class="go">        .section .mdebug.abiS32</span>
<span class="go">        .previous</span>
<span class="go">        .file &quot;ch9_1.bc&quot;</span>
<span class="go">        .globl        _Z5sum_iiiiiii</span>
<span class="go">        .align        2</span>
<span class="go">        .type _Z5sum_iiiiiii,@function</span>
<span class="go">        .ent  _Z5sum_iiiiiii          # @_Z5sum_iiiiiii</span>
<span class="go">_Z5sum_iiiiiii:</span>
<span class="go">        .frame        $fp,32,$lr</span>
<span class="go">        .mask         0x00000000,0</span>
<span class="go">        .set  noreorder</span>
<span class="go">        .cpload       $t9</span>
<span class="go">        .set  nomacro</span>
<span class="gp"># </span>BB#0:
<span class="go">        addiu $sp, $sp, -32</span>
<span class="go">        ld    $2, 52($sp)</span>
<span class="go">        ld    $3, 48($sp)</span>
<span class="go">        ld    $4, 44($sp)</span>
<span class="go">        ld    $5, 40($sp)</span>
<span class="go">        ld    $t9, 36($sp)</span>
<span class="go">        ld    $7, 32($sp)</span>
<span class="go">        st    $7, 28($sp)</span>
<span class="go">        st    $t9, 24($sp)</span>
<span class="go">        st    $5, 20($sp)</span>
<span class="go">        st    $4, 16($sp)</span>
<span class="go">        st    $3, 12($sp)</span>
<span class="go">        lui   $3, %got_hi(gI)</span>
<span class="go">        addu  $3, $3, $gp</span>
<span class="go">        st    $2, 8($sp)</span>
<span class="go">        ld    $3, %got_lo(gI)($3)</span>
<span class="go">        ld    $3, 0($3)</span>
<span class="go">        ld    $4, 28($sp)</span>
<span class="go">        addu  $3, $3, $4</span>
<span class="go">        ld    $4, 24($sp)</span>
<span class="go">        addu  $3, $3, $4</span>
<span class="go">        ld    $4, 20($sp)</span>
<span class="go">        addu  $3, $3, $4</span>
<span class="go">        ld    $4, 16($sp)</span>
<span class="go">        addu  $3, $3, $4</span>
<span class="go">        ld    $4, 12($sp)</span>
<span class="go">        addu  $3, $3, $4</span>
<span class="go">        addu  $2, $3, $2</span>
<span class="go">        st    $2, 4($sp)</span>
<span class="go">        addiu $sp, $sp, 32</span>
<span class="go">        ret   $lr</span>
<span class="go">        nop</span>
<span class="go">        .set  macro</span>
<span class="go">        .set  reorder</span>
<span class="go">        .end  _Z5sum_iiiiiii</span>
<span class="gp">$</span>tmp0:
<span class="go">        .size _Z5sum_iiiiiii, ($tmp0)-_Z5sum_iiiiiii</span>

<span class="go">        .globl        main</span>
<span class="go">        .align        2</span>
<span class="go">        .type main,@function</span>
<span class="go">        .ent  main                    # @main</span>
<span class="go">main:</span>
<span class="go">        .frame        $fp,40,$lr</span>
<span class="go">        .mask         0x00004000,-4</span>
<span class="go">        .set  noreorder</span>
<span class="go">        .cpload       $t9</span>
<span class="go">        .set  nomacro</span>
<span class="gp"># </span>BB#0:
<span class="go">        addiu $sp, $sp, -40</span>
<span class="go">        st    $lr, 36($sp)            # 4-byte Folded Spill</span>
<span class="go">        addiu $2, $zero, 0</span>
<span class="go">        st    $2, 32($sp)</span>
<span class="go">        addiu $2, $zero, 6</span>
<span class="go">        st    $2, 20($sp)</span>
<span class="go">        addiu $2, $zero, 5</span>
<span class="go">        st    $2, 16($sp)</span>
<span class="go">        addiu $2, $zero, 4</span>
<span class="go">        st    $2, 12($sp)</span>
<span class="go">        addiu $2, $zero, 3</span>
<span class="go">        st    $2, 8($sp)</span>
<span class="go">        addiu $2, $zero, 2</span>
<span class="go">        st    $2, 4($sp)</span>
<span class="go">        addiu $2, $zero, 1</span>
<span class="go">        st    $2, 0($sp)</span>
<span class="go">        ld    $t9, %call16(_Z5sum_iiiiiii)($gp)</span>
<span class="go">        jalr  $t9</span>
<span class="go">        nop</span>
<span class="go">        st    $2, 28($sp)</span>
<span class="go">        ld    $lr, 36($sp)            # 4-byte Folded Reload</span>
<span class="go">        addiu $sp, $sp, 40</span>
<span class="go">        ret   $lr</span>
<span class="go">        nop</span>
<span class="go">        .set  macro</span>
<span class="go">        .set  reorder</span>
<span class="go">        .end  main</span>
<span class="gp">$</span>tmp1:
<span class="go">        .size main, ($tmp1)-main</span>

<span class="go">        .type gI,@object              # @gI</span>
<span class="go">        .data</span>
<span class="go">        .globl        gI</span>
<span class="go">        .align        2</span>
<span class="go">gI:</span>
<span class="go">        .4byte        100                     # 0x64</span>
<span class="go">        .size gI, 4</span>

<span class="gp">118-165-78-230:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llc -march=cpu0 -mcpu=cpu032II -cpu0-s32-calls=false</span>
<span class="go">-relocation-model=pic -filetype=asm ch9_1.bc -o -</span>
<span class="go">  ...</span>
<span class="go">        .globl        main</span>
<span class="go">        .align        2</span>
<span class="go">        .type main,@function</span>
<span class="go">        .ent  main                    # @main</span>
<span class="go">main:</span>
<span class="go">        .frame        $fp,40,$lr</span>
<span class="go">        .mask         0x00004000,-4</span>
<span class="go">        .set  noreorder</span>
<span class="go">        .cpload       $t9</span>
<span class="go">        .set  nomacro</span>
<span class="gp"># </span>BB#0:
<span class="go">        addiu $sp, $sp, -40</span>
<span class="go">        st    $lr, 36($sp)            # 4-byte Folded Spill</span>
<span class="go">        addiu $2, $zero, 0</span>
<span class="go">        st    $2, 32($sp)</span>
<span class="go">        addiu $2, $zero, 6</span>
<span class="go">        st    $2, 20($sp)</span>
<span class="go">        addiu $2, $zero, 5</span>
<span class="go">        st    $2, 16($sp)</span>
<span class="go">        addiu $2, $zero, 4</span>
<span class="go">        st    $2, 12($sp)</span>
<span class="go">        addiu $2, $zero, 3</span>
<span class="go">        st    $2, 8($sp)</span>
<span class="go">        ld    $t9, %call16(_Z5sum_iiiiiii)($gp)</span>
<span class="go">        addiu $4, $zero, 1</span>
<span class="go">        addiu $5, $zero, 2</span>
<span class="go">        jalr  $t9</span>
<span class="go">        nop</span>
<span class="go">        st    $2, 28($sp)</span>
<span class="go">        ld    $lr, 36($sp)            # 4-byte Folded Reload</span>
<span class="go">        addiu $sp, $sp, 40</span>
<span class="go">        ret   $lr</span>
<span class="go">        nop</span>
<span class="go">        .set  macro</span>
<span class="go">        .set  reorder</span>
<span class="go">        .end  main</span>
</pre></div>
</div>
</section>
<section id="long-and-short-string-initialization">
<h3><a class="toc-backref" href="#id37" role="doc-backlink">Long and Short String Initialization</a><a class="headerlink" href="#long-and-short-string-initialization" title="Permalink to this heading">¶</a></h3>
<p>In the previous section, we mentioned the <cite>JSUB texternalsym</cite> pattern.</p>
<p>Run <cite>Chapter9_2</cite> with <cite>ch9_1_2.cpp</cite> to observe the following results:</p>
<p>For a long string, LLVM generates a call to <cite>memcpy()</cite> to initialize the
string—for example, <cite>char str[81] = “Hello world”</cite>.</p>
<p>For a short string, the <cite>call memcpy</cite> is optimized and translated into a
direct <cite>store</cite> with a constant value during the optimization stages.</p>
<p class="rubric">lbdex/input/ch9_1_2.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">char</span> <span class="nb">str</span><span class="p">[</span><span class="mi">81</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Hello world&quot;</span><span class="p">;</span>
  <span class="n">char</span> <span class="n">s</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Hello&quot;</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>llvm-dis ch9_1_2.bc -o -
<span class="go">; ModuleID = &#39;ch9_1_2.bc&#39;</span>
<span class="go">...</span>
<span class="go">@_ZZ4mainE3str = private unnamed_addr constant [81 x i8] c&quot;Hello world\00\00\00\</span>
<span class="go">00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00</span>
<span class="go">\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\0</span>
<span class="go">0\00\00\00\00\00\00\00\00\00\00\00\00\00&quot;, align 1</span>
<span class="go">@_ZZ4mainE1s = private unnamed_addr constant [6 x i8] c&quot;Hello\00&quot;, align 1</span>

<span class="go">; Function Attrs: nounwind</span>
<span class="go">define i32 @main() #0 {</span>
<span class="go">entry:</span>
<span class="gp">  %</span><span class="nv">retval</span> <span class="o">=</span> alloca i32, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">str</span> <span class="o">=</span> alloca <span class="o">[</span><span class="m">81</span> x i8<span class="o">]</span>, align <span class="m">1</span>
<span class="go">  store i32 0, i32* %retval</span>
<span class="gp">  %</span><span class="nv">0</span> <span class="o">=</span> bitcast <span class="o">[</span><span class="m">81</span> x i8<span class="o">]</span>* %str to i8*
<span class="go">  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %0, i8* getelementptr inbounds</span>
<span class="go">  ([81 x i8]* @_ZZ4mainE3str, i32 0, i32 0), i32 81, i32 1, i1 false)</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> bitcast <span class="o">[</span><span class="m">6</span> x i8<span class="o">]</span>* %s to i8*
<span class="go">  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %1, i8* getelementptr inbounds</span>
<span class="go">  ([6 x i8]* @_ZZ4mainE1s, i32 0, i32 0), i32 6, i32 1, i1 false)</span>

<span class="go">  ret i32 0</span>
<span class="go">}</span>

<span class="gp">JonathantekiiMac:input Jonathan$ </span>clang -target mips-unknown-linux-gnu -c
<span class="go">ch9_1_2.cpp -emit-llvm -o ch9_1_2.bc</span>
<span class="gp">JonathantekiiMac:input Jonathan$ </span>/Users/Jonathan/llvm/test/build
<span class="go">/bin/llc -march=cpu0 -mcpu=cpu032II -cpu0-s32-calls=true</span>
<span class="go">-relocation-model=static -filetype=asm ch9_1_2.bc -o -</span>
<span class="go">  .section .mdebug.abi32</span>
<span class="go">  ...</span>
<span class="go">        lui   $2, %hi($_ZZ4mainE3str)</span>
<span class="go">        ori   $2, $2, %lo($_ZZ4mainE3str)</span>
<span class="go">        st    $2, 4($sp)</span>
<span class="go">        addiu $2, $sp, 24</span>
<span class="go">        st    $2, 0($sp)</span>
<span class="go">        jsub  memcpy</span>
<span class="go">        nop</span>
<span class="go">        lui   $2, %hi($_ZZ4mainE1s)</span>
<span class="go">        ori   $2, $2, %lo($_ZZ4mainE1s)</span>
<span class="go">        lbu   $3, 4($2)</span>
<span class="go">        shl   $3, $3, 8</span>
<span class="go">        lbu   $4, 5($2)</span>
<span class="go">        or    $3, $3, $4</span>
<span class="go">        sh    $3, 20($sp)</span>
<span class="go">        lbu   $3, 2($2)</span>
<span class="go">        shl   $3, $3, 8</span>
<span class="go">        lbu   $4, 3($2)</span>
<span class="go">        or    $3, $3, $4</span>
<span class="go">        lbu   $4, 1($2)</span>
<span class="go">        lbu   $2, 0($2)</span>
<span class="go">        shl   $2, $2, 8</span>
<span class="go">        or    $2, $2, $4</span>
<span class="go">        shl   $2, $2, 16</span>
<span class="go">        or    $2, $2, $3</span>
<span class="go">        st    $2, 16($sp)</span>
<span class="go">  ...</span>
<span class="go">      .type   $_ZZ4mainE3str,@object  # @_ZZ4mainE3str</span>
<span class="go">      .section        .rodata,&quot;a&quot;,@progbits</span>
<span class="gp">$</span>_ZZ4mainE3str:
<span class="go">        .asciz        &quot;Hello world\000\000\000\000\000\000\000\000\000\000\000\000\000\000</span>
<span class="go">  \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000</span>
<span class="go">  \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000</span>
<span class="go">  \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000&quot;</span>
<span class="go">        .size $_ZZ4mainE3str, 81</span>

<span class="go">        .type $_ZZ4mainE1s,@object    # @_ZZ4mainE1s</span>
<span class="go">        .section      .rodata.str1.1,&quot;aMS&quot;,@progbits,1</span>
<span class="gp">$</span>_ZZ4mainE1s:
<span class="go">        .asciz        &quot;Hello&quot;</span>
<span class="go">        .size $_ZZ4mainE1s, 6</span>
</pre></div>
</div>
<p>The <cite>call memcpy</cite> for a short string is optimized by LLVM before the
“DAG-to-DAG Pattern Instruction Selection” stage.</p>
<p>It is translated into a <cite>store</cite> with a constant value, as shown below:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>/Users/Jonathan/llvm/test/build
<span class="go">/bin/llc -march=cpu0 -mcpu=cpu032II -cpu0-s32-calls=true</span>
<span class="go">-relocation-model=static -filetype=asm ch9_1_2.bc -debug -o -</span>

<span class="go">Initial selection DAG: BB#0 &#39;main:entry&#39;</span>
<span class="go">SelectionDAG has 35 nodes:</span>
<span class="go">  ...</span>
<span class="go">        0x7fd909030810: &lt;multiple use&gt;</span>
<span class="go">        0x7fd909030c10: i32 = Constant&lt;1214606444&gt;  // 1214606444=0x48656c6c=&quot;Hell&quot;</span>

<span class="go">        0x7fd909030910: &lt;multiple use&gt;</span>
<span class="go">        0x7fd90902d810: &lt;multiple use&gt;</span>
<span class="go">      0x7fd909030d10: ch = store 0x7fd909030810, 0x7fd909030c10, 0x7fd909030910,</span>
<span class="go">      0x7fd90902d810&lt;ST4[%1]&gt;</span>

<span class="go">        0x7fd909030810: &lt;multiple use&gt;</span>
<span class="go">        0x7fd909030e10: i16 = Constant&lt;28416&gt;      // 28416=0x6f00=&quot;o\0&quot;</span>

<span class="go">        ...</span>

<span class="go">        0x7fd90902d810: &lt;multiple use&gt;</span>
<span class="go">      0x7fd909031210: ch = store 0x7fd909030810, 0x7fd909030e10, 0x7fd909031010,</span>
<span class="go">      0x7fd90902d810&lt;ST2[%1+4](align=4)&gt;</span>
<span class="go">  ...</span>
</pre></div>
</div>
<p>The incoming arguments refer to the <em>formal arguments</em> as defined in compiler
and programming language literature. The outgoing arguments refer to the
<em>actual arguments</em> passed during a function call.</p>
<p>Summary as Table: Callee incoming arguments and caller outgoing arguments.</p>
<table class="docutils align-default" id="id26">
<caption><span class="caption-number">Table 35 </span><span class="caption-text">Callee incoming arguments and caller outgoing arguments</span><a class="headerlink" href="#id26" title="Permalink to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Description</p></th>
<th class="head"><p>Callee</p></th>
<th class="head"><p>Caller</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Charged Function</p></td>
<td><p>LowerFormalArguments()</p></td>
<td><p>LowerCall()</p></td>
</tr>
<tr class="row-odd"><td><p>Charged Function Created</p></td>
<td><p>Create load vectors for incoming arguments</p></td>
<td><p>Create store vectors for outgoing arguments</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="structure-type-support">
<h2><a class="toc-backref" href="#id38" role="doc-backlink">Structure Type Support</a><a class="headerlink" href="#structure-type-support" title="Permalink to this heading">¶</a></h2>
<section id="ordinary-struct-type">
<h3><a class="toc-backref" href="#id39" role="doc-backlink">Ordinary Struct Type</a><a class="headerlink" href="#ordinary-struct-type" title="Permalink to this heading">¶</a></h3>
<p>The following code in <cite>Chapter9_1/</cite> and <cite>Chapter3_4/</cite> supports ordinary
structure types in function calls.</p>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0ISelLowering.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">///</span> <span class="n">LowerFormalArguments</span> <span class="o">-</span> <span class="n">transform</span> <span class="n">physical</span> <span class="n">registers</span> <span class="n">into</span> <span class="n">virtual</span> <span class="n">registers</span>
<span class="o">///</span> <span class="ow">and</span> <span class="n">generate</span> <span class="n">load</span> <span class="n">operations</span> <span class="k">for</span> <span class="n">arguments</span> <span class="n">places</span> <span class="n">on</span> <span class="n">the</span> <span class="n">stack</span><span class="o">.</span>
<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">LowerFormalArguments</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span>
                                         <span class="n">CallingConv</span><span class="p">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span>
                                         <span class="nb">bool</span> <span class="n">IsVarArg</span><span class="p">,</span>
                                         <span class="n">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="p">::</span><span class="n">InputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ins</span><span class="p">,</span>
                                         <span class="n">const</span> <span class="n">SDLoc</span> <span class="o">&amp;</span><span class="n">DL</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span>
                                         <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span>
                                          <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  for (unsigned i = 0, e = ArgLocs.size(); i != e; ++i) {
    // The cpu0 ABIs for returning structs by value requires that we copy
    // the sret argument into $v0 for the return. Save the argument into
    // a virtual register so that we can access it from the return points.
    if (Ins[i].Flags.isSRet()) {
      unsigned Reg = Cpu0FI-&gt;getSRetReturnReg();
      if (!Reg) {
        Reg = MF.getRegInfo().createVirtualRegister(
            getRegClassFor(MVT::i32));
        Cpu0FI-&gt;setSRetReturnReg(Reg);
      }
      SDValue Copy = DAG.getCopyToReg(DAG.getEntryNode(), DL, Reg, InVals[i]);
      Chain = DAG.getNode(ISD::TokenFactor, DL, MVT::Other, Copy, Chain);
      break;
    }
  }
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">LowerReturn</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span>
                                <span class="n">CallingConv</span><span class="p">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">IsVarArg</span><span class="p">,</span>
                                <span class="n">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="p">::</span><span class="n">OutputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Outs</span><span class="p">,</span>
                                <span class="n">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">OutVals</span><span class="p">,</span>
                                <span class="n">const</span> <span class="n">SDLoc</span> <span class="o">&amp;</span><span class="n">DL</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  // The cpu0 ABIs for returning structs by value requires that we copy
  // the sret argument into $v0 for the return. We saved the argument into
  // a virtual register in the entry block, so now we copy the value out
  // and into $v0.
  if (MF.getFunction().hasStructRetAttr()) {
    Cpu0FunctionInfo *Cpu0FI = MF.getInfo&lt;Cpu0FunctionInfo&gt;();
    unsigned Reg = Cpu0FI-&gt;getSRetReturnReg();

    if (!Reg)
      llvm_unreachable(&quot;sret virtual register not created in the entry block&quot;);
    SDValue Val =
        DAG.getCopyFromReg(Chain, DL, Reg, getPointerTy(DAG.getDataLayout()));
    unsigned V0 = Cpu0::V0;

    Chain = DAG.getCopyToReg(Chain, DL, V0, Val, Flag);
    Flag = Chain.getValue(1);
    RetOps.push_back(DAG.getRegister(V0, getPointerTy(DAG.getDataLayout())));
  }
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>In addition to the code above, we defined the calling convention in an earlier
chapter as follows:</p>
<p class="rubric">lbdex/chapters/Chapter3_4/Cpu0CallingConv.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">RetCC_Cpu0EABI</span> <span class="p">:</span> <span class="n">CallingConv</span><span class="o">&lt;</span><span class="p">[</span>
  <span class="o">//</span> <span class="n">i32</span> <span class="n">are</span> <span class="n">returned</span> <span class="ow">in</span> <span class="n">registers</span> <span class="n">V0</span><span class="p">,</span> <span class="n">V1</span><span class="p">,</span> <span class="n">A0</span><span class="p">,</span> <span class="n">A1</span>
  <span class="n">CCIfType</span><span class="o">&lt;</span><span class="p">[</span><span class="n">i32</span><span class="p">],</span> <span class="n">CCAssignToReg</span><span class="o">&lt;</span><span class="p">[</span><span class="n">V0</span><span class="p">,</span> <span class="n">V1</span><span class="p">,</span> <span class="n">A0</span><span class="p">,</span> <span class="n">A1</span><span class="p">]</span><span class="o">&gt;&gt;</span>
<span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>This means that for the return value, we store it in registers <cite>V0</cite>, <cite>V1</cite>, <cite>A0</cite>,
and <cite>A1</cite> if the size of the return value does not exceed four registers.</p>
<p>If it exceeds four registers, Cpu0 will store the value in memory and return a
pointer to that memory in a register.</p>
<p>For demonstration, let’s run <cite>Chapter9_2/</cite> with <cite>ch9_1_struct.cpp</cite> and explain
using this example.</p>
<p class="rubric">lbdex/input/ch9_1_struct.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>extern &quot;C&quot; int printf(const char *format, ...);

struct Date
{
  int year;
  int month;
  int day;
  int hour;
  int minute;
  int second;
};
static Date gDate = {2012, 10, 12, 1, 2, 3};

struct Time
{
  int hour;
  int minute;
  int second;
};
static Time gTime = {2, 20, 30};

static Date getDate()
{ 
  return gDate;
}

static Date copyDate(Date date)
{ 
  return date;
}

static Date copyDate(Date* date)
{ 
  return *date;
}

static Time copyTime(Time time)
{ 
  return time;
}

static Time copyTime(Time* time)
{ 
  return *time;
}

int test_func_arg_struct()
{
  Time time1 = {1, 10, 12};
  Date date1 = getDate();
  Date date2 = copyDate(date1);
  Date date3 = copyDate(&amp;date1);
  Time time2 = copyTime(time1);
  Time time3 = copyTime(&amp;time1);
  if (!(date1.year == 2012 &amp;&amp; date1.month == 10 &amp;&amp; date1.day == 12 &amp;&amp; date1.hour 
      == 1 &amp;&amp; date1.minute == 2 &amp;&amp; date1.second == 3))
    return 1;
  if (!(date2.year == 2012 &amp;&amp; date2.month == 10 &amp;&amp; date2.day == 12 &amp;&amp; date2.hour 
      == 1 &amp;&amp; date2.minute == 2 &amp;&amp; date2.second == 3))
    return 1;
  if (!(time2.hour == 1 &amp;&amp; time2.minute == 10 &amp;&amp; time2.second == 12))
    return 1;
  if (!(time3.hour == 1 &amp;&amp; time3.minute == 10 &amp;&amp; time3.second == 12))
    return 1;

#ifdef PRINT_TEST
  printf(&quot;date1 = %d %d %d %d %d %d&quot;, date1.year, date1.month, date1.day,
    date1.hour, date1.minute, date1.second); // date1 = 2012 10 12 1 2 3
  if (date1.year == 2012 &amp;&amp; date1.month == 10 &amp;&amp; date1.day == 12 &amp;&amp; date1.hour 
      == 1 &amp;&amp; date1.minute == 2 &amp;&amp; date1.second == 3)
    printf(&quot;, PASS\n&quot;);
  else
    printf(&quot;, FAIL\n&quot;);
  printf(&quot;date2 = %d %d %d %d %d %d&quot;, date2.year, date2.month, date2.day,
    date2.hour, date2.minute, date2.second); // date2 = 2012 10 12 1 2 3
  if (date2.year == 2012 &amp;&amp; date2.month == 10 &amp;&amp; date2.day == 12 &amp;&amp; date2.hour 
      == 1 &amp;&amp; date2.minute == 2 &amp;&amp; date2.second == 3)
    printf(&quot;, PASS\n&quot;);
  else
    printf(&quot;, FAIL\n&quot;);
  // time2 = 1 10 12
  printf(&quot;time2 = %d %d %d&quot;, time2.hour, time2.minute, time2.second);
  if (time2.hour == 1 &amp;&amp; time2.minute == 10 &amp;&amp; time2.second == 12)
    printf(&quot;, PASS\n&quot;);
  else
    printf(&quot;, FAIL\n&quot;);
  // time3 = 1 10 12
  printf(&quot;time3 = %d %d %d&quot;, time3.hour, time3.minute, time3.second);
  if (time3.hour == 1 &amp;&amp; time3.minute == 10 &amp;&amp; time3.second == 12)
    printf(&quot;, PASS\n&quot;);
  else
    printf(&quot;, FAIL\n&quot;);
#endif

  return 0;
}
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llc -march=cpu0 -mcpu=cpu032I -relocation-model=pic -filetype=asm</span>
<span class="go">ch9_1_struct.bc -o -</span>
<span class="go">  .section .mdebug.abi32</span>
<span class="go">  .previous</span>
<span class="go">  .file &quot;ch9_1_struct.bc&quot;</span>
<span class="go">  .text</span>
<span class="go">  .globl  _Z7getDatev</span>
<span class="go">  .align  2</span>
<span class="go">  .type _Z7getDatev,@function</span>
<span class="go">  .ent  _Z7getDatev             # @_Z7getDatev</span>
<span class="go">_Z7getDatev:</span>
<span class="go">  .cfi_startproc</span>
<span class="go">  .frame  $sp,0,$lr</span>
<span class="go">  .mask   0x00000000,0</span>
<span class="go">  .set  noreorder</span>
<span class="go">  .cpload $t9</span>
<span class="go">  .set  nomacro</span>
<span class="gp"># </span>BB#0:
<span class="go">        lui   $2, %got_hi(gDate)</span>
<span class="go">        addu  $2, $2, $gp</span>
<span class="go">        ld    $3, %got_lo(gDate)($2)</span>
<span class="go">        ld    $2, 0($sp)</span>
<span class="go">  ld  $4, 20($3)        // save gDate contents to 212..192($sp)</span>
<span class="go">  st  $4, 20($2)</span>
<span class="go">  ld  $4, 16($3)</span>
<span class="go">  st  $4, 16($2)</span>
<span class="go">  ld  $4, 12($3)</span>
<span class="go">  st  $4, 12($2)</span>
<span class="go">  ld  $4, 8($3)</span>
<span class="go">  st  $4, 8($2)</span>
<span class="go">  ld  $4, 4($3)</span>
<span class="go">  st  $4, 4($2)</span>
<span class="go">  ld  $3, 0($3)</span>
<span class="go">  st  $3, 0($2)</span>
<span class="go">  ret $lr</span>
<span class="go">  nop</span>
<span class="go">  .set  macro</span>
<span class="go">  .set  reorder</span>
<span class="go">  .end  _Z7getDatev</span>
<span class="gp">$</span>tmp0:
<span class="go">  .size _Z7getDatev, ($tmp0)-_Z7getDatev</span>
<span class="go">  .cfi_endproc</span>
<span class="go">  ...</span>
<span class="go">  .globl  _Z20test_func_arg_structv</span>
<span class="go">  .align  2</span>
<span class="go">  .type _Z20test_func_arg_structv,@function</span>
<span class="go">  .ent  _Z20test_func_arg_structv                    # @main</span>
<span class="go">_Z20test_func_arg_structv:</span>
<span class="go">  .cfi_startproc</span>
<span class="go">  .frame  $sp,248,$lr</span>
<span class="go">  .mask   0x00004180,-4</span>
<span class="go">  .set  noreorder</span>
<span class="go">  .cpload $t9</span>
<span class="go">  .set  nomacro</span>
<span class="gp">  # </span>BB#0:
<span class="go">        addiu $sp, $sp, -200</span>
<span class="go">        st    $lr, 196($sp)           # 4-byte Folded Spill</span>
<span class="go">        st    $8, 192($sp)            # 4-byte Folded Spill</span>
<span class="go">        ld    $2, %got($_ZZ20test_func_arg_structvE5time1)($gp)</span>
<span class="go">        ori   $2, $2, %lo($_ZZ20test_func_arg_structvE5time1)</span>
<span class="go">        ld    $3, 8($2)</span>
<span class="go">        st    $3, 184($sp)</span>
<span class="go">        ld    $3, 4($2)</span>
<span class="go">        st    $3, 180($sp)</span>
<span class="go">        ld    $2, 0($2)</span>
<span class="go">        st    $2, 176($sp)</span>
<span class="go">        addiu $8, $sp, 152</span>
<span class="go">        st    $8, 0($sp)</span>
<span class="go">        ld    $t9, %call16(_Z7getDatev)($gp) // copy gDate contents to date1, 176..152($sp)</span>
<span class="go">        jalr  $t9</span>
<span class="go">        nop</span>
<span class="go">        ld    $gp, 176($sp)</span>
<span class="go">        ld    $2, 172($sp)</span>
<span class="go">        st    $2, 124($sp)</span>
<span class="go">        ld    $2, 168($sp)</span>
<span class="go">        st    $2, 120($sp)</span>
<span class="go">        ld    $2, 164($sp)</span>
<span class="go">        st    $2, 116($sp)</span>
<span class="go">        ld    $2, 160($sp)</span>
<span class="go">        st    $2, 112($sp)</span>
<span class="go">        ld    $2, 156($sp)</span>
<span class="go">        st    $2, 108($sp)</span>
<span class="go">        ld    $2, 152($sp)</span>
<span class="go">        st    $2, 104($sp)</span>
<span class="go">  ...</span>
</pre></div>
</div>
<p>The <cite>ch9_1_constructor.cpp</cite> includes an implementation of the C++ class <cite>Date</cite>.</p>
<p>This can also be translated by the Cpu0 backend, since the frontend (Clang, in
this case) translates C++ classes into equivalent C language constructs.</p>
<p>If you comment out the <cite>if hasStructRetAttr()</cite> part in both of the functions
mentioned above, the output Cpu0 code for <cite>ch9_1_struct.cpp</cite> will use register
<cite>$3</cite> instead of <cite>$2</cite> as the return register, as shown below:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">        .text</span>
<span class="go">        .section .mdebug.abiS32</span>
<span class="go">        .previous</span>
<span class="go">        .file &quot;ch9_1_struct.bc&quot;</span>
<span class="go">        .globl        _Z7getDatev</span>
<span class="go">        .align        2</span>
<span class="go">        .type _Z7getDatev,@function</span>
<span class="go">        .ent  _Z7getDatev             # @_Z7getDatev</span>
<span class="go">_Z7getDatev:</span>
<span class="go">        .frame        $fp,0,$lr</span>
<span class="go">        .mask         0x00000000,0</span>
<span class="go">        .set  noreorder</span>
<span class="go">        .cpload       $t9</span>
<span class="go">        .set  nomacro</span>
<span class="gp"># </span>BB#0:
<span class="go">        lui   $2, %got_hi(gDate)</span>
<span class="go">        addu  $2, $2, $gp</span>
<span class="go">        ld    $2, %got_lo(gDate)($2)</span>
<span class="go">        ld    $3, 0($sp)</span>
<span class="go">        ld    $4, 20($2)</span>
<span class="go">        st    $4, 20($3)</span>
<span class="go">        ld    $4, 16($2)</span>
<span class="go">        st    $4, 16($3)</span>
<span class="go">        ld    $4, 12($2)</span>
<span class="go">        st    $4, 12($3)</span>
<span class="go">        ld    $4, 8($2)</span>
<span class="go">        st    $4, 8($3)</span>
<span class="go">        ld    $4, 4($2)</span>
<span class="go">        st    $4, 4($3)</span>
<span class="go">        ld    $2, 0($2)</span>
<span class="go">        st    $2, 0($3)</span>
<span class="go">        ret   $lr</span>
<span class="go">        nop</span>
<span class="go">  ...</span>
</pre></div>
</div>
<p>According to the MIPS ABI, the address for returning a struct variable must be
placed in register <cite>$2</cite>.</p>
</section>
<section id="byval-struct-type">
<h3><a class="toc-backref" href="#id40" role="doc-backlink">Byval Struct Type</a><a class="headerlink" href="#byval-struct-type" title="Permalink to this heading">¶</a></h3>
<p>The following code in <cite>Chapter9_1/</cite> and <cite>Chapter9_2/</cite> supports the <cite>byval</cite>
structure type in function calls.</p>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0ISelLowering.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>void Cpu0TargetLowering::
copyByValRegs(SDValue Chain, const SDLoc &amp;DL, std::vector&lt;SDValue&gt; &amp;OutChains,
              SelectionDAG &amp;DAG, const ISD::ArgFlagsTy &amp;Flags,
              SmallVectorImpl&lt;SDValue&gt; &amp;InVals, const Argument *FuncArg,
              const Cpu0CC &amp;CC, const ByValArgInfo &amp;ByVal) const {
  MachineFunction &amp;MF = DAG.getMachineFunction();
  MachineFrameInfo &amp;MFI = MF.getFrameInfo();
  unsigned RegAreaSize = ByVal.NumRegs * CC.regSize();
  unsigned FrameObjSize = std::max(Flags.getByValSize(), RegAreaSize);
  int FrameObjOffset;

  const ArrayRef&lt;MCPhysReg&gt; ByValArgRegs = CC.intArgRegs();

  if (RegAreaSize)
    FrameObjOffset = (int)CC.reservedArgArea() -
      (int)((CC.numIntArgRegs() - ByVal.FirstIdx) * CC.regSize());
  else
    FrameObjOffset = ByVal.Address;

  // Create frame object.
  EVT PtrTy = getPointerTy(DAG.getDataLayout());
  int FI = MFI.CreateFixedObject(FrameObjSize, FrameObjOffset, true);
  SDValue FIN = DAG.getFrameIndex(FI, PtrTy);
  InVals.push_back(FIN);

  if (!ByVal.NumRegs)
    return;

  // Copy arg registers.
  MVT RegTy = MVT::getIntegerVT(CC.regSize() * 8);
  const TargetRegisterClass *RC = getRegClassFor(RegTy);

  for (unsigned I = 0; I &lt; ByVal.NumRegs; ++I) {
    unsigned ArgReg = ByValArgRegs[ByVal.FirstIdx + I];
    unsigned VReg = addLiveIn(MF, ArgReg, RC);
    unsigned Offset = I * CC.regSize();
    SDValue StorePtr = DAG.getNode(ISD::ADD, DL, PtrTy, FIN,
                                   DAG.getConstant(Offset, DL, PtrTy));
    SDValue Store = DAG.getStore(Chain, DL, DAG.getRegister(VReg, RegTy),
                                 StorePtr, MachinePointerInfo(FuncArg, Offset));
    OutChains.push_back(Store);
  }
}
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">///</span> <span class="n">LowerFormalArguments</span> <span class="o">-</span> <span class="n">transform</span> <span class="n">physical</span> <span class="n">registers</span> <span class="n">into</span> <span class="n">virtual</span> <span class="n">registers</span>
<span class="o">///</span> <span class="ow">and</span> <span class="n">generate</span> <span class="n">load</span> <span class="n">operations</span> <span class="k">for</span> <span class="n">arguments</span> <span class="n">places</span> <span class="n">on</span> <span class="n">the</span> <span class="n">stack</span><span class="o">.</span>
<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">LowerFormalArguments</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span>
                                         <span class="n">CallingConv</span><span class="p">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span>
                                         <span class="nb">bool</span> <span class="n">IsVarArg</span><span class="p">,</span>
                                         <span class="n">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="p">::</span><span class="n">InputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ins</span><span class="p">,</span>
                                         <span class="n">const</span> <span class="n">SDLoc</span> <span class="o">&amp;</span><span class="n">DL</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span>
                                         <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span>
                                          <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">for</span> <span class="p">(</span><span class="n">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">ArgLocs</span><span class="o">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="k">if</span> <span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">isByVal</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">assert</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">getByValSize</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
             <span class="s2">&quot;ByVal args of size 0 should have been ignored by front-end.&quot;</span><span class="p">);</span>
      <span class="k">assert</span><span class="p">(</span><span class="n">ByValArg</span> <span class="o">!=</span> <span class="n">Cpu0CCInfo</span><span class="o">.</span><span class="n">byval_end</span><span class="p">());</span>
      <span class="n">copyByValRegs</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">OutChains</span><span class="p">,</span> <span class="n">DAG</span><span class="p">,</span> <span class="n">Flags</span><span class="p">,</span> <span class="n">InVals</span><span class="p">,</span> <span class="o">&amp;*</span><span class="n">FuncArg</span><span class="p">,</span>
                    <span class="n">Cpu0CCInfo</span><span class="p">,</span> <span class="o">*</span><span class="n">ByValArg</span><span class="p">);</span>
      <span class="o">++</span><span class="n">ByValArg</span><span class="p">;</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">.</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  for (unsigned i = 0, e = ArgLocs.size(); i != e; ++i) {
    // The cpu0 ABIs for returning structs by value requires that we copy
    // the sret argument into $v0 for the return. Save the argument into
    // a virtual register so that we can access it from the return points.
    if (Ins[i].Flags.isSRet()) {
      unsigned Reg = Cpu0FI-&gt;getSRetReturnReg();
      if (!Reg) {
        Reg = MF.getRegInfo().createVirtualRegister(
            getRegClassFor(MVT::i32));
        Cpu0FI-&gt;setSRetReturnReg(Reg);
      }
      SDValue Copy = DAG.getCopyToReg(DAG.getEntryNode(), DL, Reg, InVals[i]);
      Chain = DAG.getNode(ISD::TokenFactor, DL, MVT::Other, Copy, Chain);
      break;
    }
  }
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_2/Cpu0ISelLowering.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Copy</span> <span class="n">byVal</span> <span class="n">arg</span> <span class="n">to</span> <span class="n">registers</span> <span class="ow">and</span> <span class="n">stack</span><span class="o">.</span>
<span class="n">void</span> <span class="n">Cpu0TargetLowering</span><span class="p">::</span>
<span class="n">passByValArg</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">const</span> <span class="n">SDLoc</span> <span class="o">&amp;</span><span class="n">DL</span><span class="p">,</span>
             <span class="n">std</span><span class="p">::</span><span class="n">deque</span><span class="o">&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">unsigned</span><span class="p">,</span> <span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">RegsToPass</span><span class="p">,</span>
             <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">MemOpChains</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">StackPtr</span><span class="p">,</span>
             <span class="n">MachineFrameInfo</span> <span class="o">&amp;</span><span class="n">MFI</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">Arg</span><span class="p">,</span>
             <span class="n">const</span> <span class="n">Cpu0CC</span> <span class="o">&amp;</span><span class="n">CC</span><span class="p">,</span> <span class="n">const</span> <span class="n">ByValArgInfo</span> <span class="o">&amp;</span><span class="n">ByVal</span><span class="p">,</span>
             <span class="n">const</span> <span class="n">ISD</span><span class="p">::</span><span class="n">ArgFlagsTy</span> <span class="o">&amp;</span><span class="n">Flags</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">isLittle</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="n">unsigned</span> <span class="n">ByValSizeInBytes</span> <span class="o">=</span> <span class="n">Flags</span><span class="o">.</span><span class="n">getByValSize</span><span class="p">();</span>
  <span class="n">unsigned</span> <span class="n">OffsetInBytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">//</span> <span class="n">From</span> <span class="n">beginning</span> <span class="n">of</span> <span class="n">struct</span>
  <span class="n">unsigned</span> <span class="n">RegSizeInBytes</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">regSize</span><span class="p">();</span>
  <span class="n">unsigned</span> <span class="n">Alignment</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="nb">min</span><span class="p">((</span><span class="n">unsigned</span><span class="p">)</span><span class="n">Flags</span><span class="o">.</span><span class="n">getNonZeroByValAlign</span><span class="p">()</span><span class="o">.</span><span class="n">value</span><span class="p">(),</span> <span class="n">RegSizeInBytes</span><span class="p">);</span>
  <span class="n">EVT</span> <span class="n">PtrTy</span> <span class="o">=</span> <span class="n">getPointerTy</span><span class="p">(</span><span class="n">DAG</span><span class="o">.</span><span class="n">getDataLayout</span><span class="p">()),</span>
      <span class="n">RegTy</span> <span class="o">=</span> <span class="n">MVT</span><span class="p">::</span><span class="n">getIntegerVT</span><span class="p">(</span><span class="n">RegSizeInBytes</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">ByVal</span><span class="o">.</span><span class="n">NumRegs</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">const</span> <span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">MCPhysReg</span><span class="o">&gt;</span> <span class="n">ArgRegs</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">intArgRegs</span><span class="p">();</span>
    <span class="nb">bool</span> <span class="n">LeftoverBytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">ByVal</span><span class="o">.</span><span class="n">NumRegs</span> <span class="o">*</span> <span class="n">RegSizeInBytes</span> <span class="o">&gt;</span> <span class="n">ByValSizeInBytes</span><span class="p">);</span>
    <span class="n">unsigned</span> <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Copy</span> <span class="n">words</span> <span class="n">to</span> <span class="n">registers</span><span class="o">.</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">I</span> <span class="o">&lt;</span> <span class="n">ByVal</span><span class="o">.</span><span class="n">NumRegs</span> <span class="o">-</span> <span class="n">LeftoverBytes</span><span class="p">;</span>
         <span class="o">++</span><span class="n">I</span><span class="p">,</span> <span class="n">OffsetInBytes</span> <span class="o">+=</span> <span class="n">RegSizeInBytes</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">SDValue</span> <span class="n">LoadPtr</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">ADD</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">PtrTy</span><span class="p">,</span> <span class="n">Arg</span><span class="p">,</span>
                                    <span class="n">DAG</span><span class="o">.</span><span class="n">getConstant</span><span class="p">(</span><span class="n">OffsetInBytes</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">PtrTy</span><span class="p">));</span>
      <span class="n">SDValue</span> <span class="n">LoadVal</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getLoad</span><span class="p">(</span><span class="n">RegTy</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">LoadPtr</span><span class="p">,</span>
                                    <span class="n">MachinePointerInfo</span><span class="p">());</span>
      <span class="n">MemOpChains</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">LoadVal</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
      <span class="n">unsigned</span> <span class="n">ArgReg</span> <span class="o">=</span> <span class="n">ArgRegs</span><span class="p">[</span><span class="n">ByVal</span><span class="o">.</span><span class="n">FirstIdx</span> <span class="o">+</span> <span class="n">I</span><span class="p">];</span>
      <span class="n">RegsToPass</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">ArgReg</span><span class="p">,</span> <span class="n">LoadVal</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="o">//</span> <span class="n">Return</span> <span class="k">if</span> <span class="n">the</span> <span class="n">struct</span> <span class="n">has</span> <span class="n">been</span> <span class="n">fully</span> <span class="n">copied</span><span class="o">.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ByValSizeInBytes</span> <span class="o">==</span> <span class="n">OffsetInBytes</span><span class="p">)</span>
      <span class="k">return</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Copy</span> <span class="n">the</span> <span class="n">remainder</span> <span class="n">of</span> <span class="n">the</span> <span class="n">byval</span> <span class="n">argument</span> <span class="k">with</span> <span class="n">sub</span><span class="o">-</span><span class="n">word</span> <span class="n">loads</span> <span class="ow">and</span> <span class="n">shifts</span><span class="o">.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">LeftoverBytes</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">assert</span><span class="p">((</span><span class="n">ByValSizeInBytes</span> <span class="o">&gt;</span> <span class="n">OffsetInBytes</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
             <span class="p">(</span><span class="n">ByValSizeInBytes</span> <span class="o">&lt;</span> <span class="n">OffsetInBytes</span> <span class="o">+</span> <span class="n">RegSizeInBytes</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
             <span class="s2">&quot;Size of the remainder should be smaller than RegSizeInBytes.&quot;</span><span class="p">);</span>
      <span class="n">SDValue</span> <span class="n">Val</span><span class="p">;</span>

      <span class="k">for</span> <span class="p">(</span><span class="n">unsigned</span> <span class="n">LoadSizeInBytes</span> <span class="o">=</span> <span class="n">RegSizeInBytes</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">TotalBytesLoaded</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
           <span class="n">OffsetInBytes</span> <span class="o">&lt;</span> <span class="n">ByValSizeInBytes</span><span class="p">;</span> <span class="n">LoadSizeInBytes</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">unsigned</span> <span class="n">RemainingSizeInBytes</span> <span class="o">=</span> <span class="n">ByValSizeInBytes</span> <span class="o">-</span> <span class="n">OffsetInBytes</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">RemainingSizeInBytes</span> <span class="o">&lt;</span> <span class="n">LoadSizeInBytes</span><span class="p">)</span>
          <span class="k">continue</span><span class="p">;</span>

        <span class="o">//</span> <span class="n">Load</span> <span class="n">subword</span><span class="o">.</span>
        <span class="n">SDValue</span> <span class="n">LoadPtr</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">ADD</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">PtrTy</span><span class="p">,</span> <span class="n">Arg</span><span class="p">,</span>
                                      <span class="n">DAG</span><span class="o">.</span><span class="n">getConstant</span><span class="p">(</span><span class="n">OffsetInBytes</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">PtrTy</span><span class="p">));</span>
        <span class="n">SDValue</span> <span class="n">LoadVal</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getExtLoad</span><span class="p">(</span>
            <span class="n">ISD</span><span class="p">::</span><span class="n">ZEXTLOAD</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">RegTy</span><span class="p">,</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">LoadPtr</span><span class="p">,</span> <span class="n">MachinePointerInfo</span><span class="p">(),</span>
            <span class="n">MVT</span><span class="p">::</span><span class="n">getIntegerVT</span><span class="p">(</span><span class="n">LoadSizeInBytes</span> <span class="o">*</span> <span class="mi">8</span><span class="p">),</span> <span class="n">Alignment</span><span class="p">);</span>
        <span class="n">MemOpChains</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">LoadVal</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>

        <span class="o">//</span> <span class="n">Shift</span> <span class="n">the</span> <span class="n">loaded</span> <span class="n">value</span><span class="o">.</span>
        <span class="n">unsigned</span> <span class="n">Shamt</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">isLittle</span><span class="p">)</span>
          <span class="n">Shamt</span> <span class="o">=</span> <span class="n">TotalBytesLoaded</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>
        <span class="k">else</span>
          <span class="n">Shamt</span> <span class="o">=</span> <span class="p">(</span><span class="n">RegSizeInBytes</span> <span class="o">-</span> <span class="p">(</span><span class="n">TotalBytesLoaded</span> <span class="o">+</span> <span class="n">LoadSizeInBytes</span><span class="p">))</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>

        <span class="n">SDValue</span> <span class="n">Shift</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">SHL</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">RegTy</span><span class="p">,</span> <span class="n">LoadVal</span><span class="p">,</span>
                                    <span class="n">DAG</span><span class="o">.</span><span class="n">getConstant</span><span class="p">(</span><span class="n">Shamt</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">MVT</span><span class="p">::</span><span class="n">i32</span><span class="p">));</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">Val</span><span class="o">.</span><span class="n">getNode</span><span class="p">())</span>
          <span class="n">Val</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">OR</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">RegTy</span><span class="p">,</span> <span class="n">Val</span><span class="p">,</span> <span class="n">Shift</span><span class="p">);</span>
        <span class="k">else</span>
          <span class="n">Val</span> <span class="o">=</span> <span class="n">Shift</span><span class="p">;</span>

        <span class="n">OffsetInBytes</span> <span class="o">+=</span> <span class="n">LoadSizeInBytes</span><span class="p">;</span>
        <span class="n">TotalBytesLoaded</span> <span class="o">+=</span> <span class="n">LoadSizeInBytes</span><span class="p">;</span>
        <span class="n">Alignment</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="nb">min</span><span class="p">(</span><span class="n">Alignment</span><span class="p">,</span> <span class="n">LoadSizeInBytes</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="n">unsigned</span> <span class="n">ArgReg</span> <span class="o">=</span> <span class="n">ArgRegs</span><span class="p">[</span><span class="n">ByVal</span><span class="o">.</span><span class="n">FirstIdx</span> <span class="o">+</span> <span class="n">I</span><span class="p">];</span>
      <span class="n">RegsToPass</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">ArgReg</span><span class="p">,</span> <span class="n">Val</span><span class="p">));</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="o">//</span> <span class="n">Copy</span> <span class="n">remainder</span> <span class="n">of</span> <span class="n">byval</span> <span class="n">arg</span> <span class="n">to</span> <span class="n">it</span> <span class="k">with</span> <span class="n">memcpy</span><span class="o">.</span>
  <span class="n">unsigned</span> <span class="n">MemCpySize</span> <span class="o">=</span> <span class="n">ByValSizeInBytes</span> <span class="o">-</span> <span class="n">OffsetInBytes</span><span class="p">;</span>
  <span class="n">SDValue</span> <span class="n">Src</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">ADD</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">PtrTy</span><span class="p">,</span> <span class="n">Arg</span><span class="p">,</span>
                            <span class="n">DAG</span><span class="o">.</span><span class="n">getConstant</span><span class="p">(</span><span class="n">OffsetInBytes</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">PtrTy</span><span class="p">));</span>
  <span class="n">SDValue</span> <span class="n">Dst</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">ADD</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">PtrTy</span><span class="p">,</span> <span class="n">StackPtr</span><span class="p">,</span>
                            <span class="n">DAG</span><span class="o">.</span><span class="n">getIntPtrConstant</span><span class="p">(</span><span class="n">ByVal</span><span class="o">.</span><span class="n">Address</span><span class="p">,</span> <span class="n">DL</span><span class="p">));</span>
  <span class="n">Chain</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getMemcpy</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Dst</span><span class="p">,</span> <span class="n">Src</span><span class="p">,</span>
                        <span class="n">DAG</span><span class="o">.</span><span class="n">getConstant</span><span class="p">(</span><span class="n">MemCpySize</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">PtrTy</span><span class="p">),</span>
                        <span class="n">Align</span><span class="p">(</span><span class="n">Alignment</span><span class="p">),</span> <span class="o">/*</span><span class="n">isVolatile</span><span class="o">=*/</span><span class="n">false</span><span class="p">,</span> <span class="o">/*</span><span class="n">AlwaysInline</span><span class="o">=*/</span><span class="n">false</span><span class="p">,</span>
                        <span class="o">/*</span><span class="n">isTailCall</span><span class="o">=*/</span><span class="n">false</span><span class="p">,</span>
                        <span class="n">MachinePointerInfo</span><span class="p">(),</span> <span class="n">MachinePointerInfo</span><span class="p">());</span>
  <span class="n">MemOpChains</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Chain</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">///</span> <span class="n">LowerCall</span> <span class="o">-</span> <span class="n">functions</span> <span class="n">arguments</span> <span class="n">are</span> <span class="n">copied</span> <span class="kn">from</span> <span class="nn">virtual</span> <span class="n">regs</span> <span class="n">to</span>
<span class="o">///</span> <span class="p">(</span><span class="n">physical</span> <span class="n">regs</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">stack</span> <span class="n">frame</span><span class="p">),</span> <span class="n">CALLSEQ_START</span> <span class="ow">and</span> <span class="n">CALLSEQ_END</span> <span class="n">are</span> <span class="n">emitted</span><span class="o">.</span>
<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">LowerCall</span><span class="p">(</span><span class="n">TargetLowering</span><span class="p">::</span><span class="n">CallLoweringInfo</span> <span class="o">&amp;</span><span class="n">CLI</span><span class="p">,</span>
                              <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="o">//</span> <span class="n">Walk</span> <span class="n">the</span> <span class="n">register</span><span class="o">/</span><span class="n">memloc</span> <span class="n">assignments</span><span class="p">,</span> <span class="n">inserting</span> <span class="n">copies</span><span class="o">/</span><span class="n">loads</span><span class="o">.</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">ArgLocs</span><span class="o">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    if (Flags.isByVal()) {
      assert(Flags.getByValSize() &amp;&amp;
             &quot;ByVal args of size 0 should have been ignored by front-end.&quot;);
      assert(ByValArg != Cpu0CCInfo.byval_end());
      assert(!IsTailCall &amp;&amp;
             &quot;Do not tail-call optimize if there is a byval argument.&quot;);
      passByValArg(Chain, DL, RegsToPass, MemOpChains, StackPtr, MFI, DAG, Arg,
                   Cpu0CCInfo, *ByValArg, Flags, Subtarget.isLittle());
      ++ByValArg;
      continue;
    }
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>In <cite>LowerCall()</cite>, <cite>Flags.isByVal()</cite> will be <cite>true</cite> if the function call in the
caller contains a <strong>byval</strong> struct type, as shown below:</p>
<p class="rubric">lbdex/input/tailcall.ll</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="k">internal</span><span class="w"> </span><span class="k">fastcc</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@caller9_1</span><span class="p">()</span><span class="w"> </span><span class="k">nounwind</span><span class="w"> </span><span class="k">noinline</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="nl">entry:</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="nv">%call</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">tail</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@callee9</span><span class="p">(</span><span class="nv">%struct.S</span><span class="p">*</span><span class="w"> </span><span class="k">byval</span><span class="w"> </span><span class="vg">@gs1</span><span class="p">)</span><span class="w"> </span><span class="k">nounwind</span><span class="w"></span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%call</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>In <cite>LowerFormalArguments()</cite>, <cite>Flags.isByVal()</cite> will be <cite>true</cite> when it encounters
a <strong>byval</strong> parameter in the callee function, as shown below:</p>
<p class="rubric">lbdex/input/tailcall.ll</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@caller12</span><span class="p">(</span><span class="nv">%struct.S</span><span class="p">*</span><span class="w"> </span><span class="k">nocapture</span><span class="w"> </span><span class="k">byval</span><span class="w"> </span><span class="nv">%a0</span><span class="p">)</span><span class="w"> </span><span class="k">nounwind</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="nl">entry:</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>At this point, I don’t know how to make Clang generate <cite>byval</cite> IR using the
C language.</p>
</section>
</section>
<section id="function-call-optimization">
<h2><a class="toc-backref" href="#id41" role="doc-backlink">Function Call Optimization</a><a class="headerlink" href="#function-call-optimization" title="Permalink to this heading">¶</a></h2>
<section id="tail-call-optimization">
<h3><a class="toc-backref" href="#id42" role="doc-backlink">Tail Call Optimization</a><a class="headerlink" href="#tail-call-optimization" title="Permalink to this heading">¶</a></h3>
<p>Tail call optimization is applied in certain function call situations. In some
cases, the caller and callee can share the same memory stack.</p>
<p>When applied to recursive function calls, this optimization often reduces the
stack space requirement from linear, or O(n), to constant, or O(1)
<a class="footnote-reference brackets" href="#wikitailcall" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a>.</p>
<p>LLVM IR supports <cite>tailcall</cite> as described here <a class="footnote-reference brackets" href="#tailcallopt" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a>.</p>
<p>The <cite>tailcall</cite> instructions appearing in <cite>Cpu0ISelLowering.cpp</cite> and
<cite>Cpu0InstrInfo.td</cite> are used to implement tail call optimization.</p>
<p class="rubric">lbdex/input/ch9_2_tailcall.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="nb">int</span> <span class="n">factorial</span><span class="p">(</span><span class="nb">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">factorial</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">test_tailcall</span><span class="p">(</span><span class="nb">int</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">factorial</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="p">}</span>

</pre></div>
</div>
<p>Run <cite>Chapter9_2/</cite> with <cite>ch9_2_tailcall.cpp</cite> to get the following result.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>clang -O1 -target mips-unknown-linux-gnu -c
<span class="go">ch9_2_tailcall.cpp -emit-llvm -o ch9_2_tailcall.bc</span>
<span class="gp">JonathantekiiMac:input Jonathan$ </span>~/llvm/test/build/bin/
<span class="go">llvm-dis ch9_2_tailcall.bc -o -</span>
<span class="go">...</span>
<span class="go">; Function Attrs: nounwind readnone</span>
<span class="go">define i32 @_Z9factoriali(i32 %x) #0 {</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> icmp sgt i32 %x, <span class="m">0</span>
<span class="go">  br i1 %1, label %tailrecurse, label %tailrecurse._crit_edge</span>

<span class="go">tailrecurse:                                      ; preds = %tailrecurse, %0</span>
<span class="gp">  %</span>x.tr2 <span class="o">=</span> phi i32 <span class="o">[</span> %2, %tailrecurse <span class="o">]</span>, <span class="o">[</span> %x, %0 <span class="o">]</span>
<span class="gp">  %</span>accumulator.tr1 <span class="o">=</span> phi i32 <span class="o">[</span> %3, %tailrecurse <span class="o">]</span>, <span class="o">[</span> <span class="m">1</span>, %0 <span class="o">]</span>
<span class="gp">  %</span><span class="nv">2</span> <span class="o">=</span> add nsw i32 %x.tr2, -1
<span class="gp">  %</span><span class="nv">3</span> <span class="o">=</span> mul nsw i32 %x.tr2, %accumulator.tr1
<span class="gp">  %</span><span class="nv">4</span> <span class="o">=</span> icmp sgt i32 %2, <span class="m">0</span>
<span class="go">  br i1 %4, label %tailrecurse, label %tailrecurse._crit_edge</span>

<span class="go">tailrecurse._crit_edge:                           ; preds = %tailrecurse, %0</span>
<span class="gp">  %</span>accumulator.tr.lcssa <span class="o">=</span> phi i32 <span class="o">[</span> <span class="m">1</span>, %0 <span class="o">]</span>, <span class="o">[</span> %3, %tailrecurse <span class="o">]</span>
<span class="go">  ret i32 %accumulator.tr.lcssa</span>
<span class="go">}</span>

<span class="go">; Function Attrs: nounwind readnone</span>
<span class="go">define i32 @_Z13test_tailcalli(i32 %a) #0 {</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> tail call i32 @_Z9factoriali<span class="o">(</span>i32 %a<span class="o">)</span>
<span class="go">  ret i32 %1</span>
<span class="go">}</span>
<span class="go">...</span>
<span class="gp">JonathantekiiMac:input Jonathan$ </span>~/llvm/test/build/bin/
<span class="go">llc -march=cpu0 -mcpu=cpu032II -relocation-model=static -filetype=asm</span>
<span class="go">-enable-cpu0-tail-calls ch9_2_tailcall.bc -stats -o -</span>
<span class="go">        .text</span>
<span class="go">        .section .mdebug.abi32</span>
<span class="go">        .previous</span>
<span class="go">        .file &quot;ch9_2_tailcall.bc&quot;</span>
<span class="go">        .globl        _Z9factoriali</span>
<span class="go">        .align        2</span>
<span class="go">        .type _Z9factoriali,@function</span>
<span class="go">        .ent  _Z9factoriali           # @_Z9factoriali</span>
<span class="go">_Z9factoriali:</span>
<span class="go">        .frame        $sp,0,$lr</span>
<span class="go">        .mask         0x00000000,0</span>
<span class="go">        .set  noreorder</span>
<span class="go">        .set  nomacro</span>
<span class="gp"># </span>BB#0:
<span class="go">        addiu $2, $zero, 1</span>
<span class="go">        slt   $3, $4, $2</span>
<span class="go">        bne   $3, $zero, $BB0_2</span>
<span class="go">        nop</span>
<span class="gp">$</span>BB0_1:                                 <span class="c1"># %tailrecurse</span>
<span class="gp">                                        # </span><span class="o">=</span>&gt;This Inner Loop Header: <span class="nv">Depth</span><span class="o">=</span><span class="m">1</span>
<span class="go">        mul   $2, $4, $2</span>
<span class="go">        addiu $4, $4, -1</span>
<span class="go">        addiu $3, $zero, 0</span>
<span class="go">        slt   $3, $3, $4</span>
<span class="go">        bne   $3, $zero, $BB0_1</span>
<span class="go">        nop</span>
<span class="gp">$</span>BB0_2:                                 <span class="c1"># %tailrecurse._crit_edge</span>
<span class="go">        ret   $lr</span>
<span class="go">        nop</span>
<span class="go">        .set  macro</span>
<span class="go">        .set  reorder</span>
<span class="go">        .end  _Z9factoriali</span>
<span class="gp">$</span>tmp0:
<span class="go">        .size _Z9factoriali, ($tmp0)-_Z9factoriali</span>

<span class="go">        .globl        _Z13test_tailcalli</span>
<span class="go">        .align        2</span>
<span class="go">        .type _Z13test_tailcalli,@function</span>
<span class="go">        .ent  _Z13test_tailcalli      # @_Z13test_tailcalli</span>
<span class="go">_Z13test_tailcalli:</span>
<span class="go">        .frame        $sp,0,$lr</span>
<span class="go">        .mask         0x00000000,0</span>
<span class="go">        .set  noreorder</span>
<span class="go">        .set  nomacro</span>
<span class="gp"># </span>BB#0:
<span class="go">        jmp   _Z9factoriali</span>
<span class="go">        nop</span>
<span class="go">        .set  macro</span>
<span class="go">        .set  reorder</span>
<span class="go">        .end  _Z13test_tailcalli</span>
<span class="gp">$</span>tmp1:
<span class="go">        .size _Z13test_tailcalli, ($tmp1)-_Z13test_tailcalli</span>


<span class="go">===-------------------------------------------------------------------------===</span>
<span class="go">                          ... Statistics Collected ...</span>
<span class="go">===-------------------------------------------------------------------------===</span>

<span class="go"> ...</span>
<span class="go"> 1 cpu0-lower        - Number of tail calls</span>
<span class="go"> ...</span>
</pre></div>
</div>
<p>The tail call optimization shares the caller’s and callee’s stack, and it is
applied in <cite>cpu032II</cite> only for this example (it uses <cite>jmp _Z9factoriali</cite>
instead of <cite>jsub _Z9factoriali</cite>).</p>
<p>However, <cite>cpu032I</cite> (which passes all arguments on the stack) does not satisfy
the condition <cite>NextStackOffset &lt;= FI.getIncomingArgSize()</cite> in
<cite>isEligibleForTailCallOptimization()</cite>, and thus returns <cite>false</cite> for the
function, as shown below:</p>
<p class="rubric">lbdex/chapters/Chapter9_2/Cpu0SEISelLowering.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>bool Cpu0SETargetLowering::
isEligibleForTailCallOptimization(const Cpu0CC &amp;Cpu0CCInfo,
                                  unsigned NextStackOffset,
                                  const Cpu0FunctionInfo&amp; FI) const {
  if (!EnableCpu0TailCalls)
    return false;

  // Return false if either the callee or caller has a byval argument.
  if (Cpu0CCInfo.hasByValArg() || FI.hasByvalArg())
    return false;

  // Return true if the callee&#39;s argument area is no larger than the
  // caller&#39;s.
  return NextStackOffset &lt;= FI.getIncomingArgSize();
}
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_2/Cpu0ISelLowering.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">///</span> <span class="n">LowerCall</span> <span class="o">-</span> <span class="n">functions</span> <span class="n">arguments</span> <span class="n">are</span> <span class="n">copied</span> <span class="kn">from</span> <span class="nn">virtual</span> <span class="n">regs</span> <span class="n">to</span>
<span class="o">///</span> <span class="p">(</span><span class="n">physical</span> <span class="n">regs</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">stack</span> <span class="n">frame</span><span class="p">),</span> <span class="n">CALLSEQ_START</span> <span class="ow">and</span> <span class="n">CALLSEQ_END</span> <span class="n">are</span> <span class="n">emitted</span><span class="o">.</span>
<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">LowerCall</span><span class="p">(</span><span class="n">TargetLowering</span><span class="p">::</span><span class="n">CallLoweringInfo</span> <span class="o">&amp;</span><span class="n">CLI</span><span class="p">,</span>
                              <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  // Check if it&#39;s really possible to do a tail call.
  if (IsTailCall)
    IsTailCall =
      isEligibleForTailCallOptimization(Cpu0CCInfo, NextStackOffset,
                                        *MF.getInfo&lt;Cpu0FunctionInfo&gt;());

  if (!IsTailCall &amp;&amp; CLI.CB &amp;&amp; CLI.CB-&gt;isMustTailCall())
    report_fatal_error(&quot;failed to perform tail call elimination on a call &quot;
                       &quot;site marked musttail&quot;);

  if (IsTailCall)
    ++NumTailCalls;
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  if (!IsTailCall)
    Chain = DAG.getCALLSEQ_START(Chain, NextStackOffset, 0, DL);
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">if</span> <span class="p">(</span><span class="n">IsTailCall</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">Cpu0ISD</span><span class="p">::</span><span class="n">TailCall</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">MVT</span><span class="p">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Ops</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Since tail call optimization translates the call into a <cite>jmp</cite> instruction
directly instead of <cite>jsub</cite>, the <cite>callseq_start</cite>, <cite>callseq_end</cite>, and the DAG
nodes created in <cite>LowerCallResult()</cite> and <cite>LowerReturn()</cite> are unnecessary. It
creates DAGs for <cite>ch9_2_tailcall.cpp</cite> as shown in
<a class="reference internal" href="#funccall-f-outgoing-arg-tailcall"><span class="std std-numref">Fig. 47</span></a>.</p>
<figure class="align-default" id="id27">
<span id="funccall-f-outgoing-arg-tailcall"></span><div class="graphviz"><img src="_images/graphviz-b890da73606c49a3fa6d966eb67aa150fc5e0a50.png" alt="digraph &quot;isel input for _Z13test_tailcalli:&quot; {
	rankdir=&quot;BT&quot;;
//	label=&quot;Figure: Outgoing arguments DAGs created for ch9_2_tailcall.cpp&quot;;

	Node0x103a04f20 [shape=record,shape=Mrecord,label=&quot;{EntryToken|t0|{&lt;d0&gt;ch}}&quot;];
	Node0x10404ef70 [shape=record,shape=Mrecord,label=&quot;{Register %vreg0|t1|{&lt;d0&gt;i32}}&quot;];
	Node0x10404ebf0 [shape=record,shape=Mrecord,label=&quot;{TargetGlobalAddress\&lt;i32 (i32)* &#64;_Z9factoriali\&gt; 0|t7|{&lt;d0&gt;i32}}&quot;];
	Node0x10404ea30 [shape=record,shape=Mrecord,label=&quot;{Register %A0|t8|{&lt;d0&gt;i32}}&quot;];
	Node0x10404ec60 [shape=record,shape=Mrecord,label=&quot;{RegisterMask|t10|{&lt;d0&gt;Untyped}}&quot;];
	Node0x10404f050 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1}|CopyFromReg|t2|{&lt;d0&gt;i32|&lt;d1&gt;ch}}&quot;];
	Node0x10404f050:s0 -&gt; Node0x103a04f20:d0[color=blue,style=dashed];
	Node0x10404f050:s1 -&gt; Node0x10404ef70:d0;
	Node0x10404eb10 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1|&lt;s2&gt;2}|CopyToReg|t9|{&lt;d0&gt;ch|&lt;d1&gt;glue}}&quot;];
	Node0x10404eb10:s0 -&gt; Node0x103a04f20:d0[color=blue,style=dashed];
	Node0x10404eb10:s1 -&gt; Node0x10404ea30:d0;
	Node0x10404eb10:s2 -&gt; Node0x10404f050:d0;
	Node0x10404e9c0 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1|&lt;s2&gt;2|&lt;s3&gt;3|&lt;s4&gt;4}|Cpu0ISD::TailCall|t11|{&lt;d0&gt;ch}}&quot;];
	Node0x10404e9c0:s0 -&gt; Node0x103a04f20:d0[color=blue,style=dashed];
	Node0x10404e9c0:s1 -&gt; Node0x10404ebf0:d0;
	Node0x10404e9c0:s2 -&gt; Node0x10404ea30:d0;
	Node0x10404e9c0:s3 -&gt; Node0x10404ec60:d0;
	Node0x10404e9c0:s4 -&gt; Node0x10404eb10:d1[color=red,style=bold];
	Node0x0[ plaintext=circle, label =&quot;GraphRoot&quot;];
	Node0x0 -&gt; Node0x10404e9c0:d0[color=blue,style=dashed];
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 47 </span><span class="caption-text">Outgoing arguments DAGs created for ch9_2_tailcall.cpp</span><a class="headerlink" href="#id27" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>Finally, the DAGs translation of the tail call is listed in the following table.</p>
<table class="docutils align-default" id="id28">
<caption><span class="caption-number">Table 36 </span><span class="caption-text">the DAGs translation of tail call</span><a class="headerlink" href="#id28" title="Permalink to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Stage</p></th>
<th class="head"><p>DAG</p></th>
<th class="head"><p>Function</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Backend lowering</p></td>
<td><p>Cpu0ISD::TailCall</p></td>
<td><p>LowerCall()</p></td>
</tr>
<tr class="row-odd"><td><p>Instruction selection</p></td>
<td><p>TAILCALL</p></td>
<td><p>note 1</p></td>
</tr>
<tr class="row-even"><td><p>Instruction Print</p></td>
<td><p>JMP</p></td>
<td><p>note 2</p></td>
</tr>
</tbody>
</table>
<p>note 1: by Cpu0InstrInfo.td as follows,</p>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0InstrInfo.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Tail</span> <span class="n">call</span>
<span class="k">def</span> <span class="nf">Cpu0TailCall</span> <span class="p">:</span> <span class="n">SDNode</span><span class="o">&lt;</span><span class="s2">&quot;Cpu0ISD::TailCall&quot;</span><span class="p">,</span> <span class="n">SDT_Cpu0JmpLink</span><span class="p">,</span>
                          <span class="p">[</span><span class="n">SDNPHasChain</span><span class="p">,</span> <span class="n">SDNPOptInGlue</span><span class="p">,</span> <span class="n">SDNPVariadic</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>def : Pat&lt;(Cpu0TailCall (iPTR tglobaladdr:$dst)),
              (TAILCALL tglobaladdr:$dst)&gt;;
def : Pat&lt;(Cpu0TailCall (iPTR texternalsym:$dst)),
              (TAILCALL texternalsym:$dst)&gt;;
</pre></div>
</div>
<p>note 2: by Cpu0InstrInfo.td and emitPseudoExpansionLowering() of
Cpu0AsmPrinter.cpp as follows,</p>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0InstrInfo.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>let isCall = 1, isTerminator = 1, isReturn = 1, isBarrier = 1, hasDelaySlot = 1,
    hasExtraSrcRegAllocReq = 1, Defs = [AT] in {
  class TailCall&lt;Instruction JumpInst&gt; :
    PseudoSE&lt;(outs), (ins calltarget:$target), [], IIBranch&gt;,
    PseudoInstExpansion&lt;(JumpInst jmptarget:$target)&gt;;

  class TailCallReg&lt;RegisterClass RO, Instruction JRInst,
                    RegisterClass ResRO = RO&gt; :
    PseudoSE&lt;(outs), (ins RO:$rs), [(Cpu0TailCall RO:$rs)], IIBranch&gt;,
    PseudoInstExpansion&lt;(JRInst ResRO:$rs)&gt;;
}
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ch9_1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">{</span>
<span class="k">def</span> <span class="nf">TAILCALL</span> <span class="p">:</span> <span class="n">TailCall</span><span class="o">&lt;</span><span class="n">JMP</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">TAILCALL_R</span> <span class="p">:</span> <span class="n">TailCallReg</span><span class="o">&lt;</span><span class="n">GPROut</span><span class="p">,</span> <span class="n">JR</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0AsmPrinter.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="o">//</span> <span class="n">tblgen</span><span class="s1">&#39;erated function.</span>
  <span class="nb">bool</span> <span class="n">emitPseudoExpansionLowering</span><span class="p">(</span><span class="n">MCStreamer</span> <span class="o">&amp;</span><span class="n">OutStreamer</span><span class="p">,</span>
                                   <span class="n">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0AsmPrinter.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>//- emitInstruction() must exists or will have run time error.
void Cpu0AsmPrinter::emitInstruction(const MachineInstr *MI) {
//@EmitInstruction body {
  if (MI-&gt;isDebugValue()) {
    SmallString&lt;128&gt; Str;
    raw_svector_ostream OS(Str);

    PrintDebugValueComment(MI, OS);
    return;
  }

  //@print out instruction:
  //  Print out both ordinary instruction and boudle instruction
  MachineBasicBlock::const_instr_iterator I = MI-&gt;getIterator();
  MachineBasicBlock::const_instr_iterator E = MI-&gt;getParent()-&gt;instr_end();

  do {
    // Do any auto-generated pseudo lowerings.
    if (emitPseudoExpansionLowering(*OutStreamer, &amp;*I))
      continue;

    if (I-&gt;isPseudo() &amp;&amp; !isLongBranchPseudo(I-&gt;getOpcode()))
      llvm_unreachable(&quot;Pseudo opcode found in emitInstruction()&quot;);

    MCInst TmpInst0;
    // Call Cpu0MCInstLower::Lower(const MachineInstr *MI, MCInst &amp;OutMI) to 
    // extracts MCInst from MachineInstr.
    MCInstLowering.Lower(&amp;*I, TmpInst0);
    OutStreamer-&gt;emitInstruction(TmpInst0, getSubtargetInfo());
  } while ((++I != E) &amp;&amp; I-&gt;isInsideBundle()); // Delay slot check
}
</pre></div>
</div>
<p>The function <cite>emitPseudoExpansionLowering()</cite> is generated by TableGen and is
located in <cite>Cpu0GenMCPseudoLowering.inc</cite>.</p>
</section>
<section id="recursion-optimization">
<h3><a class="toc-backref" href="#id43" role="doc-backlink">Recursion optimization</a><a class="headerlink" href="#recursion-optimization" title="Permalink to this heading">¶</a></h3>
<p>As mentioned in the last section, cpu032I cannot perform tail call optimization
in <cite>ch9_2_tailcall.cpp</cite> due to the limitation that the argument size condition
is not satisfied.</p>
<p>However, when running with the <code class="docutils literal notranslate"><span class="pre">clang</span> <span class="pre">-O3</span></code> optimization option, it can achieve
the same or even better performance than tail call optimization, as shown below:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>clang -O1 -target mips-unknown-linux-gnu -c
<span class="go">ch9_2_tailcall.cpp -emit-llvm -o ch9_2_tailcall.bc</span>
<span class="gp">JonathantekiiMac:input Jonathan$ </span>~/llvm/test/build/bin/
<span class="go">llvm-dis ch9_2_tailcall.bc -o -</span>
<span class="go">...</span>
<span class="go">; Function Attrs: nounwind readnone</span>
<span class="go">define i32 @_Z9factoriali(i32 %x) #0 {</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> icmp sgt i32 %x, <span class="m">0</span>
<span class="go">  br i1 %1, label %tailrecurse.preheader, label %tailrecurse._crit_edge</span>

<span class="go">tailrecurse.preheader:                            ; preds = %0</span>
<span class="go">  br label %tailrecurse</span>

<span class="go">tailrecurse:                                      ; preds = %tailrecurse,</span>
<span class="gp">%</span>tailrecurse.preheader
<span class="gp">  %</span>x.tr2 <span class="o">=</span> phi i32 <span class="o">[</span> %2, %tailrecurse <span class="o">]</span>, <span class="o">[</span> %x, %tailrecurse.preheader <span class="o">]</span>
<span class="gp">  %</span>accumulator.tr1 <span class="o">=</span> phi i32 <span class="o">[</span> %3, %tailrecurse <span class="o">]</span>, <span class="o">[</span> <span class="m">1</span>, %tailrecurse.preheader <span class="o">]</span>
<span class="gp">  %</span><span class="nv">2</span> <span class="o">=</span> add nsw i32 %x.tr2, -1
<span class="gp">  %</span><span class="nv">3</span> <span class="o">=</span> mul nsw i32 %x.tr2, %accumulator.tr1
<span class="gp">  %</span><span class="nv">4</span> <span class="o">=</span> icmp sgt i32 %2, <span class="m">0</span>
<span class="go">  br i1 %4, label %tailrecurse, label %tailrecurse._crit_edge.loopexit</span>

<span class="go">tailrecurse._crit_edge.loopexit:                  ; preds = %tailrecurse</span>
<span class="gp">  %</span>.lcssa <span class="o">=</span> phi i32 <span class="o">[</span> %3, %tailrecurse <span class="o">]</span>
<span class="go">  br label %tailrecurse._crit_edge</span>

<span class="go">tailrecurse._crit_edge:                           ; preds = %tailrecurse._crit</span>
<span class="go">  _edge.loopexit, %0</span>
<span class="gp">  %</span>accumulator.tr.lcssa <span class="o">=</span> phi i32 <span class="o">[</span> <span class="m">1</span>, %0 <span class="o">]</span>, <span class="o">[</span> %.lcssa, %tailrecurse._crit_edge
<span class="go">  .loopexit ]</span>
<span class="go">  ret i32 %accumulator.tr.lcssa</span>
<span class="go">}</span>

<span class="go">; Function Attrs: nounwind readnone</span>
<span class="go">define i32 @_Z13test_tailcalli(i32 %a) #0 {</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> icmp sgt i32 %a, <span class="m">0</span>
<span class="go">  br i1 %1, label %tailrecurse.i.preheader, label %_Z9factoriali.exit</span>

<span class="go">tailrecurse.i.preheader:                          ; preds = %0</span>
<span class="go">  br label %tailrecurse.i</span>

<span class="go">tailrecurse.i:                                    ; preds = %tailrecurse.i,</span>
<span class="gp">  %</span>tailrecurse.i.preheader
<span class="gp">  %</span>x.tr2.i <span class="o">=</span> phi i32 <span class="o">[</span> %2, %tailrecurse.i <span class="o">]</span>, <span class="o">[</span> %a, %tailrecurse.i.preheader <span class="o">]</span>
<span class="gp">  %</span>accumulator.tr1.i <span class="o">=</span> phi i32 <span class="o">[</span> %3, %tailrecurse.i <span class="o">]</span>, <span class="o">[</span> <span class="m">1</span>, %tailrecurse.i.
<span class="go">  preheader ]</span>
<span class="gp">  %</span><span class="nv">2</span> <span class="o">=</span> add nsw i32 %x.tr2.i, -1
<span class="gp">  %</span><span class="nv">3</span> <span class="o">=</span> mul nsw i32 %accumulator.tr1.i, %x.tr2.i
<span class="gp">  %</span><span class="nv">4</span> <span class="o">=</span> icmp sgt i32 %2, <span class="m">0</span>
<span class="go">  br i1 %4, label %tailrecurse.i, label %_Z9factoriali.exit.loopexit</span>

<span class="go">_Z9factoriali.exit.loopexit:                      ; preds = %tailrecurse.i</span>
<span class="gp">  %</span>.lcssa <span class="o">=</span> phi i32 <span class="o">[</span> %3, %tailrecurse.i <span class="o">]</span>
<span class="go">  br label %_Z9factoriali.exit</span>

<span class="go">_Z9factoriali.exit:                               ; preds = %_Z9factoriali.</span>
<span class="go">  exit.loopexit, %0</span>
<span class="gp">  %</span>accumulator.tr.lcssa.i <span class="o">=</span> phi i32 <span class="o">[</span> <span class="m">1</span>, %0 <span class="o">]</span>, <span class="o">[</span> %.lcssa, %_Z9factoriali.
<span class="go">  exit.loopexit ]</span>
<span class="go">  ret i32 %accumulator.tr.lcssa.i</span>
<span class="go">}</span>
<span class="go">...</span>
<span class="gp">JonathantekiiMac:input Jonathan$ </span>~/llvm/test/build/bin/
<span class="go">llc -march=cpu0 -mcpu=cpu032I -relocation-model=static -filetype=asm</span>
<span class="go">ch9_2_tailcall.bc -o -</span>
<span class="go">        .text</span>
<span class="go">        .section .mdebug.abiS32</span>
<span class="go">        .previous</span>
<span class="go">        .file &quot;ch9_2_tailcall.bc&quot;</span>
<span class="go">        .globl        _Z9factoriali</span>
<span class="go">        .align        2</span>
<span class="go">        .type _Z9factoriali,@function</span>
<span class="go">        .ent  _Z9factoriali           # @_Z9factoriali</span>
<span class="go">_Z9factoriali:</span>
<span class="go">        .frame        $sp,0,$lr</span>
<span class="go">        .mask         0x00000000,0</span>
<span class="go">        .set  noreorder</span>
<span class="go">        .set  nomacro</span>
<span class="gp"># </span>BB#0:
<span class="go">        addiu $2, $zero, 1</span>
<span class="go">        ld    $3, 0($sp)</span>
<span class="go">        cmp   $sw, $3, $2</span>
<span class="go">        jlt   $sw, $BB0_2</span>
<span class="go">        nop</span>
<span class="gp">$</span>BB0_1:                                 <span class="c1"># %tailrecurse</span>
<span class="gp">                                        # </span><span class="o">=</span>&gt;This Inner Loop Header: <span class="nv">Depth</span><span class="o">=</span><span class="m">1</span>
<span class="go">        mul   $2, $3, $2</span>
<span class="go">        addiu $3, $3, -1</span>
<span class="go">        addiu $4, $zero, 0</span>
<span class="go">        cmp   $sw, $3, $4</span>
<span class="go">        jgt   $sw, $BB0_1</span>
<span class="go">        nop</span>
<span class="gp">$</span>BB0_2:                                 <span class="c1"># %tailrecurse._crit_edge</span>
<span class="go">        ret   $lr</span>
<span class="go">        nop</span>
<span class="go">        .set  macro</span>
<span class="go">        .set  reorder</span>
<span class="go">        .end  _Z9factoriali</span>
<span class="gp">$</span>tmp0:
<span class="go">        .size _Z9factoriali, ($tmp0)-_Z9factoriali</span>

<span class="go">        .globl        _Z13test_tailcalli</span>
<span class="go">        .align        2</span>
<span class="go">        .type _Z13test_tailcalli,@function</span>
<span class="go">        .ent  _Z13test_tailcalli      # @_Z13test_tailcalli</span>
<span class="go">_Z13test_tailcalli:</span>
<span class="go">        .frame        $sp,0,$lr</span>
<span class="go">        .mask         0x00000000,0</span>
<span class="go">        .set  noreorder</span>
<span class="go">        .set  nomacro</span>
<span class="gp"># </span>BB#0:
<span class="go">        addiu $2, $zero, 1</span>
<span class="go">        ld    $3, 0($sp)</span>
<span class="go">        cmp   $sw, $3, $2</span>
<span class="go">        jlt   $sw, $BB1_2</span>
<span class="go">        nop</span>
<span class="gp">$</span>BB1_1:                                 <span class="c1"># %tailrecurse.i</span>
<span class="gp">                                        # </span><span class="o">=</span>&gt;This Inner Loop Header: <span class="nv">Depth</span><span class="o">=</span><span class="m">1</span>
<span class="go">        mul   $2, $2, $3</span>
<span class="go">        addiu $3, $3, -1</span>
<span class="go">        addiu $4, $zero, 0</span>
<span class="go">        cmp   $sw, $3, $4</span>
<span class="go">        jgt   $sw, $BB1_1</span>
<span class="go">        nop</span>
<span class="gp">$</span>BB1_2:                                 <span class="c1"># %_Z9factoriali.exit</span>
<span class="go">        ret   $lr</span>
<span class="go">        nop</span>
<span class="go">        .set  macro</span>
<span class="go">        .set  reorder</span>
<span class="go">        .end  _Z13test_tailcalli</span>
<span class="gp">$</span>tmp1:
<span class="go">        .size _Z13test_tailcalli, ($tmp1)-_Z13test_tailcalli</span>
</pre></div>
</div>
<p>According to the above LLVM IR, the <code class="docutils literal notranslate"><span class="pre">clang</span> <span class="pre">-O3</span></code> option replaces recursion
with a loop by inlining the callee recursion function. This is a frontend
optimization achieved through cross-function analysis.</p>
<p>Cpu0 doesn’t support <cite>fastcc</cite> <a class="footnote-reference brackets" href="#callconv" id="id8" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a>, but it can pass the <cite>fastcc</cite>
keyword in the IR. MIPS supports <cite>fastcc</cite> by using as many registers as
possible without strictly following the ABI specification.</p>
</section>
</section>
<section id="other-features-supported">
<h2><a class="toc-backref" href="#id44" role="doc-backlink">Other Features Supported</a><a class="headerlink" href="#other-features-supported" title="Permalink to this heading">¶</a></h2>
<p>This section supports features for the “$gp register caller saved register in
PIC addressing mode,” “variable number of arguments,” and “dynamic stack
allocation.”</p>
<p>Run <cite>Chapter9_2/</cite> with <cite>ch9_3_vararg.cpp</cite> to get the following error:</p>
<p class="rubric">lbdex/input/ch9_3_vararg.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &lt;stdarg.h&gt;</span>

<span class="nb">int</span> <span class="n">sum_i</span><span class="p">(</span><span class="nb">int</span> <span class="n">amount</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nb">int</span> <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	
  <span class="n">va_list</span> <span class="n">vl</span><span class="p">;</span>
  <span class="n">va_start</span><span class="p">(</span><span class="n">vl</span><span class="p">,</span> <span class="n">amount</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">amount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">vl</span><span class="p">,</span> <span class="nb">int</span><span class="p">);</span>
    <span class="nb">sum</span> <span class="o">+=</span> <span class="n">val</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">va_end</span><span class="p">(</span><span class="n">vl</span><span class="p">);</span>
  
  <span class="k">return</span> <span class="nb">sum</span><span class="p">;</span> 
<span class="p">}</span>

<span class="n">long</span> <span class="n">long</span> <span class="n">sum_ll</span><span class="p">(</span><span class="n">long</span> <span class="n">long</span> <span class="n">amount</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">long</span> <span class="n">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">long</span> <span class="n">long</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">long</span> <span class="n">long</span> <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	
  <span class="n">va_list</span> <span class="n">vl</span><span class="p">;</span>
  <span class="n">va_start</span><span class="p">(</span><span class="n">vl</span><span class="p">,</span> <span class="n">amount</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">amount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">vl</span><span class="p">,</span> <span class="n">long</span> <span class="n">long</span><span class="p">);</span>
    <span class="nb">sum</span> <span class="o">+=</span> <span class="n">val</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">va_end</span><span class="p">(</span><span class="n">vl</span><span class="p">);</span>
  
  <span class="k">return</span> <span class="nb">sum</span><span class="p">;</span> 
<span class="p">}</span>

<span class="nb">int</span> <span class="n">test_va_arg</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">sum_i</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
  <span class="n">long</span> <span class="n">long</span> <span class="n">b</span> <span class="o">=</span> <span class="n">sum_ll</span><span class="p">(</span><span class="mi">6</span><span class="n">LL</span><span class="p">,</span> <span class="mi">0</span><span class="n">LL</span><span class="p">,</span> <span class="mi">1</span><span class="n">LL</span><span class="p">,</span> <span class="mi">2</span><span class="n">LL</span><span class="p">,</span> <span class="mi">3</span><span class="n">LL</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="n">LL</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="n">LL</span><span class="p">);</span>
	
  <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="n">b</span><span class="p">;</span> <span class="o">//</span> <span class="mi">12</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-78-230:input Jonathan$ </span>clang -target mips-unknown-linux-gnu -c
<span class="go">ch9_3_vararg.cpp -emit-llvm -o ch9_3_vararg.bc</span>
<span class="gp">118-165-78-230:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llc -march=cpu0 -relocation-model=pic -filetype=asm ch9_3_vararg.bc -o -</span>
<span class="go">...</span>
<span class="go">LLVM ERROR: Cannot select: 0x7f8b6902fd10: ch = vastart 0x7f8b6902fa10,</span>
<span class="go">0x7f8b6902fb10, 0x7f8b6902fc10 [ORD=9] [ID=22]</span>
<span class="go">  0x7f8b6902fb10: i32 = FrameIndex&lt;5&gt; [ORD=7] [ID=9]</span>
<span class="go">In function: _Z5sum_iiz</span>
</pre></div>
</div>
<p class="rubric">lbdex/input/ch9_3_alloc.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="o">//</span> <span class="n">This</span> <span class="n">file</span> <span class="n">needed</span> <span class="nb">compile</span> <span class="n">without</span> <span class="n">option</span><span class="p">,</span> <span class="o">-</span><span class="n">target</span> <span class="n">mips</span><span class="o">-</span><span class="n">unknown</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">gnu</span><span class="p">,</span> <span class="n">so</span> 
<span class="o">//</span> <span class="n">it</span> <span class="ow">is</span> <span class="n">verified</span> <span class="n">by</span> <span class="n">build</span><span class="o">-</span><span class="n">run_backend2</span><span class="o">.</span><span class="n">sh</span> <span class="ow">or</span> <span class="n">verified</span> <span class="ow">in</span> <span class="n">lld</span> <span class="n">linker</span> <span class="n">support</span>
<span class="o">//</span> <span class="p">(</span><span class="n">build</span><span class="o">-</span><span class="n">slinker</span><span class="o">.</span><span class="n">sh</span><span class="p">)</span><span class="o">.</span>

<span class="o">//</span><span class="c1">#include &lt;alloca.h&gt;</span>
<span class="o">//</span><span class="c1">#include &lt;stdlib.h&gt;</span>

<span class="nb">int</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">int</span> <span class="n">x1</span><span class="p">,</span> <span class="nb">int</span> <span class="n">x2</span><span class="p">,</span> <span class="nb">int</span> <span class="n">x3</span><span class="p">,</span> <span class="nb">int</span> <span class="n">x4</span><span class="p">,</span> <span class="nb">int</span> <span class="n">x5</span><span class="p">,</span> <span class="nb">int</span> <span class="n">x6</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="nb">sum</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span> <span class="o">+</span> <span class="n">x3</span> <span class="o">+</span> <span class="n">x4</span> <span class="o">+</span> <span class="n">x5</span> <span class="o">+</span> <span class="n">x6</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="nb">sum</span><span class="p">;</span> 
<span class="p">}</span>

<span class="nb">int</span> <span class="n">weight_sum</span><span class="p">(</span><span class="nb">int</span> <span class="n">x1</span><span class="p">,</span> <span class="nb">int</span> <span class="n">x2</span><span class="p">,</span> <span class="nb">int</span> <span class="n">x3</span><span class="p">,</span> <span class="nb">int</span> <span class="n">x4</span><span class="p">,</span> <span class="nb">int</span> <span class="n">x5</span><span class="p">,</span> <span class="nb">int</span> <span class="n">x6</span><span class="p">)</span>
<span class="p">{</span>
<span class="o">//</span>  <span class="nb">int</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="o">*</span><span class="p">)</span><span class="n">alloca</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">x1</span><span class="p">);</span>
  <span class="nb">int</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="o">*</span><span class="p">)</span><span class="n">__builtin_alloca</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">x1</span><span class="p">);</span>
  <span class="nb">int</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
  <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">x3</span><span class="p">;</span>

  <span class="nb">int</span> <span class="n">weight</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">,</span> <span class="n">x4</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x5</span><span class="p">,</span> <span class="n">x6</span><span class="p">);</span>

  <span class="k">return</span> <span class="p">(</span><span class="n">weight</span> <span class="o">+</span> <span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">));</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">test_alloc</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">weight_sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span> <span class="o">//</span> <span class="mi">31</span>
  
  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Run <cite>Chapter9_2</cite> with <cite>ch9_3_alloc.cpp</cite> to get the following error.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-72-242:input Jonathan$ </span>clang -target mips-unknown-linux-gnu -c
<span class="go">ch9_3_alloc.cpp -emit-llvm -o ch9_3_alloc.bc</span>
<span class="gp">118-165-72-242:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llc -march=cpu0 -mcpu=cpu032I -cpu0-s32-calls=false</span>
<span class="go">-relocation-model=pic -filetype=asm ch9_3_alloc.bc -o -</span>
<span class="go">...</span>
<span class="go">LLVM ERROR: Cannot select: 0x7ffd8b02ff10: i32,ch = dynamic_stackalloc</span>
<span class="go">0x7ffd8b02f910:1, 0x7ffd8b02fe10, 0x7ffd8b02c010 [ORD=12] [ID=48]</span>
<span class="go">  0x7ffd8b02fe10: i32 = and 0x7ffd8b02fc10, 0x7ffd8b02fd10 [ORD=12] [ID=47]</span>
<span class="go">    0x7ffd8b02fc10: i32 = add 0x7ffd8b02fa10, 0x7ffd8b02fb10 [ORD=12] [ID=46]</span>
<span class="go">      0x7ffd8b02fa10: i32 = shl 0x7ffd8b02f910, 0x7ffd8b02f510 [ID=45]</span>
<span class="go">        0x7ffd8b02f910: i32,ch = load 0x7ffd8b02ee10, 0x7ffd8b02e310,</span>
<span class="go">        0x7ffd8b02b310&lt;LD4[%1]&gt; [ID=44]</span>
<span class="go">          0x7ffd8b02e310: i32 = FrameIndex&lt;1&gt; [ORD=3] [ID=10]</span>
<span class="go">          0x7ffd8b02b310: i32 = undef [ORD=1] [ID=2]</span>
<span class="go">        0x7ffd8b02f510: i32 = Constant&lt;2&gt; [ID=25]</span>
<span class="go">      0x7ffd8b02fb10: i32 = Constant&lt;7&gt; [ORD=12] [ID=16]</span>
<span class="go">    0x7ffd8b02fd10: i32 = Constant&lt;-8&gt; [ORD=12] [ID=17]</span>
<span class="go">  0x7ffd8b02c010: i32 = Constant&lt;0&gt; [ORD=12] [ID=8]</span>
<span class="go">In function: _Z5sum_iiiiiii</span>
</pre></div>
</div>
<section id="the-gp-register-caller-saved-register-in-pic-addressing-mode">
<h3><a class="toc-backref" href="#id45" role="doc-backlink">The $gp Register Caller Saved Register in PIC Addressing Mode</a><a class="headerlink" href="#the-gp-register-caller-saved-register-in-pic-addressing-mode" title="Permalink to this heading">¶</a></h3>
<p>According to the original Cpu0 website information, it only supports <strong>“jsub”</strong>
for 24-bit address range access. We added <strong>“jalr”</strong> to Cpu0 and expanded it to
32-bit addressing. We made this change for two reasons:</p>
<ol class="arabic simple">
<li><p>Cpu0 can be expanded to 32-bit address space by simply adding this instruction.</p></li>
<li><p>Cpu0 and this book are designed as a tutorial for better understanding.</p></li>
</ol>
<p>We reserve <strong>“jalr”</strong> for PIC mode, which is used for dynamic linking functions,
to demonstrate:</p>
<ol class="arabic simple">
<li><p>How the caller handles the caller-saved register <cite>$gp</cite> when calling a function.</p></li>
<li><p>How code in the shared library function uses <cite>$gp</cite> to access the global
variable address.</p></li>
<li><p>Why using <strong>jalr</strong> for dynamic linking functions is easier to implement and
faster. As we discussed in the “PIC mode” section of the chapter on “Global
variables, structs, arrays, and other types,” this solution is popular in real
applications and deserves to be incorporated into the official Cpu0 design in
compiler books.</p></li>
</ol>
<p>In the chapter on “Global Variables,” we mentioned two link types: static link
and dynamic link. The option <cite>-relocation-model=static</cite> is for static link functions,
while <cite>-relocation-model=pic</cite> is for dynamic link functions. An example of a dynamic
link function is calling functions from a shared library.</p>
<p>Shared libraries consist of many dynamic link functions that are typically loaded
at runtime. Since shared libraries can be loaded at different memory addresses,
the address of a global variable cannot be determined at link time. However, the
distance between the global variable address and the start address of the shared
library function can be calculated once it has been loaded.</p>
<p>Let’s run <cite>Chapter9_3/</cite> with <cite>ch9_gprestore.cpp</cite> to get the following result.
We will add comments in the result for explanation.</p>
<p class="rubric">lbdex/input/ch9_gprestore.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="nb">int</span> <span class="n">sum_i</span><span class="p">(</span><span class="nb">int</span> <span class="n">x1</span><span class="p">);</span>

<span class="nb">int</span> <span class="n">call_sum_i</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">sum_i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">a</span> <span class="o">+=</span> <span class="n">sum_i</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-78-230:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llc -march=cpu0 -mcpu=cpu032II-cpu0-s32-calls=true</span>
<span class="go">-relocation-model=pic -filetype=asm ch9_gprestore.bc -o -</span>
<span class="go">...</span>
<span class="go">  .cpload $t9</span>
<span class="go">  .set  nomacro</span>
<span class="gp"># </span>BB#0:                                 <span class="c1"># %entry</span>
<span class="go">  addiu $sp, $sp, -24</span>
<span class="gp">$</span>tmp0:
<span class="go">  .cfi_def_cfa_offset 24</span>
<span class="go">  st  $lr, 12($sp)            # 4-byte Folded Spill</span>
<span class="go">  st  $fp, 16($sp)              # 4-byte Folded Spill</span>
<span class="gp">$</span>tmp1:
<span class="go">  .cfi_offset 14, -4</span>
<span class="gp">$</span>tmp2:
<span class="go">  .cfi_offset 12, -8</span>
<span class="go">  .cprestore  8    // save $gp to 8($sp)</span>
<span class="go">  ld  $t9, %call16(_Z5sum_ii)($gp)</span>
<span class="go">  addiu $4, $zero, 1</span>
<span class="go">  jalr  $t9</span>
<span class="go">  nop</span>
<span class="go">  ld  $gp, 8($sp)  // restore $gp from 8($sp)</span>
<span class="go">  add $8, $zero, $2</span>
<span class="go">  ld  $t9, %call16(_Z5sum_ii)($gp)</span>
<span class="go">  addiu $4, $zero, 2</span>
<span class="go">  jalr  $t9</span>
<span class="go">  nop</span>
<span class="go">  ld  $gp, 8($sp)  // restore $gp from 8($sp)</span>
<span class="go">  addu  $2, $2, $8</span>
<span class="go">  ld  $8, 8($sp)              # 4-byte Folded Reload</span>
<span class="go">  ld  $lr, 12($sp)            # 4-byte Folded Reload</span>
<span class="go">  addiu $sp, $sp, 16</span>
<span class="go">  ret $lr</span>
<span class="go">  nop</span>
</pre></div>
</div>
<p>As mentioned in the code comment, <strong>“.cprestore 8”</strong> is a pseudo instruction
for saving <strong>$gp</strong> to <strong>8($sp)</strong>, while the instruction <strong>“ld $gp, 8($sp)”</strong>
restores the $gp. Refer to Table 8-1 of the “MIPSpro TM Assembly Language
Programmer’s Guide” <a class="footnote-reference brackets" href="#mipsasm" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> for more details.</p>
<p>In other words, $gp is a caller-saved register, so the <cite>main()</cite> function
needs to save and restore $gp before and after calling the shared library
<cite>_Z5sum_ii()</cite> function.</p>
<p>In LLVM MIPS 3.5, the <cite>.cprestore</cite> instruction was removed in PIC mode,
meaning $gp is no longer treated as a caller-saved register in PIC. However,
it is still present in Cpu0, and this feature can be removed by not defining
it in <cite>Cpu0Config.h</cite>.</p>
<p>The <cite>#ifdef ENABLE_GPRESTORE</cite> part of the code in Cpu0 can be removed, but
it comes with the cost of reserving the $gp register as a specific register
that cannot be allocated for program variables in PIC mode. As explained in
earlier chapters on “Global Variables,” PIC is not a critical function, and
its performance advantage can be considered negligible in dynamic linking.
Therefore, we keep this feature in Cpu0.</p>
<p>Reserving $gp as a specific register in PIC mode will save a lot of code
during programming. When reserving $gp, the <cite>.cprestore</cite> can be disabled
using the option <cite>“-cpu0-reserve-gp”</cite>.</p>
<p>The <cite>.cpload</cite> instruction is still needed even when reserving $gp (since
programmers may implement boot code functions with a mix of C and assembly).
In this case, the programmer can set the $gp value through <cite>.cpload</cite>.</p>
<p>If enabling <cite>-cpu0-no-cpload</cite>, and undefining <cite>ENABLE_GPRESTORE</cite> or enabling
<cite>-cpu0-reserve-gp</cite>, the <cite>.cpload</cite> and <cite>$gp</cite> save/restore instructions will
not be issued, as shown in the following.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-78-230:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llc -march=cpu0 -mcpu=cpu032II-cpu0-s32-calls=true</span>
<span class="go">-relocation-model=pic -filetype=asm ch9_gprestore.bc -cpu0-no-cpload</span>
<span class="go">-cpu0-reserve-gp -o -</span>
<span class="go">...</span>
<span class="gp"># </span>BB#0:
<span class="go">  addiu $sp, $sp, -24</span>
<span class="gp">$</span>tmp0:
<span class="go">  .cfi_def_cfa_offset 24</span>
<span class="go">  st  $lr, 20($sp)            # 4-byte Folded Spill</span>
<span class="go">  st  $fp, 16($sp)            # 4-byte Folded Spill</span>
<span class="gp">$</span>tmp1:
<span class="go">  .cfi_offset 14, -4</span>
<span class="gp">$</span>tmp2:
<span class="go">  .cfi_offset 12, -8</span>
<span class="go">  move   $fp, $sp</span>
<span class="gp">$</span>tmp3:
<span class="go">  .cfi_def_cfa_register 12</span>
<span class="go">  ld  $t9, %call16(_Z5sum_ii)($gp)</span>
<span class="go">  addiu $4, $zero, 1</span>
<span class="go">  jalr  $t9</span>
<span class="go">  nop</span>
<span class="go">  st  $2, 12($fp)</span>
<span class="go">  addiu $4, $zero, 2</span>
<span class="go">  ld  $t9, %call16(_Z5sum_ii)($gp)</span>
<span class="go">  jalr  $t9</span>
<span class="go">  nop</span>
<span class="go">  ld  $3, 12($fp)</span>
<span class="go">  addu  $2, $3, $2</span>
<span class="go">  st  $2, 12($fp)</span>
<span class="go">  move   $sp, $fp</span>
<span class="go">  ld  $fp, 16($sp)            # 4-byte Folded Reload</span>
<span class="go">  ld  $lr, 20($sp)            # 4-byte Folded Reload</span>
<span class="go">  addiu $sp, $sp, 24</span>
<span class="go">  ret $lr</span>
<span class="go">  nop</span>
</pre></div>
</div>
<p>LLVM Mips 3.1 emits the directives <code class="docutils literal notranslate"><span class="pre">.cpload</span></code> and <code class="docutils literal notranslate"><span class="pre">.cprestore</span></code>, and Cpu0
inherits this behavior from that version. However, newer versions of LLVM Mips
replace <code class="docutils literal notranslate"><span class="pre">.cpload</span></code> with actual instructions and remove <code class="docutils literal notranslate"><span class="pre">.cprestore</span></code> entirely.
In these versions, the <code class="docutils literal notranslate"><span class="pre">$gp</span></code> register is treated as a reserved register in PIC
(position-independent code) mode.</p>
<p>According to the MIPS assembly documentation I referenced, <code class="docutils literal notranslate"><span class="pre">$gp</span></code> is considered
a “caller-saved register.” Cpu0 follows this convention and provides an option to
reserve the <code class="docutils literal notranslate"><span class="pre">$gp</span></code> register accordingly.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-78-230:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llc -march=mips -relocation-model=pic -filetype=asm ch9_gprestore.bc</span>
<span class="go">-o -</span>
<span class="go">...</span>
<span class="gp"># </span>BB#0:                                 <span class="c1"># %entry</span>
<span class="go">  lui $2, %hi(_gp_disp)</span>
<span class="go">  ori $2, $2, %lo(_gp_disp)</span>
<span class="go">  addiu $sp, $sp, -32</span>
<span class="gp">$</span>tmp0:
<span class="go">  .cfi_def_cfa_offset 32</span>
<span class="go">  sw  $ra, 28($sp)            # 4-byte Folded Spill</span>
<span class="go">  sw  $fp, 24($sp)            # 4-byte Folded Spill</span>
<span class="go">  sw  $16, 20($sp)            # 4-byte Folded Spill</span>
<span class="gp">$</span>tmp1:
<span class="go">  .cfi_offset 31, -4</span>
<span class="gp">$</span>tmp2:
<span class="go">  .cfi_offset 30, -8</span>
<span class="gp">$</span>tmp3:
<span class="go">  .cfi_offset 16, -12</span>
<span class="go">  move   $fp, $sp</span>
<span class="gp">$</span>tmp4:
<span class="go">  .cfi_def_cfa_register 30</span>
<span class="go">  addu  $16, $2, $25</span>
<span class="go">  lw  $25, %call16(_Z5sum_ii)($16)</span>
<span class="go">  addiu $4, $zero, 1</span>
<span class="go">  jalr  $25</span>
<span class="go">  move   $gp, $16</span>
<span class="go">  sw  $2, 16($fp)</span>
<span class="go">  lw  $25, %call16(_Z5sum_ii)($16)</span>
<span class="go">  jalr  $25</span>
<span class="go">  addiu $4, $zero, 2</span>
<span class="go">  lw  $1, 16($fp)</span>
<span class="go">  addu  $2, $1, $2</span>
<span class="go">  sw  $2, 16($fp)</span>
<span class="go">  move   $sp, $fp</span>
<span class="go">  lw  $16, 20($sp)            # 4-byte Folded Reload</span>
<span class="go">  lw  $fp, 24($sp)            # 4-byte Folded Reload</span>
<span class="go">  lw  $ra, 28($sp)            # 4-byte Folded Reload</span>
<span class="go">  jr  $ra</span>
<span class="go">  addiu $sp, $sp, 32</span>
</pre></div>
</div>
<p>The following code, added in Chapter9_3/, emits <code class="docutils literal notranslate"><span class="pre">.cprestore</span></code> or the
corresponding machine instructions before the first PIC function call.</p>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0ISelLowering.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">///</span> <span class="n">LowerCall</span> <span class="o">-</span> <span class="n">functions</span> <span class="n">arguments</span> <span class="n">are</span> <span class="n">copied</span> <span class="kn">from</span> <span class="nn">virtual</span> <span class="n">regs</span> <span class="n">to</span>
<span class="o">///</span> <span class="p">(</span><span class="n">physical</span> <span class="n">regs</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">stack</span> <span class="n">frame</span><span class="p">),</span> <span class="n">CALLSEQ_START</span> <span class="ow">and</span> <span class="n">CALLSEQ_END</span> <span class="n">are</span> <span class="n">emitted</span><span class="o">.</span>
<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">LowerCall</span><span class="p">(</span><span class="n">TargetLowering</span><span class="p">::</span><span class="n">CallLoweringInfo</span> <span class="o">&amp;</span><span class="n">CLI</span><span class="p">,</span>
                              <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#ifdef ENABLE_GPRESTORE
  if (!Cpu0ReserveGP) {
    // If this is the first call, create a stack frame object that points to
    // a location to which .cprestore saves $gp.
    if (IsPIC &amp;&amp; Cpu0FI-&gt;globalBaseRegFixed() &amp;&amp; !Cpu0FI-&gt;getGPFI())
      Cpu0FI-&gt;setGPFI(MFI.CreateFixedObject(4, 0, true));
    if (Cpu0FI-&gt;needGPSaveRestore())
      MFI.setObjectOffset(Cpu0FI-&gt;getGPFI(), NextStackOffset);
  }
#endif
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0MachineFunction.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#ifdef ENABLE_GPRESTORE</span>
  <span class="nb">bool</span> <span class="n">needGPSaveRestore</span><span class="p">()</span> <span class="n">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">getGPFI</span><span class="p">();</span> <span class="p">}</span>
<span class="c1">#endif</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0SEFrameLowering.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">Cpu0SEFrameLowering</span><span class="p">::</span><span class="n">emitPrologue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                       <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#ifdef ENABLE_GPRESTORE</span>
  <span class="o">//</span> <span class="n">Restore</span> <span class="n">GP</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">saved</span> <span class="n">stack</span> <span class="n">location</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">needGPSaveRestore</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">unsigned</span> <span class="n">Offset</span> <span class="o">=</span> <span class="n">MFI</span><span class="o">.</span><span class="n">getObjectOffset</span><span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getGPFI</span><span class="p">());</span>
    <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MBBI</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">TII</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">Cpu0</span><span class="p">::</span><span class="n">CPRESTORE</span><span class="p">))</span><span class="o">.</span><span class="n">addImm</span><span class="p">(</span><span class="n">Offset</span><span class="p">)</span>
      <span class="o">.</span><span class="n">addReg</span><span class="p">(</span><span class="n">Cpu0</span><span class="p">::</span><span class="n">GP</span><span class="p">);</span>
  <span class="p">}</span>
<span class="c1">#endif</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0RegisterInfo.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//-</span> <span class="n">If</span> <span class="n">no</span> <span class="n">eliminateFrameIndex</span><span class="p">(),</span> <span class="n">it</span> <span class="n">will</span> <span class="n">hang</span> <span class="n">on</span> <span class="n">run</span><span class="o">.</span> 
<span class="o">//</span> <span class="n">pure</span> <span class="n">virtual</span> <span class="n">method</span>
<span class="o">//</span> <span class="n">FrameIndex</span> <span class="n">represent</span> <span class="n">objects</span> <span class="n">inside</span> <span class="n">a</span> <span class="n">abstract</span> <span class="n">stack</span><span class="o">.</span>
<span class="o">//</span> <span class="n">We</span> <span class="n">must</span> <span class="n">replace</span> <span class="n">FrameIndex</span> <span class="k">with</span> <span class="n">an</span> <span class="n">stack</span><span class="o">/</span><span class="n">frame</span> <span class="n">pointer</span>
<span class="o">//</span> <span class="n">direct</span> <span class="n">reference</span><span class="o">.</span>
<span class="n">void</span> <span class="n">Cpu0RegisterInfo</span><span class="p">::</span>
<span class="n">eliminateFrameIndex</span><span class="p">(</span><span class="n">MachineBasicBlock</span><span class="p">::</span><span class="n">iterator</span> <span class="n">II</span><span class="p">,</span> <span class="nb">int</span> <span class="n">SPAdj</span><span class="p">,</span>
                    <span class="n">unsigned</span> <span class="n">FIOperandNum</span><span class="p">,</span> <span class="n">RegScavenger</span> <span class="o">*</span><span class="n">RS</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#ifdef ENABLE_GPRESTORE //2</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">isOutArgFI</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">)</span> <span class="o">||</span> <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">isGPFI</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">)</span> <span class="o">||</span>
      <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">isDynAllocFI</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">))</span>
    <span class="n">Offset</span> <span class="o">=</span> <span class="n">spOffset</span><span class="p">;</span>
  <span class="k">else</span>
<span class="c1">#endif</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0InstrInfo.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// When handling PIC code the assembler needs .cpload and .cprestore
// directives. If the real instructions corresponding these directives
// are used, we have the same behavior, but get also a bunch of warnings
// from the assembler.
let hasSideEffects = 0 in
def CPRESTORE : Cpu0Pseudo&lt;(outs), (ins i32imm:$loc, CPURegs:$gp),
                           &quot;.cprestore\t$loc&quot;, []&gt;;
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0AsmPrinter.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#ifdef ENABLE_GPRESTORE</span>
<span class="n">void</span> <span class="n">Cpu0AsmPrinter</span><span class="p">::</span><span class="n">EmitInstrWithMacroNoAT</span><span class="p">(</span><span class="n">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MCInst</span> <span class="n">TmpInst</span><span class="p">;</span>

  <span class="n">MCInstLowering</span><span class="o">.</span><span class="n">Lower</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span> <span class="n">TmpInst</span><span class="p">);</span>
  <span class="n">OutStreamer</span><span class="o">-&gt;</span><span class="n">emitRawText</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">.set</span><span class="se">\t</span><span class="s2">macro&quot;</span><span class="p">));</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getEmitNOAT</span><span class="p">())</span>
    <span class="n">OutStreamer</span><span class="o">-&gt;</span><span class="n">emitRawText</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">.set</span><span class="se">\t</span><span class="s2">at&quot;</span><span class="p">));</span>
  <span class="n">OutStreamer</span><span class="o">-&gt;</span><span class="n">emitInstruction</span><span class="p">(</span><span class="n">TmpInst</span><span class="p">,</span> <span class="n">getSubtargetInfo</span><span class="p">());</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getEmitNOAT</span><span class="p">())</span>
    <span class="n">OutStreamer</span><span class="o">-&gt;</span><span class="n">emitRawText</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">.set</span><span class="se">\t</span><span class="s2">noat&quot;</span><span class="p">));</span>
  <span class="n">OutStreamer</span><span class="o">-&gt;</span><span class="n">emitRawText</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">.set</span><span class="se">\t</span><span class="s2">nomacro&quot;</span><span class="p">));</span>
<span class="p">}</span>
<span class="c1">#endif</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#ifdef ENABLE_GPRESTORE
void Cpu0AsmPrinter::emitPseudoCPRestore(MCStreamer &amp;OutStreamer,
                                              const MachineInstr *MI) {
  SmallVector&lt;MCInst, 4&gt; MCInsts;
  const MachineOperand &amp;MO = MI-&gt;getOperand(0);
  assert(MO.isImm() &amp;&amp; &quot;CPRESTORE&#39;s operand must be an immediate.&quot;);
  int64_t Offset = MO.getImm();

  if (OutStreamer.hasRawTextSupport()) {
    // output assembly
    if (!isInt&lt;16&gt;(Offset)) {
      EmitInstrWithMacroNoAT(MI);
      return;
    }
    MCInst TmpInst0;
    MCInstLowering.Lower(MI, TmpInst0);
    OutStreamer.emitInstruction(TmpInst0, getSubtargetInfo());
  } else {
    // output elf
    MCInstLowering.LowerCPRESTORE(Offset, MCInsts);

    for (SmallVector&lt;MCInst, 4&gt;::iterator I = MCInsts.begin();
         I != MCInsts.end(); ++I)
      OutStreamer.emitInstruction(*I, getSubtargetInfo());

    return;
  }
}
#endif
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//-</span> <span class="n">emitInstruction</span><span class="p">()</span> <span class="n">must</span> <span class="n">exists</span> <span class="ow">or</span> <span class="n">will</span> <span class="n">have</span> <span class="n">run</span> <span class="n">time</span> <span class="n">error</span><span class="o">.</span>
<span class="n">void</span> <span class="n">Cpu0AsmPrinter</span><span class="p">::</span><span class="n">emitInstruction</span><span class="p">(</span><span class="n">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#ifdef ENABLE_GPRESTORE</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">I</span><span class="o">-&gt;</span><span class="n">getOpcode</span><span class="p">()</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">CPRESTORE</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">emitPseudoCPRestore</span><span class="p">(</span><span class="o">*</span><span class="n">OutStreamer</span><span class="p">,</span> <span class="o">&amp;*</span><span class="n">I</span><span class="p">);</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
<span class="c1">#endif</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0MCInstLower.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#ifdef ENABLE_GPRESTORE</span>
  <span class="n">void</span> <span class="n">LowerCPRESTORE</span><span class="p">(</span><span class="n">int64_t</span> <span class="n">Offset</span><span class="p">,</span> <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">MCInst</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">MCInsts</span><span class="p">);</span>
<span class="c1">#endif</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0MCInstLower.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#ifdef ENABLE_GPRESTORE
// Lower &quot;.cprestore offset&quot; to &quot;st $gp, offset($sp)&quot;.
void Cpu0MCInstLower::LowerCPRESTORE(int64_t Offset,
                                     SmallVector&lt;MCInst, 4&gt;&amp; MCInsts) {
  assert(isInt&lt;32&gt;(Offset) &amp;&amp; (Offset &gt;= 0) &amp;&amp;
         &quot;Imm operand of .cprestore must be a non-negative 32-bit value.&quot;);

  MCOperand SPReg = MCOperand::createReg(Cpu0::SP), BaseReg = SPReg;
  MCOperand GPReg = MCOperand::createReg(Cpu0::GP);
  MCOperand ZEROReg = MCOperand::createReg(Cpu0::ZERO);

  if (!isInt&lt;16&gt;(Offset)) {
    unsigned Hi = ((Offset + 0x8000) &gt;&gt; 16) &amp; 0xffff;
    Offset &amp;= 0xffff;
    MCOperand ATReg = MCOperand::createReg(Cpu0::AT);
    BaseReg = ATReg;

    // lui   at,hi
    // add   at,at,sp
    MCInsts.resize(2);
    CreateMCInst(MCInsts[0], Cpu0::LUi, ATReg, ZEROReg, MCOperand::createImm(Hi));
    CreateMCInst(MCInsts[1], Cpu0::ADD, ATReg, ATReg, SPReg);
  }

  MCInst St;
  CreateMCInst(St, Cpu0::ST, GPReg, BaseReg, MCOperand::createImm(Offset));
  MCInsts.push_back(St);
}
#endif
</pre></div>
</div>
<p>The added code in <code class="docutils literal notranslate"><span class="pre">Cpu0AsmPrinter.cpp</span></code>, as shown above, will call
<code class="docutils literal notranslate"><span class="pre">LowerCPRESTORE()</span></code> when the user runs the program with
<code class="docutils literal notranslate"><span class="pre">llc</span> <span class="pre">-filetype=obj</span></code>.</p>
<p>The added code in <code class="docutils literal notranslate"><span class="pre">Cpu0MCInstLower.cpp</span></code>, as shown above, handles the
machine instructions for <code class="docutils literal notranslate"><span class="pre">.cprestore</span></code>.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-76-131:input Jonathan$ </span>/Users/Jonathan/llvm/test/
<span class="go">build/bin/llc -march=cpu0 -relocation-model=pic -filetype=</span>
<span class="go">obj ch9_1.bc -o ch9_1.cpu0.o</span>
<span class="gp">118-165-76-131:input Jonathan$ </span>hexdump  ch9_1.cpu0.o
<span class="go">...</span>
<span class="go">// .cprestore machine instruction “ 01 ad 00 18”</span>
<span class="go">00000d0 01 ad 00 18 09 20 00 00 01 2d 00 40 09 20 00 06</span>
<span class="go">...</span>

<span class="gp">118-165-67-25:input Jonathan$ </span>cat ch9_1.cpu0.s
<span class="go">...</span>
<span class="go">  .ent  _Z5sum_iiiiiii          # @_Z5sum_iiiiiii</span>
<span class="go">_Z5sum_iiiiiii:</span>
<span class="go">...</span>
<span class="go">  .cpload $t9 // assign $gp = $t9 by loader when loader load re-entry function</span>
<span class="go">              // (shared library) of _Z5sum_iiiiiii</span>
<span class="go">  .set  nomacro</span>
<span class="gp"># </span>BB#0:
<span class="go">...</span>
<span class="go">  .ent  main                    # @main</span>
<span class="go">...</span>
<span class="go">  .cprestore  24  // save $gp to 24($sp)</span>
<span class="go">...</span>
</pre></div>
</div>
<p>Running <code class="docutils literal notranslate"><span class="pre">llc</span> <span class="pre">-static</span></code> will emit the <code class="docutils literal notranslate"><span class="pre">jsub</span></code> instruction instead of
<code class="docutils literal notranslate"><span class="pre">jalr</span></code>, as shown below:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-76-131:input Jonathan$ </span>/Users/Jonathan/llvm/test/
<span class="go">build/bin/llc -march=cpu0 -relocation-model=static -filetype=</span>
<span class="go">asm ch9_1.bc -o ch9_1.cpu0.s</span>
<span class="gp">118-165-76-131:input Jonathan$ </span>cat ch9_1.cpu0.s
<span class="go">...</span>
<span class="go">  jsub  _Z5sum_iiiiiii</span>
<span class="go">...</span>
</pre></div>
</div>
<p>Run ch9_1.bc with <code class="docutils literal notranslate"><span class="pre">llc</span> <span class="pre">-filetype=obj</span></code>, and you will find the Cx of
<code class="docutils literal notranslate"><span class="pre">jsub</span> <span class="pre">Cx</span></code> is 0, since Cx is calculated by the linker, as shown below.
Mips has the same 0 in its <code class="docutils literal notranslate"><span class="pre">jal</span></code> instruction.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">// jsub _Z5sum_iiiiiii translate into 2B 00 00 00</span>
<span class="go">00F0: 2B 00 00 00 01 2D 00 34 00 ED 00 3C 09 DD 00 40</span>
</pre></div>
</div>
<p>The following code will emit <code class="docutils literal notranslate"><span class="pre">ld</span> <span class="pre">$gp,</span> <span class="pre">($gp</span> <span class="pre">save</span> <span class="pre">slot</span> <span class="pre">on</span> <span class="pre">stack)</span></code> after <code class="docutils literal notranslate"><span class="pre">jalr</span></code>
by creating the file <code class="docutils literal notranslate"><span class="pre">Cpu0EmitGPRestore.cpp</span></code>, which runs as a function pass.</p>
<p class="rubric">lbdex/chapters/Chapter9_3/CMakeLists.txt</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">Cpu0EmitGPRestore</span><span class="o">.</span><span class="n">cpp</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0TargetMachine.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">///</span> <span class="n">Cpu0</span> <span class="n">Code</span> <span class="n">Generator</span> <span class="n">Pass</span> <span class="n">Configuration</span> <span class="n">Options</span><span class="o">.</span>
<span class="k">class</span> <span class="nc">Cpu0PassConfig</span> <span class="p">:</span> <span class="n">public</span> <span class="n">TargetPassConfig</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#ifdef ENABLE_GPRESTORE</span>
  <span class="n">void</span> <span class="n">addPreRegAlloc</span><span class="p">()</span> <span class="n">override</span><span class="p">;</span>
<span class="c1">#endif</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#ifdef ENABLE_GPRESTORE
void Cpu0PassConfig::addPreRegAlloc() {
  if (!Cpu0ReserveGP) {
    // $gp is a caller-saved register.
    addPass(createCpu0EmitGPRestorePass(getCpu0TargetMachine()));
  }
  return;
}
#endif
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#ifdef ENABLE_GPRESTORE</span>
  <span class="n">FunctionPass</span> <span class="o">*</span><span class="n">createCpu0EmitGPRestorePass</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">);</span>
<span class="c1">#endif</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0EmitGPRestore.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>//===-- Cpu0EmitGPRestore.cpp - Emit GP Restore Instruction ---------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This pass emits instructions that restore $gp right
// after jalr instructions.
//
//===----------------------------------------------------------------------===//

#include &quot;Cpu0.h&quot;
#if CH &gt;= CH9_3
#ifdef ENABLE_GPRESTORE

#include &quot;Cpu0TargetMachine.h&quot;
#include &quot;Cpu0MachineFunction.h&quot;
#include &quot;llvm/ADT/Statistic.h&quot;
#include &quot;llvm/CodeGen/MachineFunctionPass.h&quot;
#include &quot;llvm/CodeGen/MachineInstrBuilder.h&quot;
#include &quot;llvm/CodeGen/TargetInstrInfo.h&quot;

using namespace llvm;

#define DEBUG_TYPE &quot;emit-gp-restore&quot;

namespace {
  struct Inserter : public MachineFunctionPass {

    TargetMachine &amp;TM;

    static char ID;
    Inserter(TargetMachine &amp;tm)
      : MachineFunctionPass(ID), TM(tm) { }

    StringRef getPassName() const override {
      return &quot;Cpu0 Emit GP Restore&quot;;
    }

    bool runOnMachineFunction(MachineFunction &amp;F) override;
  };
  char Inserter::ID = 0;
} // end of anonymous namespace

bool Inserter::runOnMachineFunction(MachineFunction &amp;F) {
  Cpu0FunctionInfo *Cpu0FI = F.getInfo&lt;Cpu0FunctionInfo&gt;();
  const TargetSubtargetInfo *STI =  TM.getSubtargetImpl(F.getFunction());
  const TargetInstrInfo *TII = STI-&gt;getInstrInfo();

  if ((TM.getRelocationModel() != Reloc::PIC_) ||
      (!Cpu0FI-&gt;globalBaseRegFixed()))
    return false;

  bool Changed = false;
  int FI = Cpu0FI-&gt;getGPFI();

  for (MachineFunction::iterator MFI = F.begin(), MFE = F.end();
       MFI != MFE; ++MFI) {
    MachineBasicBlock&amp; MBB = *MFI;
    MachineBasicBlock::iterator I = MFI-&gt;begin();
    
    /// isEHPad - Indicate that this basic block is entered via an
    /// exception handler.
    // If MBB is a landing pad, insert instruction that restores $gp after
    // EH_LABEL.
    if (MBB.isEHPad()) {
      // Find EH_LABEL first.
      for (; I-&gt;getOpcode() != TargetOpcode::EH_LABEL; ++I) ;

      // Insert ld.
      ++I;
      DebugLoc dl = I != MBB.end() ? I-&gt;getDebugLoc() : DebugLoc();
      BuildMI(MBB, I, dl, TII-&gt;get(Cpu0::LD), Cpu0::GP).addFrameIndex(FI)
                                                       .addImm(0);
      Changed = true;
    }

    while (I != MFI-&gt;end()) {
      if (I-&gt;getOpcode() != Cpu0::JALR) {
        ++I;
        continue;
      }

      DebugLoc dl = I-&gt;getDebugLoc();
      // emit ld $gp, ($gp save slot on stack) after jalr
      BuildMI(MBB, ++I, dl, TII-&gt;get(Cpu0::LD), Cpu0::GP).addFrameIndex(FI)
                                                         .addImm(0);
      Changed = true;
    }
  }

  return Changed;
}

/// createCpu0EmitGPRestorePass - Returns a pass that emits instructions that
/// restores $gp clobbered by jalr instructions.
FunctionPass *llvm::createCpu0EmitGPRestorePass(Cpu0TargetMachine &amp;tm) {
  return new Inserter(tm);
}

#endif

#endif
</pre></div>
</div>
</section>
<section id="variable-number-of-arguments">
<h3><a class="toc-backref" href="#id46" role="doc-backlink">Variable number of arguments</a><a class="headerlink" href="#variable-number-of-arguments" title="Permalink to this heading">¶</a></h3>
<p>Until now, we supported a fixed number of arguments in formal function
definitions (Incoming Arguments). This subsection adds support for a variable
number of arguments, as the C language allows this feature.</p>
<p>Run <code class="docutils literal notranslate"><span class="pre">Chapter9_3/</span></code> with <code class="docutils literal notranslate"><span class="pre">ch9_3_vararg.cpp</span></code> and use the clang option
<code class="docutils literal notranslate"><span class="pre">clang</span> <span class="pre">-target</span> <span class="pre">mips-unknown-linux-gnu</span></code> to get the following result:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-76-131:input Jonathan$ </span>clang -target mips-unknown-linux-gnu -c
<span class="go">ch9_3_vararg.cpp -emit-llvm -o ch9_3_vararg.bc</span>
<span class="gp">118-165-76-131:input Jonathan$ </span>/Users/Jonathan/llvm/test/
<span class="go">build/bin/llc -march=cpu0 -mcpu=cpu032I -cpu0-s32-calls=false</span>
<span class="go">-relocation-model=pic -filetype=asm ch9_3_vararg.bc -o ch9_3_vararg.cpu0.s</span>
<span class="gp">118-165-76-131:input Jonathan$ </span>cat ch9_3_vararg.cpu0.s
<span class="go">  .section .mdebug.abi32</span>
<span class="go">  .previous</span>
<span class="go">  .file &quot;ch9_3_vararg.bc&quot;</span>
<span class="go">  .text</span>
<span class="go">  .globl  _Z5sum_iiz</span>
<span class="go">  .align  2</span>
<span class="go">  .type _Z5sum_iiz,@function</span>
<span class="go">  .ent  _Z5sum_iiz              # @_Z5sum_iiz</span>
<span class="go">_Z5sum_iiz:</span>
<span class="go">  .frame  $fp,24,$lr</span>
<span class="go">  .mask   0x00001000,-4</span>
<span class="go">  .set  noreorder</span>
<span class="go">  .set  nomacro</span>
<span class="gp"># </span>BB#0:
<span class="go">  addiu $sp, $sp, -24</span>
<span class="go">  st  $fp, 20($sp)            # 4-byte Folded Spill</span>
<span class="go">  move    $fp, $sp</span>
<span class="go">  ld  $2, 24($fp)     // amount</span>
<span class="go">  st  $2, 16($fp)     // amount</span>
<span class="go">  addiu $2, $zero, 0</span>
<span class="go">  st  $2, 12($fp)     // i</span>
<span class="go">  st  $2, 8($fp)     // val</span>
<span class="go">  st  $2, 4($fp)      // sum</span>
<span class="go">  addiu $3, $fp, 28</span>
<span class="go">  st  $3, 0($fp)      // arg_ptr = 2nd argument = &amp;arg[1],</span>
<span class="go">              // since &amp;arg[0] = 24($sp)</span>
<span class="go">  st  $2, 12($fp)</span>
<span class="gp">$</span>BB0_1:                                 <span class="c1"># =&gt;This Inner Loop Header: Depth=1</span>
<span class="go">  ld  $2, 16($fp)</span>
<span class="go">  ld  $3, 12($fp)</span>
<span class="go">  cmp $sw, $3, $2        // compare(i, amount)</span>
<span class="go">  jge $BB0_4</span>
<span class="go">  nop</span>
<span class="go">  jmp $BB0_2</span>
<span class="go">  nop</span>
<span class="gp">$</span>BB0_2:                                 <span class="c1">#   in Loop: Header=BB0_1 Depth=1</span>
<span class="go">              // i &lt; amount</span>
<span class="go">  ld  $2, 0($fp)</span>
<span class="go">  addiu $3, $2, 4   // arg_ptr  + 4</span>
<span class="go">  st  $3, 0($fp)</span>
<span class="go">  ld  $2, 0($2)     // *arg_ptr</span>
<span class="go">  st  $2, 8($fp)</span>
<span class="go">  ld  $3, 4($fp)      // sum</span>
<span class="go">  add $2, $3, $2      // sum += *arg_ptr</span>
<span class="go">  st  $2, 4($fp)</span>
<span class="gp"># </span>BB#3:                                 <span class="c1">#   in Loop: Header=BB0_1 Depth=1</span>
<span class="go">              // i &gt;= amount</span>
<span class="go">  ld  $2, 12($fp)</span>
<span class="go">  addiu $2, $2, 1   // i++</span>
<span class="go">  st  $2, 12($fp)</span>
<span class="go">  jmp $BB0_1</span>
<span class="go">  nop</span>
<span class="gp">$</span>BB0_4:
<span class="go">  ld  $2, 4($fp)</span>
<span class="go">  move    $sp, $fp</span>
<span class="go">  ld  $fp, 20($sp)            # 4-byte Folded Reload</span>
<span class="go">  addiu $sp, $sp, 24</span>
<span class="go">  ret $lr</span>
<span class="go">  .set  macro</span>
<span class="go">  .set  reorder</span>
<span class="go">  .end  _Z5sum_iiz</span>
<span class="gp">$</span>tmp1:
<span class="go">  .size _Z5sum_iiz, ($tmp1)-_Z5sum_iiz</span>

<span class="go">  .globl  _Z11test_varargv</span>
<span class="go">  .align  2</span>
<span class="go">  .type _Z11test_varargv,@function</span>
<span class="go">  .ent  _Z11test_varargv                    # @_Z11test_varargv</span>
<span class="go">_Z11test_varargv:</span>
<span class="go">  .frame  $sp,88,$lr</span>
<span class="go">  .mask   0x00004000,-4</span>
<span class="go">  .set  noreorder</span>
<span class="go">  .cpload $t9</span>
<span class="go">  .set  nomacro</span>
<span class="gp"># </span>BB#0:
<span class="go">  addiu $sp, $sp, -48</span>
<span class="go">  st  $lr, 44($sp)            # 4-byte Folded Spill</span>
<span class="go">  st  $fp, 40($sp)            # 4-byte Folded Spill</span>
<span class="go">  move    $fp, $sp</span>
<span class="go">  .cprestore  32</span>
<span class="go">  addiu $2, $zero, 5</span>
<span class="go">  st  $2, 24($sp)</span>
<span class="go">  addiu $2, $zero, 4</span>
<span class="go">  st  $2, 20($sp)</span>
<span class="go">  addiu $2, $zero, 3</span>
<span class="go">  st  $2, 16($sp)</span>
<span class="go">  addiu $2, $zero, 2</span>
<span class="go">  st  $2, 12($sp)</span>
<span class="go">  addiu $2, $zero, 1</span>
<span class="go">  st  $2, 8($sp)</span>
<span class="go">  addiu $2, $zero, 0</span>
<span class="go">  st  $2, 4($sp)</span>
<span class="go">  addiu $2, $zero, 6</span>
<span class="go">  st  $2, 0($sp)</span>
<span class="go">  ld  $t9, %call16(_Z5sum_iiz)($gp)</span>
<span class="go">  jalr  $t9</span>
<span class="go">  nop</span>
<span class="go">  ld  $gp, 28($fp)</span>
<span class="go">  st  $2, 36($fp)</span>
<span class="go">  move    $sp, $fp</span>
<span class="go">  ld  $fp, 40($sp)            # 4-byte Folded Reload</span>
<span class="go">  ld  $lr, 44($sp)            # 4-byte Folded Reload</span>
<span class="go">  addiu $sp, $sp, 48</span>
<span class="go">  ret $lr</span>
<span class="go">  nop</span>
<span class="go">  .set  macro</span>
<span class="go">  .set  reorder</span>
<span class="go">  .end  _Z11test_varargv</span>
<span class="gp">$</span>tmp1:
<span class="go">  .size _Z11test_varargv, ($tmp1)-_Z11test_varargv</span>
</pre></div>
</div>
<p>The analysis of output <code class="docutils literal notranslate"><span class="pre">ch9_3_vararg.cpu0.s</span></code> is shown in the comments above.</p>
<p>As described in the code in <code class="docutils literal notranslate"><span class="pre">#</span> <span class="pre">BB#0</span></code>, we get the first argument <code class="docutils literal notranslate"><span class="pre">amount</span></code> from
<code class="docutils literal notranslate"><span class="pre">ld</span> <span class="pre">$2,</span> <span class="pre">24($fp)</span></code>, since the stack size of the callee function <code class="docutils literal notranslate"><span class="pre">_Z5sum_iiz()</span></code> is
24. Then we set the argument pointer, <code class="docutils literal notranslate"><span class="pre">arg_ptr</span></code>, to <code class="docutils literal notranslate"><span class="pre">0($fp)</span></code>, which is
<code class="docutils literal notranslate"><span class="pre">&amp;arg[1]</span></code>.</p>
<p>Next, we check <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">amount</span></code> in block <code class="docutils literal notranslate"><span class="pre">$BB0_1</span></code>. If <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">amount</span></code>, we enter
<code class="docutils literal notranslate"><span class="pre">$BB0_2</span></code>. In <code class="docutils literal notranslate"><span class="pre">$BB0_2</span></code>, the code performs <code class="docutils literal notranslate"><span class="pre">sum</span> <span class="pre">+=</span> <span class="pre">*arg_ptr</span></code> and
<code class="docutils literal notranslate"><span class="pre">arg_ptr</span> <span class="pre">+=</span> <span class="pre">4</span></code>. In <code class="docutils literal notranslate"><span class="pre">#</span> <span class="pre">BB#3</span></code>, the code increments <code class="docutils literal notranslate"><span class="pre">i</span></code> with <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">+=</span> <span class="pre">1</span></code>.</p>
<p>To support variable numbers of arguments, the following code needs to be added in
<code class="docutils literal notranslate"><span class="pre">Chapter9_3/</span></code>.</p>
<p>The file <code class="docutils literal notranslate"><span class="pre">ch9_3_template.cpp</span></code> contains a C++ template example. It can also be
translated into Cpu0 backend code.</p>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0ISelLowering.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">class</span> <span class="nc">Cpu0TargetLowering</span> <span class="p">:</span> <span class="n">public</span> <span class="n">TargetLowering</span>  <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="o">///</span> <span class="n">Cpu0CC</span> <span class="o">-</span> <span class="n">This</span> <span class="k">class</span> <span class="nc">provides</span> <span class="n">methods</span> <span class="n">used</span> <span class="n">to</span> <span class="n">analyze</span> <span class="n">formal</span> <span class="ow">and</span> <span class="n">call</span>
    <span class="o">///</span> <span class="n">arguments</span> <span class="ow">and</span> <span class="n">inquire</span> <span class="n">about</span> <span class="n">calling</span> <span class="n">convention</span> <span class="n">information</span><span class="o">.</span>
    <span class="k">class</span> <span class="nc">Cpu0CC</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>      <span class="o">///</span> <span class="n">Return</span> <span class="n">the</span> <span class="n">function</span> <span class="n">that</span> <span class="n">analyzes</span> <span class="n">variable</span> <span class="n">argument</span> <span class="nb">list</span> <span class="n">functions</span><span class="o">.</span>
      <span class="n">llvm</span><span class="p">::</span><span class="n">CCAssignFn</span> <span class="o">*</span><span class="n">varArgFn</span><span class="p">()</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">      </span><span class="p">...</span><span class="w"></span>
<span class="p">.</span><span class="w">   </span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">SDValue</span> <span class="n">lowerVASTART</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
    <span class="n">SDValue</span> <span class="n">lowerFRAMEADDR</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
    <span class="n">SDValue</span> <span class="n">lowerRETURNADDR</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
    <span class="n">SDValue</span> <span class="n">lowerEH_RETURN</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
    <span class="n">SDValue</span> <span class="n">lowerADD</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="o">///</span> <span class="n">writeVarArgRegs</span> <span class="o">-</span> <span class="n">Write</span> <span class="n">variable</span> <span class="n">function</span> <span class="n">arguments</span> <span class="n">passed</span> <span class="ow">in</span> <span class="n">registers</span>
    <span class="o">///</span> <span class="n">to</span> <span class="n">the</span> <span class="n">stack</span><span class="o">.</span> <span class="n">Also</span> <span class="n">create</span> <span class="n">a</span> <span class="n">stack</span> <span class="n">frame</span> <span class="nb">object</span> <span class="k">for</span> <span class="n">the</span> <span class="n">first</span> <span class="n">variable</span>
    <span class="o">///</span> <span class="n">argument</span><span class="o">.</span>
    <span class="n">void</span> <span class="n">writeVarArgRegs</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">OutChains</span><span class="p">,</span> <span class="n">const</span> <span class="n">Cpu0CC</span> <span class="o">&amp;</span><span class="n">CC</span><span class="p">,</span>
                         <span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">const</span> <span class="n">SDLoc</span> <span class="o">&amp;</span><span class="n">DL</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">.</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0ISelLowering.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="n">const</span> <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">,</span>
                                       <span class="n">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span>
    <span class="p">:</span> <span class="n">TargetLowering</span><span class="p">(</span><span class="n">TM</span><span class="p">),</span> <span class="n">Subtarget</span><span class="p">(</span><span class="n">STI</span><span class="p">),</span> <span class="n">ABI</span><span class="p">(</span><span class="n">TM</span><span class="o">.</span><span class="n">getABI</span><span class="p">())</span> <span class="p">{</span>

</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">VASTART</span><span class="p">,</span>            <span class="n">MVT</span><span class="p">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Custom</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="o">//</span> <span class="n">Support</span> <span class="n">va_arg</span><span class="p">():</span> <span class="n">variable</span> <span class="n">numbers</span> <span class="p">(</span><span class="ow">not</span> <span class="n">fixed</span> <span class="n">numbers</span><span class="p">)</span> <span class="n">of</span> <span class="n">arguments</span> 
  <span class="o">//</span>  <span class="p">(</span><span class="n">parameters</span><span class="p">)</span> <span class="k">for</span> <span class="n">function</span> <span class="nb">all</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">VAARG</span><span class="p">,</span>             <span class="n">MVT</span><span class="p">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">VACOPY</span><span class="p">,</span>            <span class="n">MVT</span><span class="p">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">VAEND</span><span class="p">,</span>             <span class="n">MVT</span><span class="p">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
  
  <span class="o">//</span><span class="nd">@llvm</span><span class="o">.</span><span class="n">stacksave</span>
  <span class="o">//</span> <span class="n">Use</span> <span class="n">the</span> <span class="n">default</span> <span class="k">for</span> <span class="n">now</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">STACKSAVE</span><span class="p">,</span>         <span class="n">MVT</span><span class="p">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">STACKRESTORE</span><span class="p">,</span>      <span class="n">MVT</span><span class="p">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="p">::</span>
<span class="n">LowerOperation</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span>
<span class="p">{</span>
  <span class="n">switch</span> <span class="p">(</span><span class="n">Op</span><span class="o">.</span><span class="n">getOpcode</span><span class="p">())</span>
  <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">case</span> <span class="n">ISD</span><span class="p">::</span><span class="n">VASTART</span><span class="p">:</span>            <span class="k">return</span> <span class="n">lowerVASTART</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="p">}</span>
  <span class="k">return</span> <span class="n">SDValue</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">lowerVASTART</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getMachineFunction</span><span class="p">();</span>
  <span class="n">Cpu0FunctionInfo</span> <span class="o">*</span><span class="n">FuncInfo</span> <span class="o">=</span> <span class="n">MF</span><span class="o">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="n">SDLoc</span> <span class="n">DL</span> <span class="o">=</span> <span class="n">SDLoc</span><span class="p">(</span><span class="n">Op</span><span class="p">);</span>
  <span class="n">SDValue</span> <span class="n">FI</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getFrameIndex</span><span class="p">(</span><span class="n">FuncInfo</span><span class="o">-&gt;</span><span class="n">getVarArgsFrameIndex</span><span class="p">(),</span>
                                 <span class="n">getPointerTy</span><span class="p">(</span><span class="n">MF</span><span class="o">.</span><span class="n">getDataLayout</span><span class="p">()));</span>

  <span class="o">//</span> <span class="n">vastart</span> <span class="n">just</span> <span class="n">stores</span> <span class="n">the</span> <span class="n">address</span> <span class="n">of</span> <span class="n">the</span> <span class="n">VarArgsFrameIndex</span> <span class="n">slot</span> <span class="n">into</span> <span class="n">the</span>
  <span class="o">//</span> <span class="n">memory</span> <span class="n">location</span> <span class="n">argument</span><span class="o">.</span>
  <span class="n">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">SV</span> <span class="o">=</span> <span class="n">cast</span><span class="o">&lt;</span><span class="n">SrcValueSDNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Op</span><span class="o">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getStore</span><span class="p">(</span><span class="n">Op</span><span class="o">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">DL</span><span class="p">,</span> <span class="n">FI</span><span class="p">,</span> <span class="n">Op</span><span class="o">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                      <span class="n">MachinePointerInfo</span><span class="p">(</span><span class="n">SV</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">///</span> <span class="n">LowerFormalArguments</span> <span class="o">-</span> <span class="n">transform</span> <span class="n">physical</span> <span class="n">registers</span> <span class="n">into</span> <span class="n">virtual</span> <span class="n">registers</span>
<span class="o">///</span> <span class="ow">and</span> <span class="n">generate</span> <span class="n">load</span> <span class="n">operations</span> <span class="k">for</span> <span class="n">arguments</span> <span class="n">places</span> <span class="n">on</span> <span class="n">the</span> <span class="n">stack</span><span class="o">.</span>
<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">LowerFormalArguments</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span>
                                         <span class="n">CallingConv</span><span class="p">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span>
                                         <span class="nb">bool</span> <span class="n">IsVarArg</span><span class="p">,</span>
                                         <span class="n">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="p">::</span><span class="n">InputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ins</span><span class="p">,</span>
                                         <span class="n">const</span> <span class="n">SDLoc</span> <span class="o">&amp;</span><span class="n">DL</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span>
                                         <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span>
                                          <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">if</span> <span class="p">(</span><span class="n">IsVarArg</span><span class="p">)</span>
    <span class="n">writeVarArgRegs</span><span class="p">(</span><span class="n">OutChains</span><span class="p">,</span> <span class="n">Cpu0CCInfo</span><span class="p">,</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">DAG</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">Cpu0CC</span><span class="p">::</span>
<span class="n">analyzeCallOperands</span><span class="p">(</span><span class="n">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="p">::</span><span class="n">OutputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Args</span><span class="p">,</span>
                    <span class="nb">bool</span> <span class="n">IsVarArg</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">IsSoftFloat</span><span class="p">,</span> <span class="n">const</span> <span class="n">SDNode</span> <span class="o">*</span><span class="n">CallNode</span><span class="p">,</span>
                    <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ArgListEntry</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">FuncArgs</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">llvm</span><span class="p">::</span><span class="n">CCAssignFn</span> <span class="o">*</span><span class="n">VarFn</span> <span class="o">=</span> <span class="n">varArgFn</span><span class="p">();</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">for</span> <span class="p">(</span><span class="n">unsigned</span> <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">I</span> <span class="o">!=</span> <span class="n">NumOpnds</span><span class="p">;</span> <span class="o">++</span><span class="n">I</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    if (IsVarArg &amp;&amp; !Args[I].IsFixed)
      R = VarFn(I, ArgVT, ArgVT, CCValAssign::Full, ArgFlags, CCInfo);
    else
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">llvm</span><span class="p">::</span><span class="n">CCAssignFn</span> <span class="o">*</span><span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">Cpu0CC</span><span class="p">::</span><span class="n">varArgFn</span><span class="p">()</span> <span class="n">const</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">IsO32</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">CC_Cpu0O32</span><span class="p">;</span>
  <span class="k">else</span> <span class="o">//</span> <span class="n">IsS32</span>
    <span class="k">return</span> <span class="n">CC_Cpu0S32</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">writeVarArgRegs</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">OutChains</span><span class="p">,</span>
                                         <span class="n">const</span> <span class="n">Cpu0CC</span> <span class="o">&amp;</span><span class="n">CC</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span>
                                         <span class="n">const</span> <span class="n">SDLoc</span> <span class="o">&amp;</span><span class="n">DL</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="n">unsigned</span> <span class="n">NumRegs</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">numIntArgRegs</span><span class="p">();</span>
  <span class="n">const</span> <span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">MCPhysReg</span><span class="o">&gt;</span> <span class="n">ArgRegs</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">intArgRegs</span><span class="p">();</span>
  <span class="n">const</span> <span class="n">CCState</span> <span class="o">&amp;</span><span class="n">CCInfo</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">getCCInfo</span><span class="p">();</span>
  <span class="n">unsigned</span> <span class="n">Idx</span> <span class="o">=</span> <span class="n">CCInfo</span><span class="o">.</span><span class="n">getFirstUnallocated</span><span class="p">(</span><span class="n">ArgRegs</span><span class="p">);</span>
  <span class="n">unsigned</span> <span class="n">RegSize</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">regSize</span><span class="p">();</span>
  <span class="n">MVT</span> <span class="n">RegTy</span> <span class="o">=</span> <span class="n">MVT</span><span class="p">::</span><span class="n">getIntegerVT</span><span class="p">(</span><span class="n">RegSize</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>
  <span class="n">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span><span class="n">RC</span> <span class="o">=</span> <span class="n">getRegClassFor</span><span class="p">(</span><span class="n">RegTy</span><span class="p">);</span>
  <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getMachineFunction</span><span class="p">();</span>
  <span class="n">MachineFrameInfo</span> <span class="o">&amp;</span><span class="n">MFI</span> <span class="o">=</span> <span class="n">MF</span><span class="o">.</span><span class="n">getFrameInfo</span><span class="p">();</span>
  <span class="n">Cpu0FunctionInfo</span> <span class="o">*</span><span class="n">Cpu0FI</span> <span class="o">=</span> <span class="n">MF</span><span class="o">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="o">//</span> <span class="n">Offset</span> <span class="n">of</span> <span class="n">the</span> <span class="n">first</span> <span class="n">variable</span> <span class="n">argument</span> <span class="kn">from</span> <span class="nn">stack</span> <span class="n">pointer</span><span class="o">.</span>
  <span class="nb">int</span> <span class="n">VaArgOffset</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">NumRegs</span> <span class="o">==</span> <span class="n">Idx</span><span class="p">)</span>
    <span class="n">VaArgOffset</span> <span class="o">=</span> <span class="n">alignTo</span><span class="p">(</span><span class="n">CCInfo</span><span class="o">.</span><span class="n">getNextStackOffset</span><span class="p">(),</span> <span class="n">RegSize</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">VaArgOffset</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="n">CC</span><span class="o">.</span><span class="n">reservedArgArea</span><span class="p">()</span> <span class="o">-</span> <span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="n">RegSize</span> <span class="o">*</span> <span class="p">(</span><span class="n">NumRegs</span> <span class="o">-</span> <span class="n">Idx</span><span class="p">));</span>

  <span class="o">//</span> <span class="n">Record</span> <span class="n">the</span> <span class="n">frame</span> <span class="n">index</span> <span class="n">of</span> <span class="n">the</span> <span class="n">first</span> <span class="n">variable</span> <span class="n">argument</span>
  <span class="o">//</span> <span class="n">which</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">value</span> <span class="n">necessary</span> <span class="n">to</span> <span class="n">VASTART</span><span class="o">.</span>
  <span class="nb">int</span> <span class="n">FI</span> <span class="o">=</span> <span class="n">MFI</span><span class="o">.</span><span class="n">CreateFixedObject</span><span class="p">(</span><span class="n">RegSize</span><span class="p">,</span> <span class="n">VaArgOffset</span><span class="p">,</span> <span class="n">true</span><span class="p">);</span>
  <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">setVarArgsFrameIndex</span><span class="p">(</span><span class="n">FI</span><span class="p">);</span>

  <span class="o">//</span> <span class="n">Copy</span> <span class="n">the</span> <span class="n">integer</span> <span class="n">registers</span> <span class="n">that</span> <span class="n">have</span> <span class="ow">not</span> <span class="n">been</span> <span class="n">used</span> <span class="k">for</span> <span class="n">argument</span> <span class="n">passing</span>
  <span class="o">//</span> <span class="n">to</span> <span class="n">the</span> <span class="n">argument</span> <span class="n">register</span> <span class="n">save</span> <span class="n">area</span><span class="o">.</span> <span class="n">For</span> <span class="n">O32</span><span class="p">,</span> <span class="n">the</span> <span class="n">save</span> <span class="n">area</span> <span class="ow">is</span> <span class="n">allocated</span>
  <span class="o">//</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">caller</span><span class="s1">&#39;s stack frame, while for N32/64, it is allocated in the</span>
  <span class="o">//</span> <span class="n">callee</span><span class="s1">&#39;s stack frame.</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">unsigned</span> <span class="n">I</span> <span class="o">=</span> <span class="n">Idx</span><span class="p">;</span> <span class="n">I</span> <span class="o">&lt;</span> <span class="n">NumRegs</span><span class="p">;</span> <span class="o">++</span><span class="n">I</span><span class="p">,</span> <span class="n">VaArgOffset</span> <span class="o">+=</span> <span class="n">RegSize</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unsigned</span> <span class="n">Reg</span> <span class="o">=</span> <span class="n">addLiveIn</span><span class="p">(</span><span class="n">MF</span><span class="p">,</span> <span class="n">ArgRegs</span><span class="p">[</span><span class="n">I</span><span class="p">],</span> <span class="n">RC</span><span class="p">);</span>
    <span class="n">SDValue</span> <span class="n">ArgValue</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getCopyFromReg</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Reg</span><span class="p">,</span> <span class="n">RegTy</span><span class="p">);</span>
    <span class="n">FI</span> <span class="o">=</span> <span class="n">MFI</span><span class="o">.</span><span class="n">CreateFixedObject</span><span class="p">(</span><span class="n">RegSize</span><span class="p">,</span> <span class="n">VaArgOffset</span><span class="p">,</span> <span class="n">true</span><span class="p">);</span>
    <span class="n">SDValue</span> <span class="n">PtrOff</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getFrameIndex</span><span class="p">(</span><span class="n">FI</span><span class="p">,</span> <span class="n">getPointerTy</span><span class="p">(</span><span class="n">DAG</span><span class="o">.</span><span class="n">getDataLayout</span><span class="p">()));</span>
    <span class="n">SDValue</span> <span class="n">Store</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getStore</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">ArgValue</span><span class="p">,</span> <span class="n">PtrOff</span><span class="p">,</span>
                                 <span class="n">MachinePointerInfo</span><span class="p">());</span>
    <span class="n">cast</span><span class="o">&lt;</span><span class="n">StoreSDNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Store</span><span class="o">.</span><span class="n">getNode</span><span class="p">())</span><span class="o">-&gt;</span><span class="n">getMemOperand</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">setValue</span><span class="p">(</span>
        <span class="p">(</span><span class="n">Value</span> <span class="o">*</span><span class="p">)</span><span class="n">nullptr</span><span class="p">);</span>
    <span class="n">OutChains</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Store</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/input/ch9_3_template.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &lt;stdarg.h&gt;</span>

<span class="n">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="nb">sum</span><span class="p">(</span><span class="n">T</span> <span class="n">amount</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">T</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">T</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">T</span> <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	
  <span class="n">va_list</span> <span class="n">vl</span><span class="p">;</span>
  <span class="n">va_start</span><span class="p">(</span><span class="n">vl</span><span class="p">,</span> <span class="n">amount</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">amount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">vl</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>
    <span class="nb">sum</span> <span class="o">+=</span> <span class="n">val</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">va_end</span><span class="p">(</span><span class="n">vl</span><span class="p">);</span>
  
  <span class="k">return</span> <span class="nb">sum</span><span class="p">;</span> 
<span class="p">}</span>

<span class="nb">int</span> <span class="n">test_template</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="nb">sum</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">));</span>
	
  <span class="k">return</span> <span class="n">a</span><span class="p">;</span> <span class="o">//</span> <span class="mi">15</span>
<span class="p">}</span>

<span class="n">long</span> <span class="n">long</span> <span class="n">test_template_ll</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">long</span> <span class="n">long</span> <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">long</span> <span class="n">long</span><span class="p">)(</span><span class="nb">sum</span><span class="o">&lt;</span><span class="n">long</span> <span class="n">long</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">6</span><span class="n">LL</span><span class="p">,</span> <span class="mi">0</span><span class="n">LL</span><span class="p">,</span> <span class="mi">1</span><span class="n">LL</span><span class="p">,</span> <span class="mi">2</span><span class="n">LL</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="n">LL</span><span class="p">,</span> <span class="mi">4</span><span class="n">LL</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="n">LL</span><span class="p">));</span>

  <span class="k">return</span> <span class="n">a</span><span class="p">;</span> <span class="o">//</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>
</pre></div>
</div>
<p>MIPS QEMU reference <a class="footnote-reference brackets" href="#mipsqemu" id="id10" role="doc-noteref"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></a> can be downloaded and run with GCC to verify the
result using the <code class="docutils literal notranslate"><span class="pre">printf()</span></code> function at this point.</p>
<p>We will verify the correctness of the code in the chapter “Verify backend on
Verilog simulator” through the Cpu0 Verilog-language machine.</p>
</section>
<section id="dynamic-stack-allocation-support">
<h3><a class="toc-backref" href="#id47" role="doc-backlink">Dynamic stack allocation support</a><a class="headerlink" href="#dynamic-stack-allocation-support" title="Permalink to this heading">¶</a></h3>
<p>Even though the C language rarely uses dynamic stack allocation, some other
languages rely on it frequently. The following C example demonstrates its use.</p>
<p><code class="docutils literal notranslate"><span class="pre">Chapter9_3</span></code> supports dynamic stack allocation with the following code added.</p>
<p class="rubric">lbdex/chapters/Chapter9_2/Cpu0FrameLowering.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// Eliminate ADJCALLSTACKDOWN, ADJCALLSTACKUP pseudo instructions
MachineBasicBlock::iterator Cpu0FrameLowering::
eliminateCallFramePseudoInstr(MachineFunction &amp;MF, MachineBasicBlock &amp;MBB,
                              MachineBasicBlock::iterator I) const {
#if CH &gt;= CH9_3 // dynamic alloc
  unsigned SP = Cpu0::SP;

  if (!hasReservedCallFrame(MF)) {
    int64_t Amount = I-&gt;getOperand(0).getImm();
    if (I-&gt;getOpcode() == Cpu0::ADJCALLSTACKDOWN)
      Amount = -Amount;

    STI.getInstrInfo()-&gt;adjustStackPtr(SP, Amount, MBB, I);
  }
#endif // dynamic alloc

  return MBB.erase(I);
}
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0SEFrameLowering.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">Cpu0SEFrameLowering</span><span class="p">::</span><span class="n">emitPrologue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                       <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">unsigned</span> <span class="n">FP</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">FP</span><span class="p">;</span>
  <span class="n">unsigned</span> <span class="n">ZERO</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">ZERO</span><span class="p">;</span>
  <span class="n">unsigned</span> <span class="n">ADDu</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">ADDu</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="o">//</span> <span class="k">if</span> <span class="n">framepointer</span> <span class="n">enabled</span><span class="p">,</span> <span class="nb">set</span> <span class="n">it</span> <span class="n">to</span> <span class="n">point</span> <span class="n">to</span> <span class="n">the</span> <span class="n">stack</span> <span class="n">pointer</span><span class="o">.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">hasFP</span><span class="p">(</span><span class="n">MF</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">callsEhDwarf</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MBBI</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">TII</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ADDu</span><span class="p">),</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">V0</span><span class="p">)</span><span class="o">.</span><span class="n">addReg</span><span class="p">(</span><span class="n">FP</span><span class="p">)</span><span class="o">.</span><span class="n">addReg</span><span class="p">(</span><span class="n">ZERO</span><span class="p">)</span>
        <span class="o">.</span><span class="n">setMIFlag</span><span class="p">(</span><span class="n">MachineInstr</span><span class="p">::</span><span class="n">FrameSetup</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="o">//@</span> <span class="n">Insert</span> <span class="n">instruction</span> <span class="s2">&quot;move $fp, $sp&quot;</span> <span class="n">at</span> <span class="n">this</span> <span class="n">location</span><span class="o">.</span>
    <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MBBI</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">TII</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ADDu</span><span class="p">),</span> <span class="n">FP</span><span class="p">)</span><span class="o">.</span><span class="n">addReg</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span><span class="o">.</span><span class="n">addReg</span><span class="p">(</span><span class="n">ZERO</span><span class="p">)</span>
      <span class="o">.</span><span class="n">setMIFlag</span><span class="p">(</span><span class="n">MachineInstr</span><span class="p">::</span><span class="n">FrameSetup</span><span class="p">);</span>

    <span class="o">//</span> <span class="n">emit</span> <span class="s2">&quot;.cfi_def_cfa_register $fp&quot;</span>
    <span class="n">unsigned</span> <span class="n">CFIIndex</span> <span class="o">=</span> <span class="n">MF</span><span class="o">.</span><span class="n">addFrameInst</span><span class="p">(</span><span class="n">MCCFIInstruction</span><span class="p">::</span><span class="n">createDefCfaRegister</span><span class="p">(</span>
        <span class="n">nullptr</span><span class="p">,</span> <span class="n">MRI</span><span class="o">-&gt;</span><span class="n">getDwarfRegNum</span><span class="p">(</span><span class="n">FP</span><span class="p">,</span> <span class="n">true</span><span class="p">)));</span>
    <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MBBI</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">TII</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">TargetOpcode</span><span class="p">::</span><span class="n">CFI_INSTRUCTION</span><span class="p">))</span>
        <span class="o">.</span><span class="n">addCFIIndex</span><span class="p">(</span><span class="n">CFIIndex</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">Cpu0SEFrameLowering</span><span class="p">::</span><span class="n">emitEpilogue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                 <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">unsigned</span> <span class="n">FP</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">FP</span><span class="p">;</span>
  <span class="n">unsigned</span> <span class="n">ZERO</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">ZERO</span><span class="p">;</span>
  <span class="n">unsigned</span> <span class="n">ADDu</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">ADDu</span><span class="p">;</span>

  <span class="o">//</span> <span class="k">if</span> <span class="n">framepointer</span> <span class="n">enabled</span><span class="p">,</span> <span class="n">restore</span> <span class="n">the</span> <span class="n">stack</span> <span class="n">pointer</span><span class="o">.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">hasFP</span><span class="p">(</span><span class="n">MF</span><span class="p">))</span> <span class="p">{</span>
    <span class="o">//</span> <span class="n">Find</span> <span class="n">the</span> <span class="n">first</span> <span class="n">instruction</span> <span class="n">that</span> <span class="n">restores</span> <span class="n">a</span> <span class="n">callee</span><span class="o">-</span><span class="n">saved</span> <span class="n">register</span><span class="o">.</span>
    <span class="n">MachineBasicBlock</span><span class="p">::</span><span class="n">iterator</span> <span class="n">I</span> <span class="o">=</span> <span class="n">MBBI</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MFI</span><span class="o">.</span><span class="n">getCalleeSavedInfo</span><span class="p">()</span><span class="o">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
      <span class="o">--</span><span class="n">I</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Insert</span> <span class="n">instruction</span> <span class="s2">&quot;move $sp, $fp&quot;</span> <span class="n">at</span> <span class="n">this</span> <span class="n">location</span><span class="o">.</span>
    <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">TII</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ADDu</span><span class="p">),</span> <span class="n">SP</span><span class="p">)</span><span class="o">.</span><span class="n">addReg</span><span class="p">(</span><span class="n">FP</span><span class="p">)</span><span class="o">.</span><span class="n">addReg</span><span class="p">(</span><span class="n">ZERO</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  unsigned FP = Cpu0::FP;

  // Mark $fp as used if function has dedicated frame pointer.
  if (hasFP(MF))
    setAliasRegs(MF, SavedRegs, FP);

</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0ISelLowering.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="n">const</span> <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">,</span>
                                       <span class="n">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span>
    <span class="p">:</span> <span class="n">TargetLowering</span><span class="p">(</span><span class="n">TM</span><span class="p">),</span> <span class="n">Subtarget</span><span class="p">(</span><span class="n">STI</span><span class="p">),</span> <span class="n">ABI</span><span class="p">(</span><span class="n">TM</span><span class="o">.</span><span class="n">getABI</span><span class="p">())</span> <span class="p">{</span>

</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">DYNAMIC_STACKALLOC</span><span class="p">,</span> <span class="n">MVT</span><span class="p">::</span><span class="n">i32</span><span class="p">,</span>  <span class="n">Expand</span><span class="p">);</span>

</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">setStackPointerRegisterToSaveRestore</span><span class="p">(</span><span class="n">Cpu0</span><span class="p">::</span><span class="n">SP</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0RegisterInfo.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BitVector</span> <span class="n">Cpu0RegisterInfo</span><span class="p">::</span>
<span class="n">getReservedRegs</span><span class="p">(</span><span class="n">const</span> <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="o">//</span> <span class="n">Reserve</span> <span class="n">FP</span> <span class="k">if</span> <span class="n">this</span> <span class="n">function</span> <span class="n">should</span> <span class="n">have</span> <span class="n">a</span> <span class="n">dedicated</span> <span class="n">frame</span> <span class="n">pointer</span> <span class="n">register</span><span class="o">.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">MF</span><span class="o">.</span><span class="n">getSubtarget</span><span class="p">()</span><span class="o">.</span><span class="n">getFrameLowering</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">hasFP</span><span class="p">(</span><span class="n">MF</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">Reserved</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">Cpu0</span><span class="p">::</span><span class="n">FP</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//-</span> <span class="n">If</span> <span class="n">no</span> <span class="n">eliminateFrameIndex</span><span class="p">(),</span> <span class="n">it</span> <span class="n">will</span> <span class="n">hang</span> <span class="n">on</span> <span class="n">run</span><span class="o">.</span> 
<span class="o">//</span> <span class="n">pure</span> <span class="n">virtual</span> <span class="n">method</span>
<span class="o">//</span> <span class="n">FrameIndex</span> <span class="n">represent</span> <span class="n">objects</span> <span class="n">inside</span> <span class="n">a</span> <span class="n">abstract</span> <span class="n">stack</span><span class="o">.</span>
<span class="o">//</span> <span class="n">We</span> <span class="n">must</span> <span class="n">replace</span> <span class="n">FrameIndex</span> <span class="k">with</span> <span class="n">an</span> <span class="n">stack</span><span class="o">/</span><span class="n">frame</span> <span class="n">pointer</span>
<span class="o">//</span> <span class="n">direct</span> <span class="n">reference</span><span class="o">.</span>
<span class="n">void</span> <span class="n">Cpu0RegisterInfo</span><span class="p">::</span>
<span class="n">eliminateFrameIndex</span><span class="p">(</span><span class="n">MachineBasicBlock</span><span class="p">::</span><span class="n">iterator</span> <span class="n">II</span><span class="p">,</span> <span class="nb">int</span> <span class="n">SPAdj</span><span class="p">,</span>
                    <span class="n">unsigned</span> <span class="n">FIOperandNum</span><span class="p">,</span> <span class="n">RegScavenger</span> <span class="o">*</span><span class="n">RS</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">isOutArgFI</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">)</span> <span class="o">||</span> <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">isGPFI</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">)</span> <span class="o">||</span>
      <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">isDynAllocFI</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">))</span>
    <span class="n">Offset</span> <span class="o">=</span> <span class="n">spOffset</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Run <code class="docutils literal notranslate"><span class="pre">Chapter9_3</span></code> with <code class="docutils literal notranslate"><span class="pre">ch9_3_alloc.cpp</span></code> to get the following correct result.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-72-242:input Jonathan$ </span>clang -target mips-unknown-linux-gnu -c
<span class="go">ch9_3_alloc.cpp -emit-llvm -o ch9_3_alloc.bc</span>
<span class="gp">118-165-72-242:input Jonathan$ </span>llvm-dis ch9_3_alloc.bc -o ch9_3_alloc.ll
<span class="gp">118-165-72-242:input Jonathan$ </span>cat ch9_3_alloc.ll
<span class="go">; ModuleID = &#39;ch9_3_alloc.bc&#39;</span>
<span class="go">target datalayout = &quot;e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-</span>
<span class="go">f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:</span>
<span class="go">32:64-S128&quot;</span>
<span class="go">target triple = &quot;x86_64-apple-macosx10.8.0&quot;</span>

<span class="go">define i32 @_Z5sum_iiiiiii(i32 %x1, i32 %x2, i32 %x3, i32 %x4, i32 %x5, i32 %x6)</span>
<span class="go"> nounwind uwtable ssp {</span>
<span class="go">  ...</span>
<span class="gp">  %</span><span class="nv">9</span> <span class="o">=</span> alloca i8, i32 %8      // int* <span class="nv">b</span> <span class="o">=</span> <span class="o">(</span>int*<span class="o">)</span>__builtin_alloca<span class="o">(</span>sizeof<span class="o">(</span>int<span class="o">)</span> * <span class="m">1</span> * x1<span class="o">)</span><span class="p">;</span>
<span class="gp">  %</span><span class="nv">10</span> <span class="o">=</span> bitcast i8* %9 to i32*
<span class="go">  store i32* %10, i32** %b, align 4</span>
<span class="go">  ...</span>
<span class="go">}</span>
<span class="go">...</span>

<span class="gp">118-165-72-242:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llc -march=cpu0 -mcpu=cpu032I -cpu0-s32-calls=false</span>
<span class="go">-relocation-model=pic -filetype=asm ch9_3_alloc.bc -o ch9_3_alloc.cpu0.s</span>
<span class="gp">118-165-72-242:input Jonathan$ </span>cat ch9_3_alloc.cpu0.s
<span class="go">...</span>
<span class="go">    .globl  _Z10weight_sumiiiiii</span>
<span class="go">  .align  2</span>
<span class="go">  .type _Z10weight_sumiiiiii,@function</span>
<span class="go">  .ent  _Z10weight_sumiiiiii    # @_Z10weight_sumiiiiii</span>
<span class="go">_Z10weight_sumiiiiii:</span>
<span class="go">  .frame  $fp,48,$lr</span>
<span class="go">  .mask   0x00005000,-4</span>
<span class="go">  .set  noreorder</span>
<span class="go">  .cpload $t9</span>
<span class="go">  .set  nomacro</span>
<span class="gp"># </span>BB#0:
<span class="go">  addiu $sp, $sp, -48</span>
<span class="go">  st  $lr, 44($sp)            # 4-byte Folded Spill</span>
<span class="go">  st  $fp, 40($sp)            # 4-byte Folded Spill</span>
<span class="go">  move   $fp, $sp</span>
<span class="go">  .cprestore  24</span>
<span class="go">  ld  $2, 68($fp)</span>
<span class="go">  ld  $3, 64($fp)</span>
<span class="go">  ld  $t9, 60($fp)</span>
<span class="go">  ld  $7, 56($fp)</span>
<span class="go">  st  $4, 36($fp)</span>
<span class="go">  st  $5, 32($fp)</span>
<span class="go">  st  $7, 28($fp)</span>
<span class="go">  st  $t9, 24($fp)</span>
<span class="go">  st  $3, 20($fp)</span>
<span class="go">  st  $2, 16($fp)</span>
<span class="go">  shl $2, $2, 2    // $2 = sizeof(int) * 1 * x2;</span>
<span class="go">  addiu $2, $2, 7</span>
<span class="go">  addiu $3, $zero, -8</span>
<span class="go">  and $2, $2, $3</span>
<span class="go">  addiu $sp, $sp, 0</span>
<span class="go">  subu  $2, $sp, $2</span>
<span class="go">  addu  $sp, $zero, $2  // set sp to the bottom of alloca area</span>
<span class="go">  addiu $sp, $sp, 0</span>
<span class="go">  st  $2, 12($fp)</span>
<span class="go">  st  $2, 8($fp)</span>
<span class="go">  ld  $2, 12($fp)</span>
<span class="go">  ld  $3, 28($fp)</span>
<span class="go">  st  $3, 0($2)    // *b = x3</span>
<span class="go">  ld  $5, 32($fp)</span>
<span class="go">  ld  $2, 36($fp)</span>
<span class="go">  ld  $3, 20($fp)</span>
<span class="go">  ld  $4, 28($fp)</span>
<span class="go">  ld  $t9, 24($fp)</span>
<span class="go">  ld  $7, 16($fp)</span>
<span class="go">  addiu $sp, $sp, -24</span>
<span class="go">  st  $7, 20($sp)</span>
<span class="go">  st  $t9, 12($sp)</span>
<span class="go">  st  $4, 8($sp)</span>
<span class="go">  shl $3, $3, 1</span>
<span class="go">  st  $3, 16($sp)</span>
<span class="go">  addiu $3, $zero, 3</span>
<span class="go">  mul $4, $2, $3</span>
<span class="go">  ld  $t9, %call16(_Z3sumiiiiii)($gp)</span>
<span class="go">  jalr  $t9</span>
<span class="go">  nop</span>
<span class="go">  ld  $gp, 24($fp)</span>
<span class="go">  addiu $sp, $sp, 24</span>
<span class="go">  st  $2, 4($fp)</span>
<span class="go">  ld  $3, 8($fp)</span>
<span class="go">  ld  $3, 0($3)</span>
<span class="go">  addu  $2, $2, $3</span>
<span class="go">  move   $sp, $fp</span>
<span class="go">  ld  $fp, 40($sp)            # 4-byte Folded Reload</span>
<span class="go">  ld  $lr, 44($sp)            # 4-byte Folded Reload</span>
<span class="go">  addiu $sp, $sp, 48</span>
<span class="go">  ret $lr</span>
<span class="go">  nop</span>
<span class="go">  .set  macro</span>
<span class="go">  .set  reorder</span>
<span class="go">  .end  _Z10weight_sumiiiiii</span>
<span class="gp">$</span>func_end1:
<span class="go">  .size _Z10weight_sumiiiiii, ($func_end1)-_Z10weight_sumiiiiii</span>
<span class="go">...</span>
</pre></div>
</div>
<p>As you can see, dynamic stack allocation requires frame pointer register <code class="docutils literal notranslate"><span class="pre">fp</span></code>
support. As shown in the assembly above, the <code class="docutils literal notranslate"><span class="pre">sp</span></code> is adjusted to <code class="docutils literal notranslate"><span class="pre">sp</span> <span class="pre">-</span> <span class="pre">48</span></code>
when entering the function by the instruction <code class="docutils literal notranslate"><span class="pre">addiu</span> <span class="pre">$sp,</span> <span class="pre">$sp,</span> <span class="pre">-48</span></code>.</p>
<p>Next, <code class="docutils literal notranslate"><span class="pre">fp</span></code> is set to <code class="docutils literal notranslate"><span class="pre">sp</span></code>, which is positioned just above the area allocated
by <code class="docutils literal notranslate"><span class="pre">alloca()</span></code>, as illustrated in <a class="reference internal" href="#funccall-f4"><span class="std std-numref">Fig. 48</span></a>, when the instruction
<code class="docutils literal notranslate"><span class="pre">move</span> <span class="pre">$fp,</span> <span class="pre">$sp</span></code> is encountered.</p>
<p>After that, <code class="docutils literal notranslate"><span class="pre">sp</span></code> is moved to the space just below the <code class="docutils literal notranslate"><span class="pre">alloca()</span></code> allocation.
Note that the space pointed to by <code class="docutils literal notranslate"><span class="pre">b</span></code>,
<code class="docutils literal notranslate"><span class="pre">*b</span> <span class="pre">=</span> <span class="pre">(int*)__builtin_alloca(sizeof(int)</span> <span class="pre">*</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">x6)</span></code>, is allocated at run time,
because the size depends on the <code class="docutils literal notranslate"><span class="pre">x1</span></code> variable and cannot be determined at link
time.</p>
<p><a class="reference internal" href="#funccall-f5"><span class="std std-numref">Fig. 49</span></a> illustrates how the stack pointer is restored to the
caller’s stack bottom. As described above, <code class="docutils literal notranslate"><span class="pre">fp</span></code> is set to the address just
above the <code class="docutils literal notranslate"><span class="pre">alloca()</span></code> area.</p>
<p>The first step restores <code class="docutils literal notranslate"><span class="pre">sp</span></code> from <code class="docutils literal notranslate"><span class="pre">fp</span></code> using the instruction <code class="docutils literal notranslate"><span class="pre">move</span> <span class="pre">$sp,</span> <span class="pre">$fp</span></code>.
Next, <code class="docutils literal notranslate"><span class="pre">sp</span></code> is adjusted back to the caller’s stack bottom using
<code class="docutils literal notranslate"><span class="pre">addiu</span> <span class="pre">$sp,</span> <span class="pre">$sp,</span> <span class="pre">40</span></code>.</p>
<figure class="align-center" id="id29">
<span id="funccall-f4"></span><a class="reference internal image-reference" href="_images/4.png"><img alt="_images/4.png" src="_images/4.png" style="width: 267.5px; height: 139.5px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 48 </span><span class="caption-text">Frame pointer changes when enter function</span><a class="headerlink" href="#id29" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id30">
<span id="funccall-f5"></span><a class="reference internal image-reference" href="_images/5.png"><img alt="_images/5.png" src="_images/5.png" style="width: 264.0px; height: 132.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 49 </span><span class="caption-text">Stack pointer changes when exit function</span><a class="headerlink" href="#id30" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id31">
<span id="funccall-f6"></span><a class="reference internal image-reference" href="_images/6.png"><img alt="_images/6.png" src="_images/6.png" style="width: 269.5px; height: 197.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 50 </span><span class="caption-text">fp and sp access areas</span><a class="headerlink" href="#id31" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>Using <code class="docutils literal notranslate"><span class="pre">fp</span></code> to keep the old stack pointer value is not the only solution.
In fact, we can store the size of the <code class="docutils literal notranslate"><span class="pre">alloca()</span></code> spaces at a specific memory
address and restore <code class="docutils literal notranslate"><span class="pre">sp</span></code> to its previous value by adding back the size of the
<code class="docutils literal notranslate"><span class="pre">alloca()</span></code> area.</p>
<p>Most ABIs, such as MIPS and ARM, access the area above <code class="docutils literal notranslate"><span class="pre">alloca()</span></code> using <code class="docutils literal notranslate"><span class="pre">fp</span></code>
and the area below <code class="docutils literal notranslate"><span class="pre">alloca()</span></code> using <code class="docutils literal notranslate"><span class="pre">sp</span></code>, as depicted in <a class="reference internal" href="#funccall-f6"><span class="std std-numref">Fig. 50</span></a>.</p>
<p>The reason for this design is performance in accessing local variables. Since
RISC CPUs commonly use immediate offsets for load and store instructions, using
both <code class="docutils literal notranslate"><span class="pre">fp</span></code> and <code class="docutils literal notranslate"><span class="pre">sp</span></code> to access the two separate areas of local variables
provides better performance compared to using only <code class="docutils literal notranslate"><span class="pre">sp</span></code>.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">ld      $2, 64($fp)</span>
<span class="go">st      $3, 4($sp)</span>
</pre></div>
</div>
<p>Cpu0 uses <code class="docutils literal notranslate"><span class="pre">fp</span></code> and <code class="docutils literal notranslate"><span class="pre">sp</span></code> to access the areas above and below <code class="docutils literal notranslate"><span class="pre">alloca()</span></code>,
respectively. As shown in <code class="docutils literal notranslate"><span class="pre">ch9_3_alloc.cpu0.s</span></code>, it accesses local variables
(above the <code class="docutils literal notranslate"><span class="pre">alloca()</span></code> area) using <code class="docutils literal notranslate"><span class="pre">fp</span></code> offset, and accesses outgoing
arguments (below the <code class="docutils literal notranslate"><span class="pre">alloca()</span></code> area) using <code class="docutils literal notranslate"><span class="pre">sp</span></code> offset.</p>
<p>Additionally, the instruction <code class="docutils literal notranslate"><span class="pre">move</span> <span class="pre">$sp,</span> <span class="pre">$fp</span></code> is an alias for the actual
machine instruction <code class="docutils literal notranslate"><span class="pre">addu</span> <span class="pre">$fp,</span> <span class="pre">$sp,</span> <span class="pre">$zero</span></code>. The machine code emitted is the
latter, while the former is used for easier readability by users.</p>
<p>This alias is defined by the code added in Chapter3_2 and Chapter3_5, as shown
below:</p>
<p class="rubric">lbdex/chapters/Chapter3_2/InstPrinter/Cpu0InstPrinter.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>void Cpu0InstPrinter::printInst(const MCInst *MI, uint64_t Address,
                                StringRef Annot, const MCSubtargetInfo &amp;STI,
                                raw_ostream &amp;O) {
  // Try to print any aliases first.
  if (!printAliasInstr(MI, Address, O))
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter3_5/Cpu0InstrInfo.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Cpu0InstAlias</span><span class="o">&lt;</span><span class="n">string</span> <span class="n">Asm</span><span class="p">,</span> <span class="n">dag</span> <span class="n">Result</span><span class="p">,</span> <span class="n">bit</span> <span class="n">Emit</span> <span class="o">=</span> <span class="mb">0b1</span><span class="o">&gt;</span> <span class="p">:</span>
  <span class="n">InstAlias</span><span class="o">&lt;</span><span class="n">Asm</span><span class="p">,</span> <span class="n">Result</span><span class="p">,</span> <span class="n">Emit</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>let Predicates = [Ch3_5] in {
//===----------------------------------------------------------------------===//
// Instruction aliases
//===----------------------------------------------------------------------===//
def : Cpu0InstAlias&lt;&quot;move $dst, $src&quot;,
                    (ADDu GPROut:$dst, GPROut:$src,ZERO), 1&gt;;
}
</pre></div>
</div>
<p>Finally, the <code class="docutils literal notranslate"><span class="pre">MFI-&gt;hasVarSizedObjects()</span></code> defined in <code class="docutils literal notranslate"><span class="pre">hasReservedCallFrame()</span></code>
of <code class="docutils literal notranslate"><span class="pre">Cpu0SEFrameLowering.cpp</span></code> is set to true when the IR contains
<code class="docutils literal notranslate"><span class="pre">%9</span> <span class="pre">=</span> <span class="pre">alloca</span> <span class="pre">i8,</span> <span class="pre">i32</span> <span class="pre">%8</span></code>, which corresponds to
<code class="docutils literal notranslate"><span class="pre">(int*)__builtin_alloca(sizeof(int)</span> <span class="pre">*</span> <span class="pre">1</span> <span class="pre">*</span> <span class="pre">x1);</span></code> in C code.</p>
<p>This triggers generation of the assembly instruction <code class="docutils literal notranslate"><span class="pre">addiu</span> <span class="pre">$sp,</span> <span class="pre">$sp,</span> <span class="pre">-24</span></code>
for <code class="docutils literal notranslate"><span class="pre">ch9_3_alloc.cpp</span></code> by invoking <code class="docutils literal notranslate"><span class="pre">adjustStackPtr()</span></code> inside
<code class="docutils literal notranslate"><span class="pre">eliminateCallFramePseudoInstr()</span></code> of <code class="docutils literal notranslate"><span class="pre">Cpu0FrameLowering.cpp</span></code>.</p>
<p>The file <code class="docutils literal notranslate"><span class="pre">ch9_3_longlongshift.cpp</span></code> demonstrates support for the type
<strong>long long shift operations</strong>, which can be tested now as shown below.</p>
<p class="rubric">lbdex/input/ch9_3_longlongshift.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &quot;debug.h&quot;</span>

<span class="n">long</span> <span class="n">long</span> <span class="n">test_longlong_shift1</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">long</span> <span class="n">long</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
  <span class="n">long</span> <span class="n">long</span> <span class="n">b</span> <span class="o">=</span> <span class="mh">0x12</span><span class="p">;</span>
  <span class="n">long</span> <span class="n">long</span> <span class="n">c</span><span class="p">;</span>
  <span class="n">long</span> <span class="n">long</span> <span class="n">d</span><span class="p">;</span>
  
  <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">);</span>  <span class="o">//</span> <span class="n">cc</span> <span class="o">=</span> <span class="mh">0x1</span>
  <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">);</span>  <span class="o">//</span> <span class="n">cc</span> <span class="o">=</span> <span class="mh">0x120</span>

  <span class="n">long</span> <span class="n">long</span> <span class="n">e</span> <span class="o">=</span> <span class="mh">0x7FFFFFFFFFFFFFF</span><span class="n">LL</span> <span class="o">&gt;&gt;</span> <span class="mi">63</span><span class="p">;</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">c</span><span class="o">+</span><span class="n">d</span><span class="o">+</span><span class="n">e</span><span class="p">);</span> <span class="o">//</span> <span class="mh">0x121</span> <span class="o">=</span> <span class="mi">289</span>
<span class="p">}</span>

<span class="n">long</span> <span class="n">long</span> <span class="n">test_longlong_shift2</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">long</span> <span class="n">long</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">48</span><span class="p">;</span>
  <span class="n">long</span> <span class="n">long</span> <span class="n">b</span> <span class="o">=</span> <span class="mh">0x001666660000000a</span><span class="p">;</span>
  <span class="n">long</span> <span class="n">long</span> <span class="n">c</span><span class="p">;</span>
  
  <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">c</span><span class="p">;</span> <span class="o">//</span> <span class="mi">22</span>
<span class="p">}</span>

</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">114-37-150-209:input Jonathan$ </span>clang -O0 -target mips-unknown-linux-gnu
<span class="go">-c ch9_3_longlongshift.cpp -emit-llvm -o ch9_3_longlongshift.bc</span>

<span class="gp">114-37-150-209:input Jonathan$ </span>~/llvm/test/build/bin/
<span class="go">llvm-dis ch9_3_longlongshift.bc -o -</span>
<span class="go">...</span>
<span class="go">; Function Attrs: nounwind</span>
<span class="go">define i64 @_Z19test_longlong_shiftv() #0 {</span>
<span class="gp">  %</span><span class="nv">a</span> <span class="o">=</span> alloca i64, align <span class="m">8</span>
<span class="gp">  %</span><span class="nv">b</span> <span class="o">=</span> alloca i64, align <span class="m">8</span>
<span class="gp">  %</span><span class="nv">c</span> <span class="o">=</span> alloca i64, align <span class="m">8</span>
<span class="gp">  %</span><span class="nv">d</span> <span class="o">=</span> alloca i64, align <span class="m">8</span>
<span class="go">  store i64 4, i64* %a, align 8</span>
<span class="go">  store i64 18, i64* %b, align 8</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> load i64* %b, align <span class="m">8</span>
<span class="gp">  %</span><span class="nv">2</span> <span class="o">=</span> load i64* %a, align <span class="m">8</span>
<span class="gp">  %</span><span class="nv">3</span> <span class="o">=</span> ashr i64 %1, %2
<span class="go">  store i64 %3, i64* %c, align 8</span>
<span class="gp">  %</span><span class="nv">4</span> <span class="o">=</span> load i64* %b, align <span class="m">8</span>
<span class="gp">  %</span><span class="nv">5</span> <span class="o">=</span> load i64* %a, align <span class="m">8</span>
<span class="gp">  %</span><span class="nv">6</span> <span class="o">=</span> shl i64 %4, %5
<span class="go">  store i64 %6, i64* %d, align 8</span>
<span class="gp">  %</span><span class="nv">7</span> <span class="o">=</span> load i64* %c, align <span class="m">8</span>
<span class="gp">  %</span><span class="nv">8</span> <span class="o">=</span> load i64* %d, align <span class="m">8</span>
<span class="gp">  %</span><span class="nv">9</span> <span class="o">=</span> add nsw i64 %7, %8
<span class="go">  ret i64 %9</span>
<span class="go">}</span>
<span class="go">...</span>
<span class="gp">114-37-150-209:input Jonathan$ </span>~/llvm/test/build/bin/llc
<span class="go">-march=cpu0 -mcpu=cpu032I -relocation-model=static -filetype=asm</span>
<span class="go">ch9_3_longlongshift.bc -o -</span>
<span class="go">  .text</span>
<span class="go">  .section .mdebug.abi32</span>
<span class="go">  .previous</span>
<span class="go">  .file &quot;ch9_3_longlongshift.bc&quot;</span>
<span class="go">  .globl  _Z20test_longlong_shift1v</span>
<span class="go">  .align  2</span>
<span class="go">  .type _Z20test_longlong_shift1v,@function</span>
<span class="go">  .ent  _Z20test_longlong_shift1v # @_Z20test_longlong_shift1v</span>
<span class="go">_Z20test_longlong_shift1v:</span>
<span class="go">  .frame  $fp,56,$lr</span>
<span class="go">  .mask   0x00005000,-4</span>
<span class="go">  .set  noreorder</span>
<span class="go">  .set  nomacro</span>
<span class="gp"># </span>BB#0:
<span class="go">  addiu $sp, $sp, -56</span>
<span class="go">  st  $lr, 52($sp)            # 4-byte Folded Spill</span>
<span class="go">  st  $fp, 48($sp)            # 4-byte Folded Spill</span>
<span class="go">  move   $fp, $sp</span>
<span class="go">  addiu $2, $zero, 4</span>
<span class="go">  st  $2, 44($fp)</span>
<span class="go">  addiu $4, $zero, 0</span>
<span class="go">  st  $4, 40($fp)</span>
<span class="go">  addiu $5, $zero, 18</span>
<span class="go">  st  $5, 36($fp)</span>
<span class="go">  st  $4, 32($fp)</span>
<span class="go">  ld  $2, 44($fp)</span>
<span class="go">  st  $2, 8($sp)</span>
<span class="go">  jsub  __lshrdi3</span>
<span class="go">  nop</span>
<span class="go">  st  $3, 28($fp)</span>
<span class="go">  st  $2, 24($fp)</span>
<span class="go">  ld  $2, 44($fp)</span>
<span class="go">  st  $2, 8($sp)</span>
<span class="go">  ld  $4, 32($fp)</span>
<span class="go">  ld  $5, 36($fp)</span>
<span class="go">  jsub  __ashldi3</span>
<span class="go">  nop</span>
<span class="go">  st  $3, 20($fp)</span>
<span class="go">  st  $2, 16($fp)</span>
<span class="go">  ld  $4, 28($fp)</span>
<span class="go">  addu  $4, $4, $3</span>
<span class="go">  cmp $sw, $4, $3</span>
<span class="go">  andi  $3, $sw, 1</span>
<span class="go">  addu  $2, $3, $2</span>
<span class="go">  ld  $3, 24($fp)</span>
<span class="go">  addu  $2, $3, $2</span>
<span class="go">  addu  $3, $zero, $4</span>
<span class="go">  move   $sp, $fp</span>
<span class="go">  ld  $fp, 48($sp)            # 4-byte Folded Reload</span>
<span class="go">  ld  $lr, 52($sp)            # 4-byte Folded Reload</span>
<span class="go">  addiu $sp, $sp, 56</span>
<span class="go">  ret $lr</span>
<span class="go">  nop</span>
<span class="go">  .set  macro</span>
<span class="go">  .set  reorder</span>
<span class="go">  .end  _Z20test_longlong_shift1v</span>
<span class="gp">$</span>tmp0:
<span class="go">  .size _Z20test_longlong_shift1v, ($tmp0)-_Z20test_longlong_shift1v</span>

<span class="go">  .globl  _Z20test_longlong_shift2v</span>
<span class="go">  .align  2</span>
<span class="go">  .type _Z20test_longlong_shift2v,@function</span>
<span class="go">  .ent  _Z20test_longlong_shift2v # @_Z20test_longlong_shift2v</span>
<span class="go">_Z20test_longlong_shift2v:</span>
<span class="go">  .frame  $fp,48,$lr</span>
<span class="go">  .mask   0x00005000,-4</span>
<span class="go">  .set  noreorder</span>
<span class="go">  .set  nomacro</span>
<span class="gp"># </span>BB#0:
<span class="go">  addiu $sp, $sp, -48</span>
<span class="go">  st  $lr, 44($sp)            # 4-byte Folded Spill</span>
<span class="go">  st  $fp, 40($sp)            # 4-byte Folded Spill</span>
<span class="go">  move   $fp, $sp</span>
<span class="go">  addiu $2, $zero, 48</span>
<span class="go">  st  $2, 36($fp)</span>
<span class="go">  addiu $2, $zero, 0</span>
<span class="go">  st  $2, 32($fp)</span>
<span class="go">  addiu $5, $zero, 10</span>
<span class="go">  st  $5, 28($fp)</span>
<span class="go">  lui $2, 22</span>
<span class="go">  ori $4, $2, 26214</span>
<span class="go">  st  $4, 24($fp)</span>
<span class="go">  ld  $2, 36($fp)</span>
<span class="go">  st  $2, 8($sp)</span>
<span class="go">  jsub  __lshrdi3</span>
<span class="go">  nop</span>
<span class="go">  st  $3, 20($fp)</span>
<span class="go">  st  $2, 16($fp)</span>
<span class="go">  move   $sp, $fp</span>
<span class="go">  ld  $fp, 40($sp)            # 4-byte Folded Reload</span>
<span class="go">  ld  $lr, 44($sp)            # 4-byte Folded Reload</span>
<span class="go">  addiu $sp, $sp, 48</span>
<span class="go">  ret $lr</span>
<span class="go">  nop</span>
<span class="go">  .set  macro</span>
<span class="go">  .set  reorder</span>
<span class="go">  .end  _Z20test_longlong_shift2v</span>
<span class="gp">$</span>tmp1:
<span class="go">  .size _Z20test_longlong_shift2v, ($tmp1)-_Z20test_longlong_shift2v</span>
</pre></div>
</div>
</section>
<section id="variable-sized-array-support">
<h3><a class="toc-backref" href="#id48" role="doc-backlink">Variable sized array support</a><a class="headerlink" href="#variable-sized-array-support" title="Permalink to this heading">¶</a></h3>
<p>LLVM supports variable sized arrays (VLA) as introduced in C99 <a class="footnote-reference brackets" href="#stacksave" id="id11" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a>
<a class="footnote-reference brackets" href="#wiki-vla" id="id12" role="doc-noteref"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></a>.
The following code is added to support this feature. These intrinsics are set to
expand, meaning LLVM replaces them with other DAG nodes during code generation.</p>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0ISelLowering.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="p">::</span>
<span class="n">LowerOperation</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span>
<span class="p">{</span>
  <span class="n">switch</span> <span class="p">(</span><span class="n">Op</span><span class="o">.</span><span class="n">getOpcode</span><span class="p">())</span>
  <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="o">//</span> <span class="n">Use</span> <span class="n">the</span> <span class="n">default</span> <span class="k">for</span> <span class="n">now</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">STACKSAVE</span><span class="p">,</span>         <span class="n">MVT</span><span class="p">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">STACKRESTORE</span><span class="p">,</span>      <span class="n">MVT</span><span class="p">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/input/ch9_3_stacksave.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">test_stacksaverestore</span><span class="p">(</span><span class="n">unsigned</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">//</span> <span class="n">CHECK</span><span class="p">:</span> <span class="n">call</span> <span class="n">i8</span><span class="o">*</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">stacksave</span><span class="p">()</span>
  <span class="n">char</span> <span class="n">s1</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
  <span class="n">s1</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="n">s1</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
  <span class="o">//</span> <span class="n">CHECK</span><span class="p">:</span> <span class="n">call</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">stackrestore</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>clang -target mips-unknown-linux-gnu -c
<span class="go">ch9_3_stacksave.cpp -emit-llvm -o ch9_3_stacksave.bc</span>
<span class="gp">JonathantekiiMac:input Jonathan$ </span>llvm-dis ch9_3_stacksave.bc -o -

<span class="go">define i32 @_Z21test_stacksaverestorej(i32 zeroext %x) #0 {</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> alloca i32, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">2</span> <span class="o">=</span> alloca i8*
<span class="gp">  %</span><span class="nv">3</span> <span class="o">=</span> alloca i32
<span class="go">  store i32 %x, i32* %1, align 4</span>
<span class="gp">  %</span><span class="nv">4</span> <span class="o">=</span> load i32, i32* %1, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">5</span> <span class="o">=</span> call i8* @llvm.stacksave<span class="o">()</span>
<span class="go">  store i8* %5, i8** %2</span>
<span class="gp">  %</span><span class="nv">6</span> <span class="o">=</span> alloca i8, i32 %4, align <span class="m">1</span>
<span class="gp">  %</span><span class="nv">7</span> <span class="o">=</span> load i32, i32* %1, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">8</span> <span class="o">=</span> getelementptr inbounds i8, i8* %6, i32 %7
<span class="go">  store i8 5, i8* %8, align 1</span>
<span class="gp">  %</span><span class="nv">9</span> <span class="o">=</span> load i32, i32* %1, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">10</span> <span class="o">=</span> getelementptr inbounds i8, i8* %6, i32 %9
<span class="gp">  %</span><span class="nv">11</span> <span class="o">=</span> load i8, i8* %10, align <span class="m">1</span>
<span class="gp">  %</span><span class="nv">12</span> <span class="o">=</span> sext i8 %11 to i32
<span class="go">  store i32 1, i32* %3</span>
<span class="gp">  %</span><span class="nv">13</span> <span class="o">=</span> load i8*, i8** %2
<span class="go">  call void @llvm.stackrestore(i8* %13)</span>
<span class="go">  ret i32 %12</span>
<span class="go">}</span>

<span class="gp">JonathantekiiMac:input Jonathan$ </span>~/llvm/test/build/bin/llc
<span class="go">-march=cpu0 -mcpu=cpu032I -relocation-model=static -filetype=asm</span>
<span class="go">ch9_3_stacksave.bc -o -</span>
<span class="go">...</span>
</pre></div>
</div>
</section>
<section id="function-related-intrinsics-support">
<h3><a class="toc-backref" href="#id49" role="doc-backlink">Function related Intrinsics support</a><a class="headerlink" href="#function-related-intrinsics-support" title="Permalink to this heading">¶</a></h3>
<p>I believe these LLVM intrinsic IRs are used for implementing exception handling
<a class="footnote-reference brackets" href="#excepthandle" id="id13" role="doc-noteref"><span class="fn-bracket">[</span>11<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#returnaddr" id="id14" role="doc-noteref"><span class="fn-bracket">[</span>12<span class="fn-bracket">]</span></a>. With these IRs, a programmer can record the
frame address and return address, which can be used in C++ programs to
implement exception handlers, as shown in the example below.</p>
<p>To support these LLVM intrinsic IRs, the following code is added to the Cpu0
backend.</p>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0ISelLowering.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="n">const</span> <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">,</span>
                                       <span class="n">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span>
    <span class="p">:</span> <span class="n">TargetLowering</span><span class="p">(</span><span class="n">TM</span><span class="p">),</span> <span class="n">Subtarget</span><span class="p">(</span><span class="n">STI</span><span class="p">),</span> <span class="n">ABI</span><span class="p">(</span><span class="n">TM</span><span class="o">.</span><span class="n">getABI</span><span class="p">())</span> <span class="p">{</span>

</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">EH_RETURN</span><span class="p">,</span> <span class="n">MVT</span><span class="p">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Custom</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">ADD</span><span class="p">,</span>                <span class="n">MVT</span><span class="p">::</span><span class="n">i32</span><span class="p">,</span>   <span class="n">Custom</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="p">::</span>
<span class="n">LowerOperation</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span>
<span class="p">{</span>
  <span class="n">switch</span> <span class="p">(</span><span class="n">Op</span><span class="o">.</span><span class="n">getOpcode</span><span class="p">())</span>
  <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">case</span> <span class="n">ISD</span><span class="p">::</span><span class="n">FRAMEADDR</span><span class="p">:</span>          <span class="k">return</span> <span class="n">lowerFRAMEADDR</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">);</span>
  <span class="k">case</span> <span class="n">ISD</span><span class="p">::</span><span class="n">RETURNADDR</span><span class="p">:</span>         <span class="k">return</span> <span class="n">lowerRETURNADDR</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">);</span>
  <span class="k">case</span> <span class="n">ISD</span><span class="p">::</span><span class="n">EH_RETURN</span><span class="p">:</span>          <span class="k">return</span> <span class="n">lowerEH_RETURN</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">);</span>
  <span class="k">case</span> <span class="n">ISD</span><span class="p">::</span><span class="n">ADD</span><span class="p">:</span>                <span class="k">return</span> <span class="n">lowerADD</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="p">::</span>
<span class="n">lowerFRAMEADDR</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="o">//</span> <span class="n">check</span> <span class="n">the</span> <span class="n">depth</span>
  <span class="k">assert</span><span class="p">((</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">ConstantSDNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Op</span><span class="o">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">getZExtValue</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
         <span class="s2">&quot;Frame address can only be determined for current frame.&quot;</span><span class="p">);</span>

  <span class="n">MachineFrameInfo</span> <span class="o">&amp;</span><span class="n">MFI</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getMachineFunction</span><span class="p">()</span><span class="o">.</span><span class="n">getFrameInfo</span><span class="p">();</span>
  <span class="n">MFI</span><span class="o">.</span><span class="n">setFrameAddressIsTaken</span><span class="p">(</span><span class="n">true</span><span class="p">);</span>
  <span class="n">EVT</span> <span class="n">VT</span> <span class="o">=</span> <span class="n">Op</span><span class="o">.</span><span class="n">getValueType</span><span class="p">();</span>
  <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">(</span><span class="n">Op</span><span class="p">);</span>
  <span class="n">SDValue</span> <span class="n">FrameAddr</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getCopyFromReg</span><span class="p">(</span>
      <span class="n">DAG</span><span class="o">.</span><span class="n">getEntryNode</span><span class="p">(),</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">FP</span><span class="p">,</span> <span class="n">VT</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">FrameAddr</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">lowerRETURNADDR</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span>
                                            <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">verifyReturnAddressArgumentIsConstant</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">SDValue</span><span class="p">();</span>

  <span class="o">//</span> <span class="n">check</span> <span class="n">the</span> <span class="n">depth</span>
  <span class="k">assert</span><span class="p">((</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">ConstantSDNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Op</span><span class="o">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">getZExtValue</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
         <span class="s2">&quot;Return address can be determined only for current frame.&quot;</span><span class="p">);</span>

  <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getMachineFunction</span><span class="p">();</span>
  <span class="n">MachineFrameInfo</span> <span class="o">&amp;</span><span class="n">MFI</span> <span class="o">=</span> <span class="n">MF</span><span class="o">.</span><span class="n">getFrameInfo</span><span class="p">();</span>
  <span class="n">MVT</span> <span class="n">VT</span> <span class="o">=</span> <span class="n">Op</span><span class="o">.</span><span class="n">getSimpleValueType</span><span class="p">();</span>
  <span class="n">unsigned</span> <span class="n">LR</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">LR</span><span class="p">;</span>
  <span class="n">MFI</span><span class="o">.</span><span class="n">setReturnAddressIsTaken</span><span class="p">(</span><span class="n">true</span><span class="p">);</span>

  <span class="o">//</span> <span class="n">Return</span> <span class="n">LR</span><span class="p">,</span> <span class="n">which</span> <span class="n">contains</span> <span class="n">the</span> <span class="k">return</span> <span class="n">address</span><span class="o">.</span> <span class="n">Mark</span> <span class="n">it</span> <span class="n">an</span> <span class="n">implicit</span> <span class="n">live</span><span class="o">-</span><span class="ow">in</span><span class="o">.</span>
  <span class="n">unsigned</span> <span class="n">Reg</span> <span class="o">=</span> <span class="n">MF</span><span class="o">.</span><span class="n">addLiveIn</span><span class="p">(</span><span class="n">LR</span><span class="p">,</span> <span class="n">getRegClassFor</span><span class="p">(</span><span class="n">VT</span><span class="p">));</span>
  <span class="k">return</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getCopyFromReg</span><span class="p">(</span><span class="n">DAG</span><span class="o">.</span><span class="n">getEntryNode</span><span class="p">(),</span> <span class="n">SDLoc</span><span class="p">(</span><span class="n">Op</span><span class="p">),</span> <span class="n">Reg</span><span class="p">,</span> <span class="n">VT</span><span class="p">);</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">An</span> <span class="n">EH_RETURN</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">result</span> <span class="n">of</span> <span class="n">lowering</span> <span class="n">llvm</span><span class="o">.</span><span class="n">eh</span><span class="o">.</span><span class="k">return</span> <span class="n">which</span> <span class="ow">in</span> <span class="n">turn</span> <span class="ow">is</span>
<span class="o">//</span> <span class="n">generated</span> <span class="kn">from</span> <span class="nn">__builtin_eh_return</span> <span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">handler</span><span class="p">)</span>
<span class="o">//</span> <span class="n">The</span> <span class="n">effect</span> <span class="n">of</span> <span class="n">this</span> <span class="ow">is</span> <span class="n">to</span> <span class="n">adjust</span> <span class="n">the</span> <span class="n">stack</span> <span class="n">pointer</span> <span class="n">by</span> <span class="s2">&quot;offset&quot;</span>
<span class="o">//</span> <span class="ow">and</span> <span class="n">then</span> <span class="n">branch</span> <span class="n">to</span> <span class="s2">&quot;handler&quot;</span><span class="o">.</span>
<span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">lowerEH_RETURN</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span>
                                                                     <span class="n">const</span> <span class="p">{</span>
  <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getMachineFunction</span><span class="p">();</span>
  <span class="n">Cpu0FunctionInfo</span> <span class="o">*</span><span class="n">Cpu0FI</span> <span class="o">=</span> <span class="n">MF</span><span class="o">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">setCallsEhReturn</span><span class="p">();</span>
  <span class="n">SDValue</span> <span class="n">Chain</span>     <span class="o">=</span> <span class="n">Op</span><span class="o">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">SDValue</span> <span class="n">Offset</span>    <span class="o">=</span> <span class="n">Op</span><span class="o">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">SDValue</span> <span class="n">Handler</span>   <span class="o">=</span> <span class="n">Op</span><span class="o">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">(</span><span class="n">Op</span><span class="p">);</span>
  <span class="n">EVT</span> <span class="n">Ty</span> <span class="o">=</span> <span class="n">MVT</span><span class="p">::</span><span class="n">i32</span><span class="p">;</span>

  <span class="o">//</span> <span class="n">Store</span> <span class="n">stack</span> <span class="n">offset</span> <span class="ow">in</span> <span class="n">V1</span><span class="p">,</span> <span class="n">store</span> <span class="n">jump</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">V0</span><span class="o">.</span> <span class="n">Glue</span> <span class="n">CopyToReg</span> <span class="ow">and</span>
  <span class="o">//</span> <span class="n">EH_RETURN</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">so</span> <span class="n">that</span> <span class="n">instructions</span> <span class="n">are</span> <span class="n">emitted</span> <span class="n">back</span><span class="o">-</span><span class="n">to</span><span class="o">-</span><span class="n">back</span><span class="o">.</span>
  <span class="n">unsigned</span> <span class="n">OffsetReg</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">V1</span><span class="p">;</span>
  <span class="n">unsigned</span> <span class="n">AddrReg</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">V0</span><span class="p">;</span>
  <span class="n">Chain</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getCopyToReg</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">OffsetReg</span><span class="p">,</span> <span class="n">Offset</span><span class="p">,</span> <span class="n">SDValue</span><span class="p">());</span>
  <span class="n">Chain</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getCopyToReg</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">AddrReg</span><span class="p">,</span> <span class="n">Handler</span><span class="p">,</span> <span class="n">Chain</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
  <span class="k">return</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">Cpu0ISD</span><span class="p">::</span><span class="n">EH_RETURN</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">MVT</span><span class="p">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Chain</span><span class="p">,</span>
                     <span class="n">DAG</span><span class="o">.</span><span class="n">getRegister</span><span class="p">(</span><span class="n">OffsetReg</span><span class="p">,</span> <span class="n">Ty</span><span class="p">),</span>
                     <span class="n">DAG</span><span class="o">.</span><span class="n">getRegister</span><span class="p">(</span><span class="n">AddrReg</span><span class="p">,</span> <span class="n">getPointerTy</span><span class="p">(</span><span class="n">MF</span><span class="o">.</span><span class="n">getDataLayout</span><span class="p">())),</span>
                     <span class="n">Chain</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">lowerADD</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Op</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">getOpcode</span><span class="p">()</span> <span class="o">!=</span> <span class="n">ISD</span><span class="p">::</span><span class="n">FRAMEADDR</span>
      <span class="o">||</span> <span class="n">cast</span><span class="o">&lt;</span><span class="n">ConstantSDNode</span><span class="o">&gt;</span>
        <span class="p">(</span><span class="n">Op</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">getZExtValue</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span>
      <span class="o">||</span> <span class="n">Op</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">getOpcode</span><span class="p">()</span> <span class="o">!=</span> <span class="n">ISD</span><span class="p">::</span><span class="n">FRAME_TO_ARGS_OFFSET</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">SDValue</span><span class="p">();</span>

  <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getMachineFunction</span><span class="p">();</span>
  <span class="n">Cpu0FunctionInfo</span> <span class="o">*</span><span class="n">Cpu0FI</span> <span class="o">=</span> <span class="n">MF</span><span class="o">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">setCallsEhDwarf</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">Op</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<section id="frameaddress-and-returnaddress-intrinsics">
<h4><a class="toc-backref" href="#id50" role="doc-backlink">frameaddress and returnaddress intrinsics</a><a class="headerlink" href="#frameaddress-and-returnaddress-intrinsics" title="Permalink to this heading">¶</a></h4>
<p>Run the following input to get the corresponding result.</p>
<p class="rubric">lbdex/input/ch9_3_frame_return_addr.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">display_frameaddress</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="n">__builtin_frame_address</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">extern</span> <span class="nb">int</span> <span class="n">fn</span><span class="p">();</span>

<span class="nb">int</span> <span class="n">display_returnaddress</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">fn</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>~/llvm/test/build/bin/
<span class="go">llvm-dis ch9_3_frame_return_addr.bc -o -</span>
<span class="go">...</span>
<span class="go">; Function Attrs: nounwind</span>
<span class="go">define i32 @_Z20display_frameaddressv() #0 {</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> call i8* @llvm.frameaddress<span class="o">(</span>i32 <span class="m">0</span><span class="o">)</span>
<span class="gp">  %</span><span class="nv">2</span> <span class="o">=</span> ptrtoint i8* %1 to i32
<span class="go">  ret i32 %2</span>
<span class="go">}</span>

<span class="go">; Function Attrs: nounwind readnone</span>
<span class="go">declare i8* @llvm.frameaddress(i32) #1</span>

<span class="go">define i32 @_Z22display_returnaddressv() #2 {</span>
<span class="gp">  %</span><span class="nv">a</span> <span class="o">=</span> alloca i32, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> call i8* @llvm.returnaddress<span class="o">(</span>i32 <span class="m">0</span><span class="o">)</span>
<span class="gp">  %</span><span class="nv">2</span> <span class="o">=</span> ptrtoint i8* %1 to i32
<span class="go">  store i32 %2, i32* %a, align 4</span>
<span class="gp">  %</span><span class="nv">3</span> <span class="o">=</span> call i32 @_Z2fnv<span class="o">()</span>
<span class="gp">  %</span><span class="nv">4</span> <span class="o">=</span> load i32, i32* %a, align <span class="m">4</span>
<span class="go">  ret i32 %4</span>
<span class="go">}</span>

<span class="gp">JonathantekiiMac:input Jonathan$ </span>~/llvm/test/build/bin/llc
<span class="go">-march=cpu0 -relocation-model=static -filetype=asm ch9_3_frame_return_addr.bc</span>
<span class="go">-o -</span>
<span class="go">      .text</span>
<span class="go">      .section .mdebug.abiO32</span>
<span class="go">      .previous</span>
<span class="go">      .file &quot;ch9_3_frame_return_addr.bc&quot;</span>
<span class="go">      .globl  _Z20display_frameaddressv</span>
<span class="go">      .align  2</span>
<span class="go">      .type _Z20display_frameaddressv,@function</span>
<span class="go">      .ent    _Z20display_frameaddressv # @_Z20display_frameaddressv</span>
<span class="go">_Z20display_frameaddressv:</span>
<span class="go">      .frame  $fp,8,$lr</span>
<span class="go">      .mask           0x00001000,-4</span>
<span class="go">      .set    noreorder</span>
<span class="go">      .set    nomacro</span>
<span class="gp"># </span>BB#0:
<span class="go">      addiu $sp, $sp, -8</span>
<span class="go">      st      $fp, 4($sp)                                                     # 4-byte Folded Spill</span>
<span class="go">      move     $fp, $sp</span>
<span class="go">      addu    $2, $zero, $fp</span>
<span class="go">      move     $sp, $fp</span>
<span class="go">      ld      $fp, 4($sp)                                                     # 4-byte Folded Reload</span>
<span class="go">      addiu $sp, $sp, 8</span>
<span class="go">      ret $lr</span>
<span class="go">      nop</span>
<span class="go">      .set    macro</span>
<span class="go">      .set    reorder</span>
<span class="go">      .end    _Z20display_frameaddressv</span>
<span class="gp">$</span>func_end0:
<span class="go">      .size _Z20display_frameaddressv, ($func_end0)-_Z20display_frameaddressv</span>

<span class="go">      .globl  _Z22display_returnaddress1v</span>
<span class="go">      .align  2</span>
<span class="go">      .type _Z22display_returnaddress1v,@function</span>
<span class="go">      .ent    _Z22display_returnaddress1v # @_Z22display_returnaddress1v</span>
<span class="go">_Z22display_returnaddress1v:</span>
<span class="go">      .cfi_startproc</span>
<span class="go">      .frame  $fp,24,$lr</span>
<span class="go">      .mask           0x00005000,-4</span>
<span class="go">      .set    noreorder</span>
<span class="go">      .set    nomacro</span>
<span class="gp"># </span>BB#0:
<span class="go">      addiu $sp, $sp, -24</span>
<span class="gp">$</span>tmp0:
<span class="go">      .cfi_def_cfa_offset 24</span>
<span class="go">      st      $lr, 20($sp)                                            # 4-byte Folded Spill</span>
<span class="go">      st      $fp, 16($sp)                                            # 4-byte Folded Spill</span>
<span class="gp">$</span>tmp1:
<span class="go">      .cfi_offset 14, -4</span>
<span class="gp">$</span>tmp2:
<span class="go">      .cfi_offset 12, -8</span>
<span class="go">      move     $fp, $sp</span>
<span class="gp">$</span>tmp3:
<span class="go">      .cfi_def_cfa_register 12</span>
<span class="go">      st      $lr, 12($fp)</span>
<span class="go">      jsub    _Z2fnv</span>
<span class="go">      nop</span>
<span class="go">      ld      $2, 12($fp)</span>
<span class="go">      move     $sp, $fp</span>
<span class="go">      ld      $fp, 16($sp)                                            # 4-byte Folded Reload</span>
<span class="go">      ld      $lr, 20($sp)                                            # 4-byte Folded Reload</span>
<span class="go">      addiu $sp, $sp, 24</span>
<span class="go">      ret $lr</span>
<span class="go">      nop</span>
<span class="go">      .set    macro</span>
<span class="go">      .set    reorder</span>
<span class="go">      .end    _Z22display_returnaddress1v</span>
<span class="gp">$</span>func_end1:
<span class="go">      .size _Z22display_returnaddress1v, ($func_end1)-_Z22display_returnaddress1v</span>
<span class="go">      .cfi_endproc</span>
</pre></div>
</div>
<p>The asm <code class="docutils literal notranslate"><span class="pre">ld</span>&#160;&#160;&#160;&#160; <span class="pre">$2,</span> <span class="pre">12($fp)</span></code> in function <code class="docutils literal notranslate"><span class="pre">_Z22display_returnaddress1v</span></code>
reloads <code class="docutils literal notranslate"><span class="pre">$lr</span></code> to <code class="docutils literal notranslate"><span class="pre">$2</span></code> after <code class="docutils literal notranslate"><span class="pre">jsub</span> <span class="pre">_Z3fnv</span></code>. The reason that Cpu0 doesn’t
produce <code class="docutils literal notranslate"><span class="pre">addiu</span> <span class="pre">$2,</span> <span class="pre">$zero,</span> <span class="pre">$lr</span></code> is that, if a buggy program in <code class="docutils literal notranslate"><span class="pre">_Z3fnv</span></code>
modifies the <code class="docutils literal notranslate"><span class="pre">$lr</span></code> value without following the ABI, then it will load an
incorrect <code class="docutils literal notranslate"><span class="pre">$lr</span></code> into <code class="docutils literal notranslate"><span class="pre">$2</span></code>.</p>
<p>The following code kills the <code class="docutils literal notranslate"><span class="pre">$lr</span></code> register and makes the reference to <code class="docutils literal notranslate"><span class="pre">$lr</span></code>
by loading from a stack slot rather than using the register directly.</p>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0SEFrameLowering.cpp</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">Cpu0SEFrameLowering</span><span class="o">::</span><span class="w"></span>
<span class="nf">spillCalleeSavedRegisters</span><span class="p">(</span><span class="n">MachineBasicBlock</span><span class="w"> </span><span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span><span class="w"> </span><span class="n">MI</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">CalleeSavedInfo</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">CSI</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="k">const</span><span class="w"> </span><span class="n">TargetRegisterInfo</span><span class="w"> </span><span class="o">*</span><span class="n">TRI</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CSI</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">e</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Add the callee-saved register as live-in. Do not add if the register is</span>
<span class="w">    </span><span class="c1">// LR and return address is taken, because it has already been added in</span>
<span class="w">    </span><span class="c1">// method Cpu0TargetLowering::LowerRETURNADDR.</span>
<span class="w">    </span><span class="c1">// It&#39;s killed at the spill, unless the register is LR and return address</span>
<span class="w">    </span><span class="c1">// is taken.</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">Reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CSI</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getReg</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">IsRAAndRetAddrIsTaken</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Reg</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Cpu0</span><span class="o">::</span><span class="n">LR</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">MF</span><span class="o">-&gt;</span><span class="n">getFrameInfo</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">isReturnAddressTaken</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">IsRAAndRetAddrIsTaken</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">EntryBlock</span><span class="o">-&gt;</span><span class="n">addLiveIn</span><span class="p">(</span><span class="n">Reg</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Insert the spill to the stack frame.</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">IsKill</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">!</span><span class="n">IsRAAndRetAddrIsTaken</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">TargetRegisterClass</span><span class="w"> </span><span class="o">*</span><span class="n">RC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TRI</span><span class="o">-&gt;</span><span class="n">getMinimalPhysRegClass</span><span class="p">(</span><span class="n">Reg</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">TII</span><span class="p">.</span><span class="n">storeRegToStackSlot</span><span class="p">(</span><span class="o">*</span><span class="n">EntryBlock</span><span class="p">,</span><span class="w"> </span><span class="n">MI</span><span class="p">,</span><span class="w"> </span><span class="n">Reg</span><span class="p">,</span><span class="w"> </span><span class="n">IsKill</span><span class="p">,</span><span class="w"></span>
<span class="w">                            </span><span class="n">CSI</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getFrameIdx</span><span class="p">(),</span><span class="w"> </span><span class="n">RC</span><span class="p">,</span><span class="w"> </span><span class="n">TRI</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="eh-return-intrinsic">
<h4><a class="toc-backref" href="#id51" role="doc-backlink">eh.return intrinsic</a><a class="headerlink" href="#eh-return-intrinsic" title="Permalink to this heading">¶</a></h4>
<p>Considering the following code,</p>
<p class="rubric">unwind example</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">A</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">func</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">catch</span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">B</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">func</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">A</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">catch</span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>When B() -&gt; calls func() -&gt; exception occurs, the frame is unwound to B and
handled by B’s exception handler. When B() -&gt; calls A() -&gt; calls func() -&gt;
exception occurs, the frame is unwound to A and handled by A’s exception
handler.</p>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_eh_return(offset,</span> <span class="pre">handler)</span></code> adjusts the stack by the given offset
and then jumps to the handler. <code class="docutils literal notranslate"><span class="pre">__builtin_eh_return</span></code> is used in the GCC
unwinder (libgcc), but not in the LLVM unwinder (libunwind) <a class="footnote-reference brackets" href="#ehreturn" id="id15" role="doc-noteref"><span class="fn-bracket">[</span>13<span class="fn-bracket">]</span></a>.</p>
<p>Besides <code class="docutils literal notranslate"><span class="pre">lowerRETURNADDR()</span></code> in <code class="docutils literal notranslate"><span class="pre">Cpu0ISelLowering</span></code>, the following code is
only for <code class="docutils literal notranslate"><span class="pre">eh.return</span></code> support. It can run with the input
<code class="docutils literal notranslate"><span class="pre">ch9_3_detect_exception.cpp</span></code> as shown below.</p>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0SEFrameLowering.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">Cpu0SEFrameLowering</span><span class="p">::</span><span class="n">emitPrologue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                       <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  if (Cpu0FI-&gt;callsEhReturn()) {
    // Insert instructions that spill eh data registers.
    for (int I = 0; I &lt; ABI.EhDataRegSize(); ++I) {
      if (!MBB.isLiveIn(ABI.GetEhDataReg(I)))
        MBB.addLiveIn(ABI.GetEhDataReg(I));
      TII.storeRegToStackSlot(MBB, MBBI, ABI.GetEhDataReg(I), false,
                              Cpu0FI-&gt;getEhDataRegFI(I), RC, &amp;RegInfo);
    }

    // Emit .cfi_offset directives for eh data registers.
    for (int I = 0; I &lt; ABI.EhDataRegSize(); ++I) {
      int64_t Offset = MFI.getObjectOffset(Cpu0FI-&gt;getEhDataRegFI(I));
      unsigned Reg = MRI-&gt;getDwarfRegNum(ABI.GetEhDataReg(I), true);
      unsigned CFIIndex = MF.addFrameInst(
          MCCFIInstruction::createOffset(nullptr, Reg, Offset));
      BuildMI(MBB, MBBI, dl, TII.get(TargetOpcode::CFI_INSTRUCTION))
          .addCFIIndex(CFIIndex);
    }
  }
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">Cpu0SEFrameLowering</span><span class="p">::</span><span class="n">emitEpilogue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                 <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">callsEhReturn</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span><span class="n">RC</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Cpu0</span><span class="p">::</span><span class="n">GPROutRegClass</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Find</span> <span class="n">first</span> <span class="n">instruction</span> <span class="n">that</span> <span class="n">restores</span> <span class="n">a</span> <span class="n">callee</span><span class="o">-</span><span class="n">saved</span> <span class="n">register</span><span class="o">.</span>
    <span class="n">MachineBasicBlock</span><span class="p">::</span><span class="n">iterator</span> <span class="n">I</span> <span class="o">=</span> <span class="n">MBBI</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MFI</span><span class="o">.</span><span class="n">getCalleeSavedInfo</span><span class="p">()</span><span class="o">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
      <span class="o">--</span><span class="n">I</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Insert</span> <span class="n">instructions</span> <span class="n">that</span> <span class="n">restore</span> <span class="n">eh</span> <span class="n">data</span> <span class="n">registers</span><span class="o">.</span>
    <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">J</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">J</span> <span class="o">&lt;</span> <span class="n">ABI</span><span class="o">.</span><span class="n">EhDataRegSize</span><span class="p">();</span> <span class="o">++</span><span class="n">J</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">TII</span><span class="o">.</span><span class="n">loadRegFromStackSlot</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">ABI</span><span class="o">.</span><span class="n">GetEhDataReg</span><span class="p">(</span><span class="n">J</span><span class="p">),</span>
                               <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getEhDataRegFI</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="n">RC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">RegInfo</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">This</span> <span class="n">method</span> <span class="ow">is</span> <span class="n">called</span> <span class="n">immediately</span> <span class="n">before</span> <span class="n">PrologEpilogInserter</span> <span class="n">scans</span> <span class="n">the</span> 
<span class="o">//</span>  <span class="n">physical</span> <span class="n">registers</span> <span class="n">used</span> <span class="n">to</span> <span class="n">determine</span> <span class="n">what</span> <span class="n">callee</span> <span class="n">saved</span> <span class="n">registers</span> <span class="n">should</span> <span class="n">be</span> 
<span class="o">//</span>  <span class="n">spilled</span><span class="o">.</span> <span class="n">This</span> <span class="n">method</span> <span class="ow">is</span> <span class="n">optional</span><span class="o">.</span> 
<span class="n">void</span> <span class="n">Cpu0SEFrameLowering</span><span class="p">::</span><span class="n">determineCalleeSaves</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                               <span class="n">BitVector</span> <span class="o">&amp;</span><span class="n">SavedRegs</span><span class="p">,</span>
                                               <span class="n">RegScavenger</span> <span class="o">*</span><span class="n">RS</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="o">//</span> <span class="n">Create</span> <span class="n">spill</span> <span class="n">slots</span> <span class="k">for</span> <span class="n">eh</span> <span class="n">data</span> <span class="n">registers</span> <span class="k">if</span> <span class="n">function</span> <span class="n">calls</span> <span class="n">eh_return</span><span class="o">.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">callsEhReturn</span><span class="p">())</span>
    <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">createEhDataRegsFI</span><span class="p">();</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0InstrInfo.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// Exception handling related node and instructions.
// The conversion sequence is:
// ISD::EH_RETURN -&gt; Cpu0ISD::EH_RETURN -&gt;
// CPU0eh_return -&gt; (stack change + indirect branch)
//
// CPU0eh_return takes the place of regular return instruction
// but takes two arguments (V1, V0) which are used for storing
// the offset and return address respectively.
def SDT_Cpu0EHRET : SDTypeProfile&lt;0, 2, [SDTCisInt&lt;0&gt;, SDTCisPtrTy&lt;1&gt;]&gt;;

def CPU0ehret : SDNode&lt;&quot;Cpu0ISD::EH_RETURN&quot;, SDT_Cpu0EHRET,
                      [SDNPHasChain, SDNPOptInGlue, SDNPVariadic]&gt;;

let Uses = [V0, V1], isTerminator = 1, isReturn = 1, isBarrier = 1 in {
  def CPU0eh_return32 : Cpu0Pseudo&lt;(outs), (ins GPROut:$spoff, GPROut:$dst), &quot;&quot;,
                                [(CPU0ehret GPROut:$spoff, GPROut:$dst)]&gt;;
}
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0SEInstrInfo.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">void</span> <span class="n">expandEhReturn</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span>
                      <span class="n">MachineBasicBlock</span><span class="p">::</span><span class="n">iterator</span> <span class="n">I</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0SEInstrInfo.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">///</span> <span class="n">Expand</span> <span class="n">Pseudo</span> <span class="n">instructions</span> <span class="n">into</span> <span class="n">real</span> <span class="n">backend</span> <span class="n">instructions</span>
<span class="nb">bool</span> <span class="n">Cpu0SEInstrInfo</span><span class="p">::</span><span class="n">expandPostRAPseudo</span><span class="p">(</span><span class="n">MachineInstr</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">case</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">CPU0eh_return32</span><span class="p">:</span>
    <span class="n">expandEhReturn</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MI</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>void Cpu0SEInstrInfo::expandEhReturn(MachineBasicBlock &amp;MBB,
                                     MachineBasicBlock::iterator I) const {
  // This pseudo instruction is generated as part of the lowering of
  // ISD::EH_RETURN. We convert it to a stack increment by OffsetReg, and
  // indirect jump to TargetReg
  unsigned ADDU = Cpu0::ADDu;
  unsigned SP = Cpu0::SP;
  unsigned LR = Cpu0::LR;
  unsigned T9 = Cpu0::T9;
  unsigned ZERO = Cpu0::ZERO;
  unsigned OffsetReg = I-&gt;getOperand(0).getReg();
  unsigned TargetReg = I-&gt;getOperand(1).getReg();

  // addu $lr, $v0, $zero
  // addu $sp, $sp, $v1
  // jr   $lr (via RetLR)
  const TargetMachine &amp;TM = MBB.getParent()-&gt;getTarget();
  if (TM.isPositionIndependent())
    BuildMI(MBB, I, I-&gt;getDebugLoc(), get(ADDU), T9)
        .addReg(TargetReg)
        .addReg(ZERO);
  BuildMI(MBB, I, I-&gt;getDebugLoc(), get(ADDU), LR)
      .addReg(TargetReg)
      .addReg(ZERO);
  BuildMI(MBB, I, I-&gt;getDebugLoc(), get(ADDU), SP).addReg(SP).addReg(OffsetReg);
  expandRetLR(MBB, I);
}
</pre></div>
</div>
<p class="rubric">lbdex/input/ch9_3_detect_exception.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">bool</span> <span class="n">exceptionOccur</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
<span class="n">void</span><span class="o">*</span> <span class="n">returnAddr</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Even</span> <span class="n">though</span> <span class="n">__builtin_frame_address</span> <span class="ow">is</span> <span class="n">useless</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">example</span><span class="p">,</span> <span class="n">I</span> <span class="n">believe</span>
<span class="o">//</span> <span class="n">it</span> <span class="n">will</span> <span class="n">be</span> <span class="n">used</span> <span class="ow">in</span> <span class="n">real</span> <span class="n">exception</span> <span class="n">handler</span> <span class="n">implementation</span><span class="o">.</span> <span class="n">Because</span> <span class="ow">in</span> <span class="n">real</span>
<span class="o">//</span> <span class="n">implementation</span><span class="p">,</span> <span class="n">the</span> <span class="n">exception</span> <span class="n">handler</span> <span class="n">keeps</span> <span class="n">a</span> <span class="n">table</span> <span class="ow">and</span> <span class="n">decide</span> <span class="n">which</span> <span class="n">function</span>
<span class="o">//</span> <span class="n">should</span> <span class="n">be</span> <span class="n">triggered</span> <span class="k">for</span> <span class="n">a</span> <span class="n">specific</span> <span class="n">exception</span> <span class="ow">and</span> <span class="n">hand</span> <span class="n">over</span> <span class="n">to</span> <span class="n">it</span><span class="o">.</span>
<span class="o">//</span> <span class="n">The</span> <span class="n">hand</span> <span class="n">over</span> <span class="n">process</span> <span class="n">needs</span> <span class="n">unwinding</span> <span class="n">the</span> <span class="n">stack</span> <span class="n">frame</span><span class="o">.</span> <span class="n">The</span> <span class="n">stack</span> <span class="n">frame</span> <span class="n">address</span>
<span class="o">//</span> <span class="n">can</span> <span class="n">be</span> <span class="n">gotten</span> <span class="n">by</span> <span class="n">calling</span> <span class="n">__builtin_frame_address</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">charged</span> <span class="n">function</span><span class="o">.</span>
<span class="n">void</span> <span class="n">exception_handler</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">exceptionOccur</span> <span class="o">=</span> <span class="n">true</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">frameaddr</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="n">__builtin_frame_address</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">__builtin_eh_return</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">returnAddr</span><span class="p">);</span> <span class="o">//</span> <span class="n">no</span> <span class="n">warning</span><span class="p">,</span> <span class="n">eh_return</span> <span class="n">never</span> <span class="n">returns</span><span class="o">.</span>
<span class="p">}</span>

<span class="n">__attribute__</span> <span class="p">((</span><span class="n">weak</span><span class="p">))</span> 
<span class="nb">int</span> <span class="n">test_detect_exception</span><span class="p">(</span><span class="nb">bool</span> <span class="n">exception</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">exceptionOccur</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">void</span><span class="o">*</span> <span class="n">handler</span> <span class="o">=</span> <span class="p">(</span><span class="n">void</span><span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">exception_handler</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">exception</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">returnAddr</span> <span class="o">=</span> <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">__builtin_eh_return</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">handler</span><span class="p">);</span> <span class="o">//</span> <span class="n">no</span> <span class="n">warning</span><span class="p">,</span> <span class="n">eh_return</span> <span class="n">never</span> <span class="n">returns</span><span class="o">.</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">114-37-150-48:input Jonathan$ </span>clang -target mips-unknown-linux-gnu -c
<span class="go">ch9_3_detect_exception.cpp -emit-llvm -o ch9_3_detect_exception.bc</span>
<span class="gp">114-37-150-48:input Jonathan$ </span>~/llvm/test/build/bin/llvm-dis
<span class="go">ch9_3_detect_exception.bc -o -</span>
<span class="go">; ModuleID = &#39;ch9_3_detect_exception.bc&#39;</span>
<span class="go">target datalayout = &quot;E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64&quot;</span>
<span class="go">target triple = &quot;mips-unknown-linux-gnu&quot;</span>

<span class="go">@exceptionOccur = global i8 0, align 1</span>
<span class="go">@returnAddr = global i8* null, align 4</span>

<span class="go">; Function Attrs: nounwind</span>
<span class="go">define void @_Z17exception_handlerv() #0 {</span>
<span class="gp">  %</span><span class="nv">frameaddr</span> <span class="o">=</span> alloca i32, align <span class="m">4</span>
<span class="go">  store i8 1, i8* @exceptionOccur, align 1</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> call i8* @llvm.frameaddress<span class="o">(</span>i32 <span class="m">0</span><span class="o">)</span>
<span class="gp">  %</span><span class="nv">2</span> <span class="o">=</span> ptrtoint i8* %1 to i32
<span class="go">  store i32 %2, i32* %frameaddr, align 4</span>
<span class="gp">  %</span><span class="nv">3</span> <span class="o">=</span> load i8*, i8** @returnAddr, align <span class="m">4</span>
<span class="go">  call void @llvm.eh.return.i32(i32 0, i8* %3)</span>
<span class="go">  unreachable</span>
<span class="go">                                                  ; No predecessors!</span>
<span class="go">  ret void</span>
<span class="go">}</span>

<span class="go">; Function Attrs: nounwind readnone</span>
<span class="go">declare i8* @llvm.frameaddress(i32) #1</span>

<span class="go">; Function Attrs: nounwind</span>
<span class="go">declare void @llvm.eh.return.i32(i32, i8*) #2</span>

<span class="go">define weak i32 @_Z21test_detect_exceptionb(i1 zeroext %exception) #3 {</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> alloca i8, align <span class="m">1</span>
<span class="gp">  %</span><span class="nv">handler</span> <span class="o">=</span> alloca i8*, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">2</span> <span class="o">=</span> zext i1 %exception to i8
<span class="go">  store i8 %2, i8* %1, align 1</span>
<span class="go">  store i8 0, i8* @exceptionOccur, align 1</span>
<span class="go">  store i8* bitcast (void ()* @_Z17exception_handlerv to i8*), i8** %handler, align 4</span>
<span class="gp">  %</span><span class="nv">3</span> <span class="o">=</span> load i8, i8* %1, align <span class="m">1</span>
<span class="gp">  %</span><span class="nv">4</span> <span class="o">=</span> trunc i8 %3 to i1
<span class="go">  br i1 %4, label %5, label %8</span>

<span class="go">; &lt;label&gt;:5                                       ; preds = %0</span>
<span class="gp">  %</span><span class="nv">6</span> <span class="o">=</span> call i8* @llvm.returnaddress<span class="o">(</span>i32 <span class="m">0</span><span class="o">)</span>
<span class="go">  store i8* %6, i8** @returnAddr, align 4</span>
<span class="gp">  %</span><span class="nv">7</span> <span class="o">=</span> load i8*, i8** %handler, align <span class="m">4</span>
<span class="go">  call void @llvm.eh.return.i32(i32 0, i8* %7)</span>
<span class="go">  unreachable</span>

<span class="go">; &lt;label&gt;:8                                       ; preds = %0</span>
<span class="go">  ret i32 0</span>
<span class="go">}</span>

<span class="go">; Function Attrs: nounwind readnone</span>
<span class="go">declare i8* @llvm.returnaddress(i32) #1</span>

<span class="go">attributes #0 = { nounwind ... }</span>
<span class="go">attributes #1 = { nounwind readnone }</span>
<span class="go">attributes #2 = { nounwind }</span>
<span class="go">attributes #3 = { &quot;less-precise-fpmad&quot;=&quot;false&quot; ... }</span>
<span class="go">...</span>

<span class="gp">114-37-150-48:input Jonathan$ </span>~/llvm/test/build/bin/llc
<span class="go">-march=cpu0 -mcpu=cpu032II -relocation-model=pic -filetype=asm</span>
<span class="go">ch9_3_detect_exception.bc -o -</span>
<span class="go">  .text</span>
<span class="go">  .section .mdebug.abiO32</span>
<span class="go">  .previous</span>
<span class="go">  .file &quot;ch9_3_detect_exception.bc&quot;</span>
<span class="go">  .globl  _Z17exception_handlerv</span>
<span class="go">  .align  2</span>
<span class="go">  .type _Z17exception_handlerv,@function</span>
<span class="go">  .ent  _Z17exception_handlerv  # @_Z17exception_handlerv</span>
<span class="go">_Z17exception_handlerv:</span>
<span class="go">  .frame  $fp,16,$lr</span>
<span class="go">  .mask   0x00001000,-4</span>
<span class="go">  .set  noreorder</span>
<span class="go">  .cpload $t9</span>
<span class="go">  .set  nomacro</span>
<span class="gp"># </span>BB#0:
<span class="go">  addiu $sp, $sp, -16</span>
<span class="go">  st  $fp, 12($sp)            # 4-byte Folded Spill</span>
<span class="go">  st  $4, 4($fp)</span>
<span class="go">  st  $5, 0($fp)</span>
<span class="go">  move   $fp, $sp</span>
<span class="go">  lui $2, %got_hi(exceptionOccur)</span>
<span class="go">  addu  $2, $2, $gp</span>
<span class="go">  ld  $2, %got_lo(exceptionOccur)($2)</span>
<span class="go">  addiu $3, $zero, 1</span>
<span class="go">  sb  $3, 0($2)</span>
<span class="go">  st  $fp, 8($fp)</span>
<span class="go">  lui $2, %got_hi(returnAddr)</span>
<span class="go">  addu  $2, $2, $gp</span>
<span class="go">  ld  $2, %got_lo(returnAddr)($2)</span>
<span class="go">  ld  $2, 0($2)</span>
<span class="go">  addiu $3, $zero, 0</span>
<span class="go">  move   $sp, $fp</span>
<span class="go">  ld  $4, 4($fp)</span>
<span class="go">  ld  $5, 0($fp)</span>
<span class="go">  ld  $fp, 12($sp)            # 4-byte Folded Reload</span>
<span class="go">  addiu $sp, $sp, 16</span>
<span class="go">  move   $t9, $2</span>
<span class="go">  move   $lr, $2</span>
<span class="go">  addu  $sp, $sp, $3</span>
<span class="go">  ret $lr</span>
<span class="go">  nop</span>
<span class="go">  .set  macro</span>
<span class="go">  .set  reorder</span>
<span class="go">  .end  _Z17exception_handlerv</span>
<span class="gp">$</span>func_end0:
<span class="go">  .size _Z17exception_handlerv, ($func_end0)-_Z17exception_handlerv</span>

<span class="go">  .weak _Z21test_detect_exceptionb</span>
<span class="go">  .align  2</span>
<span class="go">  .type _Z21test_detect_exceptionb,@function</span>
<span class="go">  .ent  _Z21test_detect_exceptionb # @_Z21test_detect_exceptionb</span>
<span class="go">_Z21test_detect_exceptionb:</span>
<span class="go">  .cfi_startproc</span>
<span class="go">  .frame  $fp,24,$lr</span>
<span class="go">  .mask   0x00001000,-4</span>
<span class="go">  .set  noreorder</span>
<span class="go">  .cpload $t9</span>
<span class="go">  .set  nomacro</span>
<span class="gp"># </span>BB#0:
<span class="go">  addiu $sp, $sp, -24</span>
<span class="gp">$</span>tmp0:
<span class="go">  .cfi_def_cfa_offset 24</span>
<span class="go">  st  $fp, 20($sp)            # 4-byte Folded Spill</span>
<span class="gp">$</span>tmp1:
<span class="go">  .cfi_offset 12, -4</span>
<span class="go">  st  $4, 8($fp)</span>
<span class="go">  st  $5, 4($fp)</span>
<span class="gp">$</span>tmp2:
<span class="go">  .cfi_offset 4, -16</span>
<span class="gp">$</span>tmp3:
<span class="go">  .cfi_offset 5, -20</span>
<span class="go">  move   $fp, $sp</span>
<span class="gp">$</span>tmp4:
<span class="go">  .cfi_def_cfa_register 12</span>
<span class="go">  sb  $4, 16($fp)</span>
<span class="go">  lui $2, %got_hi(exceptionOccur)</span>
<span class="go">  addu  $2, $2, $gp</span>
<span class="go">  ld  $2, %got_lo(exceptionOccur)($2)</span>
<span class="go">  addiu $3, $zero, 0</span>
<span class="go">  sb  $3, 0($2)</span>
<span class="go">  lui $2, %got_hi(_Z17exception_handlerv)</span>
<span class="go">  addu  $2, $2, $gp</span>
<span class="go">  ld  $2, %got_lo(_Z17exception_handlerv)($2)</span>
<span class="go">  st  $2, 12($fp)</span>
<span class="go">  lbu $2, 16($fp)</span>
<span class="go">  andi  $2, $2, 1</span>
<span class="go">  beq $2, $zero, .LBB1_2</span>
<span class="go">  nop</span>
<span class="go">  jmp .LBB1_1</span>
<span class="go">  nop</span>
<span class="go">.LBB1_2:</span>
<span class="go">  addiu $2, $zero, 0</span>
<span class="go">  move   $sp, $fp</span>
<span class="go">  ld  $4, 8($fp)</span>
<span class="go">  ld  $5, 4($fp)</span>
<span class="go">  ld  $fp, 20($sp)            # 4-byte Folded Reload</span>
<span class="go">  addiu $sp, $sp, 24</span>
<span class="go">  ret $lr</span>
<span class="go">  nop</span>
<span class="go">.LBB1_1:</span>
<span class="go">  lui $2, %got_hi(returnAddr)</span>
<span class="go">  addu  $2, $2, $gp</span>
<span class="go">  ld  $2, %got_lo(returnAddr)($2)</span>
<span class="go">  st  $lr, 0($2)</span>
<span class="go">  ld  $2, 12($fp)</span>
<span class="go">  addiu $3, $zero, 0</span>
<span class="go">  move   $sp, $fp</span>
<span class="go">  ld  $4, 8($fp)</span>
<span class="go">  ld  $5, 4($fp)</span>
<span class="go">  ld  $fp, 20($sp)            # 4-byte Folded Reload</span>
<span class="go">  addiu $sp, $sp, 24</span>
<span class="go">  move   $t9, $2</span>
<span class="go">  move   $lr, $2</span>
<span class="go">  addu  $sp, $sp, $3</span>
<span class="go">  ret $lr</span>
<span class="go">  nop</span>
<span class="go">  .set  macro</span>
<span class="go">  .set  reorder</span>
<span class="go">  .end  _Z21test_detect_exceptionb</span>
<span class="gp">$</span>func_end1:
<span class="go">  .size _Z21test_detect_exceptionb, ($func_end1)-_Z21test_detect_exceptionb</span>
<span class="go">  .cfi_endproc</span>

<span class="go">  .type exceptionOccur,@object  # @exceptionOccur</span>
<span class="go">  .bss</span>
<span class="go">  .globl  exceptionOccur</span>
<span class="go">exceptionOccur:</span>
<span class="go">  .byte 0                       # 0x0</span>
<span class="go">  .size exceptionOccur, 1</span>

<span class="go">  .type returnAddr,@object      # @returnAddr</span>
<span class="go">  .globl  returnAddr</span>
<span class="go">  .align  2</span>
<span class="go">returnAddr:</span>
<span class="go">  .4byte  0</span>
<span class="go">  .size returnAddr, 4</span>
<span class="go">  ...</span>
</pre></div>
</div>
<p>If you disable <code class="docutils literal notranslate"><span class="pre">__attribute__</span> <span class="pre">((weak))</span></code> in the C file, then the IR will have
<code class="docutils literal notranslate"><span class="pre">nounwind</span></code> in attributes #3. The side effect in the ASM output is that no
<code class="docutils literal notranslate"><span class="pre">.cfi_offset</span></code> is issued, as seen in the function <code class="docutils literal notranslate"><span class="pre">exception_handler()</span></code>.</p>
<p>This example code of exception handler implementation can get the frame,
return address, and call the exception handler by calling <code class="docutils literal notranslate"><span class="pre">__builtin_xxx</span></code>
in Clang using the C language, without introducing any assembly instruction.
This example can be verified in the chapter “Cpu0 ELF linker” of the other book
“LLVM Tool Chain for Cpu0” <a class="footnote-reference brackets" href="#cpu0lld" id="id16" role="doc-noteref"><span class="fn-bracket">[</span>14<span class="fn-bracket">]</span></a>.</p>
<p>By examining the global variable <code class="docutils literal notranslate"><span class="pre">exceptionOccur</span></code>, which is true or false,
the program will set the control flow to <code class="docutils literal notranslate"><span class="pre">exception_handler()</span></code> or skip it
accordingly.</p>
</section>
<section id="eh-dwarf-intrinsic">
<h4><a class="toc-backref" href="#id52" role="doc-backlink">eh.dwarf intrinsic</a><a class="headerlink" href="#eh-dwarf-intrinsic" title="Permalink to this heading">¶</a></h4>
<p>Besides <code class="docutils literal notranslate"><span class="pre">lowerADD()</span></code> in <code class="docutils literal notranslate"><span class="pre">Cpu0ISelLowering</span></code>, the following code is only
for supporting <code class="docutils literal notranslate"><span class="pre">eh.dwarf</span></code>. It can be run with the input <code class="docutils literal notranslate"><span class="pre">eh-dwarf-cfa.ll</span></code>
as shown below.</p>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0SEFrameLowering.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="o">//</span> <span class="k">if</span> <span class="n">framepointer</span> <span class="n">enabled</span><span class="p">,</span> <span class="nb">set</span> <span class="n">it</span> <span class="n">to</span> <span class="n">point</span> <span class="n">to</span> <span class="n">the</span> <span class="n">stack</span> <span class="n">pointer</span><span class="o">.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">hasFP</span><span class="p">(</span><span class="n">MF</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">callsEhDwarf</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MBBI</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">TII</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ADDu</span><span class="p">),</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">V0</span><span class="p">)</span><span class="o">.</span><span class="n">addReg</span><span class="p">(</span><span class="n">FP</span><span class="p">)</span><span class="o">.</span><span class="n">addReg</span><span class="p">(</span><span class="n">ZERO</span><span class="p">)</span>
        <span class="o">.</span><span class="n">setMIFlag</span><span class="p">(</span><span class="n">MachineInstr</span><span class="p">::</span><span class="n">FrameSetup</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/input/eh-dwarf-cfa.ll</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>; RUN: llc -march=cpu0el -mcpu=cpu032II &lt; %s | FileCheck %s

declare i8* @llvm.eh.dwarf.cfa(i32) nounwind
declare i8* @llvm.frameaddress(i32) nounwind readnone

define i8* @f1() nounwind {
entry:
  %x = alloca [32 x i8], align 1
  %0 = call i8* @llvm.eh.dwarf.cfa(i32 0)
  ret i8* %0

; CHECK:        addiu   $sp, $sp, -40
; CHECK:        addu    $2,  $zero, $fp
}


define i8* @f2() nounwind {
entry:
  %x = alloca [65536 x i8], align 1
  %0 = call i8* @llvm.eh.dwarf.cfa(i32 0)
  ret i8* %0

; check stack size (65536 + 8)
; CHECK:        lui     $[[R0:[a-z0-9]+]], 65535
; CHECK:        addiu   $[[R0]], $[[R0]], -8
; CHECK:        addu    $sp, $sp, $[[R0]]

; check return value ($sp + stack size)
; CHECK:        addu    $2,  $zero, $fp
}


define i32 @f3() nounwind {
entry:
  %x = alloca [32 x i8], align 1
  %0 = call i8* @llvm.eh.dwarf.cfa(i32 0)
  %1 = ptrtoint i8* %0 to i32
  %2 = call i8* @llvm.frameaddress(i32 0)
  %3 = ptrtoint i8* %2 to i32
  %add = add i32 %1, %3
  ret i32 %add

; CHECK:        addiu   $sp, $sp, -40

; check return value ($fp + stack size + $fp)
; CHECK:        move     $fp, $sp
; CHECK:        addu    $2, $fp, $fp
}

</pre></div>
</div>
</section>
<section id="bswap-intrinsic">
<h4><a class="toc-backref" href="#id53" role="doc-backlink">bswap intrinsic</a><a class="headerlink" href="#bswap-intrinsic" title="Permalink to this heading">¶</a></h4>
<p>Cpu0 supports the LLVM intrinsic <code class="docutils literal notranslate"><span class="pre">bswap</span></code> <a class="footnote-reference brackets" href="#bswapintrnsic" id="id17" role="doc-noteref"><span class="fn-bracket">[</span>15<span class="fn-bracket">]</span></a>.</p>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0ISelLowering.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="n">const</span> <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">,</span>
                                       <span class="n">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span>
    <span class="p">:</span> <span class="n">TargetLowering</span><span class="p">(</span><span class="n">TM</span><span class="p">),</span> <span class="n">Subtarget</span><span class="p">(</span><span class="n">STI</span><span class="p">),</span> <span class="n">ABI</span><span class="p">(</span><span class="n">TM</span><span class="o">.</span><span class="n">getABI</span><span class="p">())</span> <span class="p">{</span>

</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">BSWAP</span><span class="p">,</span> <span class="n">MVT</span><span class="p">::</span><span class="n">i32</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">BSWAP</span><span class="p">,</span> <span class="n">MVT</span><span class="p">::</span><span class="n">i64</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/input/ch9_3_bswap.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">test_bswap16</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">volatile</span> <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mh">0x1234</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">__builtin_bswap16</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">^</span> <span class="mh">0x3412</span><span class="p">);</span>
  
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">test_bswap32</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">volatile</span> <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mh">0x1234</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">__builtin_bswap32</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">^</span> <span class="mh">0x34120000</span><span class="p">);</span>
  
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">test_bswap64</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">volatile</span> <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mh">0x1234</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">__builtin_bswap64</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">^</span> <span class="mh">0x3412000000000000</span><span class="p">);</span>
  
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">test_bswap</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">test_bswap16</span><span class="p">()</span> <span class="o">+</span> <span class="n">test_bswap32</span><span class="p">()</span> <span class="o">+</span> <span class="n">test_bswap64</span><span class="p">();</span>
  
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">114-37-150-48:input Jonathan$ </span>clang -target mips-unknown-linux-gnu -c
<span class="go">ch9_3_bswap.cpp -emit-llvm -o ch9_3_bswap.bc</span>
<span class="gp">114-37-150-48:input Jonathan$ </span>~/llvm/test/build/bin/llvm-dis
<span class="go">ch9_3_bswap.bc -o -</span>
<span class="go">...</span>
<span class="go">define i32 @_Z12test_bswap16v() #0 {</span>
<span class="gp">  %</span><span class="nv">a</span> <span class="o">=</span> alloca i32, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">result</span> <span class="o">=</span> alloca i32, align <span class="m">4</span>
<span class="go">  store volatile i32 4660, i32* %a, align 4</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> load volatile i32, i32* %a, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">2</span> <span class="o">=</span> trunc i32 %1 to i16
<span class="gp">  %</span><span class="nv">3</span> <span class="o">=</span> call i16 @llvm.bswap.i16<span class="o">(</span>i16 %2<span class="o">)</span>
<span class="gp">  %</span><span class="nv">4</span> <span class="o">=</span> zext i16 %3 to i32
<span class="gp">  %</span><span class="nv">5</span> <span class="o">=</span> xor i32 %4, <span class="m">13330</span>
<span class="go">  store i32 %5, i32* %result, align 4</span>
<span class="gp">  %</span><span class="nv">6</span> <span class="o">=</span> load i32, i32* %result, align <span class="m">4</span>
<span class="go">  ret i32 %6</span>
<span class="go">}</span>
<span class="go">...</span>
</pre></div>
</div>
</section>
</section>
<section id="add-specific-backend-intrinsic-function">
<h3><a class="toc-backref" href="#id54" role="doc-backlink">Add specific backend intrinsic function</a><a class="headerlink" href="#add-specific-backend-intrinsic-function" title="Permalink to this heading">¶</a></h3>
<p>LLVM intrinsic functions are designed to extend LLVM IRs for hardware
acceleration in compiler design <a class="footnote-reference brackets" href="#extendintrnsic" id="id18" role="doc-noteref"><span class="fn-bracket">[</span>16<span class="fn-bracket">]</span></a>.
Many CPUs implement their own intrinsic functions for hardware-specific
instructions that improve performance.</p>
<p>Some GPUs use the LLVM infrastructure as their OpenGL/OpenCL backend compiler
and rely on many LLVM-extended intrinsic functions.</p>
<p>To demonstrate how to use backend proprietary intrinsic functions to support
specific instructions for performance improvement in domain-specific languages,
Cpu0 adds an intrinsic function <code class="docutils literal notranslate"><span class="pre">&#64;llvm.cpu0.gcd</span></code> for its
greatest common divisor (GCD) instruction.</p>
<p>This instruction demonstrates how to implement a custom intrinsic in LLVM;
however, it is not implemented in the Verilog Cpu0 hardware.</p>
<p>The code is as follows,</p>
<p class="rubric">lbdex/llvm/modify/llvm/include/llvm/IR/Intrinsics.td</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">...</span><span class="w"></span>
<span class="n">include</span><span class="w"> </span><span class="s">&quot;llvm/IR/IntrinsicsCpu0.td&quot;</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/llvm/modify/llvm/include/llvm/IR/IntrinsicsCpu0.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//===-</span> <span class="n">IntrinsicsCpu0</span><span class="o">.</span><span class="n">td</span> <span class="o">-</span> <span class="n">Defines</span> <span class="n">Mips</span> <span class="n">intrinsics</span> <span class="o">---------*-</span> <span class="n">tablegen</span> <span class="o">-*-===//</span>
<span class="o">//</span>
<span class="o">//</span>                     <span class="n">The</span> <span class="n">LLVM</span> <span class="n">Compiler</span> <span class="n">Infrastructure</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">This</span> <span class="n">file</span> <span class="ow">is</span> <span class="n">distributed</span> <span class="n">under</span> <span class="n">the</span> <span class="n">University</span> <span class="n">of</span> <span class="n">Illinois</span> <span class="n">Open</span> <span class="n">Source</span>
<span class="o">//</span> <span class="n">License</span><span class="o">.</span> <span class="n">See</span> <span class="n">LICENSE</span><span class="o">.</span><span class="n">TXT</span> <span class="k">for</span> <span class="n">details</span><span class="o">.</span>
<span class="o">//</span>
<span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">This</span> <span class="n">file</span> <span class="n">defines</span> <span class="nb">all</span> <span class="n">of</span> <span class="n">the</span> <span class="n">CPU0</span><span class="o">-</span><span class="n">specific</span> <span class="n">intrinsics</span><span class="o">.</span>
<span class="o">//</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="o">//</span> <span class="n">__builtin_cpu0_gcd</span> <span class="n">defined</span> <span class="ow">in</span>
<span class="o">//</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">Jonathan2251</span><span class="o">/</span><span class="n">lbt</span><span class="o">/</span><span class="n">blob</span><span class="o">/</span><span class="n">master</span><span class="o">/</span><span class="n">exlbt</span><span class="o">/</span><span class="n">clang</span><span class="o">/</span><span class="n">include</span><span class="o">/</span><span class="n">clang</span><span class="o">/</span><span class="n">Basic</span><span class="o">/</span><span class="n">BuiltinsCpu0</span><span class="o">.</span><span class="k">def</span>
<span class="nf">def</span> <span class="n">int_cpu0_gcd</span> <span class="p">:</span> <span class="n">GCCBuiltin</span><span class="o">&lt;</span><span class="s2">&quot;__builtin_cpu0_gcd&quot;</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">Intrinsic</span><span class="o">&lt;</span><span class="p">[</span><span class="n">llvm_i32_ty</span><span class="p">],</span> <span class="p">[</span><span class="n">llvm_i32_ty</span><span class="p">,</span> <span class="n">llvm_i32_ty</span><span class="p">],</span>
  <span class="p">[</span><span class="n">Commutative</span><span class="p">,</span> <span class="n">IntrNoMem</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0InstrInfo.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>class IntrinArithLogicR&lt;bits&lt;8&gt; op, string instr_asm, SDPatternOperator OpNode,
                  InstrItinClass itin, RegisterClass RC, bit isComm = 0&gt;:
  FA&lt;op, (outs GPROut:$ra), (ins RC:$rb, RC:$rc),
     !strconcat(instr_asm, &quot;\t$ra, $rb, $rc&quot;),
     [(set GPROut:$ra, (OpNode RC:$rb, RC:$rc))], itin&gt; {
  let shamt = 0;
  let isCommutable = isComm;	// e.g. add rb rc =  add rc rb
  let isReMaterializable = 1;
}
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">GCD</span> <span class="p">:</span> <span class="n">IntrinArithLogicR</span><span class="o">&lt;</span><span class="mh">0x60</span><span class="p">,</span> <span class="s2">&quot;gcd&quot;</span><span class="p">,</span> <span class="n">int_cpu0_gcd</span><span class="p">,</span> <span class="n">IIAlu</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>When running <code class="docutils literal notranslate"><span class="pre">llc</span></code> with <code class="docutils literal notranslate"><span class="pre">cpu0_gcd.ll</span></code>, it generates the <code class="docutils literal notranslate"><span class="pre">gcd</span></code> machine
instruction. Meanwhile, running <code class="docutils literal notranslate"><span class="pre">cpu0_gcd_soft.ll</span></code> results in a call to the
<code class="docutils literal notranslate"><span class="pre">cpu0_gcd_soft</span></code> function.</p>
<p>In other words, <code class="docutils literal notranslate"><span class="pre">&#64;llvm.cpu0.gcd</span></code> is an intrinsic function mapped to the <code class="docutils literal notranslate"><span class="pre">gcd</span></code>
machine instruction, while <code class="docutils literal notranslate"><span class="pre">&#64;cpu0_gcd_soft</span></code> is a regular function implemented
in software.</p>
<p>For undefined intrinsic functions in Cpu0, such as <code class="docutils literal notranslate"><span class="pre">fmul</span> <span class="pre">float</span> <span class="pre">%0,</span> <span class="pre">%1</span></code>, LLVM
will compile them into function calls like <code class="docutils literal notranslate"><span class="pre">jsub</span> <span class="pre">fmul</span></code> for Cpu0
<a class="footnote-reference brackets" href="#lbd-fmul" id="id19" role="doc-noteref"><span class="fn-bracket">[</span>17<span class="fn-bracket">]</span></a>.</p>
<p>The file <code class="docutils literal notranslate"><span class="pre">test_memcpy.ll</span></code> is an example of an <code class="docutils literal notranslate"><span class="pre">IntrWriteMem</span></code> instruction,
which prevents the operation from being optimized out.</p>
</section>
</section>
<section id="summary">
<h2><a class="toc-backref" href="#id55" role="doc-backlink">Summary</a><a class="headerlink" href="#summary" title="Permalink to this heading">¶</a></h2>
<p>Now, the Cpu0 backend can handle both integer function calls and control
statements, similar to the example code in the LLVM frontend tutorial.</p>
<p>It can also translate some of the C++ object-oriented programming language into
Cpu0 instructions without much additional backend effort, because the frontend
handles most of the complexity for meeting C++ requirement.</p>
<p>LLVM is a well-structured system that follows compiler theory closely. Any
backend of LLVM benefits from this structure.</p>
<p>The best part of the three-tier compiler architecture is that backends will
automatically support more languages as the frontend expands its language
support, as long as no new IRs are introduced.</p>
<aside class="footnote brackets" id="computer-arch-interface" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>Computer Organization and Design: The Hardware/Software Interface 1st edition (The Morgan Kaufmann Series in Computer Architecture and Design)</p>
</aside>
<aside class="footnote brackets" id="mipsasm" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id3">1</a>,<a role="doc-backlink" href="#id9">2</a>)</span>
<p><a class="reference external" href="http://math-atlas.sourceforge.net/devel/assembly/007-2418-003.pdf">http://math-atlas.sourceforge.net/devel/assembly/007-2418-003.pdf</a></p>
</aside>
<aside class="footnote brackets" id="abi" role="note">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id2">1</a>,<a role="doc-backlink" href="#id4">2</a>)</span>
<p><a class="reference external" href="http://www.linux-mips.org/pub/linux/mips/doc/ABI/mipsabi.pdf">http://www.linux-mips.org/pub/linux/mips/doc/ABI/mipsabi.pdf</a></p>
</aside>
<aside class="footnote brackets" id="secglobal" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">4</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://jonathan2251.github.io/lbd/globalvar.html#global-variable">http://jonathan2251.github.io/lbd/globalvar.html#global-variable</a></p>
</aside>
<aside class="footnote brackets" id="wikitailcall" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">5</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://en.wikipedia.org/wiki/Tail_call">http://en.wikipedia.org/wiki/Tail_call</a></p>
</aside>
<aside class="footnote brackets" id="tailcallopt" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">6</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://llvm.org/docs/CodeGenerator.html#tail-call-optimization">http://llvm.org/docs/CodeGenerator.html#tail-call-optimization</a></p>
</aside>
<aside class="footnote brackets" id="callconv" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id8">7</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://llvm.org/docs/LangRef.html#calling-conventions">http://llvm.org/docs/LangRef.html#calling-conventions</a></p>
</aside>
<aside class="footnote brackets" id="mipsqemu" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id10">8</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://developer.mips.com/clang-llvm/">http://developer.mips.com/clang-llvm/</a></p>
</aside>
<aside class="footnote brackets" id="stacksave" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id11">9</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://www.llvm.org/docs/LangRef.html#llvm-stacksave-intrinsic">http://www.llvm.org/docs/LangRef.html#llvm-stacksave-intrinsic</a></p>
</aside>
<aside class="footnote brackets" id="wiki-vla" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id12">10</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Variable-length_array">https://en.wikipedia.org/wiki/Variable-length_array</a></p>
</aside>
<aside class="footnote brackets" id="excepthandle" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id13">11</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://llvm.org/docs/ExceptionHandling.html#overview">http://llvm.org/docs/ExceptionHandling.html#overview</a></p>
</aside>
<aside class="footnote brackets" id="returnaddr" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id14">12</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://llvm.org/docs/LangRef.html#llvm-returnaddress-intrinsic">http://llvm.org/docs/LangRef.html#llvm-returnaddress-intrinsic</a></p>
</aside>
<aside class="footnote brackets" id="ehreturn" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id15">13</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://llvm.org/docs/ExceptionHandling.html#exception-handling-support-on-the-target">https://llvm.org/docs/ExceptionHandling.html#exception-handling-support-on-the-target</a></p>
</aside>
<aside class="footnote brackets" id="cpu0lld" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id16">14</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://jonathan2251.github.io/lbt/lld.html">http://jonathan2251.github.io/lbt/lld.html</a></p>
</aside>
<aside class="footnote brackets" id="bswapintrnsic" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id17">15</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://llvm.org/docs/LangRef.html#llvm-bswap-intrinsics">http://llvm.org/docs/LangRef.html#llvm-bswap-intrinsics</a></p>
</aside>
<aside class="footnote brackets" id="extendintrnsic" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id18">16</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://llvm.org/docs/ExtendingLLVM.html">https://llvm.org/docs/ExtendingLLVM.html</a></p>
</aside>
<aside class="footnote brackets" id="lbd-fmul" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id19">17</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="file:///Users/cschen/git/lbd/build/html/othertype.html#float-and-double">file:///Users/cschen/git/lbd/build/html/othertype.html#float-and-double</a></p>
</aside>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="ctrlflow.html">Control flow statements</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="elf.html">ELF Support</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Chen Chung-Shu.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.0.2.
    </div>
  </body>
</html>