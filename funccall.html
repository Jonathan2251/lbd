<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Function call &mdash; Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '3.9.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="top" title="Tutorial: Creating an LLVM Backend for the Cpu0 Architecture" href="index.html" />
    <link rel="next" title="ELF Support" href="elf.html" />
    <link rel="prev" title="Control flow statements" href="ctrlflow.html" /> 
  </head>
  <body role="document">
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</span></a></h1>
        <h2 class="heading"><span>Function call</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="ctrlflow.html">Control flow statements</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="elf.html">ELF Support</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="function-call">
<span id="sec-funccall"></span><h1>Function call<a class="headerlink" href="#function-call" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#mips-stack-frame" id="id23">Mips stack frame</a></li>
<li><a class="reference internal" href="#load-incoming-arguments-from-stack-frame" id="id24">Load incoming arguments from stack frame</a></li>
<li><a class="reference internal" href="#store-outgoing-arguments-to-stack-frame" id="id25">Store outgoing arguments to stack frame</a><ul>
<li><a class="reference internal" href="#pseudo-hook-instruction-adjcallstackdown-and-adjcallstackup" id="id26">Pseudo hook instruction ADJCALLSTACKDOWN and ADJCALLSTACKUP</a></li>
<li><a class="reference internal" href="#read-lowercall-with-graphivz-s-help" id="id27">Read Lowercall() with Graphivz&#8217;s help</a></li>
<li><a class="reference internal" href="#long-and-short-string-initialization" id="id28">Long and short string initialization</a></li>
</ul>
</li>
<li><a class="reference internal" href="#structure-type-support" id="id29">Structure type support</a><ul>
<li><a class="reference internal" href="#ordinary-struct-type" id="id30">Ordinary struct type</a></li>
<li><a class="reference internal" href="#byval-struct-type" id="id31">byval struct type</a></li>
</ul>
</li>
<li><a class="reference internal" href="#function-call-optiomization" id="id32">Function call optiomization</a><ul>
<li><a class="reference internal" href="#tail-call-optimization" id="id33">Tail call optimization</a></li>
<li><a class="reference internal" href="#recursion-optimization" id="id34">Recursion optimization</a></li>
</ul>
</li>
<li><a class="reference internal" href="#other-features-supporting" id="id35">Other features supporting</a><ul>
<li><a class="reference internal" href="#the-gp-register-caller-saved-register-in-pic-addressing-mode" id="id36">The $gp register caller saved register in PIC addressing mode</a></li>
<li><a class="reference internal" href="#variable-number-of-arguments" id="id37">Variable number of arguments</a></li>
<li><a class="reference internal" href="#dynamic-stack-allocation-support" id="id38">Dynamic stack allocation support</a></li>
<li><a class="reference internal" href="#variable-sized-array-support" id="id39">Variable sized array support</a></li>
<li><a class="reference internal" href="#function-related-intrinsics-support" id="id40">Function related Intrinsics support</a><ul>
<li><a class="reference internal" href="#frameaddress-and-returnaddress-intrinsics" id="id41">frameaddress and returnaddress intrinsics</a></li>
<li><a class="reference internal" href="#eh-return-intrinsic" id="id42">eh.return intrinsic</a></li>
<li><a class="reference internal" href="#eh-dwarf-intrinsic" id="id43">eh.dwarf intrinsic</a></li>
<li><a class="reference internal" href="#bswap-intrinsic" id="id44">bswap intrinsic</a></li>
</ul>
</li>
<li><a class="reference internal" href="#add-specific-backend-intrinsic-function" id="id45">Add specific backend intrinsic function</a></li>
</ul>
</li>
<li><a class="reference internal" href="#summary" id="id46">Summary</a></li>
</ul>
</div>
<p>The subroutine/function call of backend translation is supported in this
chapter.
A lot of code are needed to support function call in this chapter.
They are added according llvm supplied interface to explain easily.
This chapter starts from introducing the Mips stack frame structure since we
borrow many parts of ABI from it.
Although each CPU has it&#8217;s own ABI, most of ABI for RISC CPUs are similar.
The section “4.5 DAG Lowering” of tricore_llvm.pdf contains knowledge
about Lowering process. Section “4.5.1 Calling Conventions” of tricore_llvm.pdf
is the related material you can reference further.</p>
<p>If you have problem in reading the stack frame illustrated in the first three
sections of this chapter, you can read the appendix B of “Procedure Call
Convention” of book “Computer Organization and Design, 1st Edition”
<a class="footnote-reference" href="#computer-arch-interface" id="id1">[1]</a>,
“Run Time Memory” of compiler book, or “Function Call Sequence”  and
“Stack Frame” of Mips ABI <a class="footnote-reference" href="#abi" id="id2">[3]</a>.</p>
<div class="section" id="mips-stack-frame">
<h2><a class="toc-backref" href="#id23">Mips stack frame</a><a class="headerlink" href="#mips-stack-frame" title="Permalink to this headline">¶</a></h2>
<p>The first thing for designing the Cpu0 function call is deciding how to pass
arguments in function call. There are two options.
One is passing arguments all in stack.
The other is passing arguments in the registers which are reserved for function
arguments, and put the other arguments in stack if it over the number of
registers reserved for function call. For example, Mips pass the first 4
arguments in register $a0, $a1, $a2, $a3, and the other arguments in stack
if it over 4 arguments. <a class="reference internal" href="#funccall-f1"><span class="std std-numref">Fig. 24</span></a> is the Mips stack frame.</p>
<div class="figure align-center" id="id16">
<span id="funccall-f1"></span><a class="reference internal image-reference" href="_images/13.png"><img alt="_images/13.png" src="_images/13.png" style="width: 344.0px; height: 265.5px;" /></a>
<p class="caption"><span class="caption-number">Fig. 24 </span><span class="caption-text">Mips stack frame</span></p>
</div>
<p>Run <code class="docutils literal"><span class="pre">llc</span> <span class="pre">-march=mips</span></code> for ch9_1.bc, you will get the following result.
See comments <strong>&#8220;//&#8221;</strong>.</p>
<p class="rubric">lbdex/input/ch9_1.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">gI</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

<span class="nb">int</span> <span class="n">sum_i</span><span class="p">(</span><span class="nb">int</span> <span class="n">x1</span><span class="p">,</span> <span class="nb">int</span> <span class="n">x2</span><span class="p">,</span> <span class="nb">int</span> <span class="n">x3</span><span class="p">,</span> <span class="nb">int</span> <span class="n">x4</span><span class="p">,</span> <span class="nb">int</span> <span class="n">x5</span><span class="p">,</span> <span class="nb">int</span> <span class="n">x6</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="nb">sum</span> <span class="o">=</span> <span class="n">gI</span> <span class="o">+</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span> <span class="o">+</span> <span class="n">x3</span> <span class="o">+</span> <span class="n">x4</span> <span class="o">+</span> <span class="n">x5</span> <span class="o">+</span> <span class="n">x6</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="nb">sum</span><span class="p">;</span> 
<span class="p">}</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span> 
  <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">sum_i</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>  
  
  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">118-165-78-230:input Jonathan$</span> clang -target mips-unknown-linux-gnu -c
<span class="go">ch9_1.cpp -emit-llvm -o ch9_1.bc</span>
<span class="gp">118-165-78-230:input Jonathan$</span> /Users/Jonathan/llvm/test/cmake_debug_build/
<span class="go">Debug/bin/llc -march=mips -relocation-model=pic -filetype=asm ch9_1.bc -o</span>
<span class="go">ch9_1.mips.s</span>
<span class="gp">118-165-78-230:input Jonathan$</span> cat ch9_1.mips.s
<span class="go">  .section .mdebug.abi32</span>
<span class="go">  .previous</span>
<span class="go">  .file &quot;ch9_1.bc&quot;</span>
<span class="go">  .text</span>
<span class="go">  .globl  _Z5sum_iiiiiii</span>
<span class="go">  .align  2</span>
<span class="go">  .type _Z5sum_iiiiiii,@function</span>
<span class="go">  .set  nomips16                # @_Z5sum_iiiiiii</span>
<span class="go">  .ent  _Z5sum_iiiiiii</span>
<span class="go">_Z5sum_iiiiiii:</span>
<span class="go">  .cfi_startproc</span>
<span class="go">  .frame  $sp,32,$ra</span>
<span class="go">  .mask   0x00000000,0</span>
<span class="go">  .fmask  0x00000000,0</span>
<span class="go">  .set  noreorder</span>
<span class="go">  .set  nomacro</span>
<span class="go">  .set  noat</span>
<span class="gp">#</span> BB#0:
<span class="go">  addiu $sp, $sp, -32</span>
<span class="gp">$</span>tmp1:
<span class="go">  .cfi_def_cfa_offset 32</span>
<span class="go">  sw  $4, 28($sp)</span>
<span class="go">  sw  $5, 24($sp)</span>
<span class="go">  sw  $t9, 20($sp)</span>
<span class="go">  sw  $7, 16($sp)</span>
<span class="go">  lw  $1, 48($sp) // load argument 5</span>
<span class="go">  sw  $1, 12($sp)</span>
<span class="go">  lw  $1, 52($sp) // load argument 6</span>
<span class="go">  sw  $1, 8($sp)</span>
<span class="go">  lw  $2, 24($sp)</span>
<span class="go">  lw  $3, 28($sp)</span>
<span class="go">  addu  $2, $3, $2</span>
<span class="go">  lw  $3, 20($sp)</span>
<span class="go">  addu  $2, $2, $3</span>
<span class="go">  lw  $3, 16($sp)</span>
<span class="go">  addu  $2, $2, $3</span>
<span class="go">  lw  $3, 12($sp)</span>
<span class="go">  addu  $2, $2, $3</span>
<span class="go">  addu  $2, $2, $1</span>
<span class="go">  sw  $2, 4($sp)</span>
<span class="go">  jr  $ra</span>
<span class="go">  addiu $sp, $sp, 32</span>
<span class="go">  .set  at</span>
<span class="go">  .set  macro</span>
<span class="go">  .set  reorder</span>
<span class="go">  .end  _Z5sum_iiiiiii</span>
<span class="gp">$</span>tmp2:
<span class="go">  .size _Z5sum_iiiiiii, ($tmp2)-_Z5sum_iiiiiii</span>
<span class="go">  .cfi_endproc</span>

<span class="go">  .globl  main</span>
<span class="go">  .align  2</span>
<span class="go">  .type main,@function</span>
<span class="go">  .set  nomips16                # @main</span>
<span class="go">  .ent  main</span>
<span class="go">main:</span>
<span class="go">  .cfi_startproc</span>
<span class="go">  .frame  $sp,40,$ra</span>
<span class="go">  .mask   0x80000000,-4</span>
<span class="go">  .fmask  0x00000000,0</span>
<span class="go">  .set  noreorder</span>
<span class="go">  .set  nomacro</span>
<span class="go">  .set  noat</span>
<span class="gp">#</span> BB#0:
<span class="go">  lui $2, %hi(_gp_disp)</span>
<span class="go">  ori $2, $2, %lo(_gp_disp)</span>
<span class="go">  addiu $sp, $sp, -40</span>
<span class="gp">$</span>tmp5:
<span class="go">  .cfi_def_cfa_offset 40</span>
<span class="go">  sw  $ra, 36($sp)            # 4-byte Folded Spill</span>
<span class="gp">$</span>tmp6:
<span class="go">  .cfi_offset 31, -4</span>
<span class="go">  addu  $gp, $2, $25</span>
<span class="go">  sw  $zero, 32($sp)</span>
<span class="go">  addiu $1, $zero, 6</span>
<span class="go">  sw  $1, 20($sp) // Save argument 6 to 20($sp)</span>
<span class="go">  addiu $1, $zero, 5</span>
<span class="go">  sw  $1, 16($sp) // Save argument 5 to 16($sp)</span>
<span class="go">  lw  $25, %call16(_Z5sum_iiiiiii)($gp)</span>
<span class="go">  addiu $4, $zero, 1    // Pass argument 1 to $4 (=$a0)</span>
<span class="go">  addiu $5, $zero, 2    // Pass argument 2 to $5 (=$a1)</span>
<span class="go">  addiu $t9, $zero, 3</span>
<span class="go">  jalr  $25</span>
<span class="go">  addiu $7, $zero, 4</span>
<span class="go">  sw  $2, 28($sp)</span>
<span class="go">  lw  $ra, 36($sp)            # 4-byte Folded Reload</span>
<span class="go">  jr  $ra</span>
<span class="go">  addiu $sp, $sp, 40</span>
<span class="go">  .set  at</span>
<span class="go">  .set  macro</span>
<span class="go">  .set  reorder</span>
<span class="go">  .end  main</span>
<span class="gp">$</span>tmp7:
<span class="go">  .size main, ($tmp7)-main</span>
<span class="go">  .cfi_endproc</span>
</pre></div>
</div>
<p>From the mips assembly code generated as above, we see that it saves the first 4
arguments to $a0..$a3 and last 2 arguments to 16($sp) and 20($sp).
<a class="reference internal" href="#funccall-f2"><span class="std std-numref">Fig. 25</span></a> is the location of arguments for example code
ch9_1.cpp.
It loads argument 5 from 48($sp) in sum_i() since the argument 5 is saved to
16($sp) in main().
The stack size of sum_i() is 32, so 16+32($sp) is the location of incoming
argument 5.</p>
<div class="figure align-center" id="id17">
<span id="funccall-f2"></span><a class="reference internal image-reference" href="_images/21.png"><img alt="_images/21.png" src="_images/21.png" style="width: 370.0px; height: 288.5px;" /></a>
<p class="caption"><span class="caption-number">Fig. 25 </span><span class="caption-text">Mips arguments location in stack frame</span></p>
</div>
<p>The 007-2418-003.pdf in here <a class="footnote-reference" href="#mipsasm" id="id3">[2]</a> is the Mips assembly language manual.
Here <a class="footnote-reference" href="#abi" id="id4">[3]</a> is Mips Application Binary Interface which include the
<a class="reference internal" href="#funccall-f1"><span class="std std-numref">Fig. 24</span></a>.</p>
</div>
<div class="section" id="load-incoming-arguments-from-stack-frame">
<h2><a class="toc-backref" href="#id24">Load incoming arguments from stack frame</a><a class="headerlink" href="#load-incoming-arguments-from-stack-frame" title="Permalink to this headline">¶</a></h2>
<p>From last section, in order to support function call, we need implementing the
arguments passing mechanism with stack frame.
Before doing it, let&#8217;s run the old version of code Chapter8_2/ with ch9_1.cpp
and see what happens.</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">118-165-79-31:input Jonathan$</span> /Users/Jonathan/llvm/test/
<span class="go">cmake_debug_build/Debug/bin/llc -march=cpu0 -relocation-model=pic -filetype=asm</span>
<span class="go">ch9_1.bc -o ch9_1.cpu0.s</span>
<span class="go">Assertion failed: (InVals.size() == Ins.size() &amp;&amp; &quot;LowerFormalArguments didn&#39;t</span>
<span class="go">emit the correct number of values!&quot;), function LowerArguments, file /Users/</span>
<span class="go">Jonathan/llvm/test/src/lib/CodeGen/SelectionDAG/</span>
<span class="go">SelectionDAGBuilder.cpp, ...</span>
<span class="go">...</span>
<span class="go">0.  Program arguments: /Users/Jonathan/llvm/test/cmake_debug_build/</span>
<span class="go">Debug/bin/llc -march=cpu0 -relocation-model=pic -filetype=asm ch9_1.bc -o</span>
<span class="go">ch9_1.cpu0.s</span>
<span class="go">1.  Running pass &#39;Function Pass Manager&#39; on module &#39;ch9_1.bc&#39;.</span>
<span class="go">2.  Running pass &#39;CPU0 DAG-&gt;DAG Pattern Instruction Selection&#39; on function</span>
<span class="go">&#39;@_Z5sum_iiiiiii&#39;</span>
<span class="go">Illegal instruction: 4</span>
</pre></div>
</div>
<p>Since Chapter8_2/ define the LowerFormalArguments() with empty body, we get the error
messages as above.
Before defining LowerFormalArguments(), we have to choose how to pass arguments
in function call.
For demonstration, Cpu0 passes first two arguments in registers as
default setting of <code class="docutils literal"><span class="pre">llc</span> <span class="pre">-cpu0-s32-calls=false</span></code>.
When <code class="docutils literal"><span class="pre">llc</span> <span class="pre">-cpu0-s32-calls=true</span></code>, Cpu0 passes all it&#8217;s arguments in stack.</p>
<p>Function LowerFormalArguments() is in charge of incoming arguments creation.
We define it as follows,</p>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0ISelLowering.h</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="k">class</span> <span class="nc">Cpu0TargetLowering</span> <span class="p">:</span> <span class="n">public</span> <span class="n">TargetLowering</span>  <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>    <span class="o">///</span> <span class="n">Cpu0CC</span> <span class="o">-</span> <span class="n">This</span> <span class="k">class</span> <span class="nc">provides</span> <span class="n">methods</span> <span class="n">used</span> <span class="n">to</span> <span class="n">analyze</span> <span class="n">formal</span> <span class="ow">and</span> <span class="n">call</span>
    <span class="o">///</span> <span class="n">arguments</span> <span class="ow">and</span> <span class="n">inquire</span> <span class="n">about</span> <span class="n">calling</span> <span class="n">convention</span> <span class="n">information</span><span class="o">.</span>
    <span class="k">class</span> <span class="nc">Cpu0CC</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>      <span class="n">void</span> <span class="n">analyzeFormalArguments</span><span class="p">(</span><span class="n">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="p">::</span><span class="n">InputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ins</span><span class="p">,</span>
                                  <span class="nb">bool</span> <span class="n">IsSoftFloat</span><span class="p">,</span>
                                  <span class="n">Function</span><span class="p">::</span><span class="n">const_arg_iterator</span> <span class="n">FuncArg</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>      /// regSize - Size (in number of bits) of integer registers.
      unsigned regSize() const { return IsO32 ? 4 : 4; }
      /// numIntArgRegs - Number of integer registers available for calls.
      unsigned numIntArgRegs() const;
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>      <span class="o">///</span> <span class="n">Return</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">array</span> <span class="n">of</span> <span class="n">integer</span> <span class="n">argument</span> <span class="n">registers</span><span class="o">.</span>
      <span class="n">const</span> <span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">MCPhysReg</span><span class="o">&gt;</span> <span class="n">intArgRegs</span><span class="p">()</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>      <span class="n">void</span> <span class="n">handleByValArg</span><span class="p">(</span><span class="n">unsigned</span> <span class="n">ValNo</span><span class="p">,</span> <span class="n">MVT</span> <span class="n">ValVT</span><span class="p">,</span> <span class="n">MVT</span> <span class="n">LocVT</span><span class="p">,</span>
                          <span class="n">CCValAssign</span><span class="p">::</span><span class="n">LocInfo</span> <span class="n">LocInfo</span><span class="p">,</span>
                          <span class="n">ISD</span><span class="p">::</span><span class="n">ArgFlagsTy</span> <span class="n">ArgFlags</span><span class="p">);</span>

      <span class="o">///</span> <span class="n">useRegsForByval</span> <span class="o">-</span> <span class="n">Returns</span> <span class="n">true</span> <span class="k">if</span> <span class="n">the</span> <span class="n">calling</span> <span class="n">convention</span> <span class="n">allows</span> <span class="n">the</span>
      <span class="o">///</span> <span class="n">use</span> <span class="n">of</span> <span class="n">registers</span> <span class="n">to</span> <span class="k">pass</span> <span class="n">byval</span> <span class="n">arguments</span><span class="o">.</span>
      <span class="nb">bool</span> <span class="n">useRegsForByval</span><span class="p">()</span> <span class="n">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">CallConv</span> <span class="o">!=</span> <span class="n">CallingConv</span><span class="p">::</span><span class="n">Fast</span><span class="p">;</span> <span class="p">}</span>

      <span class="o">///</span> <span class="n">Return</span> <span class="n">the</span> <span class="n">function</span> <span class="n">that</span> <span class="n">analyzes</span> <span class="n">fixed</span> <span class="n">argument</span> <span class="nb">list</span> <span class="n">functions</span><span class="o">.</span>
      <span class="n">llvm</span><span class="p">::</span><span class="n">CCAssignFn</span> <span class="o">*</span><span class="n">fixedArgFn</span><span class="p">()</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>      <span class="n">void</span> <span class="n">allocateRegs</span><span class="p">(</span><span class="n">ByValArgInfo</span> <span class="o">&amp;</span><span class="n">ByVal</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">ByValSize</span><span class="p">,</span>
                        <span class="n">unsigned</span> <span class="n">Align</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="p">};</span>
<span class="p">...</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>    <span class="o">///</span> <span class="n">isEligibleForTailCallOptimization</span> <span class="o">-</span> <span class="n">Check</span> <span class="n">whether</span> <span class="n">the</span> <span class="n">call</span> <span class="ow">is</span> <span class="n">eligible</span>
    <span class="o">///</span> <span class="k">for</span> <span class="n">tail</span> <span class="n">call</span> <span class="n">optimization</span><span class="o">.</span>
    <span class="n">virtual</span> <span class="nb">bool</span>
    <span class="n">isEligibleForTailCallOptimization</span><span class="p">(</span><span class="n">const</span> <span class="n">Cpu0CC</span> <span class="o">&amp;</span><span class="n">Cpu0CCInfo</span><span class="p">,</span>
                                      <span class="n">unsigned</span> <span class="n">NextStackOffset</span><span class="p">,</span>
                                      <span class="n">const</span> <span class="n">Cpu0FunctionInfo</span><span class="o">&amp;</span> <span class="n">FI</span><span class="p">)</span> <span class="n">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>    <span class="o">///</span> <span class="n">copyByValArg</span> <span class="o">-</span> <span class="n">Copy</span> <span class="n">argument</span> <span class="n">registers</span> <span class="n">which</span> <span class="n">were</span> <span class="n">used</span> <span class="n">to</span> <span class="k">pass</span> <span class="n">a</span> <span class="n">byval</span>
    <span class="o">///</span> <span class="n">argument</span> <span class="n">to</span> <span class="n">the</span> <span class="n">stack</span><span class="o">.</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">stack</span> <span class="n">frame</span> <span class="nb">object</span> <span class="k">for</span> <span class="n">the</span> <span class="n">byval</span>
    <span class="o">///</span> <span class="n">argument</span><span class="o">.</span>
    <span class="n">void</span> <span class="n">copyByValRegs</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">const</span> <span class="n">SDLoc</span> <span class="o">&amp;</span><span class="n">DL</span><span class="p">,</span>
                       <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">OutChains</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span>
                       <span class="n">const</span> <span class="n">ISD</span><span class="p">::</span><span class="n">ArgFlagsTy</span> <span class="o">&amp;</span><span class="n">Flags</span><span class="p">,</span>
                       <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">,</span>
                       <span class="n">const</span> <span class="n">Argument</span> <span class="o">*</span><span class="n">FuncArg</span><span class="p">,</span>
                       <span class="n">const</span> <span class="n">Cpu0CC</span> <span class="o">&amp;</span><span class="n">CC</span><span class="p">,</span> <span class="n">const</span> <span class="n">ByValArgInfo</span> <span class="o">&amp;</span><span class="n">ByVal</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>    <span class="n">SDValue</span> <span class="n">LowerCall</span><span class="p">(</span><span class="n">TargetLowering</span><span class="p">::</span><span class="n">CallLoweringInfo</span> <span class="o">&amp;</span><span class="n">CLI</span><span class="p">,</span>
                      <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0ISelLowering.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">addLiveIn</span> <span class="o">-</span> <span class="n">This</span> <span class="n">helper</span> <span class="n">function</span> <span class="n">adds</span> <span class="n">the</span> <span class="n">specified</span> <span class="n">physical</span> <span class="n">register</span> <span class="n">to</span> <span class="n">the</span>
<span class="o">//</span> <span class="n">MachineFunction</span> <span class="k">as</span> <span class="n">a</span> <span class="n">live</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span>  <span class="n">It</span> <span class="n">also</span> <span class="n">creates</span> <span class="n">a</span> <span class="n">corresponding</span>
<span class="o">//</span> <span class="n">virtual</span> <span class="n">register</span> <span class="k">for</span> <span class="n">it</span><span class="o">.</span>
<span class="n">static</span> <span class="n">unsigned</span>
<span class="n">addLiveIn</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">PReg</span><span class="p">,</span> <span class="n">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span><span class="n">RC</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">unsigned</span> <span class="n">VReg</span> <span class="o">=</span> <span class="n">MF</span><span class="o">.</span><span class="n">getRegInfo</span><span class="p">()</span><span class="o">.</span><span class="n">createVirtualRegister</span><span class="p">(</span><span class="n">RC</span><span class="p">);</span>
  <span class="n">MF</span><span class="o">.</span><span class="n">getRegInfo</span><span class="p">()</span><span class="o">.</span><span class="n">addLiveIn</span><span class="p">(</span><span class="n">PReg</span><span class="p">,</span> <span class="n">VReg</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">VReg</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>//===----------------------------------------------------------------------===//
// TODO: Implement a generic logic using tblgen that can support this.
// Cpu0 32 ABI rules:
// ---
//===----------------------------------------------------------------------===//

// Passed in stack only.
static bool CC_Cpu0S32(unsigned ValNo, MVT ValVT, MVT LocVT,
                       CCValAssign::LocInfo LocInfo, ISD::ArgFlagsTy ArgFlags,
                       CCState &amp;State) {
  // Do not process byval args here.
  if (ArgFlags.isByVal())
    return true;

  // Promote i8 and i16
  if (LocVT == MVT::i8 || LocVT == MVT::i16) {
    LocVT = MVT::i32;
    if (ArgFlags.isSExt())
      LocInfo = CCValAssign::SExt;
    else if (ArgFlags.isZExt())
      LocInfo = CCValAssign::ZExt;
    else
      LocInfo = CCValAssign::AExt;
  }

  unsigned OrigAlign = ArgFlags.getOrigAlign();
  unsigned Offset = State.AllocateStack(ValVT.getSizeInBits() &gt;&gt; 3,
                                        OrigAlign);
  State.addLoc(CCValAssign::getMem(ValNo, ValVT, Offset, LocVT, LocInfo));
  return false;
}

// Passed first two i32 arguments in registers and others in stack.
static bool CC_Cpu0O32(unsigned ValNo, MVT ValVT, MVT LocVT,
                       CCValAssign::LocInfo LocInfo, ISD::ArgFlagsTy ArgFlags,
                       CCState &amp;State) {
  static const MCPhysReg IntRegs[] = { Cpu0::A0, Cpu0::A1 };

  // Do not process byval args here.
  if (ArgFlags.isByVal())
    return true;

  // Promote i8 and i16
  if (LocVT == MVT::i8 || LocVT == MVT::i16) {
    LocVT = MVT::i32;
    if (ArgFlags.isSExt())
      LocInfo = CCValAssign::SExt;
    else if (ArgFlags.isZExt())
      LocInfo = CCValAssign::ZExt;
    else
      LocInfo = CCValAssign::AExt;
  }

  unsigned Reg;

  // f32 and f64 are allocated in A0, A1 when either of the following
  // is true: function is vararg, argument is 3rd or higher, there is previous
  // argument which is not f32 or f64.
  bool AllocateFloatsInIntReg = true;
  unsigned OrigAlign = ArgFlags.getOrigAlign();
  bool isI64 = (ValVT == MVT::i32 &amp;&amp; OrigAlign == 8);

  if (ValVT == MVT::i32 || (ValVT == MVT::f32 &amp;&amp; AllocateFloatsInIntReg)) {
    Reg = State.AllocateReg(IntRegs);
    // If this is the first part of an i64 arg,
    // the allocated register must be A0.
    if (isI64 &amp;&amp; (Reg == Cpu0::A1))
      Reg = State.AllocateReg(IntRegs);
    LocVT = MVT::i32;
  } else if (ValVT == MVT::f64 &amp;&amp; AllocateFloatsInIntReg) {
    // Allocate int register. If first
    // available register is Cpu0::A1, shadow it too.
    Reg = State.AllocateReg(IntRegs);
    if (Reg == Cpu0::A1)
      Reg = State.AllocateReg(IntRegs);
    State.AllocateReg(IntRegs);
    LocVT = MVT::i32;
  } else
    llvm_unreachable(&quot;Cannot handle this ValVT.&quot;);

  if (!Reg) {
    unsigned Offset = State.AllocateStack(ValVT.getSizeInBits() &gt;&gt; 3,
                                          OrigAlign);
    State.addLoc(CCValAssign::getMem(ValNo, ValVT, Offset, LocVT, LocInfo));
  } else
    State.addLoc(CCValAssign::getReg(ValNo, ValVT, Reg, LocVT, LocInfo));

  return false;
}
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">//</span>                  <span class="n">Call</span> <span class="n">Calling</span> <span class="n">Convention</span> <span class="n">Implementation</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="n">static</span> <span class="n">const</span> <span class="n">MCPhysReg</span> <span class="n">O32IntRegs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="n">Cpu0</span><span class="p">::</span><span class="n">A0</span><span class="p">,</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">A1</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span><span class="nd">@LowerCall</span> <span class="p">{</span>
<span class="o">///</span> <span class="n">LowerCall</span> <span class="o">-</span> <span class="n">functions</span> <span class="n">arguments</span> <span class="n">are</span> <span class="n">copied</span> <span class="kn">from</span> <span class="nn">virtual</span> <span class="n">regs</span> <span class="n">to</span>
<span class="o">///</span> <span class="p">(</span><span class="n">physical</span> <span class="n">regs</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">stack</span> <span class="n">frame</span><span class="p">),</span> <span class="n">CALLSEQ_START</span> <span class="ow">and</span> <span class="n">CALLSEQ_END</span> <span class="n">are</span> <span class="n">emitted</span><span class="o">.</span>
<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">LowerCall</span><span class="p">(</span><span class="n">TargetLowering</span><span class="p">::</span><span class="n">CallLoweringInfo</span> <span class="o">&amp;</span><span class="n">CLI</span><span class="p">,</span>
                              <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span><span class="nd">@LowerCall</span> <span class="p">{</span>
<span class="o">///</span> <span class="n">LowerCall</span> <span class="o">-</span> <span class="n">functions</span> <span class="n">arguments</span> <span class="n">are</span> <span class="n">copied</span> <span class="kn">from</span> <span class="nn">virtual</span> <span class="n">regs</span> <span class="n">to</span>
<span class="o">///</span> <span class="p">(</span><span class="n">physical</span> <span class="n">regs</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">stack</span> <span class="n">frame</span><span class="p">),</span> <span class="n">CALLSEQ_START</span> <span class="ow">and</span> <span class="n">CALLSEQ_END</span> <span class="n">are</span> <span class="n">emitted</span><span class="o">.</span>
<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">LowerCall</span><span class="p">(</span><span class="n">TargetLowering</span><span class="p">::</span><span class="n">CallLoweringInfo</span> <span class="o">&amp;</span><span class="n">CLI</span><span class="p">,</span>
                              <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="k">return</span> <span class="n">CLI</span><span class="o">.</span><span class="n">Chain</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>//===----------------------------------------------------------------------===//

//@LowerFormalArguments {
/// LowerFormalArguments - transform physical registers into virtual registers
/// and generate load operations for arguments places on the stack.
SDValue
Cpu0TargetLowering::LowerFormalArguments(SDValue Chain,
                                         CallingConv::ID CallConv,
                                         bool IsVarArg,
                                         const SmallVectorImpl&lt;ISD::InputArg&gt; &amp;Ins,
                                         const SDLoc &amp;DL, SelectionDAG &amp;DAG,
                                         SmallVectorImpl&lt;SDValue&gt; &amp;InVals)
                                          const {
  MachineFunction &amp;MF = DAG.getMachineFunction();
  MachineFrameInfo *MFI = MF.getFrameInfo();
  Cpu0FunctionInfo *Cpu0FI = MF.getInfo&lt;Cpu0FunctionInfo&gt;();

  Cpu0FI-&gt;setVarArgsFrameIndex(0);

  // Assign locations to all of the incoming arguments.
  SmallVector&lt;CCValAssign, 16&gt; ArgLocs;
  CCState CCInfo(CallConv, IsVarArg, DAG.getMachineFunction(),
                 ArgLocs, *DAG.getContext());
  Cpu0CC Cpu0CCInfo(CallConv, ABI.IsO32(), 
                    CCInfo);

  Function::const_arg_iterator FuncArg =
    DAG.getMachineFunction().getFunction()-&gt;arg_begin();
  bool UseSoftFloat = Subtarget.abiUsesSoftFloat();

  Cpu0CCInfo.analyzeFormalArguments(Ins, UseSoftFloat, FuncArg);
  Cpu0FI-&gt;setFormalArgInfo(CCInfo.getNextStackOffset(),
                           Cpu0CCInfo.hasByValArg());

  // Used with vargs to acumulate store chains.
  std::vector&lt;SDValue&gt; OutChains;

  unsigned CurArgIdx = 0;
  Cpu0CC::byval_iterator ByValArg = Cpu0CCInfo.byval_begin();

  //@2 {
  for (unsigned i = 0, e = ArgLocs.size(); i != e; ++i) {
  //@2 }
    CCValAssign &amp;VA = ArgLocs[i];
    if (Ins[i].isOrigArg()) {
      std::advance(FuncArg, Ins[i].getOrigArgIndex() - CurArgIdx);
      CurArgIdx = Ins[i].getOrigArgIndex();
    }
    EVT ValVT = VA.getValVT();
    ISD::ArgFlagsTy Flags = Ins[i].Flags;
    bool IsRegLoc = VA.isRegLoc();

    //@byval pass {
    if (Flags.isByVal()) {
      assert(Flags.getByValSize() &amp;&amp;
             &quot;ByVal args of size 0 should have been ignored by front-end.&quot;);
      assert(ByValArg != Cpu0CCInfo.byval_end());
      copyByValRegs(Chain, DL, OutChains, DAG, Flags, InVals, &amp;*FuncArg,
                    Cpu0CCInfo, *ByValArg);
      ++ByValArg;
      continue;
    }
    //@byval pass }
    // Arguments stored on registers
    if (ABI.IsO32() &amp;&amp; IsRegLoc) {
      MVT RegVT = VA.getLocVT();
      unsigned ArgReg = VA.getLocReg();
      const TargetRegisterClass *RC = getRegClassFor(RegVT);

      // Transform the arguments stored on
      // physical registers into virtual ones
      unsigned Reg = addLiveIn(DAG.getMachineFunction(), ArgReg, RC);
      SDValue ArgValue = DAG.getCopyFromReg(Chain, DL, Reg, RegVT);

      // If this is an 8 or 16-bit value, it has been passed promoted
      // to 32 bits.  Insert an assert[sz]ext to capture this, then
      // truncate to the right size.
      if (VA.getLocInfo() != CCValAssign::Full) {
        unsigned Opcode = 0;
        if (VA.getLocInfo() == CCValAssign::SExt)
          Opcode = ISD::AssertSext;
        else if (VA.getLocInfo() == CCValAssign::ZExt)
          Opcode = ISD::AssertZext;
        if (Opcode)
          ArgValue = DAG.getNode(Opcode, DL, RegVT, ArgValue,
                                 DAG.getValueType(ValVT));
        ArgValue = DAG.getNode(ISD::TRUNCATE, DL, ValVT, ArgValue);
      }

      // Handle floating point arguments passed in integer registers.
      if ((RegVT == MVT::i32 &amp;&amp; ValVT == MVT::f32) ||
          (RegVT == MVT::i64 &amp;&amp; ValVT == MVT::f64))
        ArgValue = DAG.getNode(ISD::BITCAST, DL, ValVT, ArgValue);
      InVals.push_back(ArgValue);
    } else { // VA.isRegLoc()
      MVT LocVT = VA.getLocVT();

      // sanity check
      assert(VA.isMemLoc());

      // The stack pointer offset is relative to the caller stack frame.
      int FI = MFI-&gt;CreateFixedObject(ValVT.getSizeInBits()/8,
                                      VA.getLocMemOffset(), true);

      // Create load nodes to retrieve arguments from the stack
      SDValue FIN = DAG.getFrameIndex(FI, getPointerTy(DAG.getDataLayout()));
      SDValue Load = DAG.getLoad(
          LocVT, DL, Chain, FIN,
          MachinePointerInfo::getFixedStack(DAG.getMachineFunction(), FI));
      InVals.push_back(Load);
      OutChains.push_back(Load.getValue(1));
    }
  }

//@Ordinary struct type: 1 {
  for (unsigned i = 0, e = ArgLocs.size(); i != e; ++i) {
    // The cpu0 ABIs for returning structs by value requires that we copy
    // the sret argument into $v0 for the return. Save the argument into
    // a virtual register so that we can access it from the return points.
    if (Ins[i].Flags.isSRet()) {
      unsigned Reg = Cpu0FI-&gt;getSRetReturnReg();
      if (!Reg) {
        Reg = MF.getRegInfo().createVirtualRegister(
            getRegClassFor(MVT::i32));
        Cpu0FI-&gt;setSRetReturnReg(Reg);
      }
      SDValue Copy = DAG.getCopyToReg(DAG.getEntryNode(), DL, Reg, InVals[i]);
      Chain = DAG.getNode(ISD::TokenFactor, DL, MVT::Other, Copy, Chain);
      break;
    }
  }
//@Ordinary struct type: 1 }

  // All stores are grouped in one node to allow the matching between
  // the size of Ins and InVals. This only happens when on varg functions
  if (!OutChains.empty()) {
    OutChains.push_back(Chain);
    Chain = DAG.getNode(ISD::TokenFactor, DL, MVT::Other, OutChains);
  }

  return Chain;
}
// @LowerFormalArguments }

//===----------------------------------------------------------------------===//
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>void Cpu0TargetLowering::Cpu0CC::
analyzeFormalArguments(const SmallVectorImpl&lt;ISD::InputArg&gt; &amp;Args,
                       bool IsSoftFloat, Function::const_arg_iterator FuncArg) {
  unsigned NumArgs = Args.size();
  llvm::CCAssignFn *FixedFn = fixedArgFn();
  unsigned CurArgIdx = 0;

  for (unsigned I = 0; I != NumArgs; ++I) {
    MVT ArgVT = Args[I].VT;
    ISD::ArgFlagsTy ArgFlags = Args[I].Flags;
    if (Args[I].isOrigArg()) {
      std::advance(FuncArg, Args[I].getOrigArgIndex() - CurArgIdx);
      CurArgIdx = Args[I].getOrigArgIndex();
    }
    CurArgIdx = Args[I].OrigArgIndex;

    if (ArgFlags.isByVal()) {
      handleByValArg(I, ArgVT, ArgVT, CCValAssign::Full, ArgFlags);
      continue;
    }

    MVT RegVT = getRegVT(ArgVT, FuncArg-&gt;getType(), nullptr, IsSoftFloat);

    if (!FixedFn(I, ArgVT, RegVT, CCValAssign::Full, ArgFlags, CCInfo))
      continue;

#ifndef NDEBUG
    dbgs() &lt;&lt; &quot;Formal Arg #&quot; &lt;&lt; I &lt;&lt; &quot; has unhandled type &quot;
           &lt;&lt; EVT(ArgVT).getEVTString();
#endif
    llvm_unreachable(nullptr);
  }
}
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>void Cpu0TargetLowering::Cpu0CC::handleByValArg(unsigned ValNo, MVT ValVT,
                                                MVT LocVT,
                                                CCValAssign::LocInfo LocInfo,
                                                ISD::ArgFlagsTy ArgFlags) {
  assert(ArgFlags.getByValSize() &amp;&amp; &quot;Byval argument&#39;s size shouldn&#39;t be 0.&quot;);

  struct ByValArgInfo ByVal;
  unsigned RegSize = regSize();
  unsigned ByValSize = alignTo(ArgFlags.getByValSize(), RegSize);
  unsigned Align = std::min(std::max(ArgFlags.getByValAlign(), RegSize),
                            RegSize * 2);

  if (useRegsForByval())
    allocateRegs(ByVal, ByValSize, Align);

  // Allocate space on caller&#39;s stack.
  ByVal.Address = CCInfo.AllocateStack(ByValSize - RegSize * ByVal.NumRegs,
                                       Align);
  CCInfo.addLoc(CCValAssign::getMem(ValNo, ValVT, ByVal.Address, LocVT,
                                    LocInfo));
  ByValArgs.push_back(ByVal);
}

unsigned Cpu0TargetLowering::Cpu0CC::numIntArgRegs() const {
  return IsO32 ? array_lengthof(O32IntRegs) : 0;
}
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">MCPhysReg</span><span class="o">&gt;</span> <span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">Cpu0CC</span><span class="p">::</span><span class="n">intArgRegs</span><span class="p">()</span> <span class="n">const</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">makeArrayRef</span><span class="p">(</span><span class="n">O32IntRegs</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">llvm</span><span class="p">::</span><span class="n">CCAssignFn</span> <span class="o">*</span><span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">Cpu0CC</span><span class="p">::</span><span class="n">fixedArgFn</span><span class="p">()</span> <span class="n">const</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">IsO32</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">CC_Cpu0O32</span><span class="p">;</span>
  <span class="k">else</span> <span class="o">//</span> <span class="n">IsS32</span>
    <span class="k">return</span> <span class="n">CC_Cpu0S32</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>void Cpu0TargetLowering::Cpu0CC::allocateRegs(ByValArgInfo &amp;ByVal,
                                              unsigned ByValSize,
                                              unsigned Align) {
  unsigned RegSize = regSize(), NumIntArgRegs = numIntArgRegs();
  const ArrayRef&lt;MCPhysReg&gt; IntArgRegs = intArgRegs();
  assert(!(ByValSize % RegSize) &amp;&amp; !(Align % RegSize) &amp;&amp;
         &quot;Byval argument&#39;s size and alignment should be a multiple of&quot;
         &quot;RegSize.&quot;);

  ByVal.FirstIdx = CCInfo.getFirstUnallocated(IntArgRegs);

  // If Align &gt; RegSize, the first arg register must be even.
  if ((Align &gt; RegSize) &amp;&amp; (ByVal.FirstIdx % 2)) {
    CCInfo.AllocateReg(IntArgRegs[ByVal.FirstIdx]);
    ++ByVal.FirstIdx;
  }

  // Mark the registers allocated.
  for (unsigned I = ByVal.FirstIdx; ByValSize &amp;&amp; (I &lt; NumIntArgRegs);
       ByValSize -= RegSize, ++I, ++ByVal.NumRegs)
    CCInfo.AllocateReg(IntArgRegs[I]);
}
</pre></div>
</div>
<p>Refresh &#8220;section Global variable&#8221; <a class="footnote-reference" href="#secglobal" id="id5">[4]</a>, we handled global
variable translation by creating the IR DAG in LowerGlobalAddress() first, and
then finish the Instruction Selection according their corresponding machine
instruction DAGs in Cpu0InstrInfo.td.
LowerGlobalAddress() is called when <code class="docutils literal"><span class="pre">llc</span></code> meets the global variable access.
LowerFormalArguments() work in the same way.
It is called when function is entered.
It gets incoming arguments information by CCInfo(CallConv,..., ArgLocs, ...)
before entering <strong>“for loop”</strong>. In ch9_1.cpp, there are 6 arguments in sum_i(...)
function call.
So ArgLocs.size() is 6, each argument information is in ArgLocs[i].
When VA.isRegLoc() is true, meaning the arguement passes in register. On the
contrary, when VA.isMemLoc() is true, meaning the arguement pass in memory
stack.
When passing in register, it marks the register &#8220;live in&#8221; and copy directly
from the register.
When passing in memory stack, it creates stack offset for this frame index
object and load node with the created stack offset, and then puts the load node
into vector InVals.</p>
<p>When <code class="docutils literal"><span class="pre">llc</span> <span class="pre">-cpu0-s32-calls=false</span></code> it passes first two arguments registers
and the other arguments in stack frame. When <code class="docutils literal"><span class="pre">llc</span> <span class="pre">-cpu0-s32-calls=true</span></code> it
passes all arguments in stack frame.</p>
<p>Before taking care the arguments as above, it calls analyzeFormalArguments().
In analyzeFormalArguments() it calls fixedArgFn() which return the function
pointer of CC_Cpu0O32() or CC_Cpu0S32().
ArgFlags.isByVal() will be true when it meets &#8220;struct pointer byval&#8221; keyword,
such as &#8220;%struct.S* byval&#8221; in tailcall.ll.
When <code class="docutils literal"><span class="pre">llc</span> <span class="pre">-cpu0-s32-calls=false</span></code> the stack offset begin from 8 (in case the
arguement registers need spill out) while <code class="docutils literal"><span class="pre">llc</span> <span class="pre">-cpu0-s32-calls=true</span></code> stack
offset begin from 0.</p>
<p>For instance of example code ch9_1.cpp with <code class="docutils literal"><span class="pre">llc</span> <span class="pre">-cpu0-s32-calls=true</span></code> (using
memory stack only to pass arguments), LowerFormalArguments()
will be called twice. First time is for sum_i() which will create 6 &#8220;load DAGs&#8221;
for 6 incoming arguments passing into this function.
Second time is for main() which won&#8217;t create any &#8220;load DAG&#8221; since no incoming
argument passing into main().
In addition to LowerFormalArguments() which creates the &#8220;load DAG&#8221;, we need
loadRegFromStackSlot() (defined in the early chapter) to issue the machine
instruction
<strong>“ld $r, offset($sp)”</strong> to load incoming arguments from stack frame offset.
GetMemOperand(..., FI, ...) return the Memory location of the frame index
variable, which is the offset.</p>
<p>For input ch9_incoming.cpp as below, LowerFormalArguments() will generate the
red box parts of DAG nodes shown as the next two figures for
<code class="docutils literal"><span class="pre">llc</span> <span class="pre">-cpu0-s32-calls=true</span></code> and <code class="docutils literal"><span class="pre">llc</span> <span class="pre">-cpu0-s32-calls=false</span></code>, respectively.
The root node at bottom is created by</p>
<p class="rubric">lbdex/input/ch9_incoming.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">sum_i</span><span class="p">(</span><span class="nb">int</span> <span class="n">x1</span><span class="p">,</span> <span class="nb">int</span> <span class="n">x2</span><span class="p">,</span> <span class="nb">int</span> <span class="n">x3</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="nb">sum</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span> <span class="o">+</span> <span class="n">x3</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="nb">sum</span><span class="p">;</span> 
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$</span> clang -O3 -target mips-unknown-linux-gnu -c
<span class="go">ch9_incoming.cpp -emit-llvm -o ch9_incoming.bc</span>
<span class="gp">JonathantekiiMac:input Jonathan$</span> /Users/Jonathan/llvm/test/cmake_debug_build/
<span class="go">Debug/bin/llvm-dis ch9_incoming.bc -o -</span>
<span class="go">...</span>
<span class="go">define i32 @_Z5sum_iiii(i32 %x1, i32 %x2, i32 %x3) #0 {</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> add nsw i32 %x2, %x1
<span class="gp">  %</span><span class="nv">2</span> <span class="o">=</span> add nsw i32 %1, %x3
<span class="go">  ret i32 %2</span>
<span class="go">}</span>
</pre></div>
</div>
<img src="_images/graphviz-a2c0091df95214306672a11eee96a25a3525d7d2.png" alt="digraph &quot;dag-combine1 input for _Z5sum_iiii:&quot; {
	rankdir=&quot;BT&quot;;
	label=&quot;Incoming arguments DAG created for ch9_incoming.cpp with -cpu0-s32-calls=true&quot;;

  subgraph cluster_0 {
    fontcolor=red;
    fontsize=24;
    label = &quot;LowerFormalArguments&quot;;
	Node0x102f0dbe0 [shape=record,shape=Mrecord,label=&quot;{EntryToken|t0|{&lt;d0&gt;ch}}&quot;];
	Node0x10304e800 [shape=record,shape=Mrecord,label=&quot;{FrameIndex\&lt;-1\&gt;|t1|{&lt;d0&gt;i32}}&quot;];
	Node0x10304e870 [shape=record,shape=Mrecord,label=&quot;{undef|t2|{&lt;d0&gt;i32}}&quot;];
	Node0x10304e8e0 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1|&lt;s2&gt;2}|load\&lt;LD4[FixedStack-1]\&gt;|t3|{&lt;d0&gt;i32|&lt;d1&gt;ch}}&quot;];
	Node0x10304e8e0:s0 -&gt; Node0x102f0dbe0:d0[color=blue,style=dashed];
	Node0x10304e8e0:s1 -&gt; Node0x10304e800:d0;
	Node0x10304e8e0:s2 -&gt; Node0x10304e870:d0;
	Node0x10304e950 [shape=record,shape=Mrecord,label=&quot;{FrameIndex\&lt;-2\&gt;|t4|{&lt;d0&gt;i32}}&quot;];
	Node0x10304e9c0 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1|&lt;s2&gt;2}|load\&lt;LD4[FixedStack-2]\&gt;|t5|{&lt;d0&gt;i32|&lt;d1&gt;ch}}&quot;];
	Node0x10304e9c0:s0 -&gt; Node0x102f0dbe0:d0[color=blue,style=dashed];
	Node0x10304e9c0:s1 -&gt; Node0x10304e950:d0;
	Node0x10304e9c0:s2 -&gt; Node0x10304e870:d0;
	Node0x10304ea30 [shape=record,shape=Mrecord,label=&quot;{FrameIndex\&lt;-3\&gt;|t6|{&lt;d0&gt;i32}}&quot;];
	Node0x10304eaa0 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1|&lt;s2&gt;2}|load\&lt;LD4[FixedStack-3]\&gt;|t7|{&lt;d0&gt;i32|&lt;d1&gt;ch}}&quot;];
	Node0x10304eaa0:s0 -&gt; Node0x102f0dbe0:d0[color=blue,style=dashed];
	Node0x10304eaa0:s1 -&gt; Node0x10304ea30:d0;
	Node0x10304eaa0:s2 -&gt; Node0x10304e870:d0;
	Node0x10304eb10 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1|&lt;s2&gt;2|&lt;s3&gt;3}|TokenFactor|t8|{&lt;d0&gt;ch}}&quot;];
	Node0x10304eb10:s0 -&gt; Node0x10304e8e0:d1[color=blue,style=dashed];
	Node0x10304eb10:s1 -&gt; Node0x10304e9c0:d1[color=blue,style=dashed];
	Node0x10304eb10:s2 -&gt; Node0x10304eaa0:d1[color=blue,style=dashed];
	Node0x10304eb10:s3 -&gt; Node0x102f0dbe0:d0[color=blue,style=dashed];
	Node0x10304eb80 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1}|add|t9|{&lt;d0&gt;i32}}&quot;];
	Node0x10304eb80:s0 -&gt; Node0x10304e9c0:d0;
	Node0x10304eb80:s1 -&gt; Node0x10304e8e0:d0;
	Node0x10304ebf0 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1}|add|t10|{&lt;d0&gt;i32}}&quot;];
	Node0x10304ebf0:s0 -&gt; Node0x10304eb80:d0;
	Node0x10304ebf0:s1 -&gt; Node0x10304eaa0:d0;
	Node0x10304ec60 [shape=record,shape=Mrecord,label=&quot;{Register %V0|t11|{&lt;d0&gt;i32}}&quot;];
  }
  subgraph cluster_1 {
    fontcolor=red;
    fontsize=24;
    label = &quot;LowerReturn&quot;;
	Node0x10304ecd0 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1|&lt;s2&gt;2}|CopyToReg|t12|{&lt;d0&gt;ch|&lt;d1&gt;glue}}&quot;];
	Node0x10304ecd0:s0 -&gt; Node0x10304eb10:d0[color=blue,style=dashed];
	Node0x10304ecd0:s1 -&gt; Node0x10304ec60:d0;
	Node0x10304ecd0:s2 -&gt; Node0x10304ebf0:d0;
	Node0x10304ed40 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1|&lt;s2&gt;2}|Cpu0ISD::Ret|t13|{&lt;d0&gt;ch}}&quot;];
	Node0x10304ed40:s0 -&gt; Node0x10304ecd0:d0[color=blue,style=dashed];
	Node0x10304ed40:s1 -&gt; Node0x10304ec60:d0;
	Node0x10304ed40:s2 -&gt; Node0x10304ecd0:d1[color=red,style=bold];
  }
	Node0x0[ plaintext=circle, label =&quot;GraphRoot&quot;];
	Node0x0 -&gt; Node0x10304ed40:d0[color=blue,style=dashed];
}" />
<img src="_images/graphviz-fcad19b86b2989d5003a167de8394ec809e8b13c.png" alt="digraph &quot;dag-combine1 input for _Z5sum_iiii:&quot; {
	rankdir=&quot;BT&quot;;
	label=&quot;Figure: Incoming arguments DAG created for ch9_incoming.cpp with -cpu0-s32-calls=false&quot;;

  subgraph cluster_0 {
    fontcolor=red;
    fontsize=24;
    label = &quot;LowerFormalArguments&quot;;
	Node0x102f0e0f0 [shape=record,shape=Mrecord,label=&quot;{EntryToken|t0|{&lt;d0&gt;ch}}&quot;];
	Node0x10305c200 [shape=record,shape=Mrecord,label=&quot;{Register %vreg0|t1|{&lt;d0&gt;i32}}&quot;];
	Node0x10305c270 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1}|CopyFromReg|t2|{&lt;d0&gt;i32|&lt;d1&gt;ch}}&quot;];
	Node0x10305c270:s0 -&gt; Node0x102f0e0f0:d0[color=blue,style=dashed];
	Node0x10305c270:s1 -&gt; Node0x10305c200:d0;
	Node0x10305c2e0 [shape=record,shape=Mrecord,label=&quot;{Register %vreg1|t3|{&lt;d0&gt;i32}}&quot;];
	Node0x10305c350 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1}|CopyFromReg|t4|{&lt;d0&gt;i32|&lt;d1&gt;ch}}&quot;];
	Node0x10305c350:s0 -&gt; Node0x102f0e0f0:d0[color=blue,style=dashed];
	Node0x10305c350:s1 -&gt; Node0x10305c2e0:d0;
	Node0x10305c3c0 [shape=record,shape=Mrecord,label=&quot;{FrameIndex\&lt;-1\&gt;|t5|{&lt;d0&gt;i32}}&quot;];
	Node0x10305c430 [shape=record,shape=Mrecord,label=&quot;{undef|t6|{&lt;d0&gt;i32}}&quot;];
	Node0x10305c4a0 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1|&lt;s2&gt;2}|load\&lt;LD4[FixedStack-1]\&gt;|t7|{&lt;d0&gt;i32|&lt;d1&gt;ch}}&quot;];
	Node0x10305c4a0:s0 -&gt; Node0x102f0e0f0:d0[color=blue,style=dashed];
	Node0x10305c4a0:s1 -&gt; Node0x10305c3c0:d0;
	Node0x10305c4a0:s2 -&gt; Node0x10305c430:d0;
	Node0x10305c510 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1}|add|t8|{&lt;d0&gt;i32}}&quot;];
	Node0x10305c510:s0 -&gt; Node0x10305c350:d0;
	Node0x10305c510:s1 -&gt; Node0x10305c270:d0;
	Node0x10305c580 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1}|add|t9|{&lt;d0&gt;i32}}&quot;];
	Node0x10305c580:s0 -&gt; Node0x10305c510:d0;
	Node0x10305c580:s1 -&gt; Node0x10305c4a0:d0;
	Node0x10305c5f0 [shape=record,shape=Mrecord,label=&quot;{Register %V0|t10|{&lt;d0&gt;i32}}&quot;];
  }
  subgraph cluster_1 {
    fontcolor=red;
    fontsize=24;
    label = &quot;LowerReturn&quot;;
	Node0x10305c660 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1|&lt;s2&gt;2}|CopyToReg|t11|{&lt;d0&gt;ch|&lt;d1&gt;glue}}&quot;];
	Node0x10305c660:s0 -&gt; Node0x10305c4a0:d1[color=blue,style=dashed];
	Node0x10305c660:s1 -&gt; Node0x10305c5f0:d0;
	Node0x10305c660:s2 -&gt; Node0x10305c580:d0;
	Node0x10305c6d0 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1|&lt;s2&gt;2}|Cpu0ISD::Ret|t12|{&lt;d0&gt;ch}}&quot;];
	Node0x10305c6d0:s0 -&gt; Node0x10305c660:d0[color=blue,style=dashed];
	Node0x10305c6d0:s1 -&gt; Node0x10305c5f0:d0;
	Node0x10305c6d0:s2 -&gt; Node0x10305c660:d1[color=red,style=bold];
  }
	Node0x0[ plaintext=circle, label =&quot;GraphRoot&quot;];
	Node0x0 -&gt; Node0x10305c6d0:d0[color=blue,style=dashed];
}" />
<p>In addition to Calling Convention and LowerFormalArguments(), Chapter9_1/ adds
the following code for the instruction selection and printing of Cpu0
instructions <strong>swi</strong> (Software Interrupt), <strong>jsub</strong> and <strong>jalr</strong> (function call).</p>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0InstrInfo.td</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">SDT_Cpu0JmpLink</span>      <span class="p">:</span> <span class="n">SDTypeProfile</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="n">SDTCisVT</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">iPTR</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Call</span>
<span class="k">def</span> <span class="nf">Cpu0JmpLink</span> <span class="p">:</span> <span class="n">SDNode</span><span class="o">&lt;</span><span class="s2">&quot;Cpu0ISD::JmpLink&quot;</span><span class="p">,</span><span class="n">SDT_Cpu0JmpLink</span><span class="p">,</span>
                         <span class="p">[</span><span class="n">SDNPHasChain</span><span class="p">,</span> <span class="n">SDNPOutGlue</span><span class="p">,</span> <span class="n">SDNPOptInGlue</span><span class="p">,</span>
                          <span class="n">SDNPVariadic</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">IsTailCall</span> <span class="p">{</span>
  <span class="n">bit</span> <span class="n">isCall</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">bit</span> <span class="n">isTerminator</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">bit</span> <span class="n">isReturn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">bit</span> <span class="n">isBarrier</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">bit</span> <span class="n">hasExtraSrcRegAllocReq</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">bit</span> <span class="n">isCodeGenOnly</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">calltarget</span>  <span class="p">:</span> <span class="n">Operand</span><span class="o">&lt;</span><span class="n">iPTR</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">let</span> <span class="n">EncoderMethod</span> <span class="o">=</span> <span class="s2">&quot;getJumpTargetOpValue&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>let Predicates = [Ch9_1] in {
// Jump and Link (Call)
let isCall=1, hasDelaySlot=1 in {
  //@JumpLink {
  class JumpLink&lt;bits&lt;8&gt; op, string instr_asm&gt;:
    FJ&lt;op, (outs), (ins calltarget:$target, variable_ops),
       !strconcat(instr_asm, &quot;\t$target&quot;), [(Cpu0JmpLink imm:$target)],
       IIBranch&gt; {
//#if CH &gt;= CH10_1 2
       let DecoderMethod = &quot;DecodeJumpTarget&quot;;
//#endif
       }
  //@JumpLink }

  class JumpLinkReg&lt;bits&lt;8&gt; op, string instr_asm,
                    RegisterClass RC&gt;:
    FA&lt;op, (outs), (ins RC:$rb, variable_ops),
       !strconcat(instr_asm, &quot;\t$rb&quot;), [(Cpu0JmpLink RC:$rb)], IIBranch&gt; {
    let rc = 0;
    let ra = 14;
    let shamt = 0;
  }
}

</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">///</span> <span class="n">Jump</span> <span class="o">&amp;</span> <span class="n">link</span> <span class="ow">and</span> <span class="n">Return</span> <span class="n">Instructions</span>
<span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ch9_1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">{</span>
<span class="k">def</span> <span class="nf">JSUB</span>    <span class="p">:</span> <span class="n">JumpLink</span><span class="o">&lt;</span><span class="mh">0x3b</span><span class="p">,</span> <span class="s2">&quot;jsub&quot;</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ch9_1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">{</span>
<span class="k">def</span> <span class="nf">JALR</span>    <span class="p">:</span> <span class="n">JumpLinkReg</span><span class="o">&lt;</span><span class="mh">0x39</span><span class="p">,</span> <span class="s2">&quot;jalr&quot;</span><span class="p">,</span> <span class="n">GPROut</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>let Predicates = [Ch9_1] in {
def : Pat&lt;(Cpu0JmpLink (i32 tglobaladdr:$dst)),
          (JSUB tglobaladdr:$dst)&gt;;
def : Pat&lt;(Cpu0JmpLink (i32 texternalsym:$dst)),
          (JSUB texternalsym:$dst)&gt;;

</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0MCInstLower.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MCOperand</span> <span class="n">Cpu0MCInstLower</span><span class="p">::</span><span class="n">LowerSymbolOperand</span><span class="p">(</span><span class="n">const</span> <span class="n">MachineOperand</span> <span class="o">&amp;</span><span class="n">MO</span><span class="p">,</span>
                                              <span class="n">MachineOperandType</span> <span class="n">MOTy</span><span class="p">,</span>
                                              <span class="n">unsigned</span> <span class="n">Offset</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VariantKind</span> <span class="n">Kind</span> <span class="o">=</span> <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VK_None</span><span class="p">;</span>
  <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">Cpu0ExprKind</span> <span class="n">TargetKind</span> <span class="o">=</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_None</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">MCSymbol</span> <span class="o">*</span><span class="n">Symbol</span><span class="p">;</span>

  <span class="n">switch</span><span class="p">(</span><span class="n">MO</span><span class="o">.</span><span class="n">getTargetFlags</span><span class="p">())</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="n">case</span> <span class="n">Cpu0II</span><span class="p">::</span><span class="n">MO_GOT_CALL</span><span class="p">:</span>
    <span class="n">TargetKind</span> <span class="o">=</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_GOT_CALL</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="p">...</span>
  <span class="p">}</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">MOTy</span><span class="p">)</span> <span class="p">{</span>
<span class="p">.</span> <span class="p">...</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="n">case</span> <span class="n">MachineOperand</span><span class="p">::</span><span class="n">MO_ExternalSymbol</span><span class="p">:</span>
    <span class="n">Symbol</span> <span class="o">=</span> <span class="n">AsmPrinter</span><span class="o">.</span><span class="n">GetExternalSymbolSymbol</span><span class="p">(</span><span class="n">MO</span><span class="o">.</span><span class="n">getSymbolName</span><span class="p">());</span>
    <span class="n">Offset</span> <span class="o">+=</span> <span class="n">MO</span><span class="o">.</span><span class="n">getOffset</span><span class="p">();</span>
    <span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="p">...</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MCOperand</span> <span class="n">Cpu0MCInstLower</span><span class="p">::</span><span class="n">LowerOperand</span><span class="p">(</span><span class="n">const</span> <span class="n">MachineOperand</span><span class="o">&amp;</span> <span class="n">MO</span><span class="p">,</span>
                                        <span class="n">unsigned</span> <span class="n">offset</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="n">MachineOperandType</span> <span class="n">MOTy</span> <span class="o">=</span> <span class="n">MO</span><span class="o">.</span><span class="n">getType</span><span class="p">();</span>

  <span class="n">switch</span> <span class="p">(</span><span class="n">MOTy</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">//</span><span class="nd">@2</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="n">case</span> <span class="n">MachineOperand</span><span class="p">::</span><span class="n">MO_ExternalSymbol</span><span class="p">:</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>    <span class="k">return</span> <span class="n">LowerSymbolOperand</span><span class="p">(</span><span class="n">MO</span><span class="p">,</span> <span class="n">MOTy</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="p">...</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_1/MCTargetDesc/Cpu0AsmBackend.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Prepare</span> <span class="n">value</span> <span class="k">for</span> <span class="n">the</span> <span class="n">target</span> <span class="n">space</span> <span class="k">for</span> <span class="n">it</span>
<span class="n">static</span> <span class="n">unsigned</span> <span class="n">adjustFixupValue</span><span class="p">(</span><span class="n">const</span> <span class="n">MCFixup</span> <span class="o">&amp;</span><span class="n">Fixup</span><span class="p">,</span> <span class="n">uint64_t</span> <span class="n">Value</span><span class="p">,</span>
                                 <span class="n">MCContext</span> <span class="o">*</span><span class="n">Ctx</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">)</span> <span class="p">{</span>

  <span class="n">unsigned</span> <span class="n">Kind</span> <span class="o">=</span> <span class="n">Fixup</span><span class="o">.</span><span class="n">getKind</span><span class="p">();</span>

  <span class="o">//</span> <span class="n">Add</span><span class="o">/</span><span class="n">subtract</span> <span class="ow">and</span> <span class="n">shift</span>
  <span class="n">switch</span> <span class="p">(</span><span class="n">Kind</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="n">case</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_CALL16</span><span class="p">:</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="p">...</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_1/MCTargetDesc/Cpu0ELFObjectWriter.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">unsigned</span> <span class="n">Cpu0ELFObjectWriter</span><span class="p">::</span><span class="n">getRelocType</span><span class="p">(</span><span class="n">MCContext</span> <span class="o">&amp;</span><span class="n">Ctx</span><span class="p">,</span>
                                           <span class="n">const</span> <span class="n">MCValue</span> <span class="o">&amp;</span><span class="n">Target</span><span class="p">,</span>
                                           <span class="n">const</span> <span class="n">MCFixup</span> <span class="o">&amp;</span><span class="n">Fixup</span><span class="p">,</span>
                                           <span class="nb">bool</span> <span class="n">IsPCRel</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="o">//</span> <span class="n">determine</span> <span class="n">the</span> <span class="nb">type</span> <span class="n">of</span> <span class="n">the</span> <span class="n">relocation</span>
  <span class="n">unsigned</span> <span class="n">Type</span> <span class="o">=</span> <span class="p">(</span><span class="n">unsigned</span><span class="p">)</span><span class="n">ELF</span><span class="p">::</span><span class="n">R_CPU0_NONE</span><span class="p">;</span>
  <span class="n">unsigned</span> <span class="n">Kind</span> <span class="o">=</span> <span class="p">(</span><span class="n">unsigned</span><span class="p">)</span><span class="n">Fixup</span><span class="o">.</span><span class="n">getKind</span><span class="p">();</span>

  <span class="n">switch</span> <span class="p">(</span><span class="n">Kind</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="n">case</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_CALL16</span><span class="p">:</span>
    <span class="n">Type</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">::</span><span class="n">R_CPU0_CALL16</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="p">...</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_1/MCTargetDesc/Cpu0FixupKinds.h</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="n">enum</span> <span class="n">Fixups</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>    <span class="o">//</span> <span class="n">resulting</span> <span class="ow">in</span> <span class="o">-</span> <span class="n">R_CPU0_CALL16</span><span class="o">.</span>
    <span class="n">fixup_Cpu0_CALL16</span><span class="p">,</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>    <span class="p">...</span>
<span class="p">.</span> <span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_1/MCTargetDesc/Cpu0MCCodeEmitter.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">unsigned</span> <span class="n">Cpu0MCCodeEmitter</span><span class="p">::</span>
<span class="n">getJumpTargetOpValue</span><span class="p">(</span><span class="n">const</span> <span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">OpNo</span><span class="p">,</span>
                     <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCFixup</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Fixups</span><span class="p">,</span>
                     <span class="n">const</span> <span class="n">MCSubtargetInfo</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="k">if</span> <span class="p">(</span><span class="n">Opcode</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">JSUB</span> <span class="o">||</span> <span class="n">Opcode</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">JMP</span> <span class="o">||</span> <span class="n">Opcode</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">BAL</span><span class="p">)</span>
<span class="c1">#elif CH &gt;= CH8_2 //1</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Opcode</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">JMP</span> <span class="o">||</span> <span class="n">Opcode</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">BAL</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>    <span class="n">Fixups</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">MCFixup</span><span class="p">::</span><span class="n">create</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Expr</span><span class="p">,</span>
                                     <span class="n">MCFixupKind</span><span class="p">(</span><span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_PC24</span><span class="p">)));</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">unsigned</span> <span class="n">Cpu0MCCodeEmitter</span><span class="p">::</span>
<span class="n">getExprOpValue</span><span class="p">(</span><span class="n">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">Expr</span><span class="p">,</span><span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCFixup</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Fixups</span><span class="p">,</span>
               <span class="n">const</span> <span class="n">MCSubtargetInfo</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span>    <span class="n">switch</span><span class="p">(</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">MCSymbolRefExpr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Expr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">getKind</span><span class="p">())</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>    <span class="n">case</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_GOT_CALL</span><span class="p">:</span>
      <span class="n">FixupKind</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_CALL16</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="p">...</span>
  <span class="p">}</span>
<span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0MachineFunction.h</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">///</span> <span class="n">Cpu0FunctionInfo</span> <span class="o">-</span> <span class="n">This</span> <span class="k">class</span> <span class="nc">is</span> <span class="n">derived</span> <span class="kn">from</span> <span class="nn">MachineFunction</span> <span class="n">private</span>
<span class="o">///</span> <span class="n">Cpu0</span> <span class="n">target</span><span class="o">-</span><span class="n">specific</span> <span class="n">information</span> <span class="k">for</span> <span class="n">each</span> <span class="n">MachineFunction</span><span class="o">.</span>
<span class="k">class</span> <span class="nc">Cpu0FunctionInfo</span> <span class="p">:</span> <span class="n">public</span> <span class="n">MachineFunctionInfo</span> <span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
  <span class="n">Cpu0FunctionInfo</span><span class="p">(</span><span class="n">MachineFunction</span><span class="o">&amp;</span> <span class="n">MF</span><span class="p">)</span>
  <span class="p">:</span> <span class="n">MF</span><span class="p">(</span><span class="n">MF</span><span class="p">),</span> 
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>    <span class="n">InArgFIRange</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">make_pair</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span>
    <span class="n">OutArgFIRange</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">make_pair</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="n">GPFI</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">DynAllocFI</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="nb">bool</span> <span class="n">isInArgFI</span><span class="p">(</span><span class="nb">int</span> <span class="n">FI</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">FI</span> <span class="o">&lt;=</span> <span class="n">InArgFIRange</span><span class="o">.</span><span class="n">first</span> <span class="o">&amp;&amp;</span> <span class="n">FI</span> <span class="o">&gt;=</span> <span class="n">InArgFIRange</span><span class="o">.</span><span class="n">second</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">void</span> <span class="n">setLastInArgFI</span><span class="p">(</span><span class="nb">int</span> <span class="n">FI</span><span class="p">)</span> <span class="p">{</span> <span class="n">InArgFIRange</span><span class="o">.</span><span class="n">second</span> <span class="o">=</span> <span class="n">FI</span><span class="p">;</span> <span class="p">}</span>
  <span class="nb">bool</span> <span class="n">isOutArgFI</span><span class="p">(</span><span class="nb">int</span> <span class="n">FI</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">FI</span> <span class="o">&lt;=</span> <span class="n">OutArgFIRange</span><span class="o">.</span><span class="n">first</span> <span class="o">&amp;&amp;</span> <span class="n">FI</span> <span class="o">&gt;=</span> <span class="n">OutArgFIRange</span><span class="o">.</span><span class="n">second</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="nb">int</span> <span class="n">getGPFI</span><span class="p">()</span> <span class="n">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">GPFI</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">void</span> <span class="n">setGPFI</span><span class="p">(</span><span class="nb">int</span> <span class="n">FI</span><span class="p">)</span> <span class="p">{</span> <span class="n">GPFI</span> <span class="o">=</span> <span class="n">FI</span><span class="p">;</span> <span class="p">}</span>
  <span class="nb">bool</span> <span class="n">isGPFI</span><span class="p">(</span><span class="nb">int</span> <span class="n">FI</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">GPFI</span> <span class="o">&amp;&amp;</span> <span class="n">GPFI</span> <span class="o">==</span> <span class="n">FI</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>
  <span class="nb">bool</span> <span class="n">isDynAllocFI</span><span class="p">(</span><span class="nb">int</span> <span class="n">FI</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">DynAllocFI</span> <span class="o">&amp;&amp;</span> <span class="n">DynAllocFI</span> <span class="o">==</span> <span class="n">FI</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  // Range of frame object indices.
  // InArgFIRange: Range of indices of all frame objects created during call to
  //               LowerFormalArguments.
  // OutArgFIRange: Range of indices of all frame objects created during call to
  //                LowerCall except for the frame object for restoring $gp.
  std::pair&lt;int, int&gt; InArgFIRange, OutArgFIRange;
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="n">mutable</span> <span class="nb">int</span> <span class="n">DynAllocFI</span><span class="p">;</span> <span class="o">//</span> <span class="n">Frame</span> <span class="n">index</span> <span class="n">of</span> <span class="n">dynamically</span> <span class="n">allocated</span> <span class="n">stack</span> <span class="n">area</span><span class="o">.</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0SEFrameLowering.h</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="nb">bool</span> <span class="n">spillCalleeSavedRegisters</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span>
                                 <span class="n">MachineBasicBlock</span><span class="p">::</span><span class="n">iterator</span> <span class="n">MI</span><span class="p">,</span>
                                 <span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">CalleeSavedInfo</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">CSI</span><span class="p">,</span>
                                 <span class="n">const</span> <span class="n">TargetRegisterInfo</span> <span class="o">*</span><span class="n">TRI</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0SEFrameLowering.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>bool Cpu0SEFrameLowering::
spillCalleeSavedRegisters(MachineBasicBlock &amp;MBB,
                          MachineBasicBlock::iterator MI,
                          const std::vector&lt;CalleeSavedInfo&gt; &amp;CSI,
                          const TargetRegisterInfo *TRI) const {
  MachineFunction *MF = MBB.getParent();
  MachineBasicBlock *EntryBlock = &amp;MF-&gt;front();
  const TargetInstrInfo &amp;TII = *MF-&gt;getSubtarget().getInstrInfo();

  for (unsigned i = 0, e = CSI.size(); i != e; ++i) {
    // Add the callee-saved register as live-in. Do not add if the register is
    // LR and return address is taken, because it has already been added in
    // method Cpu0TargetLowering::LowerRETURNADDR.
    // It&#39;s killed at the spill, unless the register is LR and return address
    // is taken.
    unsigned Reg = CSI[i].getReg();
    bool IsRAAndRetAddrIsTaken = (Reg == Cpu0::LR)
        &amp;&amp; MF-&gt;getFrameInfo()-&gt;isReturnAddressTaken();
    if (!IsRAAndRetAddrIsTaken)
      EntryBlock-&gt;addLiveIn(Reg);

    // Insert the spill to the stack frame.
    bool IsKill = !IsRAAndRetAddrIsTaken;
    const TargetRegisterClass *RC = TRI-&gt;getMinimalPhysRegClass(Reg);
    TII.storeRegToStackSlot(*EntryBlock, MI, Reg, IsKill,
                            CSI[i].getFrameIdx(), RC, TRI);
  }

  return true;
}
</pre></div>
</div>
<p>Both JSUB and JALR defined in Cpu0InstrInfo.td as above use Cpu0JmpLink
node. They are distinguishable since JSUB use &#8220;imm&#8221; operand while
JALR uses register operand.</p>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0InstrInfo.td</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>let Predicates = [Ch9_1] in {
def : Pat&lt;(Cpu0JmpLink (i32 tglobaladdr:$dst)),
          (JSUB tglobaladdr:$dst)&gt;;
def : Pat&lt;(Cpu0JmpLink (i32 texternalsym:$dst)),
          (JSUB texternalsym:$dst)&gt;;

</pre></div>
</div>
<p>The code tells TableGen generating pattern match code that matching the &#8220;imm&#8221; for
&#8220;tglobaladdr&#8221; pattern first. If it fails then trying to match &#8220;texternalsym&#8221; next.
The function you declared belongs to &#8220;tglobaladdr&#8221;, (for instance the function
sum_i(...) defined in ch9_1.cpp belongs to &#8220;tglobaladdr&#8221;); the function which
implicitly used by llvm belongs to &#8220;texternalsym&#8221; (for instance the function
&#8220;memcpy&#8221; belongs to &#8220;texternalsym&#8221;). The &#8220;memcpy&#8221; will be generated when
defining a long string. The ch9_1_2.cpp is an example for generating &#8220;memcpy&#8221;
function call. It will be shown in next section with Chapter9_2 example code.
Cpu0GenDAGISel.inc contains pattern matched information of JSUB and JALR
which generated from TablGen as follows,</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span>          <span class="cm">/*SwitchOpcode*/</span> <span class="mi">74</span><span class="p">,</span>  <span class="n">TARGET_VAL</span><span class="p">(</span><span class="n">Cpu0ISD</span><span class="o">::</span><span class="n">JmpLink</span><span class="p">),</span><span class="c1">// -&gt;734</span>
<span class="cm">/*660*/</span>     <span class="n">OPC_RecordNode</span><span class="p">,</span>   <span class="c1">// #0 = &#39;Cpu0JmpLink&#39; chained node</span>
<span class="cm">/*661*/</span>     <span class="n">OPC_CaptureGlueInput</span><span class="p">,</span>
<span class="cm">/*662*/</span>     <span class="n">OPC_RecordChild1</span><span class="p">,</span> <span class="c1">// #1 = $target</span>
<span class="cm">/*663*/</span>     <span class="n">OPC_Scope</span><span class="p">,</span> <span class="mi">57</span><span class="p">,</span> <span class="cm">/*-&gt;722*/</span> <span class="c1">// 2 children in Scope</span>
<span class="cm">/*665*/</span>       <span class="n">OPC_MoveChild</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
<span class="cm">/*667*/</span>       <span class="n">OPC_SwitchOpcode</span> <span class="cm">/*3 cases */</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span>  <span class="n">TARGET_VAL</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">Constant</span><span class="p">),</span>
<span class="c1">// -&gt;693</span>
<span class="cm">/*671*/</span>         <span class="n">OPC_MoveParent</span><span class="p">,</span>
<span class="cm">/*672*/</span>         <span class="n">OPC_EmitMergeInputChains1_0</span><span class="p">,</span>
<span class="cm">/*673*/</span>         <span class="n">OPC_EmitConvertToTarget</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
<span class="cm">/*675*/</span>         <span class="n">OPC_Scope</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="cm">/*-&gt;684*/</span> <span class="c1">// 2 children in Scope</span>
<span class="cm">/*684*/</span>         <span class="cm">/*Scope*/</span> <span class="mi">7</span><span class="p">,</span> <span class="cm">/*-&gt;692*/</span>
<span class="cm">/*685*/</span>           <span class="n">OPC_MorphNodeTo</span><span class="p">,</span> <span class="n">TARGET_VAL</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">JSUB</span><span class="p">),</span> <span class="mi">0</span><span class="o">|</span><span class="n">OPFL_Chain</span><span class="o">|</span>
<span class="n">OPFL_GlueInput</span><span class="o">|</span><span class="n">OPFL_GlueOutput</span><span class="o">|</span><span class="n">OPFL_Variadic1</span><span class="p">,</span>
                      <span class="mi">0</span><span class="cm">/*#VTs*/</span><span class="p">,</span> <span class="mi">1</span><span class="cm">/*#Ops*/</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
                  <span class="c1">// Src: (Cpu0JmpLink (imm:iPTR):$target) - Complexity = 6</span>
                  <span class="c1">// Dst: (JSUB (imm:iPTR):$target)</span>
<span class="cm">/*692*/</span>         <span class="mi">0</span><span class="p">,</span> <span class="cm">/*End of Scope*/</span>
              <span class="cm">/*SwitchOpcode*/</span> <span class="mi">11</span><span class="p">,</span>  <span class="n">TARGET_VAL</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">TargetGlobalAddress</span><span class="p">),</span><span class="c1">// -&gt;707</span>
<span class="cm">/*696*/</span>         <span class="n">OPC_CheckType</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span>
<span class="cm">/*698*/</span>         <span class="n">OPC_MoveParent</span><span class="p">,</span>
<span class="cm">/*699*/</span>         <span class="n">OPC_EmitMergeInputChains1_0</span><span class="p">,</span>
<span class="cm">/*700*/</span>         <span class="n">OPC_MorphNodeTo</span><span class="p">,</span> <span class="n">TARGET_VAL</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">JSUB</span><span class="p">),</span> <span class="mi">0</span><span class="o">|</span><span class="n">OPFL_Chain</span><span class="o">|</span>
<span class="n">OPFL_GlueInput</span><span class="o">|</span><span class="n">OPFL_GlueOutput</span><span class="o">|</span><span class="n">OPFL_Variadic1</span><span class="p">,</span>
                    <span class="mi">0</span><span class="cm">/*#VTs*/</span><span class="p">,</span> <span class="mi">1</span><span class="cm">/*#Ops*/</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
                <span class="c1">// Src: (Cpu0JmpLink (tglobaladdr:i32):$dst) - Complexity = 6</span>
                <span class="c1">// Dst: (JSUB (tglobaladdr:i32):$dst)</span>
              <span class="cm">/*SwitchOpcode*/</span> <span class="mi">11</span><span class="p">,</span>  <span class="n">TARGET_VAL</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">TargetExternalSymbol</span><span class="p">),</span><span class="c1">// -&gt;721</span>
<span class="cm">/*710*/</span>         <span class="n">OPC_CheckType</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span>
<span class="cm">/*712*/</span>         <span class="n">OPC_MoveParent</span><span class="p">,</span>
<span class="cm">/*713*/</span>         <span class="n">OPC_EmitMergeInputChains1_0</span><span class="p">,</span>
<span class="cm">/*714*/</span>         <span class="n">OPC_MorphNodeTo</span><span class="p">,</span> <span class="n">TARGET_VAL</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">JSUB</span><span class="p">),</span> <span class="mi">0</span><span class="o">|</span><span class="n">OPFL_Chain</span><span class="o">|</span>
<span class="n">OPFL_GlueInput</span><span class="o">|</span><span class="n">OPFL_GlueOutput</span><span class="o">|</span><span class="n">OPFL_Variadic1</span><span class="p">,</span>
                    <span class="mi">0</span><span class="cm">/*#VTs*/</span><span class="p">,</span> <span class="mi">1</span><span class="cm">/*#Ops*/</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
                <span class="c1">// Src: (Cpu0JmpLink (texternalsym:i32):$dst) - Complexity = 6</span>
                <span class="c1">// Dst: (JSUB (texternalsym:i32):$dst)</span>
              <span class="mi">0</span><span class="p">,</span> <span class="c1">// EndSwitchOpcode</span>
<span class="cm">/*722*/</span>     <span class="cm">/*Scope*/</span> <span class="mi">10</span><span class="p">,</span> <span class="cm">/*-&gt;733*/</span>
<span class="cm">/*723*/</span>       <span class="n">OPC_CheckChild1Type</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span>
<span class="cm">/*725*/</span>       <span class="n">OPC_EmitMergeInputChains1_0</span><span class="p">,</span>
<span class="cm">/*726*/</span>       <span class="n">OPC_MorphNodeTo</span><span class="p">,</span> <span class="n">TARGET_VAL</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">JALR</span><span class="p">),</span> <span class="mi">0</span><span class="o">|</span><span class="n">OPFL_Chain</span><span class="o">|</span>
<span class="n">OPFL_GlueInput</span><span class="o">|</span><span class="n">OPFL_GlueOutput</span><span class="o">|</span><span class="n">OPFL_Variadic1</span><span class="p">,</span>
                  <span class="mi">0</span><span class="cm">/*#VTs*/</span><span class="p">,</span> <span class="mi">1</span><span class="cm">/*#Ops*/</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
              <span class="c1">// Src: (Cpu0JmpLink CPURegs:i32:$rb) - Complexity = 3</span>
              <span class="c1">// Dst: (JALR CPURegs:i32:$rb)</span>
<span class="cm">/*733*/</span>     <span class="mi">0</span><span class="p">,</span> <span class="cm">/*End of Scope*/</span>
</pre></div>
</div>
<p>After above changes, you can run Chapter9_1/ with ch9_1.cpp and see what happens
in the following,</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">118-165-79-83:input Jonathan$</span> /Users/Jonathan/llvm/test/
<span class="go">cmake_debug_build/Debug/bin/llc -march=cpu0 -relocation-model=pic -filetype=asm</span>
<span class="go">ch9_1.bc -o ch9_1.cpu0.s</span>
<span class="go">Assertion failed: ((CLI.IsTailCall || InVals.size() == CLI.Ins.size()) &amp;&amp;</span>
<span class="go">&quot;LowerCall didn&#39;t emit the correct number of values!&quot;), function LowerCallTo,</span>
<span class="go">file /Users/Jonathan/llvm/test/src/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.</span>
<span class="go">cpp, ...</span>
<span class="go">...</span>
<span class="go">0.  Program arguments: /Users/Jonathan/llvm/test/cmake_debug_build/</span>
<span class="go">Debug/bin/llc -march=cpu0 -relocation-model=pic -filetype=asm ch9_1.bc -o</span>
<span class="go">ch9_1.cpu0.s</span>
<span class="go">1.  Running pass &#39;Function Pass Manager&#39; on module &#39;ch9_1.bc&#39;.</span>
<span class="go">2.  Running pass &#39;CPU0 DAG-&gt;DAG Pattern Instruction Selection&#39; on function</span>
<span class="go">&#39;@main&#39;</span>
<span class="go">Illegal instruction: 4</span>
</pre></div>
</div>
<p>Now, the LowerFormalArguments() has the correct number, but LowerCall() has not
the correct number of values!</p>
</div>
<div class="section" id="store-outgoing-arguments-to-stack-frame">
<h2><a class="toc-backref" href="#id25">Store outgoing arguments to stack frame</a><a class="headerlink" href="#store-outgoing-arguments-to-stack-frame" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="#funccall-f2"><span class="std std-numref">Fig. 25</span></a> depicts two steps to take care arguments passing.
One is store outgoing arguments into caller function, the other is load
incoming arguments into callee function.
We defined LowerFormalArguments() for <strong>“load incoming arguments”</strong> in callee
function last section.
Now, we will finish <strong>“store outgoing arguments”</strong> in caller function.
LowerCall() is responsible in doing this. The implementation as follows,</p>
<p class="rubric">lbdex/chapters/Chapter9_2/Cpu0MachineFunction.h</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="o">///</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">MachinePointerInfo</span> <span class="n">that</span> <span class="n">has</span> <span class="n">an</span> <span class="n">ExternalSymbolPseudoSourceValue</span>
  <span class="o">///</span> <span class="nb">object</span> <span class="n">representing</span> <span class="n">a</span> <span class="n">GOT</span> <span class="n">entry</span> <span class="k">for</span> <span class="n">an</span> <span class="n">external</span> <span class="n">function</span><span class="o">.</span>
  <span class="n">MachinePointerInfo</span> <span class="n">callPtrInfo</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">ES</span><span class="p">);</span>

  <span class="o">///</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">MachinePointerInfo</span> <span class="n">that</span> <span class="n">has</span> <span class="n">a</span> <span class="n">GlobalValuePseudoSourceValue</span> <span class="nb">object</span>
  <span class="o">///</span> <span class="n">representing</span> <span class="n">a</span> <span class="n">GOT</span> <span class="n">entry</span> <span class="k">for</span> <span class="n">a</span> <span class="k">global</span> <span class="n">function</span><span class="o">.</span>
  <span class="n">MachinePointerInfo</span> <span class="n">callPtrInfo</span><span class="p">(</span><span class="n">const</span> <span class="n">GlobalValue</span> <span class="o">*</span><span class="n">GV</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_2/Cpu0MachineFunction.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MachinePointerInfo</span> <span class="n">Cpu0FunctionInfo</span><span class="p">::</span><span class="n">callPtrInfo</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">ES</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">MachinePointerInfo</span><span class="p">(</span><span class="n">MF</span><span class="o">.</span><span class="n">getPSVManager</span><span class="p">()</span><span class="o">.</span><span class="n">getExternalSymbolCallEntry</span><span class="p">(</span><span class="n">ES</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">MachinePointerInfo</span> <span class="n">Cpu0FunctionInfo</span><span class="p">::</span><span class="n">callPtrInfo</span><span class="p">(</span><span class="n">const</span> <span class="n">GlobalValue</span> <span class="o">*</span><span class="n">GV</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">MachinePointerInfo</span><span class="p">(</span><span class="n">MF</span><span class="o">.</span><span class="n">getPSVManager</span><span class="p">()</span><span class="o">.</span><span class="n">getGlobalValueCallEntry</span><span class="p">(</span><span class="n">GV</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_2/Cpu0ISelLowering.h</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>    <span class="o">///</span> <span class="n">This</span> <span class="n">function</span> <span class="n">fills</span> <span class="n">Ops</span><span class="p">,</span> <span class="n">which</span> <span class="ow">is</span> <span class="n">the</span> <span class="nb">list</span> <span class="n">of</span> <span class="n">operands</span> <span class="n">that</span> <span class="n">will</span> <span class="n">later</span>
    <span class="o">///</span> <span class="n">be</span> <span class="n">used</span> <span class="n">when</span> <span class="n">a</span> <span class="n">function</span> <span class="n">call</span> <span class="n">node</span> <span class="ow">is</span> <span class="n">created</span><span class="o">.</span> <span class="n">It</span> <span class="n">also</span> <span class="n">generates</span>
    <span class="o">///</span> <span class="n">copyToReg</span> <span class="n">nodes</span> <span class="n">to</span> <span class="nb">set</span> <span class="n">up</span> <span class="n">argument</span> <span class="n">registers</span><span class="o">.</span>
    <span class="n">virtual</span> <span class="n">void</span>
    <span class="n">getOpndList</span><span class="p">(</span><span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ops</span><span class="p">,</span>
                <span class="n">std</span><span class="p">::</span><span class="n">deque</span><span class="o">&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">unsigned</span><span class="p">,</span> <span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">RegsToPass</span><span class="p">,</span>
                <span class="nb">bool</span> <span class="n">IsPICCall</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">GlobalOrExternal</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">InternalLinkage</span><span class="p">,</span>
                <span class="n">CallLoweringInfo</span> <span class="o">&amp;</span><span class="n">CLI</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">Callee</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">Chain</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>    <span class="o">///</span> <span class="n">Cpu0CC</span> <span class="o">-</span> <span class="n">This</span> <span class="k">class</span> <span class="nc">provides</span> <span class="n">methods</span> <span class="n">used</span> <span class="n">to</span> <span class="n">analyze</span> <span class="n">formal</span> <span class="ow">and</span> <span class="n">call</span>
    <span class="o">///</span> <span class="n">arguments</span> <span class="ow">and</span> <span class="n">inquire</span> <span class="n">about</span> <span class="n">calling</span> <span class="n">convention</span> <span class="n">information</span><span class="o">.</span>
    <span class="k">class</span> <span class="nc">Cpu0CC</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>      <span class="n">void</span> <span class="n">analyzeCallOperands</span><span class="p">(</span><span class="n">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="p">::</span><span class="n">OutputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Outs</span><span class="p">,</span>
                               <span class="nb">bool</span> <span class="n">IsVarArg</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">IsSoftFloat</span><span class="p">,</span>
                               <span class="n">const</span> <span class="n">SDNode</span> <span class="o">*</span><span class="n">CallNode</span><span class="p">,</span>
                               <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ArgListEntry</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">FuncArgs</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="p">.</span>  <span class="p">};</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>    <span class="n">Cpu0CC</span><span class="p">::</span><span class="n">SpecialCallingConvType</span> <span class="n">getSpecialCallingConv</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Callee</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>    <span class="o">//</span> <span class="n">Lower</span> <span class="n">Operand</span> <span class="n">helpers</span>
    <span class="n">SDValue</span> <span class="n">LowerCallResult</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">InFlag</span><span class="p">,</span>
                            <span class="n">CallingConv</span><span class="p">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">isVarArg</span><span class="p">,</span>
                            <span class="n">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="p">::</span><span class="n">InputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ins</span><span class="p">,</span>
                            <span class="n">const</span> <span class="n">SDLoc</span> <span class="o">&amp;</span><span class="n">dl</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span>
                            <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">,</span>
                            <span class="n">const</span> <span class="n">SDNode</span> <span class="o">*</span><span class="n">CallNode</span><span class="p">,</span> <span class="n">const</span> <span class="n">Type</span> <span class="o">*</span><span class="n">RetTy</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>    <span class="o">///</span> <span class="n">passByValArg</span> <span class="o">-</span> <span class="n">Pass</span> <span class="n">a</span> <span class="n">byval</span> <span class="n">argument</span> <span class="ow">in</span> <span class="n">registers</span> <span class="ow">or</span> <span class="n">on</span> <span class="n">stack</span><span class="o">.</span>
    <span class="n">void</span> <span class="n">passByValArg</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">const</span> <span class="n">SDLoc</span> <span class="o">&amp;</span><span class="n">DL</span><span class="p">,</span>
                      <span class="n">std</span><span class="p">::</span><span class="n">deque</span><span class="o">&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">unsigned</span><span class="p">,</span> <span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">RegsToPass</span><span class="p">,</span>
                      <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">MemOpChains</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">StackPtr</span><span class="p">,</span>
                      <span class="n">MachineFrameInfo</span> <span class="o">*</span><span class="n">MFI</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">Arg</span><span class="p">,</span>
                      <span class="n">const</span> <span class="n">Cpu0CC</span> <span class="o">&amp;</span><span class="n">CC</span><span class="p">,</span> <span class="n">const</span> <span class="n">ByValArgInfo</span> <span class="o">&amp;</span><span class="n">ByVal</span><span class="p">,</span>
                      <span class="n">const</span> <span class="n">ISD</span><span class="p">::</span><span class="n">ArgFlagsTy</span> <span class="o">&amp;</span><span class="n">Flags</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">isLittle</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>    <span class="n">SDValue</span> <span class="n">passArgOnStack</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">StackPtr</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">Offset</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span>
                           <span class="n">SDValue</span> <span class="n">Arg</span><span class="p">,</span> <span class="n">const</span> <span class="n">SDLoc</span> <span class="o">&amp;</span><span class="n">DL</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">IsTailCall</span><span class="p">,</span>
                           <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>    <span class="nb">bool</span> <span class="n">CanLowerReturn</span><span class="p">(</span><span class="n">CallingConv</span><span class="p">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span> <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                        <span class="nb">bool</span> <span class="n">isVarArg</span><span class="p">,</span>
                        <span class="n">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="p">::</span><span class="n">OutputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Outs</span><span class="p">,</span>
                        <span class="n">LLVMContext</span> <span class="o">&amp;</span><span class="n">Context</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_2/Cpu0ISelLowering.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>SDValue
Cpu0TargetLowering::passArgOnStack(SDValue StackPtr, unsigned Offset,
                                   SDValue Chain, SDValue Arg, const SDLoc &amp;DL,
                                   bool IsTailCall, SelectionDAG &amp;DAG) const {
  if (!IsTailCall) {
    SDValue PtrOff =
        DAG.getNode(ISD::ADD, DL, getPointerTy(DAG.getDataLayout()), StackPtr,
                    DAG.getIntPtrConstant(Offset, DL));
    return DAG.getStore(Chain, DL, Arg, PtrOff, MachinePointerInfo());
  }

  MachineFrameInfo *MFI = DAG.getMachineFunction().getFrameInfo();
  int FI = MFI-&gt;CreateFixedObject(Arg.getValueSizeInBits() / 8, Offset, false);
  SDValue FIN = DAG.getFrameIndex(FI, getPointerTy(DAG.getDataLayout()));
  return DAG.getStore(Chain, DL, Arg, FIN, MachinePointerInfo(),
                      /* Alignment = */ 0, MachineMemOperand::MOVolatile);
}

void Cpu0TargetLowering::
getOpndList(SmallVectorImpl&lt;SDValue&gt; &amp;Ops,
            std::deque&lt; std::pair&lt;unsigned, SDValue&gt; &gt; &amp;RegsToPass,
            bool IsPICCall, bool GlobalOrExternal, bool InternalLinkage,
            CallLoweringInfo &amp;CLI, SDValue Callee, SDValue Chain) const {
  // T9 should contain the address of the callee function if
  // -reloction-model=pic or it is an indirect call.
  if (IsPICCall || !GlobalOrExternal) {
    unsigned T9Reg = Cpu0::T9;
    RegsToPass.push_front(std::make_pair(T9Reg, Callee));
  } else
    Ops.push_back(Callee);

  // Insert node &quot;GP copy globalreg&quot; before call to function.
  //
  // R_CPU0_CALL* operators (emitted when non-internal functions are called
  // in PIC mode) allow symbols to be resolved via lazy binding.
  // The lazy binding stub requires GP to point to the GOT.
  if (IsPICCall &amp;&amp; !InternalLinkage) {
    unsigned GPReg = Cpu0::GP;
    EVT Ty = MVT::i32;
    RegsToPass.push_back(std::make_pair(GPReg, getGlobalReg(CLI.DAG, Ty)));
  }

  // Build a sequence of copy-to-reg nodes chained together with token
  // chain and flag operands which copy the outgoing args into registers.
  // The InFlag in necessary since all emitted instructions must be
  // stuck together.
  SDValue InFlag;

  for (unsigned i = 0, e = RegsToPass.size(); i != e; ++i) {
    Chain = CLI.DAG.getCopyToReg(Chain, CLI.DL, RegsToPass[i].first,
                                 RegsToPass[i].second, InFlag);
    InFlag = Chain.getValue(1);
  }

  // Add argument registers to the end of the list so that they are
  // known live into the call.
  for (unsigned i = 0, e = RegsToPass.size(); i != e; ++i)
    Ops.push_back(CLI.DAG.getRegister(RegsToPass[i].first,
                                      RegsToPass[i].second.getValueType()));

  // Add a register mask operand representing the call-preserved registers.
  const TargetRegisterInfo *TRI = Subtarget.getRegisterInfo();
  const uint32_t *Mask = 
      TRI-&gt;getCallPreservedMask(CLI.DAG.getMachineFunction(), CLI.CallConv);
  assert(Mask &amp;&amp; &quot;Missing call preserved mask for calling convention&quot;);
  Ops.push_back(CLI.DAG.getRegisterMask(Mask));

  if (InFlag.getNode())
    Ops.push_back(InFlag);
}
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>/// LowerCall - functions arguments are copied from virtual regs to
/// (physical regs)/(stack frame), CALLSEQ_START and CALLSEQ_END are emitted.
SDValue
Cpu0TargetLowering::LowerCall(TargetLowering::CallLoweringInfo &amp;CLI,
                              SmallVectorImpl&lt;SDValue&gt; &amp;InVals) const {
  SelectionDAG &amp;DAG                     = CLI.DAG;
  SDLoc DL                              = CLI.DL;
  SmallVectorImpl&lt;ISD::OutputArg&gt; &amp;Outs = CLI.Outs;
  SmallVectorImpl&lt;SDValue&gt; &amp;OutVals     = CLI.OutVals;
  SmallVectorImpl&lt;ISD::InputArg&gt; &amp;Ins   = CLI.Ins;
  SDValue Chain                         = CLI.Chain;
  SDValue Callee                        = CLI.Callee;
  bool &amp;IsTailCall                      = CLI.IsTailCall;
  CallingConv::ID CallConv              = CLI.CallConv;
  bool IsVarArg                         = CLI.IsVarArg;

  MachineFunction &amp;MF = DAG.getMachineFunction();
  MachineFrameInfo *MFI = MF.getFrameInfo();
  const TargetFrameLowering *TFL = MF.getSubtarget().getFrameLowering();
  Cpu0FunctionInfo *FuncInfo = MF.getInfo&lt;Cpu0FunctionInfo&gt;();
  bool IsPIC = isPositionIndependent();
  Cpu0FunctionInfo *Cpu0FI = MF.getInfo&lt;Cpu0FunctionInfo&gt;();

  // Analyze operands of the call, assigning locations to each operand.
  SmallVector&lt;CCValAssign, 16&gt; ArgLocs;
  CCState CCInfo(CallConv, IsVarArg, DAG.getMachineFunction(),
                 ArgLocs, *DAG.getContext());
  Cpu0CC::SpecialCallingConvType SpecialCallingConv =
    getSpecialCallingConv(Callee);
  Cpu0CC Cpu0CCInfo(CallConv, ABI.IsO32(), 
                    CCInfo, SpecialCallingConv);

  Cpu0CCInfo.analyzeCallOperands(Outs, IsVarArg,
                                 Subtarget.abiUsesSoftFloat(),
                                 Callee.getNode(), CLI.getArgs());

  // Get a count of how many bytes are to be pushed on the stack.
  unsigned NextStackOffset = CCInfo.getNextStackOffset();

  //@TailCall 1 {
  // Check if it&#39;s really possible to do a tail call.
  if (IsTailCall)
    IsTailCall =
      isEligibleForTailCallOptimization(Cpu0CCInfo, NextStackOffset,
                                        *MF.getInfo&lt;Cpu0FunctionInfo&gt;());

  if (!IsTailCall &amp;&amp; CLI.CS &amp;&amp; CLI.CS-&gt;isMustTailCall())
    report_fatal_error(&quot;failed to perform tail call elimination on a call &quot;
                       &quot;site marked musttail&quot;);

  if (IsTailCall)
    ++NumTailCalls;
  //@TailCall 1 }

  // Chain is the output chain of the last Load/Store or CopyToReg node.
  // ByValChain is the output chain of the last Memcpy node created for copying
  // byval arguments to the stack.
  unsigned StackAlignment = TFL-&gt;getStackAlignment();
  NextStackOffset = alignTo(NextStackOffset, StackAlignment);
  SDValue NextStackOffsetVal = DAG.getIntPtrConstant(NextStackOffset, DL, true);

  //@TailCall 2 {
  if (!IsTailCall)
    Chain = DAG.getCALLSEQ_START(Chain, NextStackOffsetVal, DL);
  //@TailCall 2 }

  SDValue StackPtr =
      DAG.getCopyFromReg(Chain, DL, Cpu0::SP,
                         getPointerTy(DAG.getDataLayout()));

  // With EABI is it possible to have 16 args on registers.
  std::deque&lt; std::pair&lt;unsigned, SDValue&gt; &gt; RegsToPass;
  SmallVector&lt;SDValue, 8&gt; MemOpChains;
  Cpu0CC::byval_iterator ByValArg = Cpu0CCInfo.byval_begin();

  //@1 {
  // Walk the register/memloc assignments, inserting copies/loads.
  for (unsigned i = 0, e = ArgLocs.size(); i != e; ++i) {
  //@1 }
    SDValue Arg = OutVals[i];
    CCValAssign &amp;VA = ArgLocs[i];
    MVT LocVT = VA.getLocVT();
    ISD::ArgFlagsTy Flags = Outs[i].Flags;

    //@ByVal Arg {
    if (Flags.isByVal()) {
      assert(Flags.getByValSize() &amp;&amp;
             &quot;ByVal args of size 0 should have been ignored by front-end.&quot;);
      assert(ByValArg != Cpu0CCInfo.byval_end());
      assert(!IsTailCall &amp;&amp;
             &quot;Do not tail-call optimize if there is a byval argument.&quot;);
      passByValArg(Chain, DL, RegsToPass, MemOpChains, StackPtr, MFI, DAG, Arg,
                   Cpu0CCInfo, *ByValArg, Flags, Subtarget.isLittle());
      ++ByValArg;
      continue;
    }
    //@ByVal Arg }

    // Promote the value if needed.
    switch (VA.getLocInfo()) {
    default: llvm_unreachable(&quot;Unknown loc info!&quot;);
    case CCValAssign::Full:
      break;
    case CCValAssign::SExt:
      Arg = DAG.getNode(ISD::SIGN_EXTEND, DL, LocVT, Arg);
      break;
    case CCValAssign::ZExt:
      Arg = DAG.getNode(ISD::ZERO_EXTEND, DL, LocVT, Arg);
      break;
    case CCValAssign::AExt:
      Arg = DAG.getNode(ISD::ANY_EXTEND, DL, LocVT, Arg);
      break;
    }

    // Arguments that can be passed on register must be kept at
    // RegsToPass vector
    if (VA.isRegLoc()) {
      RegsToPass.push_back(std::make_pair(VA.getLocReg(), Arg));
      continue;
    }

    // Register can&#39;t get to this point...
    assert(VA.isMemLoc());

    // emit ISD::STORE whichs stores the
    // parameter value to a stack Location
    MemOpChains.push_back(passArgOnStack(StackPtr, VA.getLocMemOffset(),
                                         Chain, Arg, DL, IsTailCall, DAG));
  }

  // Transform all store nodes into one single node because all store
  // nodes are independent of each other.
  if (!MemOpChains.empty())
    Chain = DAG.getNode(ISD::TokenFactor, DL, MVT::Other, MemOpChains);

  // If the callee is a GlobalAddress/ExternalSymbol node (quite common, every
  // direct call is) turn it into a TargetGlobalAddress/TargetExternalSymbol
  // node so that legalize doesn&#39;t hack it.
  bool IsPICCall = IsPIC; // true if calls are translated to
                                         // jalr $t9
  bool GlobalOrExternal = false, InternalLinkage = false;
  SDValue CalleeLo;
  EVT Ty = Callee.getValueType();

  if (GlobalAddressSDNode *G = dyn_cast&lt;GlobalAddressSDNode&gt;(Callee)) {
    if (IsPICCall) {
      const GlobalValue *Val = G-&gt;getGlobal();
      InternalLinkage = Val-&gt;hasInternalLinkage();

      if (InternalLinkage)
        Callee = getAddrLocal(G, Ty, DAG);
      else
        Callee = getAddrGlobal(G, Ty, DAG, Cpu0II::MO_GOT_CALL, Chain,
                               FuncInfo-&gt;callPtrInfo(Val));
    } else
      Callee = DAG.getTargetGlobalAddress(G-&gt;getGlobal(), DL,
                                          getPointerTy(DAG.getDataLayout()), 0,
                                          Cpu0II::MO_NO_FLAG);
    GlobalOrExternal = true;
  }
  else if (ExternalSymbolSDNode *S = dyn_cast&lt;ExternalSymbolSDNode&gt;(Callee)) {
    const char *Sym = S-&gt;getSymbol();

    if (!IsPIC) // static
      Callee = DAG.getTargetExternalSymbol(Sym,
                                           getPointerTy(DAG.getDataLayout()),
                                           Cpu0II::MO_NO_FLAG);
    else // PIC
      Callee = getAddrGlobal(S, Ty, DAG, Cpu0II::MO_GOT_CALL, Chain,
                             FuncInfo-&gt;callPtrInfo(Sym));

    GlobalOrExternal = true;
  }

  SmallVector&lt;SDValue, 8&gt; Ops(1, Chain);
  SDVTList NodeTys = DAG.getVTList(MVT::Other, MVT::Glue);

  getOpndList(Ops, RegsToPass, IsPICCall, GlobalOrExternal, InternalLinkage,
              CLI, Callee, Chain);

  //@TailCall 3 {
  if (IsTailCall)
    return DAG.getNode(Cpu0ISD::TailCall, DL, MVT::Other, Ops);
  //@TailCall 3 }

  Chain = DAG.getNode(Cpu0ISD::JmpLink, DL, NodeTys, Ops);
  SDValue InFlag = Chain.getValue(1);

  // Create the CALLSEQ_END node.
  Chain = DAG.getCALLSEQ_END(Chain, NextStackOffsetVal,
                             DAG.getIntPtrConstant(0, DL, true), InFlag, DL);
  InFlag = Chain.getValue(1);

  // Handle result values, copying them out of physregs into vregs that we
  // return.
  return LowerCallResult(Chain, InFlag, CallConv, IsVarArg,
                         Ins, DL, DAG, InVals, CLI.Callee.getNode(), CLI.RetTy);
}
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">///</span> <span class="n">LowerCallResult</span> <span class="o">-</span> <span class="n">Lower</span> <span class="n">the</span> <span class="n">result</span> <span class="n">values</span> <span class="n">of</span> <span class="n">a</span> <span class="n">call</span> <span class="n">into</span> <span class="n">the</span>
<span class="o">///</span> <span class="n">appropriate</span> <span class="n">copies</span> <span class="n">out</span> <span class="n">of</span> <span class="n">appropriate</span> <span class="n">physical</span> <span class="n">registers</span><span class="o">.</span>
<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">LowerCallResult</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">InFlag</span><span class="p">,</span>
                                    <span class="n">CallingConv</span><span class="p">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">IsVarArg</span><span class="p">,</span>
                                    <span class="n">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="p">::</span><span class="n">InputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ins</span><span class="p">,</span>
                                    <span class="n">const</span> <span class="n">SDLoc</span> <span class="o">&amp;</span><span class="n">DL</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span>
                                    <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">,</span>
                                    <span class="n">const</span> <span class="n">SDNode</span> <span class="o">*</span><span class="n">CallNode</span><span class="p">,</span>
                                    <span class="n">const</span> <span class="n">Type</span> <span class="o">*</span><span class="n">RetTy</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="o">//</span> <span class="n">Assign</span> <span class="n">locations</span> <span class="n">to</span> <span class="n">each</span> <span class="n">value</span> <span class="n">returned</span> <span class="n">by</span> <span class="n">this</span> <span class="n">call</span><span class="o">.</span>
  <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">CCValAssign</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">RVLocs</span><span class="p">;</span>
  <span class="n">CCState</span> <span class="n">CCInfo</span><span class="p">(</span><span class="n">CallConv</span><span class="p">,</span> <span class="n">IsVarArg</span><span class="p">,</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getMachineFunction</span><span class="p">(),</span>
		 <span class="n">RVLocs</span><span class="p">,</span> <span class="o">*</span><span class="n">DAG</span><span class="o">.</span><span class="n">getContext</span><span class="p">());</span>
		 
  <span class="n">Cpu0CC</span> <span class="n">Cpu0CCInfo</span><span class="p">(</span><span class="n">CallConv</span><span class="p">,</span> <span class="n">ABI</span><span class="o">.</span><span class="n">IsO32</span><span class="p">(),</span> <span class="n">CCInfo</span><span class="p">);</span>

  <span class="n">Cpu0CCInfo</span><span class="o">.</span><span class="n">analyzeCallResult</span><span class="p">(</span><span class="n">Ins</span><span class="p">,</span> <span class="n">Subtarget</span><span class="o">.</span><span class="n">abiUsesSoftFloat</span><span class="p">(),</span>
                               <span class="n">CallNode</span><span class="p">,</span> <span class="n">RetTy</span><span class="p">);</span>

  <span class="o">//</span> <span class="n">Copy</span> <span class="nb">all</span> <span class="n">of</span> <span class="n">the</span> <span class="n">result</span> <span class="n">registers</span> <span class="n">out</span> <span class="n">of</span> <span class="n">their</span> <span class="n">specified</span> <span class="n">physreg</span><span class="o">.</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">RVLocs</span><span class="o">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">SDValue</span> <span class="n">Val</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getCopyFromReg</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">RVLocs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">getLocReg</span><span class="p">(),</span>
                                     <span class="n">RVLocs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">getLocVT</span><span class="p">(),</span> <span class="n">InFlag</span><span class="p">);</span>
    <span class="n">Chain</span> <span class="o">=</span> <span class="n">Val</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">InFlag</span> <span class="o">=</span> <span class="n">Val</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">RVLocs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">getValVT</span><span class="p">()</span> <span class="o">!=</span> <span class="n">RVLocs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">getLocVT</span><span class="p">())</span>
      <span class="n">Val</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">BITCAST</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">RVLocs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">getValVT</span><span class="p">(),</span> <span class="n">Val</span><span class="p">);</span>

    <span class="n">InVals</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Val</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">Chain</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">bool</span>
<span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">CanLowerReturn</span><span class="p">(</span><span class="n">CallingConv</span><span class="p">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span>
                                   <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">IsVarArg</span><span class="p">,</span>
                                   <span class="n">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="p">::</span><span class="n">OutputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Outs</span><span class="p">,</span>
                                   <span class="n">LLVMContext</span> <span class="o">&amp;</span><span class="n">Context</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">CCValAssign</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">RVLocs</span><span class="p">;</span>
  <span class="n">CCState</span> <span class="n">CCInfo</span><span class="p">(</span><span class="n">CallConv</span><span class="p">,</span> <span class="n">IsVarArg</span><span class="p">,</span> <span class="n">MF</span><span class="p">,</span>
                 <span class="n">RVLocs</span><span class="p">,</span> <span class="n">Context</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">CCInfo</span><span class="o">.</span><span class="n">CheckReturn</span><span class="p">(</span><span class="n">Outs</span><span class="p">,</span> <span class="n">RetCC_Cpu0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">Cpu0CC</span><span class="p">::</span><span class="n">SpecialCallingConvType</span>
  <span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">getSpecialCallingConv</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Callee</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="n">Cpu0CC</span><span class="p">::</span><span class="n">SpecialCallingConvType</span> <span class="n">SpecialCallingConv</span> <span class="o">=</span>
    <span class="n">Cpu0CC</span><span class="p">::</span><span class="n">NoSpecialCallingConv</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">SpecialCallingConv</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>void Cpu0TargetLowering::Cpu0CC::
analyzeCallOperands(const SmallVectorImpl&lt;ISD::OutputArg&gt; &amp;Args,
                    bool IsVarArg, bool IsSoftFloat, const SDNode *CallNode,
                    std::vector&lt;ArgListEntry&gt; &amp;FuncArgs) {
//@analyzeCallOperands body {
  assert((CallConv != CallingConv::Fast || !IsVarArg) &amp;&amp;
         &quot;CallingConv::Fast shouldn&#39;t be used for vararg functions.&quot;);

  unsigned NumOpnds = Args.size();
  llvm::CCAssignFn *FixedFn = fixedArgFn();

  //@3 {
  for (unsigned I = 0; I != NumOpnds; ++I) {
  //@3 }
    MVT ArgVT = Args[I].VT;
    ISD::ArgFlagsTy ArgFlags = Args[I].Flags;
    bool R;

    if (ArgFlags.isByVal()) {
      handleByValArg(I, ArgVT, ArgVT, CCValAssign::Full, ArgFlags);
      continue;
    }

    {
      MVT RegVT = getRegVT(ArgVT, FuncArgs[Args[I].OrigArgIndex].Ty, CallNode,
                           IsSoftFloat);
      R = FixedFn(I, ArgVT, RegVT, CCValAssign::Full, ArgFlags, CCInfo);
    }

    if (R) {
#ifndef NDEBUG
      dbgs() &lt;&lt; &quot;Call operand #&quot; &lt;&lt; I &lt;&lt; &quot; has unhandled type &quot;
             &lt;&lt; EVT(ArgVT).getEVTString();
#endif
      llvm_unreachable(nullptr);
    }
  }
}
</pre></div>
</div>
<p>Just like load incoming arguments from stack frame, we call
CCInfo(CallConv,..., ArgLocs, ...) to get outgoing arguments information before
entering <strong>“for loop”*.
They&#8217;re almost same in **“for loop”</strong> with LowerFormalArguments(), except
LowerCall() creates &#8220;store DAG vector&#8221; instead of &#8220;load DAG vector&#8221;.
After the <strong>“for loop”</strong>, it create <strong>“ld $t9, %call16(_Z5sum_iiiiiii)($gp)”</strong>
and jalr $t9 for calling subroutine (the $6 is $t9) in PIC mode.</p>
<p>Like loading incoming arguments, we need to implement storeRegToStackSlot() at
early chapter.</p>
<div class="section" id="pseudo-hook-instruction-adjcallstackdown-and-adjcallstackup">
<h3><a class="toc-backref" href="#id26">Pseudo hook instruction ADJCALLSTACKDOWN and ADJCALLSTACKUP</a><a class="headerlink" href="#pseudo-hook-instruction-adjcallstackdown-and-adjcallstackup" title="Permalink to this headline">¶</a></h3>
<p>DAG.getCALLSEQ_START() and DAG.getCALLSEQ_END() are set before and after the
<strong>“for loop”</strong>, respectively, they insert
CALLSEQ_START, CALLSEQ_END, and translate them into pseudo machine instructions
!ADJCALLSTACKDOWN, !ADJCALLSTACKUP later according Cpu0InstrInfo.td definition
as follows.</p>
<p class="rubric">lbdex/chapters/Chapter9_2/Cpu0InstrInfo.td</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">SDT_Cpu0CallSeqStart</span> <span class="p">:</span> <span class="n">SDCallSeqStart</span><span class="o">&lt;</span><span class="p">[</span><span class="n">SDTCisVT</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">i32</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">SDT_Cpu0CallSeqEnd</span>   <span class="p">:</span> <span class="n">SDCallSeqEnd</span><span class="o">&lt;</span><span class="p">[</span><span class="n">SDTCisVT</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">i32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">SDTCisVT</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="n">i32</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">These</span> <span class="n">are</span> <span class="n">target</span><span class="o">-</span><span class="n">independent</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">but</span> <span class="n">have</span> <span class="n">target</span><span class="o">-</span><span class="n">specific</span> <span class="n">formats</span><span class="o">.</span>
<span class="k">def</span> <span class="nf">callseq_start</span> <span class="p">:</span> <span class="n">SDNode</span><span class="o">&lt;</span><span class="s2">&quot;ISD::CALLSEQ_START&quot;</span><span class="p">,</span> <span class="n">SDT_Cpu0CallSeqStart</span><span class="p">,</span>
                           <span class="p">[</span><span class="n">SDNPHasChain</span><span class="p">,</span> <span class="n">SDNPOutGlue</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">callseq_end</span>   <span class="p">:</span> <span class="n">SDNode</span><span class="o">&lt;</span><span class="s2">&quot;ISD::CALLSEQ_END&quot;</span><span class="p">,</span> <span class="n">SDT_Cpu0CallSeqEnd</span><span class="p">,</span>
                           <span class="p">[</span><span class="n">SDNPHasChain</span><span class="p">,</span> <span class="n">SDNPOptInGlue</span><span class="p">,</span> <span class="n">SDNPOutGlue</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>//===----------------------------------------------------------------------===//
// Pseudo instructions
//===----------------------------------------------------------------------===//

let Predicates = [Ch9_2] in {
// As stack alignment is always done with addiu, we need a 16-bit immediate
let Defs = [SP], Uses = [SP] in {
def ADJCALLSTACKDOWN : Cpu0Pseudo&lt;(outs), (ins uimm16:$amt),
                                  &quot;!ADJCALLSTACKDOWN $amt&quot;,
                                  [(callseq_start timm:$amt)]&gt;;
def ADJCALLSTACKUP   : Cpu0Pseudo&lt;(outs), (ins uimm16:$amt1, uimm16:$amt2),
                                  &quot;!ADJCALLSTACKUP $amt1&quot;,
                                  [(callseq_end timm:$amt1, timm:$amt2)]&gt;;
}

//@def CPRESTORE {
// When handling PIC code the assembler needs .cpload and .cprestore
// directives. If the real instructions corresponding these directives
// are used, we have the same behavior, but get also a bunch of warnings
// from the assembler.
let hasSideEffects = 0 in
def CPRESTORE : Cpu0Pseudo&lt;(outs), (ins i32imm:$loc, CPURegs:$gp),
                           &quot;.cprestore\t$loc&quot;, []&gt;;
} // let Predicates = [Ch9_2]
</pre></div>
</div>
<p>With below definition, eliminateCallFramePseudoInstr() will be called when
llvm meets pseudo instructions ADJCALLSTACKDOWN and ADJCALLSTACKUP.
It justs discard these 2 pseudo instructions, and llvm will add offset to
stack.</p>
<p class="rubric">lbdex/chapters/Chapter9_2/Cpu0InstrInfo.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Cpu0InstrInfo</span><span class="p">::</span><span class="n">Cpu0InstrInfo</span><span class="p">(</span><span class="n">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span>
    <span class="p">:</span> 
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>      <span class="n">Cpu0GenInstrInfo</span><span class="p">(</span><span class="n">Cpu0</span><span class="p">::</span><span class="n">ADJCALLSTACKDOWN</span><span class="p">,</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">ADJCALLSTACKUP</span><span class="p">),</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_2/Cpu0FrameLowering.h</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="n">MachineBasicBlock</span><span class="p">::</span><span class="n">iterator</span>
  <span class="n">eliminateCallFramePseudoInstr</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                  <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span>
                                  <span class="n">MachineBasicBlock</span><span class="p">::</span><span class="n">iterator</span> <span class="n">I</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_2/Cpu0FrameLowering.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Eliminate</span> <span class="n">ADJCALLSTACKDOWN</span><span class="p">,</span> <span class="n">ADJCALLSTACKUP</span> <span class="n">pseudo</span> <span class="n">instructions</span>
<span class="n">MachineBasicBlock</span><span class="p">::</span><span class="n">iterator</span> <span class="n">Cpu0FrameLowering</span><span class="p">::</span>
<span class="n">eliminateCallFramePseudoInstr</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span> <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span>
                              <span class="n">MachineBasicBlock</span><span class="p">::</span><span class="n">iterator</span> <span class="n">I</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>
  <span class="k">return</span> <span class="n">MBB</span><span class="o">.</span><span class="n">erase</span><span class="p">(</span><span class="n">I</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="read-lowercall-with-graphivz-s-help">
<h3><a class="toc-backref" href="#id27">Read Lowercall() with Graphivz&#8217;s help</a><a class="headerlink" href="#read-lowercall-with-graphivz-s-help" title="Permalink to this headline">¶</a></h3>
<p>The whole DAGs created for outgoing arguments as
&#8220;Figure Outgoing arguments DAG (A)...&#8221; below for ch9_outgoing.cpp with cpu032I.
LowerCall() (excluding calling LowerCallResult()) will generate the DAG nodes as
&#8220;Figure Outgoing arguments DAG (B)...&#8221; below
for ch9_outgoing.cpp with cpu032I. The corresponding code of DAGs Store and
TargetGlobalAddress are listed in the figure, user can match the other DAGs
to function LowerCall() easily.
Through Graphivz tool with llc option -view-dag-combine1-dags, you can design
a small input C or llvm IR source code and then check the DAGs to understand the
code in LowerCall() and LowerFormalArguments().
At the sub-sections &#8220;variable arguments&#8221; and &#8220;dynamic stack allocation
support&#8221; in the later section of this chapter, you can design
the input example with this features and check the DAGs with these two functions
again to make sure you know the code in these two function. About Graphivz,
please refer to section &#8220;Display llvm IR nodes with Graphviz&#8221; of chapter 4,
Arithmetic and logic instructions.
The DAGs diagram can be got by llc option as follows,</p>
<p class="rubric">lbdex/input/ch9_outgoing.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="nb">int</span> <span class="n">sum_i</span><span class="p">(</span><span class="nb">int</span> <span class="n">x1</span><span class="p">);</span>

<span class="nb">int</span> <span class="n">call_sum_i</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">sum_i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$</span> clang -O3 -target mips-unknown-linux-gnu -c
<span class="go">ch9_outgoing.cpp -emit-llvm -o ch9_outgoing.bc</span>
<span class="gp">JonathantekiiMac:input Jonathan$</span> /Users/Jonathan/llvm/test/cmake_debug_build/
<span class="go">Debug/bin/llvm-dis ch9_outgoing.bc -o -</span>
<span class="go">...</span>
<span class="go">define i32 @_Z10call_sum_iv() #0 {</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> tail call i32 @_Z5sum_ii<span class="o">(</span>i32 1<span class="o">)</span>
<span class="go">  ret i32 %1</span>
<span class="go">}</span>
<span class="gp">JonathantekiiMac:input Jonathan$</span> /Users/Jonathan/llvm/test/cmake_debug_build/
<span class="go">Debug/bin/llc -march=cpu0 -mcpu=cpu032I -view-dag-combine1-dags -relocation-</span>
<span class="go">model=static -filetype=asm ch9_outgoing.bc -o -</span>
<span class="go">      .text</span>
<span class="go">      .section .mdebug.abiS32</span>
<span class="go">      .previous</span>
<span class="go">      .file   &quot;ch9_outgoing.bc&quot;</span>
<span class="go">Writing &#39;/var/folders/rf/8bgdgt9d6vgf5sn8h8_zycd00000gn/T/dag._Z10call_sum_iv-</span>
<span class="go">0dfaf1.dot&#39;...  done.</span>
<span class="go">Running &#39;Graphviz&#39; program...</span>
</pre></div>
</div>
<img src="_images/graphviz-7b0edf25ec54f08813b295ab8247a52506e27c24.png" alt="digraph &quot;dag-combine1 input for _Z10call_sum_iv:&quot; {
	rankdir=&quot;BT&quot;;
	label=&quot;Figure Outgoing arguments DAG (A) created for ch9_outgoing.cpp with -cpu0-s32-calls=true&quot;;

  subgraph cluster_0 {
    fontcolor=red;
    fontsize=24;
    label = &quot;LowerCall&quot;;
	Node0x102f0d060 [shape=record,shape=Mrecord,label=&quot;{EntryToken|t0|{&lt;d0&gt;ch}}&quot;];
	Node0x10304f200 [shape=record,shape=Mrecord,label=&quot;{GlobalAddress\&lt;i32 (i32)* &#64;_Z5sum_ii\&gt; 0|t1|{&lt;d0&gt;i32}}&quot;];
	Node0x10304f270 [shape=record,shape=Mrecord,label=&quot;{Constant\&lt;1\&gt;|t2|{&lt;d0&gt;i32}}&quot;];
	Node0x10304f2e0 [shape=record,shape=Mrecord,label=&quot;{TargetConstant\&lt;8\&gt;|t3|{&lt;d0&gt;i32}}&quot;];
	Node0x10304f350 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1}|callseq_start|t4|{&lt;d0&gt;ch|&lt;d1&gt;glue}}&quot;];
	Node0x10304f350:s0 -&gt; Node0x102f0d060:d0[color=blue,style=dashed];
	Node0x10304f350:s1 -&gt; Node0x10304f2e0:d0;
	Node0x10304f3c0 [shape=record,shape=Mrecord,label=&quot;{Register %SP|t5|{&lt;d0&gt;i32}}&quot;];
	Node0x10304f430 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1}|CopyFromReg|t6|{&lt;d0&gt;i32|&lt;d1&gt;ch}}&quot;];
	Node0x10304f430:s0 -&gt; Node0x10304f350:d0[color=blue,style=dashed];
	Node0x10304f430:s1 -&gt; Node0x10304f3c0:d0;
	Node0x10304f4a0 [shape=record,shape=Mrecord,label=&quot;{Constant\&lt;0\&gt;|t7|{&lt;d0&gt;i32}}&quot;];
	Node0x10304f510 [shape=record,shape=Mrecord,label=&quot;{undef|t8|{&lt;d0&gt;i32}}&quot;];
	Node0x10304f580 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1|&lt;s2&gt;2|&lt;s3&gt;3}|store\&lt;ST4[\&lt;unknown\&gt;]\&gt;|t9|{&lt;d0&gt;ch}}&quot;];
	Node0x10304f580:s0 -&gt; Node0x10304f350:d0[color=blue,style=dashed];
	Node0x10304f580:s1 -&gt; Node0x10304f270:d0;
	Node0x10304f580:s2 -&gt; Node0x10304f430:d0;
	Node0x10304f580:s3 -&gt; Node0x10304f510:d0;
	Node0x10304f5f0 [shape=record,shape=Mrecord,label=&quot;{TargetGlobalAddress\&lt;i32 (i32)* &#64;_Z5sum_ii\&gt; 0|t10|{&lt;d0&gt;i32}}&quot;];
	Node0x10304f660 [shape=record,shape=Mrecord,label=&quot;{RegisterMask|t11|{&lt;d0&gt;Untyped}}&quot;];
	Node0x10304f6d0 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1|&lt;s2&gt;2}|Cpu0ISD::JmpLink|t12|{&lt;d0&gt;ch|&lt;d1&gt;glue}}&quot;];
	Node0x10304f6d0:s0 -&gt; Node0x10304f580:d0[color=blue,style=dashed];
	Node0x10304f6d0:s1 -&gt; Node0x10304f5f0:d0;
	Node0x10304f6d0:s2 -&gt; Node0x10304f660:d0;
	Node0x10304f740 [shape=record,shape=Mrecord,label=&quot;{TargetConstant\&lt;0\&gt;|t13|{&lt;d0&gt;i32}}&quot;];
	Node0x10304f7b0 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1|&lt;s2&gt;2|&lt;s3&gt;3}|callseq_end|t14|{&lt;d0&gt;ch|&lt;d1&gt;glue}}&quot;];
	Node0x10304f7b0:s0 -&gt; Node0x10304f6d0:d0[color=blue,style=dashed];
	Node0x10304f7b0:s1 -&gt; Node0x10304f2e0:d0;
	Node0x10304f7b0:s2 -&gt; Node0x10304f740:d0;
	Node0x10304f7b0:s3 -&gt; Node0x10304f6d0:d1[color=red,style=bold];
  }
  subgraph cluster_1 {
    fontcolor=red;
    fontsize=24;
    label = &quot;LowerCallResult&quot;;
	Node0x10304f820 [shape=record,shape=Mrecord,label=&quot;{Register %V0|t15|{&lt;d0&gt;i32}}&quot;];
	Node0x10304f890 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1|&lt;s2&gt;2}|CopyFromReg|t16|{&lt;d0&gt;i32|&lt;d1&gt;ch|&lt;d2&gt;glue}}&quot;];
  }
  subgraph cluster_2 {
    fontcolor=red;
    fontsize=24;
    label = &quot;LowerReturn&quot;;
	Node0x10304f900 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1|&lt;s2&gt;2}|CopyToReg|t17|{&lt;d0&gt;ch|&lt;d1&gt;glue}}&quot;];
	Node0x10304f970 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1|&lt;s2&gt;2}|Cpu0ISD::Ret|t18|{&lt;d0&gt;ch}}&quot;];
  }
	Node0x10304f890:s0 -&gt; Node0x10304f7b0:d0[color=blue,style=dashed];
	Node0x10304f890:s1 -&gt; Node0x10304f820:d0;
	Node0x10304f890:s2 -&gt; Node0x10304f7b0:d1[color=red,style=bold];
	
	Node0x10304f900:s0 -&gt; Node0x10304f890:d1[color=blue,style=dashed];
	Node0x10304f900:s1 -&gt; Node0x10304f820:d0;
	Node0x10304f900:s2 -&gt; Node0x10304f890:d0;
	Node0x10304f970:s0 -&gt; Node0x10304f900:d0[color=blue,style=dashed];
	Node0x10304f970:s1 -&gt; Node0x10304f820:d0;
	Node0x10304f970:s2 -&gt; Node0x10304f900:d1[color=red,style=bold];
	
	Node0x0[ plaintext=circle, label =&quot;GraphRoot&quot;];
	Node0x0 -&gt; Node0x10304f970:d0[color=blue,style=dashed];
}" />
<img src="_images/graphviz-872d9406c8f7076da808aa8cff561ce22047180c.png" alt="digraph &quot;isel input for _Z10call_sum_iv:&quot; {
	rankdir=&quot;BT&quot;;
	label=&quot;Figure Outgoing arguments DAG (B) created by LowerCall() for ch9_outgoing.cpp with -cpu0-s32-calls=true&quot;;
	Node0x102f0d060 [shape=record,shape=Mrecord,label=&quot;{EntryToken|t0|{&lt;d0&gt;ch}}&quot;];
	Node0x10304f270 [shape=record,shape=Mrecord,label=&quot;{Constant\&lt;1\&gt;|t2|{&lt;d0&gt;i32}}&quot;];
	Node0x10304f2e0 [shape=record,shape=Mrecord,label=&quot;{TargetConstant\&lt;8\&gt;|t3|{&lt;d0&gt;i32}}&quot;];
	Node0x10304f350 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1}|callseq_start|t4|{&lt;d0&gt;ch|&lt;d1&gt;glue}}&quot;];
	Node0x10304f350:s0 -&gt; Node0x102f0d060:d0[color=blue,style=dashed];
	Node0x10304f350:s1 -&gt; Node0x10304f2e0:d0;
	Node0x10304f3c0 [shape=record,shape=Mrecord,label=&quot;{Register %SP|t5|{&lt;d0&gt;i32}}&quot;];
	Node0x10304f430 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1}|CopyFromReg|t6|{&lt;d0&gt;i32|&lt;d1&gt;ch}}&quot;];
	Node0x10304f430:s0 -&gt; Node0x10304f350:d0[color=blue,style=dashed];
	Node0x10304f430:s1 -&gt; Node0x10304f3c0:d0;
	Node0x10304f510 [shape=record,shape=Mrecord,label=&quot;{undef|t8|{&lt;d0&gt;i32}}&quot;];
	Node0x10304f580 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1|&lt;s2&gt;2|&lt;s3&gt;3}|store\&lt;ST4[\&lt;unknown\&gt;]\&gt;|t9|{&lt;d0&gt;ch}}&quot;];
	Node0x10304f580:s0 -&gt; Node0x10304f350:d0[color=blue,style=dashed];
	Node0x10304f580:s1 -&gt; Node0x10304f270:d0;
	Node0x10304f580:s2 -&gt; Node0x10304f430:d0;
	Node0x10304f580:s3 -&gt; Node0x10304f510:d0;
	Node0x10304f5f0 [shape=record,shape=Mrecord,label=&quot;{TargetGlobalAddress\&lt;i32 (i32)* &#64;_Z5sum_ii\&gt; 0|t10|{&lt;d0&gt;i32}}&quot;];
	Node0x10304f660 [shape=record,shape=Mrecord,label=&quot;{RegisterMask|t11|{&lt;d0&gt;Untyped}}&quot;];
	Node0x10304f6d0 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1|&lt;s2&gt;2}|Cpu0ISD::JmpLink|t12|{&lt;d0&gt;ch|&lt;d1&gt;glue}}&quot;];
	Node0x10304f6d0:s0 -&gt; Node0x10304f580:d0[color=blue,style=dashed];
	Node0x10304f6d0:s1 -&gt; Node0x10304f5f0:d0;
	Node0x10304f6d0:s2 -&gt; Node0x10304f660:d0;
	Node0x10304f740 [shape=record,shape=Mrecord,label=&quot;{TargetConstant\&lt;0\&gt;|t13|{&lt;d0&gt;i32}}&quot;];
	Node0x10304f7b0 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1|&lt;s2&gt;2|&lt;s3&gt;3}|callseq_end|t14|{&lt;d0&gt;ch|&lt;d1&gt;glue}}&quot;];
	Node0x10304f7b0:s0 -&gt; Node0x10304f6d0:d0[color=blue,style=dashed];
	Node0x10304f7b0:s1 -&gt; Node0x10304f2e0:d0;
	Node0x10304f7b0:s2 -&gt; Node0x10304f740:d0;
	Node0x10304f7b0:s3 -&gt; Node0x10304f6d0:d1[color=red,style=bold];
	
    NodeComment1 [ penwidth = 1, fontname = &quot;Courier New&quot;, shape = &quot;note&quot;, label =&lt;&lt;table border=&quot;0&quot; cellborder=&quot;0&quot; cellpadding=&quot;3&quot; bgcolor=&quot;gray&quot;&gt;
      &lt;tr&gt;&lt;td align=&quot;left&quot;&gt;// Transform all store nodes into one single node because all store&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td align=&quot;left&quot; port=&quot;f1&quot;&gt;// nodes are independent of each other.&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td align=&quot;left&quot; port=&quot;f2&quot;&gt;if (!MemOpChains.empty())&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td align=&quot;left&quot; port=&quot;f3&quot;&gt;  Chain = DAG.getNode(ISD::TokenFactor, DL, MVT::Other, MemOpChains);&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td align=&quot;left&quot;&gt;  ...&lt;/td&gt;&lt;/tr&gt;
      &lt;/table&gt;&gt; ];
      
    NodeComment2 [ penwidth = 1, fontname = &quot;Courier New&quot;, shape = &quot;note&quot;, label =&lt;&lt;table border=&quot;0&quot; cellborder=&quot;0&quot; cellpadding=&quot;3&quot; bgcolor=&quot;gray&quot;&gt;
      &lt;tr&gt;&lt;td align=&quot;left&quot;&gt;if (!IsPIC) // static&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td align=&quot;left&quot; port=&quot;f1&quot;&gt;  Callee = DAG.getTargetExternalSymbol(Sym,&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td align=&quot;left&quot; port=&quot;f2&quot;&gt;                                       getPointerTy(DAG.getDataLayout()),&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td align=&quot;left&quot; port=&quot;f3&quot;&gt;                                       Cpu0II::MO_NO_FLAG);&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td align=&quot;left&quot;&gt;  ...&lt;/td&gt;&lt;/tr&gt;
      &lt;/table&gt;&gt; ];
      
    Node0x10304f580 -&gt; NodeComment1[color=black,style=dashed];
    NodeComment2:n -&gt; Node0x10304f6d0:e[color=black,style=dashed];
}" />
<p>Mentioned in last section, option <code class="docutils literal"><span class="pre">llc</span> <span class="pre">-cpu0-s32-calls=true</span></code> uses S32 calling
convention which passes all arguements at registers while option
<code class="docutils literal"><span class="pre">llc</span> <span class="pre">-cpu0-s32-calls=false</span></code> uses O32 pass first two arguments at
registers and other arguments at stack. The result as follows,</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">118-165-78-230:input Jonathan$</span> /Users/Jonathan/llvm/test/cmake_debug_build/
<span class="go">Debug/bin/llc -march=cpu0 -mcpu=cpu032I -cpu0-s32-calls=true</span>
<span class="go">-relocation-model=pic -filetype=asm ch9_1.bc -o -</span>
<span class="go">        .text</span>
<span class="go">        .section .mdebug.abiS32</span>
<span class="go">        .previous</span>
<span class="go">        .file &quot;ch9_1.bc&quot;</span>
<span class="go">        .globl        _Z5sum_iiiiiii</span>
<span class="go">        .align        2</span>
<span class="go">        .type _Z5sum_iiiiiii,@function</span>
<span class="go">        .ent  _Z5sum_iiiiiii          # @_Z5sum_iiiiiii</span>
<span class="go">_Z5sum_iiiiiii:</span>
<span class="go">        .frame        $fp,32,$lr</span>
<span class="go">        .mask         0x00000000,0</span>
<span class="go">        .set  noreorder</span>
<span class="go">        .cpload       $t9</span>
<span class="go">        .set  nomacro</span>
<span class="gp">#</span> BB#0:
<span class="go">        addiu $sp, $sp, -32</span>
<span class="go">        ld    $2, 52($sp)</span>
<span class="go">        ld    $3, 48($sp)</span>
<span class="go">        ld    $4, 44($sp)</span>
<span class="go">        ld    $5, 40($sp)</span>
<span class="go">        ld    $t9, 36($sp)</span>
<span class="go">        ld    $7, 32($sp)</span>
<span class="go">        st    $7, 28($sp)</span>
<span class="go">        st    $t9, 24($sp)</span>
<span class="go">        st    $5, 20($sp)</span>
<span class="go">        st    $4, 16($sp)</span>
<span class="go">        st    $3, 12($sp)</span>
<span class="go">        lui   $3, %got_hi(gI)</span>
<span class="go">        addu  $3, $3, $gp</span>
<span class="go">        st    $2, 8($sp)</span>
<span class="go">        ld    $3, %got_lo(gI)($3)</span>
<span class="go">        ld    $3, 0($3)</span>
<span class="go">        ld    $4, 28($sp)</span>
<span class="go">        addu  $3, $3, $4</span>
<span class="go">        ld    $4, 24($sp)</span>
<span class="go">        addu  $3, $3, $4</span>
<span class="go">        ld    $4, 20($sp)</span>
<span class="go">        addu  $3, $3, $4</span>
<span class="go">        ld    $4, 16($sp)</span>
<span class="go">        addu  $3, $3, $4</span>
<span class="go">        ld    $4, 12($sp)</span>
<span class="go">        addu  $3, $3, $4</span>
<span class="go">        addu  $2, $3, $2</span>
<span class="go">        st    $2, 4($sp)</span>
<span class="go">        addiu $sp, $sp, 32</span>
<span class="go">        ret   $lr</span>
<span class="go">        nop</span>
<span class="go">        .set  macro</span>
<span class="go">        .set  reorder</span>
<span class="go">        .end  _Z5sum_iiiiiii</span>
<span class="gp">$</span>tmp0:
<span class="go">        .size _Z5sum_iiiiiii, ($tmp0)-_Z5sum_iiiiiii</span>

<span class="go">        .globl        main</span>
<span class="go">        .align        2</span>
<span class="go">        .type main,@function</span>
<span class="go">        .ent  main                    # @main</span>
<span class="go">main:</span>
<span class="go">        .frame        $fp,40,$lr</span>
<span class="go">        .mask         0x00004000,-4</span>
<span class="go">        .set  noreorder</span>
<span class="go">        .cpload       $t9</span>
<span class="go">        .set  nomacro</span>
<span class="gp">#</span> BB#0:
<span class="go">        addiu $sp, $sp, -40</span>
<span class="go">        st    $lr, 36($sp)            # 4-byte Folded Spill</span>
<span class="go">        addiu $2, $zero, 0</span>
<span class="go">        st    $2, 32($sp)</span>
<span class="go">        addiu $2, $zero, 6</span>
<span class="go">        st    $2, 20($sp)</span>
<span class="go">        addiu $2, $zero, 5</span>
<span class="go">        st    $2, 16($sp)</span>
<span class="go">        addiu $2, $zero, 4</span>
<span class="go">        st    $2, 12($sp)</span>
<span class="go">        addiu $2, $zero, 3</span>
<span class="go">        st    $2, 8($sp)</span>
<span class="go">        addiu $2, $zero, 2</span>
<span class="go">        st    $2, 4($sp)</span>
<span class="go">        addiu $2, $zero, 1</span>
<span class="go">        st    $2, 0($sp)</span>
<span class="go">        ld    $t9, %call16(_Z5sum_iiiiiii)($gp)</span>
<span class="go">        jalr  $t9</span>
<span class="go">        nop</span>
<span class="go">        st    $2, 28($sp)</span>
<span class="go">        ld    $lr, 36($sp)            # 4-byte Folded Reload</span>
<span class="go">        addiu $sp, $sp, 40</span>
<span class="go">        ret   $lr</span>
<span class="go">        nop</span>
<span class="go">        .set  macro</span>
<span class="go">        .set  reorder</span>
<span class="go">        .end  main</span>
<span class="gp">$</span>tmp1:
<span class="go">        .size main, ($tmp1)-main</span>

<span class="go">        .type gI,@object              # @gI</span>
<span class="go">        .data</span>
<span class="go">        .globl        gI</span>
<span class="go">        .align        2</span>
<span class="go">gI:</span>
<span class="go">        .4byte        100                     # 0x64</span>
<span class="go">        .size gI, 4</span>

<span class="gp">118-165-78-230:input Jonathan$</span> /Users/Jonathan/llvm/test/cmake_debug_build/
<span class="go">Debug/bin/llc -march=cpu0 -mcpu=cpu032II -cpu0-s32-calls=false</span>
<span class="go">-relocation-model=pic -filetype=asm ch9_1.bc -o -</span>
<span class="go">  ...</span>
<span class="go">        .globl        main</span>
<span class="go">        .align        2</span>
<span class="go">        .type main,@function</span>
<span class="go">        .ent  main                    # @main</span>
<span class="go">main:</span>
<span class="go">        .frame        $fp,40,$lr</span>
<span class="go">        .mask         0x00004000,-4</span>
<span class="go">        .set  noreorder</span>
<span class="go">        .cpload       $t9</span>
<span class="go">        .set  nomacro</span>
<span class="gp">#</span> BB#0:
<span class="go">        addiu $sp, $sp, -40</span>
<span class="go">        st    $lr, 36($sp)            # 4-byte Folded Spill</span>
<span class="go">        addiu $2, $zero, 0</span>
<span class="go">        st    $2, 32($sp)</span>
<span class="go">        addiu $2, $zero, 6</span>
<span class="go">        st    $2, 20($sp)</span>
<span class="go">        addiu $2, $zero, 5</span>
<span class="go">        st    $2, 16($sp)</span>
<span class="go">        addiu $2, $zero, 4</span>
<span class="go">        st    $2, 12($sp)</span>
<span class="go">        addiu $2, $zero, 3</span>
<span class="go">        st    $2, 8($sp)</span>
<span class="go">        ld    $t9, %call16(_Z5sum_iiiiiii)($gp)</span>
<span class="go">        addiu $4, $zero, 1</span>
<span class="go">        addiu $5, $zero, 2</span>
<span class="go">        jalr  $t9</span>
<span class="go">        nop</span>
<span class="go">        st    $2, 28($sp)</span>
<span class="go">        ld    $lr, 36($sp)            # 4-byte Folded Reload</span>
<span class="go">        addiu $sp, $sp, 40</span>
<span class="go">        ret   $lr</span>
<span class="go">        nop</span>
<span class="go">        .set  macro</span>
<span class="go">        .set  reorder</span>
<span class="go">        .end  main</span>
</pre></div>
</div>
</div>
<div class="section" id="long-and-short-string-initialization">
<h3><a class="toc-backref" href="#id28">Long and short string initialization</a><a class="headerlink" href="#long-and-short-string-initialization" title="Permalink to this headline">¶</a></h3>
<p>The last section mentioned the &#8220;JSUB texternalsym&#8221; pattern. Run Chapter9_2 with
ch9_1_2.cpp to get the result as below. For long string, llvm call memcpy() to
initialize string (char str[81] = &#8220;Hello world&#8221; in this case). For short string,
the &#8220;call memcpy&#8221; is translated into &#8220;store with contant&#8221; in stages of
optimization.</p>
<p class="rubric">lbdex/input/ch9_1_2.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">char</span> <span class="nb">str</span><span class="p">[</span><span class="mi">81</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Hello world&quot;</span><span class="p">;</span>
  <span class="n">char</span> <span class="n">s</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Hello&quot;</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$</span> llvm-dis ch9_1_2.bc -o -
<span class="go">; ModuleID = &#39;ch9_1_2.bc&#39;</span>
<span class="go">...</span>
<span class="go">@_ZZ4mainE3str = private unnamed_addr constant [81 x i8] c&quot;Hello world\00\00\00\</span>
<span class="go">00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00</span>
<span class="go">\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\0</span>
<span class="go">0\00\00\00\00\00\00\00\00\00\00\00\00\00&quot;, align 1</span>
<span class="go">@_ZZ4mainE1s = private unnamed_addr constant [6 x i8] c&quot;Hello\00&quot;, align 1</span>

<span class="go">; Function Attrs: nounwind</span>
<span class="go">define i32 @main() #0 {</span>
<span class="go">entry:</span>
<span class="gp">  %</span><span class="nv">retval</span> <span class="o">=</span> alloca i32, align 4
<span class="gp">  %</span><span class="nv">str</span> <span class="o">=</span> alloca <span class="o">[</span><span class="m">81</span> x i8<span class="o">]</span>, align 1
<span class="go">  store i32 0, i32* %retval</span>
<span class="gp">  %</span><span class="nv">0</span> <span class="o">=</span> bitcast <span class="o">[</span><span class="m">81</span> x i8<span class="o">]</span>* %str to i8*
<span class="go">  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %0, i8* getelementptr inbounds</span>
<span class="go">  ([81 x i8]* @_ZZ4mainE3str, i32 0, i32 0), i32 81, i32 1, i1 false)</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> bitcast <span class="o">[</span><span class="m">6</span> x i8<span class="o">]</span>* %s to i8*
<span class="go">  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %1, i8* getelementptr inbounds</span>
<span class="go">  ([6 x i8]* @_ZZ4mainE1s, i32 0, i32 0), i32 6, i32 1, i1 false)</span>

<span class="go">  ret i32 0</span>
<span class="go">}</span>

<span class="gp">JonathantekiiMac:input Jonathan$</span> clang -target mips-unknown-linux-gnu -c
<span class="go">ch9_1_2.cpp -emit-llvm -o ch9_1_2.bc</span>
<span class="gp">JonathantekiiMac:input Jonathan$</span> /Users/Jonathan/llvm/test/cmake_debug_build
<span class="go">/Debug/bin/llc -march=cpu0 -mcpu=cpu032II -cpu0-s32-calls=true</span>
<span class="go">-relocation-model=static -filetype=asm ch9_1_2.bc -o -</span>
<span class="go">  .section .mdebug.abi32</span>
<span class="go">  ...</span>
<span class="go">        lui   $2, %hi($_ZZ4mainE3str)</span>
<span class="go">        ori   $2, $2, %lo($_ZZ4mainE3str)</span>
<span class="go">        st    $2, 4($sp)</span>
<span class="go">        addiu $2, $sp, 24</span>
<span class="go">        st    $2, 0($sp)</span>
<span class="go">        jsub  memcpy</span>
<span class="go">        nop</span>
<span class="go">        lui   $2, %hi($_ZZ4mainE1s)</span>
<span class="go">        ori   $2, $2, %lo($_ZZ4mainE1s)</span>
<span class="go">        lbu   $3, 4($2)</span>
<span class="go">        shl   $3, $3, 8</span>
<span class="go">        lbu   $4, 5($2)</span>
<span class="go">        or    $3, $3, $4</span>
<span class="go">        sh    $3, 20($sp)</span>
<span class="go">        lbu   $3, 2($2)</span>
<span class="go">        shl   $3, $3, 8</span>
<span class="go">        lbu   $4, 3($2)</span>
<span class="go">        or    $3, $3, $4</span>
<span class="go">        lbu   $4, 1($2)</span>
<span class="go">        lbu   $2, 0($2)</span>
<span class="go">        shl   $2, $2, 8</span>
<span class="go">        or    $2, $2, $4</span>
<span class="go">        shl   $2, $2, 16</span>
<span class="go">        or    $2, $2, $3</span>
<span class="go">        st    $2, 16($sp)</span>
<span class="go">  ...</span>
<span class="go">      .type   $_ZZ4mainE3str,@object  # @_ZZ4mainE3str</span>
<span class="go">      .section        .rodata,&quot;a&quot;,@progbits</span>
<span class="gp">$</span>_ZZ4mainE3str:
<span class="go">        .asciz        &quot;Hello world\000\000\000\000\000\000\000\000\000\000\000\000\000\000</span>
<span class="go">  \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000</span>
<span class="go">  \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000</span>
<span class="go">  \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000&quot;</span>
<span class="go">        .size $_ZZ4mainE3str, 81</span>

<span class="go">        .type $_ZZ4mainE1s,@object    # @_ZZ4mainE1s</span>
<span class="go">        .section      .rodata.str1.1,&quot;aMS&quot;,@progbits,1</span>
<span class="gp">$</span>_ZZ4mainE1s:
<span class="go">        .asciz        &quot;Hello&quot;</span>
<span class="go">        .size $_ZZ4mainE1s, 6</span>
</pre></div>
</div>
<p>The &#8220;call memcpy&#8221; for short string is optimized by llvm before &#8220;DAG-&gt;DAG Pattern
Instruction Selection&#8221; stage and translates it into &#8220;store with contant&#8221; as
follows,</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$</span> /Users/Jonathan/llvm/test/cmake_debug_build
<span class="go">/Debug/bin/llc -march=cpu0 -mcpu=cpu032II -cpu0-s32-calls=true</span>
<span class="go">-relocation-model=static -filetype=asm ch9_1_2.bc -debug -o -</span>

<span class="go">Initial selection DAG: BB#0 &#39;main:entry&#39;</span>
<span class="go">SelectionDAG has 35 nodes:</span>
<span class="go">  ...</span>
<span class="go">        0x7fd909030810: &lt;multiple use&gt;</span>
<span class="go">        0x7fd909030c10: i32 = Constant&lt;1214606444&gt;  // 1214606444=0x48656c6c=&quot;Hell&quot;</span>

<span class="go">        0x7fd909030910: &lt;multiple use&gt;</span>
<span class="go">        0x7fd90902d810: &lt;multiple use&gt;</span>
<span class="go">      0x7fd909030d10: ch = store 0x7fd909030810, 0x7fd909030c10, 0x7fd909030910,</span>
<span class="go">      0x7fd90902d810&lt;ST4[%1]&gt;</span>

<span class="go">        0x7fd909030810: &lt;multiple use&gt;</span>
<span class="go">        0x7fd909030e10: i16 = Constant&lt;28416&gt;      // 28416=0x6f00=&quot;o\0&quot;</span>

<span class="go">        ...</span>

<span class="go">        0x7fd90902d810: &lt;multiple use&gt;</span>
<span class="go">      0x7fd909031210: ch = store 0x7fd909030810, 0x7fd909030e10, 0x7fd909031010,</span>
<span class="go">      0x7fd90902d810&lt;ST2[%1+4](align=4)&gt;</span>
<span class="go">  ...</span>
</pre></div>
</div>
<p>The incoming arguments is the formal arguments defined in compiler and program
language books. The outgoing arguments is the actual arguments.
Summary as Table: Callee incoming arguments and caller outgoing arguments.</p>
<table border="1" class="docutils" id="id18">
<caption><span class="caption-number">Table 30 </span><span class="caption-text">Callee incoming arguments and caller outgoing arguments</span><a class="headerlink" href="#id18" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="22%" />
<col width="39%" />
<col width="39%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Description</th>
<th class="head">Callee</th>
<th class="head">Caller</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Charged Function</td>
<td>LowerFormalArguments()</td>
<td>LowerCall()</td>
</tr>
<tr class="row-odd"><td>Charged Function Created</td>
<td>Create load vectors for incoming arguments</td>
<td>Create store vectors for outgoing arguments</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="structure-type-support">
<h2><a class="toc-backref" href="#id29">Structure type support</a><a class="headerlink" href="#structure-type-support" title="Permalink to this headline">¶</a></h2>
<div class="section" id="ordinary-struct-type">
<h3><a class="toc-backref" href="#id30">Ordinary struct type</a><a class="headerlink" href="#ordinary-struct-type" title="Permalink to this headline">¶</a></h3>
<p>The following code in Chapter9_1/ and Chapter3_4/ support the ordinary
structure type in function call.</p>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0ISelLowering.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">///</span> <span class="n">LowerFormalArguments</span> <span class="o">-</span> <span class="n">transform</span> <span class="n">physical</span> <span class="n">registers</span> <span class="n">into</span> <span class="n">virtual</span> <span class="n">registers</span>
<span class="o">///</span> <span class="ow">and</span> <span class="n">generate</span> <span class="n">load</span> <span class="n">operations</span> <span class="k">for</span> <span class="n">arguments</span> <span class="n">places</span> <span class="n">on</span> <span class="n">the</span> <span class="n">stack</span><span class="o">.</span>
<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">LowerFormalArguments</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span>
                                         <span class="n">CallingConv</span><span class="p">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span>
                                         <span class="nb">bool</span> <span class="n">IsVarArg</span><span class="p">,</span>
                                         <span class="n">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="p">::</span><span class="n">InputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ins</span><span class="p">,</span>
                                         <span class="n">const</span> <span class="n">SDLoc</span> <span class="o">&amp;</span><span class="n">DL</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span>
                                         <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span>
                                          <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  for (unsigned i = 0, e = ArgLocs.size(); i != e; ++i) {
    // The cpu0 ABIs for returning structs by value requires that we copy
    // the sret argument into $v0 for the return. Save the argument into
    // a virtual register so that we can access it from the return points.
    if (Ins[i].Flags.isSRet()) {
      unsigned Reg = Cpu0FI-&gt;getSRetReturnReg();
      if (!Reg) {
        Reg = MF.getRegInfo().createVirtualRegister(
            getRegClassFor(MVT::i32));
        Cpu0FI-&gt;setSRetReturnReg(Reg);
      }
      SDValue Copy = DAG.getCopyToReg(DAG.getEntryNode(), DL, Reg, InVals[i]);
      Chain = DAG.getNode(ISD::TokenFactor, DL, MVT::Other, Copy, Chain);
      break;
    }
  }
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">LowerReturn</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span>
                                <span class="n">CallingConv</span><span class="p">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">IsVarArg</span><span class="p">,</span>
                                <span class="n">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="p">::</span><span class="n">OutputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Outs</span><span class="p">,</span>
                                <span class="n">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">OutVals</span><span class="p">,</span>
                                <span class="n">const</span> <span class="n">SDLoc</span> <span class="o">&amp;</span><span class="n">DL</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  // The cpu0 ABIs for returning structs by value requires that we copy
  // the sret argument into $v0 for the return. We saved the argument into
  // a virtual register in the entry block, so now we copy the value out
  // and into $v0.
  if (MF.getFunction()-&gt;hasStructRetAttr()) {
    Cpu0FunctionInfo *Cpu0FI = MF.getInfo&lt;Cpu0FunctionInfo&gt;();
    unsigned Reg = Cpu0FI-&gt;getSRetReturnReg();

    if (!Reg)
      llvm_unreachable(&quot;sret virtual register not created in the entry block&quot;);
    SDValue Val =
        DAG.getCopyFromReg(Chain, DL, Reg, getPointerTy(DAG.getDataLayout()));
    unsigned V0 = Cpu0::V0;

    Chain = DAG.getCopyToReg(Chain, DL, V0, Val, Flag);
    Flag = Chain.getValue(1);
    RetOps.push_back(DAG.getRegister(V0, getPointerTy(DAG.getDataLayout())));
  }
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="p">}</span>
</pre></div>
</div>
<p>In addition to above code, we defined the calling convention in early
chapter as follows,</p>
<p class="rubric">lbdex/chapters/Chapter3_4/Cpu0CallingConv.td</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">RetCC_Cpu0EABI</span> <span class="p">:</span> <span class="n">CallingConv</span><span class="o">&lt;</span><span class="p">[</span>
  <span class="o">//</span> <span class="n">i32</span> <span class="n">are</span> <span class="n">returned</span> <span class="ow">in</span> <span class="n">registers</span> <span class="n">V0</span><span class="p">,</span> <span class="n">V1</span><span class="p">,</span> <span class="n">A0</span><span class="p">,</span> <span class="n">A1</span>
  <span class="n">CCIfType</span><span class="o">&lt;</span><span class="p">[</span><span class="n">i32</span><span class="p">],</span> <span class="n">CCAssignToReg</span><span class="o">&lt;</span><span class="p">[</span><span class="n">V0</span><span class="p">,</span> <span class="n">V1</span><span class="p">,</span> <span class="n">A0</span><span class="p">,</span> <span class="n">A1</span><span class="p">]</span><span class="o">&gt;&gt;</span>
<span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>It meaning for the return value, we keep it in registers V0, V1, A0, A1 if the size of
return value doesn&#8217;t over 4 registers; If it overs 4 registers, cpu0 will save
them in memory with a pointer of memory in register.
For explanation, let&#8217;s run Chapter9_2/ with ch9_1_struct.cpp and explain with this
example.</p>
<p class="rubric">lbdex/input/ch9_1_struct.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>extern &quot;C&quot; int printf(const char *format, ...);

struct Date
{
  int year;
  int month;
  int day;
  int hour;
  int minute;
  int second;
};
static Date gDate = {2012, 10, 12, 1, 2, 3};

struct Time
{
  int hour;
  int minute;
  int second;
};
static Time gTime = {2, 20, 30};

static Date getDate()
{ 
  return gDate;
}

static Date copyDate(Date date)
{ 
  return date;
}

static Date copyDate(Date* date)
{ 
  return *date;
}

static Time copyTime(Time time)
{ 
  return time;
}

static Time copyTime(Time* time)
{ 
  return *time;
}

int test_func_arg_struct()
{
  Time time1 = {1, 10, 12};
  Date date1 = getDate();
  Date date2 = copyDate(date1);
  Date date3 = copyDate(&amp;date1);
  Time time2 = copyTime(time1);
  Time time3 = copyTime(&amp;time1);
  if (!(date1.year == 2012 &amp;&amp; date1.month == 10 &amp;&amp; date1.day == 12 &amp;&amp; date1.hour 
      == 1 &amp;&amp; date1.minute == 2 &amp;&amp; date1.second == 3))
    return 1;
  if (!(date2.year == 2012 &amp;&amp; date2.month == 10 &amp;&amp; date2.day == 12 &amp;&amp; date2.hour 
      == 1 &amp;&amp; date2.minute == 2 &amp;&amp; date2.second == 3))
    return 1;
  if (!(time2.hour == 1 &amp;&amp; time2.minute == 10 &amp;&amp; time2.second == 12))
    return 1;
  if (!(time3.hour == 1 &amp;&amp; time3.minute == 10 &amp;&amp; time3.second == 12))
    return 1;

#ifdef PRINT_TEST
  printf(&quot;date1 = %d %d %d %d %d %d&quot;, date1.year, date1.month, date1.day,
    date1.hour, date1.minute, date1.second); // date1 = 2012 10 12 1 2 3
  if (date1.year == 2012 &amp;&amp; date1.month == 10 &amp;&amp; date1.day == 12 &amp;&amp; date1.hour 
      == 1 &amp;&amp; date1.minute == 2 &amp;&amp; date1.second == 3)
    printf(&quot;, PASS\n&quot;);
  else
    printf(&quot;, FAIL\n&quot;);
  printf(&quot;date2 = %d %d %d %d %d %d&quot;, date2.year, date2.month, date2.day,
    date2.hour, date2.minute, date2.second); // date2 = 2012 10 12 1 2 3
  if (date2.year == 2012 &amp;&amp; date2.month == 10 &amp;&amp; date2.day == 12 &amp;&amp; date2.hour 
      == 1 &amp;&amp; date2.minute == 2 &amp;&amp; date2.second == 3)
    printf(&quot;, PASS\n&quot;);
  else
    printf(&quot;, FAIL\n&quot;);
  // time2 = 1 10 12
  printf(&quot;time2 = %d %d %d&quot;, time2.hour, time2.minute, time2.second);
  if (time2.hour == 1 &amp;&amp; time2.minute == 10 &amp;&amp; time2.second == 12)
    printf(&quot;, PASS\n&quot;);
  else
    printf(&quot;, FAIL\n&quot;);
  // time3 = 1 10 12
  printf(&quot;time3 = %d %d %d&quot;, time3.hour, time3.minute, time3.second);
  if (time3.hour == 1 &amp;&amp; time3.minute == 10 &amp;&amp; time3.second == 12)
    printf(&quot;, PASS\n&quot;);
  else
    printf(&quot;, FAIL\n&quot;);
#endif

  return 0;
}
</pre></div>
</div>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$</span> /Users/Jonathan/llvm/test/cmake_debug_build/
<span class="go">Debug/bin/llc -march=cpu0 -mcpu=cpu032I -relocation-model=pic -filetype=asm</span>
<span class="go">ch9_1_struct.bc -o -</span>
<span class="go">  .section .mdebug.abi32</span>
<span class="go">  .previous</span>
<span class="go">  .file &quot;ch9_1_struct.bc&quot;</span>
<span class="go">  .text</span>
<span class="go">  .globl  _Z7getDatev</span>
<span class="go">  .align  2</span>
<span class="go">  .type _Z7getDatev,@function</span>
<span class="go">  .ent  _Z7getDatev             # @_Z7getDatev</span>
<span class="go">_Z7getDatev:</span>
<span class="go">  .cfi_startproc</span>
<span class="go">  .frame  $sp,0,$lr</span>
<span class="go">  .mask   0x00000000,0</span>
<span class="go">  .set  noreorder</span>
<span class="go">  .cpload $t9</span>
<span class="go">  .set  nomacro</span>
<span class="gp">#</span> BB#0:
<span class="go">        lui   $2, %got_hi(gDate)</span>
<span class="go">        addu  $2, $2, $gp</span>
<span class="go">        ld    $3, %got_lo(gDate)($2)</span>
<span class="go">        ld    $2, 0($sp)</span>
<span class="go">  ld  $4, 20($3)        // save gDate contents to 212..192($sp)</span>
<span class="go">  st  $4, 20($2)</span>
<span class="go">  ld  $4, 16($3)</span>
<span class="go">  st  $4, 16($2)</span>
<span class="go">  ld  $4, 12($3)</span>
<span class="go">  st  $4, 12($2)</span>
<span class="go">  ld  $4, 8($3)</span>
<span class="go">  st  $4, 8($2)</span>
<span class="go">  ld  $4, 4($3)</span>
<span class="go">  st  $4, 4($2)</span>
<span class="go">  ld  $3, 0($3)</span>
<span class="go">  st  $3, 0($2)</span>
<span class="go">  ret $lr</span>
<span class="go">  nop</span>
<span class="go">  .set  macro</span>
<span class="go">  .set  reorder</span>
<span class="go">  .end  _Z7getDatev</span>
<span class="gp">$</span>tmp0:
<span class="go">  .size _Z7getDatev, ($tmp0)-_Z7getDatev</span>
<span class="go">  .cfi_endproc</span>
<span class="go">  ...</span>
<span class="go">  .globl  _Z20test_func_arg_structv</span>
<span class="go">  .align  2</span>
<span class="go">  .type _Z20test_func_arg_structv,@function</span>
<span class="go">  .ent  _Z20test_func_arg_structv                    # @main</span>
<span class="go">_Z20test_func_arg_structv:</span>
<span class="go">  .cfi_startproc</span>
<span class="go">  .frame  $sp,248,$lr</span>
<span class="go">  .mask   0x00004180,-4</span>
<span class="go">  .set  noreorder</span>
<span class="go">  .cpload $t9</span>
<span class="go">  .set  nomacro</span>
<span class="gp">  #</span> BB#0:
<span class="go">        addiu $sp, $sp, -200</span>
<span class="go">        st    $lr, 196($sp)           # 4-byte Folded Spill</span>
<span class="go">        st    $8, 192($sp)            # 4-byte Folded Spill</span>
<span class="go">        ld    $2, %got($_ZZ20test_func_arg_structvE5time1)($gp)</span>
<span class="go">        ori   $2, $2, %lo($_ZZ20test_func_arg_structvE5time1)</span>
<span class="go">        ld    $3, 8($2)</span>
<span class="go">        st    $3, 184($sp)</span>
<span class="go">        ld    $3, 4($2)</span>
<span class="go">        st    $3, 180($sp)</span>
<span class="go">        ld    $2, 0($2)</span>
<span class="go">        st    $2, 176($sp)</span>
<span class="go">        addiu $8, $sp, 152</span>
<span class="go">        st    $8, 0($sp)</span>
<span class="go">        ld    $t9, %call16(_Z7getDatev)($gp) // copy gDate contents to date1, 176..152($sp)</span>
<span class="go">        jalr  $t9</span>
<span class="go">        nop</span>
<span class="go">        ld    $gp, 176($sp)</span>
<span class="go">        ld    $2, 172($sp)</span>
<span class="go">        st    $2, 124($sp)</span>
<span class="go">        ld    $2, 168($sp)</span>
<span class="go">        st    $2, 120($sp)</span>
<span class="go">        ld    $2, 164($sp)</span>
<span class="go">        st    $2, 116($sp)</span>
<span class="go">        ld    $2, 160($sp)</span>
<span class="go">        st    $2, 112($sp)</span>
<span class="go">        ld    $2, 156($sp)</span>
<span class="go">        st    $2, 108($sp)</span>
<span class="go">        ld    $2, 152($sp)</span>
<span class="go">        st    $2, 104($sp)</span>
<span class="go">  ...</span>
</pre></div>
</div>
<p>The ch9_1_constructor.cpp includes C++ class &#8220;Date&#8221; implementation.
It can be translated into cpu0 backend too since the frontend (clang in this
example) translate them into C language form.
If you mark the &#8220;if hasStructRetAttr()&#8221; part from both of above functions,
the output of cpu0 code for ch9_1_struct.cpp will use $3 instead of $2 as return
register as follows,</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">        .text</span>
<span class="go">        .section .mdebug.abiS32</span>
<span class="go">        .previous</span>
<span class="go">        .file &quot;ch9_1_struct.bc&quot;</span>
<span class="go">        .globl        _Z7getDatev</span>
<span class="go">        .align        2</span>
<span class="go">        .type _Z7getDatev,@function</span>
<span class="go">        .ent  _Z7getDatev             # @_Z7getDatev</span>
<span class="go">_Z7getDatev:</span>
<span class="go">        .frame        $fp,0,$lr</span>
<span class="go">        .mask         0x00000000,0</span>
<span class="go">        .set  noreorder</span>
<span class="go">        .cpload       $t9</span>
<span class="go">        .set  nomacro</span>
<span class="gp">#</span> BB#0:
<span class="go">        lui   $2, %got_hi(gDate)</span>
<span class="go">        addu  $2, $2, $gp</span>
<span class="go">        ld    $2, %got_lo(gDate)($2)</span>
<span class="go">        ld    $3, 0($sp)</span>
<span class="go">        ld    $4, 20($2)</span>
<span class="go">        st    $4, 20($3)</span>
<span class="go">        ld    $4, 16($2)</span>
<span class="go">        st    $4, 16($3)</span>
<span class="go">        ld    $4, 12($2)</span>
<span class="go">        st    $4, 12($3)</span>
<span class="go">        ld    $4, 8($2)</span>
<span class="go">        st    $4, 8($3)</span>
<span class="go">        ld    $4, 4($2)</span>
<span class="go">        st    $4, 4($3)</span>
<span class="go">        ld    $2, 0($2)</span>
<span class="go">        st    $2, 0($3)</span>
<span class="go">        ret   $lr</span>
<span class="go">        nop</span>
<span class="go">  ...</span>
</pre></div>
</div>
<p>Mips ABI asks &#8220;return struct varaible address&#8221; to be set at $2.</p>
</div>
<div class="section" id="byval-struct-type">
<h3><a class="toc-backref" href="#id31">byval struct type</a><a class="headerlink" href="#byval-struct-type" title="Permalink to this headline">¶</a></h3>
<p>The following code in Chapter9_1/ and Chapter9_2/ support the byval structure
type in function call.</p>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0ISelLowering.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>void Cpu0TargetLowering::
copyByValRegs(SDValue Chain, const SDLoc &amp;DL, std::vector&lt;SDValue&gt; &amp;OutChains,
              SelectionDAG &amp;DAG, const ISD::ArgFlagsTy &amp;Flags,
              SmallVectorImpl&lt;SDValue&gt; &amp;InVals, const Argument *FuncArg,
              const Cpu0CC &amp;CC, const ByValArgInfo &amp;ByVal) const {
  MachineFunction &amp;MF = DAG.getMachineFunction();
  MachineFrameInfo *MFI = MF.getFrameInfo();
  unsigned RegAreaSize = ByVal.NumRegs * CC.regSize();
  unsigned FrameObjSize = std::max(Flags.getByValSize(), RegAreaSize);
  int FrameObjOffset;

  const ArrayRef&lt;MCPhysReg&gt; ByValArgRegs = CC.intArgRegs();

  if (RegAreaSize)
    FrameObjOffset = (int)CC.reservedArgArea() -
      (int)((CC.numIntArgRegs() - ByVal.FirstIdx) * CC.regSize());
  else
    FrameObjOffset = ByVal.Address;

  // Create frame object.
  EVT PtrTy = getPointerTy(DAG.getDataLayout());
  int FI = MFI-&gt;CreateFixedObject(FrameObjSize, FrameObjOffset, true);
  SDValue FIN = DAG.getFrameIndex(FI, PtrTy);
  InVals.push_back(FIN);

  if (!ByVal.NumRegs)
    return;

  // Copy arg registers.
  MVT RegTy = MVT::getIntegerVT(CC.regSize() * 8);
  const TargetRegisterClass *RC = getRegClassFor(RegTy);

  for (unsigned I = 0; I &lt; ByVal.NumRegs; ++I) {
    unsigned ArgReg = ByValArgRegs[ByVal.FirstIdx + I];
    unsigned VReg = addLiveIn(MF, ArgReg, RC);
    unsigned Offset = I * CC.regSize();
    SDValue StorePtr = DAG.getNode(ISD::ADD, DL, PtrTy, FIN,
                                   DAG.getConstant(Offset, DL, PtrTy));
    SDValue Store = DAG.getStore(Chain, DL, DAG.getRegister(VReg, RegTy),
                                 StorePtr, MachinePointerInfo(FuncArg, Offset));
    OutChains.push_back(Store);
  }
}
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">///</span> <span class="n">LowerFormalArguments</span> <span class="o">-</span> <span class="n">transform</span> <span class="n">physical</span> <span class="n">registers</span> <span class="n">into</span> <span class="n">virtual</span> <span class="n">registers</span>
<span class="o">///</span> <span class="ow">and</span> <span class="n">generate</span> <span class="n">load</span> <span class="n">operations</span> <span class="k">for</span> <span class="n">arguments</span> <span class="n">places</span> <span class="n">on</span> <span class="n">the</span> <span class="n">stack</span><span class="o">.</span>
<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">LowerFormalArguments</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span>
                                         <span class="n">CallingConv</span><span class="p">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span>
                                         <span class="nb">bool</span> <span class="n">IsVarArg</span><span class="p">,</span>
                                         <span class="n">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="p">::</span><span class="n">InputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ins</span><span class="p">,</span>
                                         <span class="n">const</span> <span class="n">SDLoc</span> <span class="o">&amp;</span><span class="n">DL</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span>
                                         <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span>
                                          <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="k">for</span> <span class="p">(</span><span class="n">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">ArgLocs</span><span class="o">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>    <span class="k">if</span> <span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">isByVal</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">assert</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">getByValSize</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
             <span class="s2">&quot;ByVal args of size 0 should have been ignored by front-end.&quot;</span><span class="p">);</span>
      <span class="k">assert</span><span class="p">(</span><span class="n">ByValArg</span> <span class="o">!=</span> <span class="n">Cpu0CCInfo</span><span class="o">.</span><span class="n">byval_end</span><span class="p">());</span>
      <span class="n">copyByValRegs</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">OutChains</span><span class="p">,</span> <span class="n">DAG</span><span class="p">,</span> <span class="n">Flags</span><span class="p">,</span> <span class="n">InVals</span><span class="p">,</span> <span class="o">&amp;*</span><span class="n">FuncArg</span><span class="p">,</span>
                    <span class="n">Cpu0CCInfo</span><span class="p">,</span> <span class="o">*</span><span class="n">ByValArg</span><span class="p">);</span>
      <span class="o">++</span><span class="n">ByValArg</span><span class="p">;</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>    <span class="p">...</span>
<span class="p">.</span> <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  for (unsigned i = 0, e = ArgLocs.size(); i != e; ++i) {
    // The cpu0 ABIs for returning structs by value requires that we copy
    // the sret argument into $v0 for the return. Save the argument into
    // a virtual register so that we can access it from the return points.
    if (Ins[i].Flags.isSRet()) {
      unsigned Reg = Cpu0FI-&gt;getSRetReturnReg();
      if (!Reg) {
        Reg = MF.getRegInfo().createVirtualRegister(
            getRegClassFor(MVT::i32));
        Cpu0FI-&gt;setSRetReturnReg(Reg);
      }
      SDValue Copy = DAG.getCopyToReg(DAG.getEntryNode(), DL, Reg, InVals[i]);
      Chain = DAG.getNode(ISD::TokenFactor, DL, MVT::Other, Copy, Chain);
      break;
    }
  }
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_2/Cpu0ISelLowering.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Copy</span> <span class="n">byVal</span> <span class="n">arg</span> <span class="n">to</span> <span class="n">registers</span> <span class="ow">and</span> <span class="n">stack</span><span class="o">.</span>
<span class="n">void</span> <span class="n">Cpu0TargetLowering</span><span class="p">::</span>
<span class="n">passByValArg</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">const</span> <span class="n">SDLoc</span> <span class="o">&amp;</span><span class="n">DL</span><span class="p">,</span>
             <span class="n">std</span><span class="p">::</span><span class="n">deque</span><span class="o">&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">unsigned</span><span class="p">,</span> <span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">RegsToPass</span><span class="p">,</span>
             <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">MemOpChains</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">StackPtr</span><span class="p">,</span>
             <span class="n">MachineFrameInfo</span> <span class="o">*</span><span class="n">MFI</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">Arg</span><span class="p">,</span>
             <span class="n">const</span> <span class="n">Cpu0CC</span> <span class="o">&amp;</span><span class="n">CC</span><span class="p">,</span> <span class="n">const</span> <span class="n">ByValArgInfo</span> <span class="o">&amp;</span><span class="n">ByVal</span><span class="p">,</span>
             <span class="n">const</span> <span class="n">ISD</span><span class="p">::</span><span class="n">ArgFlagsTy</span> <span class="o">&amp;</span><span class="n">Flags</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">isLittle</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="n">unsigned</span> <span class="n">ByValSizeInBytes</span> <span class="o">=</span> <span class="n">Flags</span><span class="o">.</span><span class="n">getByValSize</span><span class="p">();</span>
  <span class="n">unsigned</span> <span class="n">OffsetInBytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">//</span> <span class="n">From</span> <span class="n">beginning</span> <span class="n">of</span> <span class="n">struct</span>
  <span class="n">unsigned</span> <span class="n">RegSizeInBytes</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">regSize</span><span class="p">();</span>
  <span class="n">unsigned</span> <span class="n">Alignment</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="nb">min</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">getByValAlign</span><span class="p">(),</span> <span class="n">RegSizeInBytes</span><span class="p">);</span>
  <span class="n">EVT</span> <span class="n">PtrTy</span> <span class="o">=</span> <span class="n">getPointerTy</span><span class="p">(</span><span class="n">DAG</span><span class="o">.</span><span class="n">getDataLayout</span><span class="p">()),</span>
      <span class="n">RegTy</span> <span class="o">=</span> <span class="n">MVT</span><span class="p">::</span><span class="n">getIntegerVT</span><span class="p">(</span><span class="n">RegSizeInBytes</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">ByVal</span><span class="o">.</span><span class="n">NumRegs</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">const</span> <span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">MCPhysReg</span><span class="o">&gt;</span> <span class="n">ArgRegs</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">intArgRegs</span><span class="p">();</span>
    <span class="nb">bool</span> <span class="n">LeftoverBytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">ByVal</span><span class="o">.</span><span class="n">NumRegs</span> <span class="o">*</span> <span class="n">RegSizeInBytes</span> <span class="o">&gt;</span> <span class="n">ByValSizeInBytes</span><span class="p">);</span>
    <span class="n">unsigned</span> <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Copy</span> <span class="n">words</span> <span class="n">to</span> <span class="n">registers</span><span class="o">.</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">I</span> <span class="o">&lt;</span> <span class="n">ByVal</span><span class="o">.</span><span class="n">NumRegs</span> <span class="o">-</span> <span class="n">LeftoverBytes</span><span class="p">;</span>
         <span class="o">++</span><span class="n">I</span><span class="p">,</span> <span class="n">OffsetInBytes</span> <span class="o">+=</span> <span class="n">RegSizeInBytes</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">SDValue</span> <span class="n">LoadPtr</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">ADD</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">PtrTy</span><span class="p">,</span> <span class="n">Arg</span><span class="p">,</span>
                                    <span class="n">DAG</span><span class="o">.</span><span class="n">getConstant</span><span class="p">(</span><span class="n">OffsetInBytes</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">PtrTy</span><span class="p">));</span>
      <span class="n">SDValue</span> <span class="n">LoadVal</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getLoad</span><span class="p">(</span><span class="n">RegTy</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">LoadPtr</span><span class="p">,</span>
                                    <span class="n">MachinePointerInfo</span><span class="p">());</span>
      <span class="n">MemOpChains</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">LoadVal</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
      <span class="n">unsigned</span> <span class="n">ArgReg</span> <span class="o">=</span> <span class="n">ArgRegs</span><span class="p">[</span><span class="n">ByVal</span><span class="o">.</span><span class="n">FirstIdx</span> <span class="o">+</span> <span class="n">I</span><span class="p">];</span>
      <span class="n">RegsToPass</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">ArgReg</span><span class="p">,</span> <span class="n">LoadVal</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="o">//</span> <span class="n">Return</span> <span class="k">if</span> <span class="n">the</span> <span class="n">struct</span> <span class="n">has</span> <span class="n">been</span> <span class="n">fully</span> <span class="n">copied</span><span class="o">.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ByValSizeInBytes</span> <span class="o">==</span> <span class="n">OffsetInBytes</span><span class="p">)</span>
      <span class="k">return</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Copy</span> <span class="n">the</span> <span class="n">remainder</span> <span class="n">of</span> <span class="n">the</span> <span class="n">byval</span> <span class="n">argument</span> <span class="k">with</span> <span class="n">sub</span><span class="o">-</span><span class="n">word</span> <span class="n">loads</span> <span class="ow">and</span> <span class="n">shifts</span><span class="o">.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">LeftoverBytes</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">assert</span><span class="p">((</span><span class="n">ByValSizeInBytes</span> <span class="o">&gt;</span> <span class="n">OffsetInBytes</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
             <span class="p">(</span><span class="n">ByValSizeInBytes</span> <span class="o">&lt;</span> <span class="n">OffsetInBytes</span> <span class="o">+</span> <span class="n">RegSizeInBytes</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
             <span class="s2">&quot;Size of the remainder should be smaller than RegSizeInBytes.&quot;</span><span class="p">);</span>
      <span class="n">SDValue</span> <span class="n">Val</span><span class="p">;</span>

      <span class="k">for</span> <span class="p">(</span><span class="n">unsigned</span> <span class="n">LoadSizeInBytes</span> <span class="o">=</span> <span class="n">RegSizeInBytes</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">TotalBytesLoaded</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
           <span class="n">OffsetInBytes</span> <span class="o">&lt;</span> <span class="n">ByValSizeInBytes</span><span class="p">;</span> <span class="n">LoadSizeInBytes</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">unsigned</span> <span class="n">RemainingSizeInBytes</span> <span class="o">=</span> <span class="n">ByValSizeInBytes</span> <span class="o">-</span> <span class="n">OffsetInBytes</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">RemainingSizeInBytes</span> <span class="o">&lt;</span> <span class="n">LoadSizeInBytes</span><span class="p">)</span>
          <span class="k">continue</span><span class="p">;</span>

        <span class="o">//</span> <span class="n">Load</span> <span class="n">subword</span><span class="o">.</span>
        <span class="n">SDValue</span> <span class="n">LoadPtr</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">ADD</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">PtrTy</span><span class="p">,</span> <span class="n">Arg</span><span class="p">,</span>
                                      <span class="n">DAG</span><span class="o">.</span><span class="n">getConstant</span><span class="p">(</span><span class="n">OffsetInBytes</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">PtrTy</span><span class="p">));</span>
        <span class="n">SDValue</span> <span class="n">LoadVal</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getExtLoad</span><span class="p">(</span>
            <span class="n">ISD</span><span class="p">::</span><span class="n">ZEXTLOAD</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">RegTy</span><span class="p">,</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">LoadPtr</span><span class="p">,</span> <span class="n">MachinePointerInfo</span><span class="p">(),</span>
            <span class="n">MVT</span><span class="p">::</span><span class="n">getIntegerVT</span><span class="p">(</span><span class="n">LoadSizeInBytes</span> <span class="o">*</span> <span class="mi">8</span><span class="p">),</span> <span class="n">Alignment</span><span class="p">);</span>
        <span class="n">MemOpChains</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">LoadVal</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>

        <span class="o">//</span> <span class="n">Shift</span> <span class="n">the</span> <span class="n">loaded</span> <span class="n">value</span><span class="o">.</span>
        <span class="n">unsigned</span> <span class="n">Shamt</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">isLittle</span><span class="p">)</span>
          <span class="n">Shamt</span> <span class="o">=</span> <span class="n">TotalBytesLoaded</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>
        <span class="k">else</span>
          <span class="n">Shamt</span> <span class="o">=</span> <span class="p">(</span><span class="n">RegSizeInBytes</span> <span class="o">-</span> <span class="p">(</span><span class="n">TotalBytesLoaded</span> <span class="o">+</span> <span class="n">LoadSizeInBytes</span><span class="p">))</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>

        <span class="n">SDValue</span> <span class="n">Shift</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">SHL</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">RegTy</span><span class="p">,</span> <span class="n">LoadVal</span><span class="p">,</span>
                                    <span class="n">DAG</span><span class="o">.</span><span class="n">getConstant</span><span class="p">(</span><span class="n">Shamt</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">MVT</span><span class="p">::</span><span class="n">i32</span><span class="p">));</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">Val</span><span class="o">.</span><span class="n">getNode</span><span class="p">())</span>
          <span class="n">Val</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">OR</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">RegTy</span><span class="p">,</span> <span class="n">Val</span><span class="p">,</span> <span class="n">Shift</span><span class="p">);</span>
        <span class="k">else</span>
          <span class="n">Val</span> <span class="o">=</span> <span class="n">Shift</span><span class="p">;</span>

        <span class="n">OffsetInBytes</span> <span class="o">+=</span> <span class="n">LoadSizeInBytes</span><span class="p">;</span>
        <span class="n">TotalBytesLoaded</span> <span class="o">+=</span> <span class="n">LoadSizeInBytes</span><span class="p">;</span>
        <span class="n">Alignment</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="nb">min</span><span class="p">(</span><span class="n">Alignment</span><span class="p">,</span> <span class="n">LoadSizeInBytes</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="n">unsigned</span> <span class="n">ArgReg</span> <span class="o">=</span> <span class="n">ArgRegs</span><span class="p">[</span><span class="n">ByVal</span><span class="o">.</span><span class="n">FirstIdx</span> <span class="o">+</span> <span class="n">I</span><span class="p">];</span>
      <span class="n">RegsToPass</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">ArgReg</span><span class="p">,</span> <span class="n">Val</span><span class="p">));</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="o">//</span> <span class="n">Copy</span> <span class="n">remainder</span> <span class="n">of</span> <span class="n">byval</span> <span class="n">arg</span> <span class="n">to</span> <span class="n">it</span> <span class="k">with</span> <span class="n">memcpy</span><span class="o">.</span>
  <span class="n">unsigned</span> <span class="n">MemCpySize</span> <span class="o">=</span> <span class="n">ByValSizeInBytes</span> <span class="o">-</span> <span class="n">OffsetInBytes</span><span class="p">;</span>
  <span class="n">SDValue</span> <span class="n">Src</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">ADD</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">PtrTy</span><span class="p">,</span> <span class="n">Arg</span><span class="p">,</span>
                            <span class="n">DAG</span><span class="o">.</span><span class="n">getConstant</span><span class="p">(</span><span class="n">OffsetInBytes</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">PtrTy</span><span class="p">));</span>
  <span class="n">SDValue</span> <span class="n">Dst</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">ADD</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">PtrTy</span><span class="p">,</span> <span class="n">StackPtr</span><span class="p">,</span>
                            <span class="n">DAG</span><span class="o">.</span><span class="n">getIntPtrConstant</span><span class="p">(</span><span class="n">ByVal</span><span class="o">.</span><span class="n">Address</span><span class="p">,</span> <span class="n">DL</span><span class="p">));</span>
  <span class="n">Chain</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getMemcpy</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Dst</span><span class="p">,</span> <span class="n">Src</span><span class="p">,</span>
                        <span class="n">DAG</span><span class="o">.</span><span class="n">getConstant</span><span class="p">(</span><span class="n">MemCpySize</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">PtrTy</span><span class="p">),</span>
                        <span class="n">Alignment</span><span class="p">,</span> <span class="o">/*</span><span class="n">isVolatile</span><span class="o">=*/</span><span class="n">false</span><span class="p">,</span> <span class="o">/*</span><span class="n">AlwaysInline</span><span class="o">=*/</span><span class="n">false</span><span class="p">,</span>
                        <span class="o">/*</span><span class="n">isTailCall</span><span class="o">=*/</span><span class="n">false</span><span class="p">,</span>
                        <span class="n">MachinePointerInfo</span><span class="p">(),</span> <span class="n">MachinePointerInfo</span><span class="p">());</span>
  <span class="n">MemOpChains</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Chain</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">///</span> <span class="n">LowerCall</span> <span class="o">-</span> <span class="n">functions</span> <span class="n">arguments</span> <span class="n">are</span> <span class="n">copied</span> <span class="kn">from</span> <span class="nn">virtual</span> <span class="n">regs</span> <span class="n">to</span>
<span class="o">///</span> <span class="p">(</span><span class="n">physical</span> <span class="n">regs</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">stack</span> <span class="n">frame</span><span class="p">),</span> <span class="n">CALLSEQ_START</span> <span class="ow">and</span> <span class="n">CALLSEQ_END</span> <span class="n">are</span> <span class="n">emitted</span><span class="o">.</span>
<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">LowerCall</span><span class="p">(</span><span class="n">TargetLowering</span><span class="p">::</span><span class="n">CallLoweringInfo</span> <span class="o">&amp;</span><span class="n">CLI</span><span class="p">,</span>
                              <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="o">//</span> <span class="n">Walk</span> <span class="n">the</span> <span class="n">register</span><span class="o">/</span><span class="n">memloc</span> <span class="n">assignments</span><span class="p">,</span> <span class="n">inserting</span> <span class="n">copies</span><span class="o">/</span><span class="n">loads</span><span class="o">.</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">ArgLocs</span><span class="o">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>    if (Flags.isByVal()) {
      assert(Flags.getByValSize() &amp;&amp;
             &quot;ByVal args of size 0 should have been ignored by front-end.&quot;);
      assert(ByValArg != Cpu0CCInfo.byval_end());
      assert(!IsTailCall &amp;&amp;
             &quot;Do not tail-call optimize if there is a byval argument.&quot;);
      passByValArg(Chain, DL, RegsToPass, MemOpChains, StackPtr, MFI, DAG, Arg,
                   Cpu0CCInfo, *ByValArg, Flags, Subtarget.isLittle());
      ++ByValArg;
      continue;
    }
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>    <span class="p">...</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In LowerCall(), Flags.isByVal() will be true if it meets <strong>byval</strong> for struct
type in caller function as follows,</p>
<p class="rubric">lbdex/input/tailcall.ll</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">define</span> <span class="k">internal</span> <span class="k">fastcc</span> <span class="k">i32</span> <span class="vg">@caller9_1</span><span class="p">()</span> <span class="k">nounwind</span> <span class="k">noinline</span> <span class="p">{</span>
<span class="nl">entry:</span>
  <span class="p">...</span>
  <span class="nv">%call</span> <span class="p">=</span> <span class="k">tail</span> <span class="k">call</span> <span class="k">i32</span> <span class="vg">@callee9</span><span class="p">(</span><span class="nv">%struct.S</span><span class="p">*</span> <span class="k">byval</span> <span class="vg">@gs1</span><span class="p">)</span> <span class="k">nounwind</span>
  <span class="k">ret</span> <span class="k">i32</span> <span class="nv">%call</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In LowerFormalArguments(), Flags.isByVal() will be true when it meets <strong>byval</strong>
in callee function as follows,</p>
<p class="rubric">lbdex/input/tailcall.ll</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">define</span> <span class="k">i32</span> <span class="vg">@caller12</span><span class="p">(</span><span class="nv">%struct.S</span><span class="p">*</span> <span class="k">nocapture</span> <span class="k">byval</span> <span class="nv">%a0</span><span class="p">)</span> <span class="k">nounwind</span> <span class="p">{</span>
<span class="nl">entry:</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>At this point, I don&#8217;t know how to create a make clang to generate byval IR with
C language.</p>
</div>
</div>
<div class="section" id="function-call-optiomization">
<h2><a class="toc-backref" href="#id32">Function call optiomization</a><a class="headerlink" href="#function-call-optiomization" title="Permalink to this headline">¶</a></h2>
<div class="section" id="tail-call-optimization">
<h3><a class="toc-backref" href="#id33">Tail call optimization</a><a class="headerlink" href="#tail-call-optimization" title="Permalink to this headline">¶</a></h3>
<p>Tail call optimization is used in some situation of function call. For some
situation, the caller and callee stack can share the same memory stack.
When this situation applied in recursive function call, it often asymptotically
reduces stack space requirements from linear, or O(n), to constant, or O(1)
<a class="footnote-reference" href="#wikitailcall" id="id6">[5]</a>. LLVM IR supports tailcall here <a class="footnote-reference" href="#tailcallopt" id="id7">[6]</a>.</p>
<p>The <strong>tailcall</strong> appeared in Cpu0ISelLowering.cpp and Cpu0InstrInfo.td are used
to make tail call optimization.</p>
<p class="rubric">lbdex/input/ch9_2_tailcall.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>
<span class="nb">int</span> <span class="n">factorial</span><span class="p">(</span><span class="nb">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">factorial</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">test_tailcall</span><span class="p">(</span><span class="nb">int</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">factorial</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="p">}</span>

</pre></div>
</div>
<p>Run Chapter9_2/ with ch9_2_tailcall.cpp will get the following result.</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$</span> clang -O1 -target mips-unknown-linux-gnu -c
<span class="go">ch9_2_tailcall.cpp -emit-llvm -o ch9_2_tailcall.bc</span>
<span class="gp">JonathantekiiMac:input Jonathan$</span> ~/llvm/test/cmake_debug_build/bin/
<span class="go">llvm-dis ch9_2_tailcall.bc -o -</span>
<span class="go">...</span>
<span class="go">; Function Attrs: nounwind readnone</span>
<span class="go">define i32 @_Z9factoriali(i32 %x) #0 {</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> icmp sgt i32 %x, 0
<span class="go">  br i1 %1, label %tailrecurse, label %tailrecurse._crit_edge</span>

<span class="go">tailrecurse:                                      ; preds = %tailrecurse, %0</span>
<span class="gp">  %</span>x.tr2 <span class="o">=</span> phi i32 <span class="o">[</span> %2, %tailrecurse <span class="o">]</span>, <span class="o">[</span> %x, %0 <span class="o">]</span>
<span class="gp">  %</span>accumulator.tr1 <span class="o">=</span> phi i32 <span class="o">[</span> %3, %tailrecurse <span class="o">]</span>, <span class="o">[</span> 1, %0 <span class="o">]</span>
<span class="gp">  %</span><span class="nv">2</span> <span class="o">=</span> add nsw i32 %x.tr2, -1
<span class="gp">  %</span><span class="nv">3</span> <span class="o">=</span> mul nsw i32 %x.tr2, %accumulator.tr1
<span class="gp">  %</span><span class="nv">4</span> <span class="o">=</span> icmp sgt i32 %2, 0
<span class="go">  br i1 %4, label %tailrecurse, label %tailrecurse._crit_edge</span>

<span class="go">tailrecurse._crit_edge:                           ; preds = %tailrecurse, %0</span>
<span class="gp">  %</span>accumulator.tr.lcssa <span class="o">=</span> phi i32 <span class="o">[</span> 1, %0 <span class="o">]</span>, <span class="o">[</span> %3, %tailrecurse <span class="o">]</span>
<span class="go">  ret i32 %accumulator.tr.lcssa</span>
<span class="go">}</span>

<span class="go">; Function Attrs: nounwind readnone</span>
<span class="go">define i32 @_Z13test_tailcalli(i32 %a) #0 {</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> tail call i32 @_Z9factoriali<span class="o">(</span>i32 %a<span class="o">)</span>
<span class="go">  ret i32 %1</span>
<span class="go">}</span>
<span class="go">...</span>
<span class="gp">JonathantekiiMac:input Jonathan$</span> ~/llvm/test/cmake_debug_build/bin/
<span class="go">llc -march=cpu0 -mcpu=cpu032II -relocation-model=static -filetype=asm</span>
<span class="go">-enable-cpu0-tail-calls ch9_2_tailcall.bc -stats -o -</span>
<span class="go">        .text</span>
<span class="go">        .section .mdebug.abi32</span>
<span class="go">        .previous</span>
<span class="go">        .file &quot;ch9_2_tailcall.bc&quot;</span>
<span class="go">        .globl        _Z9factoriali</span>
<span class="go">        .align        2</span>
<span class="go">        .type _Z9factoriali,@function</span>
<span class="go">        .ent  _Z9factoriali           # @_Z9factoriali</span>
<span class="go">_Z9factoriali:</span>
<span class="go">        .frame        $sp,0,$lr</span>
<span class="go">        .mask         0x00000000,0</span>
<span class="go">        .set  noreorder</span>
<span class="go">        .set  nomacro</span>
<span class="gp">#</span> BB#0:
<span class="go">        addiu $2, $zero, 1</span>
<span class="go">        slt   $3, $4, $2</span>
<span class="go">        bne   $3, $zero, $BB0_2</span>
<span class="go">        nop</span>
<span class="gp">$</span>BB0_1:                                 <span class="c1"># %tailrecurse</span>
<span class="gp">                                        #</span> <span class="o">=</span>&gt;This Inner Loop Header: <span class="nv">Depth</span><span class="o">=</span>1
<span class="go">        mul   $2, $4, $2</span>
<span class="go">        addiu $4, $4, -1</span>
<span class="go">        addiu $3, $zero, 0</span>
<span class="go">        slt   $3, $3, $4</span>
<span class="go">        bne   $3, $zero, $BB0_1</span>
<span class="go">        nop</span>
<span class="gp">$</span>BB0_2:                                 <span class="c1"># %tailrecurse._crit_edge</span>
<span class="go">        ret   $lr</span>
<span class="go">        nop</span>
<span class="go">        .set  macro</span>
<span class="go">        .set  reorder</span>
<span class="go">        .end  _Z9factoriali</span>
<span class="gp">$</span>tmp0:
<span class="go">        .size _Z9factoriali, ($tmp0)-_Z9factoriali</span>

<span class="go">        .globl        _Z13test_tailcalli</span>
<span class="go">        .align        2</span>
<span class="go">        .type _Z13test_tailcalli,@function</span>
<span class="go">        .ent  _Z13test_tailcalli      # @_Z13test_tailcalli</span>
<span class="go">_Z13test_tailcalli:</span>
<span class="go">        .frame        $sp,0,$lr</span>
<span class="go">        .mask         0x00000000,0</span>
<span class="go">        .set  noreorder</span>
<span class="go">        .set  nomacro</span>
<span class="gp">#</span> BB#0:
<span class="go">        jmp   _Z9factoriali</span>
<span class="go">        nop</span>
<span class="go">        .set  macro</span>
<span class="go">        .set  reorder</span>
<span class="go">        .end  _Z13test_tailcalli</span>
<span class="gp">$</span>tmp1:
<span class="go">        .size _Z13test_tailcalli, ($tmp1)-_Z13test_tailcalli</span>


<span class="go">===-------------------------------------------------------------------------===</span>
<span class="go">                          ... Statistics Collected ...</span>
<span class="go">===-------------------------------------------------------------------------===</span>

<span class="go"> ...</span>
<span class="go"> 1 cpu0-lower        - Number of tail calls</span>
<span class="go"> ...</span>
</pre></div>
</div>
<p>The tail call optimization shares caller&#8217;s and callee&#8217;s stack and it is applied
in cpu032II only for this example (it uses &#8220;jmp _Z9factoriali&#8221; instead of
&#8220;jsub _Z9factoriali&#8221;).
Then cpu032I (pass all arguments in
stack) doesn&#8217;t satisfy the statement, NextStackOffset &lt;=
FI.getIncomingArgSize() in isEligibleForTailCallOptimization(), and return
false for the function as follows,</p>
<p class="rubric">lbdex/chapters/Chapter9_2/Cpu0SEISelLowering.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>bool Cpu0SETargetLowering::
isEligibleForTailCallOptimization(const Cpu0CC &amp;Cpu0CCInfo,
                                  unsigned NextStackOffset,
                                  const Cpu0FunctionInfo&amp; FI) const {
  if (!EnableCpu0TailCalls)
    return false;

  // Return false if either the callee or caller has a byval argument.
  if (Cpu0CCInfo.hasByValArg() || FI.hasByvalArg())
    return false;

  // Return true if the callee&#39;s argument area is no larger than the
  // caller&#39;s.
  return NextStackOffset &lt;= FI.getIncomingArgSize();
}
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_2/Cpu0ISelLowering.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">///</span> <span class="n">LowerCall</span> <span class="o">-</span> <span class="n">functions</span> <span class="n">arguments</span> <span class="n">are</span> <span class="n">copied</span> <span class="kn">from</span> <span class="nn">virtual</span> <span class="n">regs</span> <span class="n">to</span>
<span class="o">///</span> <span class="p">(</span><span class="n">physical</span> <span class="n">regs</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">stack</span> <span class="n">frame</span><span class="p">),</span> <span class="n">CALLSEQ_START</span> <span class="ow">and</span> <span class="n">CALLSEQ_END</span> <span class="n">are</span> <span class="n">emitted</span><span class="o">.</span>
<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">LowerCall</span><span class="p">(</span><span class="n">TargetLowering</span><span class="p">::</span><span class="n">CallLoweringInfo</span> <span class="o">&amp;</span><span class="n">CLI</span><span class="p">,</span>
                              <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  // Check if it&#39;s really possible to do a tail call.
  if (IsTailCall)
    IsTailCall =
      isEligibleForTailCallOptimization(Cpu0CCInfo, NextStackOffset,
                                        *MF.getInfo&lt;Cpu0FunctionInfo&gt;());

  if (!IsTailCall &amp;&amp; CLI.CS &amp;&amp; CLI.CS-&gt;isMustTailCall())
    report_fatal_error(&quot;failed to perform tail call elimination on a call &quot;
                       &quot;site marked musttail&quot;);

  if (IsTailCall)
    ++NumTailCalls;
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  if (!IsTailCall)
    Chain = DAG.getCALLSEQ_START(Chain, NextStackOffsetVal, DL);
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="k">if</span> <span class="p">(</span><span class="n">IsTailCall</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">Cpu0ISD</span><span class="p">::</span><span class="n">TailCall</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">MVT</span><span class="p">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Ops</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Since tailcall optimization will translate jmp instruction directly instead of
jsub. The callseq_start, callseq_end, and the DAG nodes created in
LowerCallResult() and LowerReturn() are needless. It creates DAGs for
ch9_2_tailcall.cpp as the following figure,</p>
<img src="_images/graphviz-884adc625838a4d6778fccde9b873cbbed007c4b.png" alt="digraph &quot;isel input for _Z13test_tailcalli:&quot; {
	rankdir=&quot;BT&quot;;
	label=&quot;Figure: Outgoing arguments DAGs created for ch9_2_tailcall.cpp&quot;;

	Node0x103a04f20 [shape=record,shape=Mrecord,label=&quot;{EntryToken|t0|{&lt;d0&gt;ch}}&quot;];
	Node0x10404ef70 [shape=record,shape=Mrecord,label=&quot;{Register %vreg0|t1|{&lt;d0&gt;i32}}&quot;];
	Node0x10404ebf0 [shape=record,shape=Mrecord,label=&quot;{TargetGlobalAddress\&lt;i32 (i32)* &#64;_Z9factoriali\&gt; 0|t7|{&lt;d0&gt;i32}}&quot;];
	Node0x10404ea30 [shape=record,shape=Mrecord,label=&quot;{Register %A0|t8|{&lt;d0&gt;i32}}&quot;];
	Node0x10404ec60 [shape=record,shape=Mrecord,label=&quot;{RegisterMask|t10|{&lt;d0&gt;Untyped}}&quot;];
	Node0x10404f050 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1}|CopyFromReg|t2|{&lt;d0&gt;i32|&lt;d1&gt;ch}}&quot;];
	Node0x10404f050:s0 -&gt; Node0x103a04f20:d0[color=blue,style=dashed];
	Node0x10404f050:s1 -&gt; Node0x10404ef70:d0;
	Node0x10404eb10 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1|&lt;s2&gt;2}|CopyToReg|t9|{&lt;d0&gt;ch|&lt;d1&gt;glue}}&quot;];
	Node0x10404eb10:s0 -&gt; Node0x103a04f20:d0[color=blue,style=dashed];
	Node0x10404eb10:s1 -&gt; Node0x10404ea30:d0;
	Node0x10404eb10:s2 -&gt; Node0x10404f050:d0;
	Node0x10404e9c0 [shape=record,shape=Mrecord,label=&quot;{{&lt;s0&gt;0|&lt;s1&gt;1|&lt;s2&gt;2|&lt;s3&gt;3|&lt;s4&gt;4}|Cpu0ISD::TailCall|t11|{&lt;d0&gt;ch}}&quot;];
	Node0x10404e9c0:s0 -&gt; Node0x103a04f20:d0[color=blue,style=dashed];
	Node0x10404e9c0:s1 -&gt; Node0x10404ebf0:d0;
	Node0x10404e9c0:s2 -&gt; Node0x10404ea30:d0;
	Node0x10404e9c0:s3 -&gt; Node0x10404ec60:d0;
	Node0x10404e9c0:s4 -&gt; Node0x10404eb10:d1[color=red,style=bold];
	Node0x0[ plaintext=circle, label =&quot;GraphRoot&quot;];
	Node0x0 -&gt; Node0x10404e9c0:d0[color=blue,style=dashed];
}" />
<p>Finally, listing the DAGs translation of tail call as the following table.</p>
<table border="1" class="docutils" id="id19">
<caption><span class="caption-number">Table 31 </span><span class="caption-text">the DAGs translation of tail call</span><a class="headerlink" href="#id19" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="49%" />
<col width="29%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Stage</th>
<th class="head">DAG</th>
<th class="head">Function</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Backend lowering</td>
<td>Cpu0ISD::TailCall</td>
<td>LowerCall()</td>
</tr>
<tr class="row-odd"><td>Instruction selection</td>
<td>TAILCALL</td>
<td>note 1</td>
</tr>
<tr class="row-even"><td>Instruction Print</td>
<td>JMP</td>
<td>note 2</td>
</tr>
</tbody>
</table>
<p>note 1: by Cpu0InstrInfo.td as follows,</p>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0InstrInfo.td</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Tail</span> <span class="n">call</span>
<span class="k">def</span> <span class="nf">Cpu0TailCall</span> <span class="p">:</span> <span class="n">SDNode</span><span class="o">&lt;</span><span class="s2">&quot;Cpu0ISD::TailCall&quot;</span><span class="p">,</span> <span class="n">SDT_Cpu0JmpLink</span><span class="p">,</span>
                          <span class="p">[</span><span class="n">SDNPHasChain</span><span class="p">,</span> <span class="n">SDNPOptInGlue</span><span class="p">,</span> <span class="n">SDNPVariadic</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>def : Pat&lt;(Cpu0TailCall (iPTR tglobaladdr:$dst)),
              (TAILCALL tglobaladdr:$dst)&gt;;
def : Pat&lt;(Cpu0TailCall (iPTR texternalsym:$dst)),
              (TAILCALL texternalsym:$dst)&gt;;
</pre></div>
</div>
<p>note 2: by Cpu0InstrInfo.td and emitPseudoExpansionLowering() of
Cpu0AsmPrinter.cpp as follows,</p>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0InstrInfo.td</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>let isCall = 1, isTerminator = 1, isReturn = 1, isBarrier = 1, hasDelaySlot = 1,
    hasExtraSrcRegAllocReq = 1, Defs = [AT] in {
  class TailCall&lt;Instruction JumpInst&gt; :
    PseudoSE&lt;(outs), (ins calltarget:$target), [], IIBranch&gt;,
    PseudoInstExpansion&lt;(JumpInst jmptarget:$target)&gt;;

  class TailCallReg&lt;RegisterClass RO, Instruction JRInst,
                    RegisterClass ResRO = RO&gt; :
    PseudoSE&lt;(outs), (ins RO:$rs), [(Cpu0TailCall RO:$rs)], IIBranch&gt;,
    PseudoInstExpansion&lt;(JRInst ResRO:$rs)&gt;;
}
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ch9_1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">{</span>
<span class="k">def</span> <span class="nf">TAILCALL</span> <span class="p">:</span> <span class="n">TailCall</span><span class="o">&lt;</span><span class="n">JMP</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">TAILCALL_R</span> <span class="p">:</span> <span class="n">TailCallReg</span><span class="o">&lt;</span><span class="n">GPROut</span><span class="p">,</span> <span class="n">JR</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0AsmPrinter.h</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="o">//</span> <span class="n">tblgen</span><span class="s1">&#39;erated function.</span>
  <span class="nb">bool</span> <span class="n">emitPseudoExpansionLowering</span><span class="p">(</span><span class="n">MCStreamer</span> <span class="o">&amp;</span><span class="n">OutStreamer</span><span class="p">,</span>
                                   <span class="n">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0AsmPrinter.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>//- EmitInstruction() must exists or will have run time error.
void Cpu0AsmPrinter::EmitInstruction(const MachineInstr *MI) {
//@EmitInstruction body {
  if (MI-&gt;isDebugValue()) {
    SmallString&lt;128&gt; Str;
    raw_svector_ostream OS(Str);

    PrintDebugValueComment(MI, OS);
    return;
  }

  //@print out instruction:
  //  Print out both ordinary instruction and boudle instruction
  MachineBasicBlock::const_instr_iterator I = MI-&gt;getIterator();
  MachineBasicBlock::const_instr_iterator E = MI-&gt;getParent()-&gt;instr_end();

  do {
    // Do any auto-generated pseudo lowerings.
    if (emitPseudoExpansionLowering(*OutStreamer, &amp;*I))
      continue;

    if (I-&gt;isPseudo() &amp;&amp; !isLongBranchPseudo(I-&gt;getOpcode()))
      llvm_unreachable(&quot;Pseudo opcode found in EmitInstruction()&quot;);

    MCInst TmpInst0;
    MCInstLowering.Lower(&amp;*I, TmpInst0);
    OutStreamer-&gt;EmitInstruction(TmpInst0, getSubtargetInfo());
  } while ((++I != E) &amp;&amp; I-&gt;isInsideBundle()); // Delay slot check
}
</pre></div>
</div>
<p>Function emitPseudoExpansionLowering() is generated by TableGen and exists
in Cpu0GenMCPseudoLowering.inc.</p>
</div>
<div class="section" id="recursion-optimization">
<h3><a class="toc-backref" href="#id34">Recursion optimization</a><a class="headerlink" href="#recursion-optimization" title="Permalink to this headline">¶</a></h3>
<p>As last section, cpu032I cannot does tail call optimization in
ch9_2_tailcall.cpp since the limitation of arguments size is not satisfied.
If runnig with <code class="docutils literal"><span class="pre">clang</span> <span class="pre">-O3</span></code> option, it can get the same or better performance
than tail call as follows,</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$</span> clang -O1 -target mips-unknown-linux-gnu -c
<span class="go">ch9_2_tailcall.cpp -emit-llvm -o ch9_2_tailcall.bc</span>
<span class="gp">JonathantekiiMac:input Jonathan$</span> ~/llvm/test/cmake_debug_build/bin/
<span class="go">llvm-dis ch9_2_tailcall.bc -o -</span>
<span class="go">...</span>
<span class="go">; Function Attrs: nounwind readnone</span>
<span class="go">define i32 @_Z9factoriali(i32 %x) #0 {</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> icmp sgt i32 %x, 0
<span class="go">  br i1 %1, label %tailrecurse.preheader, label %tailrecurse._crit_edge</span>

<span class="go">tailrecurse.preheader:                            ; preds = %0</span>
<span class="go">  br label %tailrecurse</span>

<span class="go">tailrecurse:                                      ; preds = %tailrecurse,</span>
<span class="gp">%</span>tailrecurse.preheader
<span class="gp">  %</span>x.tr2 <span class="o">=</span> phi i32 <span class="o">[</span> %2, %tailrecurse <span class="o">]</span>, <span class="o">[</span> %x, %tailrecurse.preheader <span class="o">]</span>
<span class="gp">  %</span>accumulator.tr1 <span class="o">=</span> phi i32 <span class="o">[</span> %3, %tailrecurse <span class="o">]</span>, <span class="o">[</span> 1, %tailrecurse.preheader <span class="o">]</span>
<span class="gp">  %</span><span class="nv">2</span> <span class="o">=</span> add nsw i32 %x.tr2, -1
<span class="gp">  %</span><span class="nv">3</span> <span class="o">=</span> mul nsw i32 %x.tr2, %accumulator.tr1
<span class="gp">  %</span><span class="nv">4</span> <span class="o">=</span> icmp sgt i32 %2, 0
<span class="go">  br i1 %4, label %tailrecurse, label %tailrecurse._crit_edge.loopexit</span>

<span class="go">tailrecurse._crit_edge.loopexit:                  ; preds = %tailrecurse</span>
<span class="gp">  %</span>.lcssa <span class="o">=</span> phi i32 <span class="o">[</span> %3, %tailrecurse <span class="o">]</span>
<span class="go">  br label %tailrecurse._crit_edge</span>

<span class="go">tailrecurse._crit_edge:                           ; preds = %tailrecurse._crit</span>
<span class="go">  _edge.loopexit, %0</span>
<span class="gp">  %</span>accumulator.tr.lcssa <span class="o">=</span> phi i32 <span class="o">[</span> 1, %0 <span class="o">]</span>, <span class="o">[</span> %.lcssa, %tailrecurse._crit_edge
<span class="go">  .loopexit ]</span>
<span class="go">  ret i32 %accumulator.tr.lcssa</span>
<span class="go">}</span>

<span class="go">; Function Attrs: nounwind readnone</span>
<span class="go">define i32 @_Z13test_tailcalli(i32 %a) #0 {</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> icmp sgt i32 %a, 0
<span class="go">  br i1 %1, label %tailrecurse.i.preheader, label %_Z9factoriali.exit</span>

<span class="go">tailrecurse.i.preheader:                          ; preds = %0</span>
<span class="go">  br label %tailrecurse.i</span>

<span class="go">tailrecurse.i:                                    ; preds = %tailrecurse.i,</span>
<span class="gp">  %</span>tailrecurse.i.preheader
<span class="gp">  %</span>x.tr2.i <span class="o">=</span> phi i32 <span class="o">[</span> %2, %tailrecurse.i <span class="o">]</span>, <span class="o">[</span> %a, %tailrecurse.i.preheader <span class="o">]</span>
<span class="gp">  %</span>accumulator.tr1.i <span class="o">=</span> phi i32 <span class="o">[</span> %3, %tailrecurse.i <span class="o">]</span>, <span class="o">[</span> 1, %tailrecurse.i.
<span class="go">  preheader ]</span>
<span class="gp">  %</span><span class="nv">2</span> <span class="o">=</span> add nsw i32 %x.tr2.i, -1
<span class="gp">  %</span><span class="nv">3</span> <span class="o">=</span> mul nsw i32 %accumulator.tr1.i, %x.tr2.i
<span class="gp">  %</span><span class="nv">4</span> <span class="o">=</span> icmp sgt i32 %2, 0
<span class="go">  br i1 %4, label %tailrecurse.i, label %_Z9factoriali.exit.loopexit</span>

<span class="go">_Z9factoriali.exit.loopexit:                      ; preds = %tailrecurse.i</span>
<span class="gp">  %</span>.lcssa <span class="o">=</span> phi i32 <span class="o">[</span> %3, %tailrecurse.i <span class="o">]</span>
<span class="go">  br label %_Z9factoriali.exit</span>

<span class="go">_Z9factoriali.exit:                               ; preds = %_Z9factoriali.</span>
<span class="go">  exit.loopexit, %0</span>
<span class="gp">  %</span>accumulator.tr.lcssa.i <span class="o">=</span> phi i32 <span class="o">[</span> 1, %0 <span class="o">]</span>, <span class="o">[</span> %.lcssa, %_Z9factoriali.
<span class="go">  exit.loopexit ]</span>
<span class="go">  ret i32 %accumulator.tr.lcssa.i</span>
<span class="go">}</span>
<span class="go">...</span>
<span class="gp">JonathantekiiMac:input Jonathan$</span> ~/llvm/test/cmake_debug_build/bin/
<span class="go">llc -march=cpu0 -mcpu=cpu032I -relocation-model=static -filetype=asm</span>
<span class="go">ch9_2_tailcall.bc -o -</span>
<span class="go">        .text</span>
<span class="go">        .section .mdebug.abiS32</span>
<span class="go">        .previous</span>
<span class="go">        .file &quot;ch9_2_tailcall.bc&quot;</span>
<span class="go">        .globl        _Z9factoriali</span>
<span class="go">        .align        2</span>
<span class="go">        .type _Z9factoriali,@function</span>
<span class="go">        .ent  _Z9factoriali           # @_Z9factoriali</span>
<span class="go">_Z9factoriali:</span>
<span class="go">        .frame        $sp,0,$lr</span>
<span class="go">        .mask         0x00000000,0</span>
<span class="go">        .set  noreorder</span>
<span class="go">        .set  nomacro</span>
<span class="gp">#</span> BB#0:
<span class="go">        addiu $2, $zero, 1</span>
<span class="go">        ld    $3, 0($sp)</span>
<span class="go">        cmp   $sw, $3, $2</span>
<span class="go">        jlt   $sw, $BB0_2</span>
<span class="go">        nop</span>
<span class="gp">$</span>BB0_1:                                 <span class="c1"># %tailrecurse</span>
<span class="gp">                                        #</span> <span class="o">=</span>&gt;This Inner Loop Header: <span class="nv">Depth</span><span class="o">=</span>1
<span class="go">        mul   $2, $3, $2</span>
<span class="go">        addiu $3, $3, -1</span>
<span class="go">        addiu $4, $zero, 0</span>
<span class="go">        cmp   $sw, $3, $4</span>
<span class="go">        jgt   $sw, $BB0_1</span>
<span class="go">        nop</span>
<span class="gp">$</span>BB0_2:                                 <span class="c1"># %tailrecurse._crit_edge</span>
<span class="go">        ret   $lr</span>
<span class="go">        nop</span>
<span class="go">        .set  macro</span>
<span class="go">        .set  reorder</span>
<span class="go">        .end  _Z9factoriali</span>
<span class="gp">$</span>tmp0:
<span class="go">        .size _Z9factoriali, ($tmp0)-_Z9factoriali</span>

<span class="go">        .globl        _Z13test_tailcalli</span>
<span class="go">        .align        2</span>
<span class="go">        .type _Z13test_tailcalli,@function</span>
<span class="go">        .ent  _Z13test_tailcalli      # @_Z13test_tailcalli</span>
<span class="go">_Z13test_tailcalli:</span>
<span class="go">        .frame        $sp,0,$lr</span>
<span class="go">        .mask         0x00000000,0</span>
<span class="go">        .set  noreorder</span>
<span class="go">        .set  nomacro</span>
<span class="gp">#</span> BB#0:
<span class="go">        addiu $2, $zero, 1</span>
<span class="go">        ld    $3, 0($sp)</span>
<span class="go">        cmp   $sw, $3, $2</span>
<span class="go">        jlt   $sw, $BB1_2</span>
<span class="go">        nop</span>
<span class="gp">$</span>BB1_1:                                 <span class="c1"># %tailrecurse.i</span>
<span class="gp">                                        #</span> <span class="o">=</span>&gt;This Inner Loop Header: <span class="nv">Depth</span><span class="o">=</span>1
<span class="go">        mul   $2, $2, $3</span>
<span class="go">        addiu $3, $3, -1</span>
<span class="go">        addiu $4, $zero, 0</span>
<span class="go">        cmp   $sw, $3, $4</span>
<span class="go">        jgt   $sw, $BB1_1</span>
<span class="go">        nop</span>
<span class="gp">$</span>BB1_2:                                 <span class="c1"># %_Z9factoriali.exit</span>
<span class="go">        ret   $lr</span>
<span class="go">        nop</span>
<span class="go">        .set  macro</span>
<span class="go">        .set  reorder</span>
<span class="go">        .end  _Z13test_tailcalli</span>
<span class="gp">$</span>tmp1:
<span class="go">        .size _Z13test_tailcalli, ($tmp1)-_Z13test_tailcalli</span>
</pre></div>
</div>
<p>According above llvm IR, <code class="docutils literal"><span class="pre">clang</span> <span class="pre">-O3</span></code> option replace recursion with loop by
inline the callee recursion function. This is a frontend optimization through
cross over function analysis.</p>
<p>Cpu0 doesn&#8217;t support fastcc <a class="footnote-reference" href="#callconv" id="id8">[7]</a> but it can pass the fastcc keyword of
IR.
Mips supports fastcc by using as more registers as possible without following
ABI specification.</p>
</div>
</div>
<div class="section" id="other-features-supporting">
<h2><a class="toc-backref" href="#id35">Other features supporting</a><a class="headerlink" href="#other-features-supporting" title="Permalink to this headline">¶</a></h2>
<p>This section supports features for &#8220;$gp register caller saved register in PIC
addressing mode&#8221;, &#8220;variable number of arguments&#8221; and &#8220;dynamic stack allocation&#8221;.</p>
<p>Run Chapter9_2/ with ch9_3_vararg.cpp to get the following error,</p>
<p class="rubric">lbdex/input/ch9_3_vararg.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1">#include &lt;stdarg.h&gt;</span>

<span class="nb">int</span> <span class="n">sum_i</span><span class="p">(</span><span class="nb">int</span> <span class="n">amount</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nb">int</span> <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	
  <span class="n">va_list</span> <span class="n">vl</span><span class="p">;</span>
  <span class="n">va_start</span><span class="p">(</span><span class="n">vl</span><span class="p">,</span> <span class="n">amount</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">amount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">vl</span><span class="p">,</span> <span class="nb">int</span><span class="p">);</span>
    <span class="nb">sum</span> <span class="o">+=</span> <span class="n">val</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">va_end</span><span class="p">(</span><span class="n">vl</span><span class="p">);</span>
  
  <span class="k">return</span> <span class="nb">sum</span><span class="p">;</span> 
<span class="p">}</span>

<span class="nb">int</span> <span class="n">test_vararg</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">sum_i</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
	
  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">118-165-78-230:input Jonathan$</span> clang -target mips-unknown-linux-gnu -c
<span class="go">ch9_3_vararg.cpp -emit-llvm -o ch9_3_vararg.bc</span>
<span class="gp">118-165-78-230:input Jonathan$</span> /Users/Jonathan/llvm/test/cmake_debug_build/
<span class="go">Debug/bin/llc -march=cpu0 -relocation-model=pic -filetype=asm ch9_3_vararg.bc -o -</span>
<span class="go">...</span>
<span class="go">LLVM ERROR: Cannot select: 0x7f8b6902fd10: ch = vastart 0x7f8b6902fa10,</span>
<span class="go">0x7f8b6902fb10, 0x7f8b6902fc10 [ORD=9] [ID=22]</span>
<span class="go">  0x7f8b6902fb10: i32 = FrameIndex&lt;5&gt; [ORD=7] [ID=9]</span>
<span class="go">In function: _Z5sum_iiz</span>
</pre></div>
</div>
<p class="rubric">lbdex/input/ch9_3_alloc.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>
<span class="o">//</span> <span class="n">This</span> <span class="n">file</span> <span class="n">needed</span> <span class="nb">compile</span> <span class="n">without</span> <span class="n">option</span><span class="p">,</span> <span class="o">-</span><span class="n">target</span> <span class="n">mips</span><span class="o">-</span><span class="n">unknown</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">gnu</span><span class="p">,</span> <span class="n">so</span> 
<span class="o">//</span> <span class="n">it</span> <span class="ow">is</span> <span class="n">verified</span> <span class="n">by</span> <span class="n">build</span><span class="o">-</span><span class="n">run_backend2</span><span class="o">.</span><span class="n">sh</span> <span class="ow">or</span> <span class="n">verified</span> <span class="ow">in</span> <span class="n">lld</span> <span class="n">linker</span> <span class="n">support</span>
<span class="o">//</span> <span class="p">(</span><span class="n">build</span><span class="o">-</span><span class="n">slinker</span><span class="o">.</span><span class="n">sh</span><span class="p">)</span><span class="o">.</span>

<span class="o">//</span><span class="c1">#include &lt;alloca.h&gt;</span>
<span class="o">//</span><span class="c1">#include &lt;stdlib.h&gt;</span>

<span class="nb">int</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">int</span> <span class="n">x1</span><span class="p">,</span> <span class="nb">int</span> <span class="n">x2</span><span class="p">,</span> <span class="nb">int</span> <span class="n">x3</span><span class="p">,</span> <span class="nb">int</span> <span class="n">x4</span><span class="p">,</span> <span class="nb">int</span> <span class="n">x5</span><span class="p">,</span> <span class="nb">int</span> <span class="n">x6</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="nb">sum</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span> <span class="o">+</span> <span class="n">x3</span> <span class="o">+</span> <span class="n">x4</span> <span class="o">+</span> <span class="n">x5</span> <span class="o">+</span> <span class="n">x6</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="nb">sum</span><span class="p">;</span> 
<span class="p">}</span>

<span class="nb">int</span> <span class="n">weight_sum</span><span class="p">(</span><span class="nb">int</span> <span class="n">x1</span><span class="p">,</span> <span class="nb">int</span> <span class="n">x2</span><span class="p">,</span> <span class="nb">int</span> <span class="n">x3</span><span class="p">,</span> <span class="nb">int</span> <span class="n">x4</span><span class="p">,</span> <span class="nb">int</span> <span class="n">x5</span><span class="p">,</span> <span class="nb">int</span> <span class="n">x6</span><span class="p">)</span>
<span class="p">{</span>
<span class="o">//</span>  <span class="nb">int</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="o">*</span><span class="p">)</span><span class="n">alloca</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">x1</span><span class="p">);</span>
  <span class="nb">int</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="o">*</span><span class="p">)</span><span class="n">__builtin_alloca</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">x1</span><span class="p">);</span>
  <span class="nb">int</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
  <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">x3</span><span class="p">;</span>

  <span class="nb">int</span> <span class="n">weight</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">,</span> <span class="n">x4</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x5</span><span class="p">,</span> <span class="n">x6</span><span class="p">);</span>

  <span class="k">return</span> <span class="p">(</span><span class="n">weight</span> <span class="o">+</span> <span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">));</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">test_alloc</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">weight_sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span> <span class="o">//</span> <span class="mi">31</span>
  
  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Run Chapter9_2 with ch9_3_alloc.cpp will get the following error.</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">118-165-72-242:input Jonathan$</span> clang -target mips-unknown-linux-gnu -c
<span class="go">ch9_3_alloc.cpp -emit-llvm -o ch9_3_alloc.bc</span>
<span class="gp">118-165-72-242:input Jonathan$</span> /Users/Jonathan/llvm/test/cmake_debug_build/
<span class="go">Debug/bin/llc -march=cpu0 -mcpu=cpu032I -cpu0-s32-calls=false</span>
<span class="go">-relocation-model=pic -filetype=asm ch9_3_alloc.bc -o -</span>
<span class="go">...</span>
<span class="go">LLVM ERROR: Cannot select: 0x7ffd8b02ff10: i32,ch = dynamic_stackalloc</span>
<span class="go">0x7ffd8b02f910:1, 0x7ffd8b02fe10, 0x7ffd8b02c010 [ORD=12] [ID=48]</span>
<span class="go">  0x7ffd8b02fe10: i32 = and 0x7ffd8b02fc10, 0x7ffd8b02fd10 [ORD=12] [ID=47]</span>
<span class="go">    0x7ffd8b02fc10: i32 = add 0x7ffd8b02fa10, 0x7ffd8b02fb10 [ORD=12] [ID=46]</span>
<span class="go">      0x7ffd8b02fa10: i32 = shl 0x7ffd8b02f910, 0x7ffd8b02f510 [ID=45]</span>
<span class="go">        0x7ffd8b02f910: i32,ch = load 0x7ffd8b02ee10, 0x7ffd8b02e310,</span>
<span class="go">        0x7ffd8b02b310&lt;LD4[%1]&gt; [ID=44]</span>
<span class="go">          0x7ffd8b02e310: i32 = FrameIndex&lt;1&gt; [ORD=3] [ID=10]</span>
<span class="go">          0x7ffd8b02b310: i32 = undef [ORD=1] [ID=2]</span>
<span class="go">        0x7ffd8b02f510: i32 = Constant&lt;2&gt; [ID=25]</span>
<span class="go">      0x7ffd8b02fb10: i32 = Constant&lt;7&gt; [ORD=12] [ID=16]</span>
<span class="go">    0x7ffd8b02fd10: i32 = Constant&lt;-8&gt; [ORD=12] [ID=17]</span>
<span class="go">  0x7ffd8b02c010: i32 = Constant&lt;0&gt; [ORD=12] [ID=8]</span>
<span class="go">In function: _Z5sum_iiiiiii</span>
</pre></div>
</div>
<div class="section" id="the-gp-register-caller-saved-register-in-pic-addressing-mode">
<h3><a class="toc-backref" href="#id36">The $gp register caller saved register in PIC addressing mode</a><a class="headerlink" href="#the-gp-register-caller-saved-register-in-pic-addressing-mode" title="Permalink to this headline">¶</a></h3>
<p>According the original cpu0 web site information, it only supports <strong>“jsub”</strong>
of 24-bit address range access.
We add <strong>“jalr”</strong> to cpu0 and expand it to 32 bit address. We do this change for
two reasons. One is that cpu0 can be expanded to 32 bit address space by only
adding this instruction, and the other is cpu0 and this book are designed for
tutorial.
We reserve <strong>“jalr”</strong> as PIC mode for dynamic linking function to demonstrates:</p>
<ol class="arabic simple">
<li>How caller handles the caller saved register $gp in calling the function.</li>
<li>How the code in the shared libray function uses $gp to access global variable
address.</li>
<li>The jalr for dynamic linking function is easier in implementation and faster.
As we have depicted in section &#8220;pic mode&#8221; of chapter &#8220;Global variables, structs
and arrays, other type&#8221;. This solution is popular in reality and deserve changing
cpu0 official design as a compiler book.</li>
</ol>
<p>In chapter &#8220;Global variable&#8221;, we mentioned two link
type, the static link and dynamic link.
The option -relocation-model=static is for static link function while option
-relocation-model=pic is for dynamic link function.
One instance of dynamic link function is used is for calling functions of share
library.
Share library includes a lots of dynamic link functions usually can be loaded
at run time.
Since share library can be loaded in different memory address, the global
variable address be accessed cannot be decided at link time.
Whatever, he distance between the global variable address and the start address
of shared library function can be calculated when it has been loaded.</p>
<p>Let&#8217;s run Chapter9_3/ with ch9_gprestore.cpp to get the following result.
We putting the comments in the result for explanation.</p>
<p class="rubric">lbdex/input/ch9_gprestore.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="nb">int</span> <span class="n">sum_i</span><span class="p">(</span><span class="nb">int</span> <span class="n">x1</span><span class="p">);</span>

<span class="nb">int</span> <span class="n">call_sum_i</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">sum_i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">a</span> <span class="o">+=</span> <span class="n">sum_i</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">118-165-78-230:input Jonathan$</span> /Users/Jonathan/llvm/test/cmake_debug_build/
<span class="go">Debug/bin/llc -march=cpu0 -mcpu=cpu032II-cpu0-s32-calls=true</span>
<span class="go">-relocation-model=pic -filetype=asm ch9_gprestore.bc -o -</span>
<span class="go">...</span>
<span class="go">  .cpload $t9</span>
<span class="go">  .set  nomacro</span>
<span class="gp">#</span> BB#0:                                 <span class="c1"># %entry</span>
<span class="go">  addiu $sp, $sp, -24</span>
<span class="gp">$</span>tmp0:
<span class="go">  .cfi_def_cfa_offset 24</span>
<span class="go">  st  $lr, 12($sp)            # 4-byte Folded Spill</span>
<span class="go">  st  $fp, 16($sp)              # 4-byte Folded Spill</span>
<span class="gp">$</span>tmp1:
<span class="go">  .cfi_offset 14, -4</span>
<span class="gp">$</span>tmp2:
<span class="go">  .cfi_offset 12, -8</span>
<span class="go">  .cprestore  8    // save $gp to 8($sp)</span>
<span class="go">  ld  $t9, %call16(_Z5sum_ii)($gp)</span>
<span class="go">  addiu $4, $zero, 1</span>
<span class="go">  jalr  $t9</span>
<span class="go">  nop</span>
<span class="go">  ld  $gp, 8($sp)  // restore $gp from 8($sp)</span>
<span class="go">  add $8, $zero, $2</span>
<span class="go">  ld  $t9, %call16(_Z5sum_ii)($gp)</span>
<span class="go">  addiu $4, $zero, 2</span>
<span class="go">  jalr  $t9</span>
<span class="go">  nop</span>
<span class="go">  ld  $gp, 8($sp)  // restore $gp from 8($sp)</span>
<span class="go">  addu  $2, $2, $8</span>
<span class="go">  ld  $8, 8($sp)              # 4-byte Folded Reload</span>
<span class="go">  ld  $lr, 12($sp)            # 4-byte Folded Reload</span>
<span class="go">  addiu $sp, $sp, 16</span>
<span class="go">  ret $lr</span>
<span class="go">  nop</span>
</pre></div>
</div>
<p>As above code comment, <strong>“.cprestore 8”</strong> is a pseudo instruction for saving
<strong>$gp</strong> to <strong>8($sp)</strong> while Instruction <strong>“ld $gp, 8($sp)”</strong> restore
the $gp, refer to Table 8-1 of &#8220;MIPSpro TM Assembly Language Programmer’s
Guide&#8221; <a class="footnote-reference" href="#mipsasm" id="id9">[2]</a>.
In other words, $gp is a caller saved register, so main() need to save/restore
$gp before/after call the shared library _Z5sum_ii() function.
In llvm Mips 3.5, it removed the .cprestore in mode PIC which meaning $gp
is not a caller saved register in PIC anymore.
However, it is still existed in Cpu0 and this feature can be removed by not
defining it in Cpu0Config.h.
The #ifdef ENABLE_GPRESTORE part of code in Cpu0 can be removed but it comes with
the cost of reserving $gp register as a specific register and cannot be allocated
for the program variable in PIC mode. As explained in early chapter Gloabal
variable, the PIC is not critial function and the performance advantage can be
ignored in dynamic link, so we keep this feature in Cpu0.
Reserving $gp as a specific register in
PIC will save a lot of code in programming.
When reserving $gp, .cprestore can be disabled by option &#8220;-cpu0-reserve-gp&#8221;.
The .cpload is needed even reserving $gp (considering that programmers
implement a boot code function with C and assembly mixed, programmer can set
$gp value through .cpload be issued.</p>
<p>If enabling &#8220;-cpu0-no-cpload&#8221;, and undefining ENABLE_GPRESTORE or enable
&#8220;-cpu0-reserve-gp&#8221;, .cpload and $gp save/restore won&#8217;t be issued as follow,</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">118-165-78-230:input Jonathan$</span> /Users/Jonathan/llvm/test/cmake_debug_build/
<span class="go">Debug/bin/llc -march=cpu0 -mcpu=cpu032II-cpu0-s32-calls=true</span>
<span class="go">-relocation-model=pic -filetype=asm ch9_gprestore.bc -cpu0-no-cpload</span>
<span class="go">-cpu0-reserve-gp -o -</span>
<span class="go">...</span>
<span class="gp">#</span> BB#0:
<span class="go">  addiu $sp, $sp, -24</span>
<span class="gp">$</span>tmp0:
<span class="go">  .cfi_def_cfa_offset 24</span>
<span class="go">  st  $lr, 20($sp)            # 4-byte Folded Spill</span>
<span class="go">  st  $fp, 16($sp)            # 4-byte Folded Spill</span>
<span class="gp">$</span>tmp1:
<span class="go">  .cfi_offset 14, -4</span>
<span class="gp">$</span>tmp2:
<span class="go">  .cfi_offset 12, -8</span>
<span class="go">  move   $fp, $sp</span>
<span class="gp">$</span>tmp3:
<span class="go">  .cfi_def_cfa_register 12</span>
<span class="go">  ld  $t9, %call16(_Z5sum_ii)($gp)</span>
<span class="go">  addiu $4, $zero, 1</span>
<span class="go">  jalr  $t9</span>
<span class="go">  nop</span>
<span class="go">  st  $2, 12($fp)</span>
<span class="go">  addiu $4, $zero, 2</span>
<span class="go">  ld  $t9, %call16(_Z5sum_ii)($gp)</span>
<span class="go">  jalr  $t9</span>
<span class="go">  nop</span>
<span class="go">  ld  $3, 12($fp)</span>
<span class="go">  addu  $2, $3, $2</span>
<span class="go">  st  $2, 12($fp)</span>
<span class="go">  move   $sp, $fp</span>
<span class="go">  ld  $fp, 16($sp)            # 4-byte Folded Reload</span>
<span class="go">  ld  $lr, 20($sp)            # 4-byte Folded Reload</span>
<span class="go">  addiu $sp, $sp, 24</span>
<span class="go">  ret $lr</span>
<span class="go">  nop</span>
</pre></div>
</div>
<p>LLVM Mips 3.1 issues the .cpload and .cprestore and Cpu0 borrows it from that
version. But now, llvm Mips replace .cpload with real instructions and remove
.cprestore. It treats $gp as reserved register in PIC mode. Since the Mips
assembly document which I reference say $gp is &#8220;caller save register&#8221;, Cpu0 follows
this document at this point and provides reserving $gp register as option.</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">118-165-78-230:input Jonathan$</span> /Users/Jonathan/llvm/test/cmake_debug_build/
<span class="go">Debug/bin/llc -march=mips -relocation-model=pic -filetype=asm ch9_gprestore.bc</span>
<span class="go">-o -</span>
<span class="go">...</span>
<span class="gp">#</span> BB#0:                                 <span class="c1"># %entry</span>
<span class="go">  lui $2, %hi(_gp_disp)</span>
<span class="go">  ori $2, $2, %lo(_gp_disp)</span>
<span class="go">  addiu $sp, $sp, -32</span>
<span class="gp">$</span>tmp0:
<span class="go">  .cfi_def_cfa_offset 32</span>
<span class="go">  sw  $ra, 28($sp)            # 4-byte Folded Spill</span>
<span class="go">  sw  $fp, 24($sp)            # 4-byte Folded Spill</span>
<span class="go">  sw  $16, 20($sp)            # 4-byte Folded Spill</span>
<span class="gp">$</span>tmp1:
<span class="go">  .cfi_offset 31, -4</span>
<span class="gp">$</span>tmp2:
<span class="go">  .cfi_offset 30, -8</span>
<span class="gp">$</span>tmp3:
<span class="go">  .cfi_offset 16, -12</span>
<span class="go">  move   $fp, $sp</span>
<span class="gp">$</span>tmp4:
<span class="go">  .cfi_def_cfa_register 30</span>
<span class="go">  addu  $16, $2, $25</span>
<span class="go">  lw  $25, %call16(_Z5sum_ii)($16)</span>
<span class="go">  addiu $4, $zero, 1</span>
<span class="go">  jalr  $25</span>
<span class="go">  move   $gp, $16</span>
<span class="go">  sw  $2, 16($fp)</span>
<span class="go">  lw  $25, %call16(_Z5sum_ii)($16)</span>
<span class="go">  jalr  $25</span>
<span class="go">  addiu $4, $zero, 2</span>
<span class="go">  lw  $1, 16($fp)</span>
<span class="go">  addu  $2, $1, $2</span>
<span class="go">  sw  $2, 16($fp)</span>
<span class="go">  move   $sp, $fp</span>
<span class="go">  lw  $16, 20($sp)            # 4-byte Folded Reload</span>
<span class="go">  lw  $fp, 24($sp)            # 4-byte Folded Reload</span>
<span class="go">  lw  $ra, 28($sp)            # 4-byte Folded Reload</span>
<span class="go">  jr  $ra</span>
<span class="go">  addiu $sp, $sp, 32</span>
</pre></div>
</div>
<p>The following code added in Chapter9_3/ issues <strong>“.cprestore”</strong> or the
corresponding machine code before the first time of PIC function call.</p>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0ISelLowering.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">///</span> <span class="n">LowerCall</span> <span class="o">-</span> <span class="n">functions</span> <span class="n">arguments</span> <span class="n">are</span> <span class="n">copied</span> <span class="kn">from</span> <span class="nn">virtual</span> <span class="n">regs</span> <span class="n">to</span>
<span class="o">///</span> <span class="p">(</span><span class="n">physical</span> <span class="n">regs</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">stack</span> <span class="n">frame</span><span class="p">),</span> <span class="n">CALLSEQ_START</span> <span class="ow">and</span> <span class="n">CALLSEQ_END</span> <span class="n">are</span> <span class="n">emitted</span><span class="o">.</span>
<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">LowerCall</span><span class="p">(</span><span class="n">TargetLowering</span><span class="p">::</span><span class="n">CallLoweringInfo</span> <span class="o">&amp;</span><span class="n">CLI</span><span class="p">,</span>
                              <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>#ifdef ENABLE_GPRESTORE
  if (!Cpu0ReserveGP) {
    // If this is the first call, create a stack frame object that points to
    // a location to which .cprestore saves $gp.
    if (IsPIC &amp;&amp; Cpu0FI-&gt;globalBaseRegFixed() &amp;&amp; !Cpu0FI-&gt;getGPFI())
      Cpu0FI-&gt;setGPFI(MFI-&gt;CreateFixedObject(4, 0, true));
    if (Cpu0FI-&gt;needGPSaveRestore())
      MFI-&gt;setObjectOffset(Cpu0FI-&gt;getGPFI(), NextStackOffset);
  }
#endif
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0MachineFunction.h</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1">#ifdef ENABLE_GPRESTORE</span>
  <span class="nb">bool</span> <span class="n">needGPSaveRestore</span><span class="p">()</span> <span class="n">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">getGPFI</span><span class="p">();</span> <span class="p">}</span>
<span class="c1">#endif</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0SEFrameLowering.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">Cpu0SEFrameLowering</span><span class="p">::</span><span class="n">emitPrologue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                       <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1">#ifdef ENABLE_GPRESTORE</span>
  <span class="o">//</span> <span class="n">Restore</span> <span class="n">GP</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">saved</span> <span class="n">stack</span> <span class="n">location</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">needGPSaveRestore</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">unsigned</span> <span class="n">Offset</span> <span class="o">=</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">getObjectOffset</span><span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getGPFI</span><span class="p">());</span>
    <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MBBI</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">TII</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">Cpu0</span><span class="p">::</span><span class="n">CPRESTORE</span><span class="p">))</span><span class="o">.</span><span class="n">addImm</span><span class="p">(</span><span class="n">Offset</span><span class="p">)</span>
      <span class="o">.</span><span class="n">addReg</span><span class="p">(</span><span class="n">Cpu0</span><span class="p">::</span><span class="n">GP</span><span class="p">);</span>
  <span class="p">}</span>
<span class="c1">#endif</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0RegisterInfo.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//-</span> <span class="n">If</span> <span class="n">no</span> <span class="n">eliminateFrameIndex</span><span class="p">(),</span> <span class="n">it</span> <span class="n">will</span> <span class="n">hang</span> <span class="n">on</span> <span class="n">run</span><span class="o">.</span> 
<span class="o">//</span> <span class="n">pure</span> <span class="n">virtual</span> <span class="n">method</span>
<span class="o">//</span> <span class="n">FrameIndex</span> <span class="n">represent</span> <span class="n">objects</span> <span class="n">inside</span> <span class="n">a</span> <span class="n">abstract</span> <span class="n">stack</span><span class="o">.</span>
<span class="o">//</span> <span class="n">We</span> <span class="n">must</span> <span class="n">replace</span> <span class="n">FrameIndex</span> <span class="k">with</span> <span class="n">an</span> <span class="n">stack</span><span class="o">/</span><span class="n">frame</span> <span class="n">pointer</span>
<span class="o">//</span> <span class="n">direct</span> <span class="n">reference</span><span class="o">.</span>
<span class="n">void</span> <span class="n">Cpu0RegisterInfo</span><span class="p">::</span>
<span class="n">eliminateFrameIndex</span><span class="p">(</span><span class="n">MachineBasicBlock</span><span class="p">::</span><span class="n">iterator</span> <span class="n">II</span><span class="p">,</span> <span class="nb">int</span> <span class="n">SPAdj</span><span class="p">,</span>
                    <span class="n">unsigned</span> <span class="n">FIOperandNum</span><span class="p">,</span> <span class="n">RegScavenger</span> <span class="o">*</span><span class="n">RS</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1">#ifdef ENABLE_GPRESTORE //2</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">isOutArgFI</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">)</span> <span class="o">||</span> <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">isGPFI</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">)</span> <span class="o">||</span>
      <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">isDynAllocFI</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">))</span>
    <span class="n">Offset</span> <span class="o">=</span> <span class="n">spOffset</span><span class="p">;</span>
  <span class="k">else</span>
<span class="c1">#endif</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0InstrInfo.td</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>// When handling PIC code the assembler needs .cpload and .cprestore
// directives. If the real instructions corresponding these directives
// are used, we have the same behavior, but get also a bunch of warnings
// from the assembler.
let hasSideEffects = 0 in
def CPRESTORE : Cpu0Pseudo&lt;(outs), (ins i32imm:$loc, CPURegs:$gp),
                           &quot;.cprestore\t$loc&quot;, []&gt;;
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0AsmPrinter.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1">#ifdef ENABLE_GPRESTORE</span>
<span class="n">void</span> <span class="n">Cpu0AsmPrinter</span><span class="p">::</span><span class="n">EmitInstrWithMacroNoAT</span><span class="p">(</span><span class="n">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MCInst</span> <span class="n">TmpInst</span><span class="p">;</span>

  <span class="n">MCInstLowering</span><span class="o">.</span><span class="n">Lower</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span> <span class="n">TmpInst</span><span class="p">);</span>
  <span class="n">OutStreamer</span><span class="o">-&gt;</span><span class="n">EmitRawText</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">.set</span><span class="se">\t</span><span class="s2">macro&quot;</span><span class="p">));</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getEmitNOAT</span><span class="p">())</span>
    <span class="n">OutStreamer</span><span class="o">-&gt;</span><span class="n">EmitRawText</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">.set</span><span class="se">\t</span><span class="s2">at&quot;</span><span class="p">));</span>
  <span class="n">OutStreamer</span><span class="o">-&gt;</span><span class="n">EmitInstruction</span><span class="p">(</span><span class="n">TmpInst</span><span class="p">,</span> <span class="n">getSubtargetInfo</span><span class="p">());</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getEmitNOAT</span><span class="p">())</span>
    <span class="n">OutStreamer</span><span class="o">-&gt;</span><span class="n">EmitRawText</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">.set</span><span class="se">\t</span><span class="s2">noat&quot;</span><span class="p">));</span>
  <span class="n">OutStreamer</span><span class="o">-&gt;</span><span class="n">EmitRawText</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">.set</span><span class="se">\t</span><span class="s2">nomacro&quot;</span><span class="p">));</span>
<span class="p">}</span>
<span class="c1">#endif</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>#ifdef ENABLE_GPRESTORE
void Cpu0AsmPrinter::emitPseudoCPRestore(MCStreamer &amp;OutStreamer,
                                              const MachineInstr *MI) {
  unsigned Opc = MI-&gt;getOpcode();
  SmallVector&lt;MCInst, 4&gt; MCInsts;
  const MachineOperand &amp;MO = MI-&gt;getOperand(0);
  assert(MO.isImm() &amp;&amp; &quot;CPRESTORE&#39;s operand must be an immediate.&quot;);
  int64_t Offset = MO.getImm();

  if (OutStreamer.hasRawTextSupport()) {
    // output assembly
    if (!isInt&lt;16&gt;(Offset)) {
      EmitInstrWithMacroNoAT(MI);
      return;
    }
    MCInst TmpInst0;
    MCInstLowering.Lower(MI, TmpInst0);
    OutStreamer.EmitInstruction(TmpInst0, getSubtargetInfo());
  } else {
    // output elf
    MCInstLowering.LowerCPRESTORE(Offset, MCInsts);

    for (SmallVector&lt;MCInst, 4&gt;::iterator I = MCInsts.begin();
         I != MCInsts.end(); ++I)
      OutStreamer.EmitInstruction(*I, getSubtargetInfo());

    return;
  }
}
#endif
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//-</span> <span class="n">EmitInstruction</span><span class="p">()</span> <span class="n">must</span> <span class="n">exists</span> <span class="ow">or</span> <span class="n">will</span> <span class="n">have</span> <span class="n">run</span> <span class="n">time</span> <span class="n">error</span><span class="o">.</span>
<span class="n">void</span> <span class="n">Cpu0AsmPrinter</span><span class="p">::</span><span class="n">EmitInstruction</span><span class="p">(</span><span class="n">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1">#ifdef ENABLE_GPRESTORE</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">I</span><span class="o">-&gt;</span><span class="n">getOpcode</span><span class="p">()</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">CPRESTORE</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">emitPseudoCPRestore</span><span class="p">(</span><span class="o">*</span><span class="n">OutStreamer</span><span class="p">,</span> <span class="o">&amp;*</span><span class="n">I</span><span class="p">);</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
<span class="c1">#endif</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0MCInstLower.h</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1">#ifdef ENABLE_GPRESTORE</span>
  <span class="n">void</span> <span class="n">LowerCPRESTORE</span><span class="p">(</span><span class="n">int64_t</span> <span class="n">Offset</span><span class="p">,</span> <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">MCInst</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">MCInsts</span><span class="p">);</span>
<span class="c1">#endif</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0MCInstLower.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>#ifdef ENABLE_GPRESTORE
// Lower &quot;.cprestore offset&quot; to &quot;st $gp, offset($sp)&quot;.
void Cpu0MCInstLower::LowerCPRESTORE(int64_t Offset,
                                     SmallVector&lt;MCInst, 4&gt;&amp; MCInsts) {
  assert(isInt&lt;32&gt;(Offset) &amp;&amp; (Offset &gt;= 0) &amp;&amp;
         &quot;Imm operand of .cprestore must be a non-negative 32-bit value.&quot;);

  MCOperand SPReg = MCOperand::createReg(Cpu0::SP), BaseReg = SPReg;
  MCOperand GPReg = MCOperand::createReg(Cpu0::GP);
  MCOperand ZEROReg = MCOperand::createReg(Cpu0::ZERO);

  if (!isInt&lt;16&gt;(Offset)) {
    unsigned Hi = ((Offset + 0x8000) &gt;&gt; 16) &amp; 0xffff;
    Offset &amp;= 0xffff;
    MCOperand ATReg = MCOperand::createReg(Cpu0::AT);
    BaseReg = ATReg;

    // lui   at,hi
    // add   at,at,sp
    MCInsts.resize(2);
    CreateMCInst(MCInsts[0], Cpu0::LUi, ATReg, ZEROReg, MCOperand::createImm(Hi));
    CreateMCInst(MCInsts[1], Cpu0::ADD, ATReg, ATReg, SPReg);
  }

  MCInst St;
  CreateMCInst(St, Cpu0::ST, GPReg, BaseReg, MCOperand::createImm(Offset));
  MCInsts.push_back(St);
}
#endif
</pre></div>
</div>
<p>The added code of Cpu0AsmPrinter.cpp as above will call the LowerCPRESTORE() when
user run program with <code class="docutils literal"><span class="pre">llc</span> <span class="pre">-filetype=obj</span></code>.
The added code of Cpu0MCInstLower.cpp as above takes care the .cprestore machine
instructions.</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">118-165-76-131:input Jonathan$</span> /Users/Jonathan/llvm/test/
<span class="go">cmake_debug_build/Debug/bin/llc -march=cpu0 -relocation-model=pic -filetype=</span>
<span class="go">obj ch9_1.bc -o ch9_1.cpu0.o</span>
<span class="gp">118-165-76-131:input Jonathan$</span> hexdump  ch9_1.cpu0.o
<span class="go">...</span>
<span class="go">// .cprestore machine instruction “ 01 ad 00 18”</span>
<span class="go">00000d0 01 ad 00 18 09 20 00 00 01 2d 00 40 09 20 00 06</span>
<span class="go">...</span>

<span class="gp">118-165-67-25:input Jonathan$</span> cat ch9_1.cpu0.s
<span class="go">...</span>
<span class="go">  .ent  _Z5sum_iiiiiii          # @_Z5sum_iiiiiii</span>
<span class="go">_Z5sum_iiiiiii:</span>
<span class="go">...</span>
<span class="go">  .cpload $t9 // assign $gp = $t9 by loader when loader load re-entry function</span>
<span class="go">              // (shared library) of _Z5sum_iiiiiii</span>
<span class="go">  .set  nomacro</span>
<span class="gp">#</span> BB#0:
<span class="go">...</span>
<span class="go">  .ent  main                    # @main</span>
<span class="go">...</span>
<span class="go">  .cprestore  24  // save $gp to 24($sp)</span>
<span class="go">...</span>
</pre></div>
</div>
<p>Run <code class="docutils literal"><span class="pre">llc</span> <span class="pre">-static</span></code> will call jsub instruction instead of jalr as follows,</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">118-165-76-131:input Jonathan$</span> /Users/Jonathan/llvm/test/
<span class="go">cmake_debug_build/Debug/bin/llc -march=cpu0 -relocation-model=static -filetype=</span>
<span class="go">asm ch9_1.bc -o ch9_1.cpu0.s</span>
<span class="gp">118-165-76-131:input Jonathan$</span> cat ch9_1.cpu0.s
<span class="go">...</span>
<span class="go">  jsub  _Z5sum_iiiiiii</span>
<span class="go">...</span>
</pre></div>
</div>
<p>Run ch9_1.bc with <code class="docutils literal"><span class="pre">llc</span> <span class="pre">-filetype=obj</span></code>, you will find the Cx of <strong>“jsub Cx”</strong>
is 0 since the Cx is calculated by linker as below.
Mips has the same 0 in it&#8217;s jal instruction.</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">// jsub _Z5sum_iiiiiii translate into 2B 00 00 00</span>
<span class="go">00F0: 2B 00 00 00 01 2D 00 34 00 ED 00 3C 09 DD 00 40</span>
</pre></div>
</div>
<p>The following code will emit &#8220;ld $gp, ($gp save slot on stack)&#8221; after jalr by
creating file Cpu0EmitGPRestore.cpp which run as a function pass.</p>
<p class="rubric">lbdex/chapters/Chapter9_3/CMakeLists.txt</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="n">Cpu0EmitGPRestore</span><span class="o">.</span><span class="n">cpp</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0TargetMachine.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">///</span> <span class="n">Cpu0</span> <span class="n">Code</span> <span class="n">Generator</span> <span class="n">Pass</span> <span class="n">Configuration</span> <span class="n">Options</span><span class="o">.</span>
<span class="k">class</span> <span class="nc">Cpu0PassConfig</span> <span class="p">:</span> <span class="n">public</span> <span class="n">TargetPassConfig</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1">#ifdef ENABLE_GPRESTORE</span>
  <span class="n">void</span> <span class="n">addPreRegAlloc</span><span class="p">()</span> <span class="n">override</span><span class="p">;</span>
<span class="c1">#endif</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>#ifdef ENABLE_GPRESTORE
void Cpu0PassConfig::addPreRegAlloc() {
  if (!Cpu0ReserveGP) {
    // $gp is a caller-saved register.
    addPass(createCpu0EmitGPRestorePass(getCpu0TargetMachine()));
  }
  return;
}
#endif
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0.h</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1">#ifdef ENABLE_GPRESTORE</span>
  <span class="n">FunctionPass</span> <span class="o">*</span><span class="n">createCpu0EmitGPRestorePass</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">);</span>
<span class="c1">#endif</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0EmitGPRestore.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>//===-- Cpu0EmitGPRestore.cpp - Emit GP Restore Instruction ---------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This pass emits instructions that restore $gp right
// after jalr instructions.
//
//===----------------------------------------------------------------------===//

#include &quot;Cpu0.h&quot;
#if CH &gt;= CH9_3
#ifdef ENABLE_GPRESTORE

#include &quot;Cpu0TargetMachine.h&quot;
#include &quot;Cpu0MachineFunction.h&quot;
#include &quot;llvm/CodeGen/MachineFunctionPass.h&quot;
#include &quot;llvm/CodeGen/MachineInstrBuilder.h&quot;
#include &quot;llvm/Target/TargetInstrInfo.h&quot;
#include &quot;llvm/ADT/Statistic.h&quot;

using namespace llvm;

#define DEBUG_TYPE &quot;emit-gp-restore&quot;

namespace {
  struct Inserter : public MachineFunctionPass {

    TargetMachine &amp;TM;

    static char ID;
    Inserter(TargetMachine &amp;tm)
      : MachineFunctionPass(ID), TM(tm) { }

    virtual const char *getPassName() const {
      return &quot;Cpu0 Emit GP Restore&quot;;
    }

    bool runOnMachineFunction(MachineFunction &amp;F);
  };
  char Inserter::ID = 0;
} // end of anonymous namespace

bool Inserter::runOnMachineFunction(MachineFunction &amp;F) {
  Cpu0FunctionInfo *Cpu0FI = F.getInfo&lt;Cpu0FunctionInfo&gt;();
  const TargetSubtargetInfo *STI =  TM.getSubtargetImpl(*(F.getFunction()));
  const TargetInstrInfo *TII = STI-&gt;getInstrInfo();

  if ((TM.getRelocationModel() != Reloc::PIC_) ||
      (!Cpu0FI-&gt;globalBaseRegFixed()))
    return false;

  bool Changed = false;
  int FI = Cpu0FI-&gt;getGPFI();

  for (MachineFunction::iterator MFI = F.begin(), MFE = F.end();
       MFI != MFE; ++MFI) {
    MachineBasicBlock&amp; MBB = *MFI;
    MachineBasicBlock::iterator I = MFI-&gt;begin();
    
    /// isEHPad - Indicate that this basic block is entered via an
    /// exception handler.
    // If MBB is a landing pad, insert instruction that restores $gp after
    // EH_LABEL.
    if (MBB.isEHPad()) {
      // Find EH_LABEL first.
      for (; I-&gt;getOpcode() != TargetOpcode::EH_LABEL; ++I) ;

      // Insert ld.
      ++I;
      DebugLoc dl = I != MBB.end() ? I-&gt;getDebugLoc() : DebugLoc();
      BuildMI(MBB, I, dl, TII-&gt;get(Cpu0::LD), Cpu0::GP).addFrameIndex(FI)
                                                       .addImm(0);
      Changed = true;
    }

    while (I != MFI-&gt;end()) {
      if (I-&gt;getOpcode() != Cpu0::JALR) {
        ++I;
        continue;
      }

      DebugLoc dl = I-&gt;getDebugLoc();
      // emit ld $gp, ($gp save slot on stack) after jalr
      BuildMI(MBB, ++I, dl, TII-&gt;get(Cpu0::LD), Cpu0::GP).addFrameIndex(FI)
                                                         .addImm(0);
      Changed = true;
    }
  }

  return Changed;
}

/// createCpu0EmitGPRestorePass - Returns a pass that emits instructions that
/// restores $gp clobbered by jalr instructions.
FunctionPass *llvm::createCpu0EmitGPRestorePass(Cpu0TargetMachine &amp;tm) {
  return new Inserter(tm);
}

#endif

#endif
</pre></div>
</div>
</div>
<div class="section" id="variable-number-of-arguments">
<h3><a class="toc-backref" href="#id37">Variable number of arguments</a><a class="headerlink" href="#variable-number-of-arguments" title="Permalink to this headline">¶</a></h3>
<p>Until now, we support fixed number of arguments in formal function definition
(Incoming Arguments).
This subsection supports variable number of arguments since C language supports
this feature.</p>
<p>Run Chapter9_3/ with ch9_3_vararg.cpp as well as clang option,
<strong>clang -target mips-unknown-linux-gnu</strong>, to get the following result,</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">118-165-76-131:input Jonathan$</span> clang -target mips-unknown-linux-gnu -c
<span class="go">ch9_3_vararg.cpp -emit-llvm -o ch9_3_vararg.bc</span>
<span class="gp">118-165-76-131:input Jonathan$</span> /Users/Jonathan/llvm/test/
<span class="go">cmake_debug_build/Debug/bin/llc -march=cpu0 -mcpu=cpu032I -cpu0-s32-calls=false</span>
<span class="go">-relocation-model=pic -filetype=asm ch9_3_vararg.bc -o ch9_3_vararg.cpu0.s</span>
<span class="gp">118-165-76-131:input Jonathan$</span> cat ch9_3_vararg.cpu0.s
<span class="go">  .section .mdebug.abi32</span>
<span class="go">  .previous</span>
<span class="go">  .file &quot;ch9_3_vararg.bc&quot;</span>
<span class="go">  .text</span>
<span class="go">  .globl  _Z5sum_iiz</span>
<span class="go">  .align  2</span>
<span class="go">  .type _Z5sum_iiz,@function</span>
<span class="go">  .ent  _Z5sum_iiz              # @_Z5sum_iiz</span>
<span class="go">_Z5sum_iiz:</span>
<span class="go">  .frame  $fp,24,$lr</span>
<span class="go">  .mask   0x00001000,-4</span>
<span class="go">  .set  noreorder</span>
<span class="go">  .set  nomacro</span>
<span class="gp">#</span> BB#0:
<span class="go">  addiu $sp, $sp, -24</span>
<span class="go">  st  $fp, 20($sp)            # 4-byte Folded Spill</span>
<span class="go">  move    $fp, $sp</span>
<span class="go">  ld  $2, 24($fp)     // amount</span>
<span class="go">  st  $2, 16($fp)     // amount</span>
<span class="go">  addiu $2, $zero, 0</span>
<span class="go">  st  $2, 12($fp)     // i</span>
<span class="go">  st  $2, 8($fp)     // val</span>
<span class="go">  st  $2, 4($fp)      // sum</span>
<span class="go">  addiu $3, $fp, 28</span>
<span class="go">  st  $3, 0($fp)      // arg_ptr = 2nd argument = &amp;arg[1],</span>
<span class="go">              // since &amp;arg[0] = 24($sp)</span>
<span class="go">  st  $2, 12($fp)</span>
<span class="gp">$</span>BB0_1:                                 <span class="c1"># =&gt;This Inner Loop Header: Depth=1</span>
<span class="go">  ld  $2, 16($fp)</span>
<span class="go">  ld  $3, 12($fp)</span>
<span class="go">  cmp $sw, $3, $2        // compare(i, amount)</span>
<span class="go">  jge $BB0_4</span>
<span class="go">  nop</span>
<span class="go">  jmp $BB0_2</span>
<span class="go">  nop</span>
<span class="gp">$</span>BB0_2:                                 <span class="c1">#   in Loop: Header=BB0_1 Depth=1</span>
<span class="go">              // i &lt; amount</span>
<span class="go">  ld  $2, 0($fp)</span>
<span class="go">  addiu $3, $2, 4   // arg_ptr  + 4</span>
<span class="go">  st  $3, 0($fp)</span>
<span class="go">  ld  $2, 0($2)     // *arg_ptr</span>
<span class="go">  st  $2, 8($fp)</span>
<span class="go">  ld  $3, 4($fp)      // sum</span>
<span class="go">  add $2, $3, $2      // sum += *arg_ptr</span>
<span class="go">  st  $2, 4($fp)</span>
<span class="gp">#</span> BB#3:                                 <span class="c1">#   in Loop: Header=BB0_1 Depth=1</span>
<span class="go">              // i &gt;= amount</span>
<span class="go">  ld  $2, 12($fp)</span>
<span class="go">  addiu $2, $2, 1   // i++</span>
<span class="go">  st  $2, 12($fp)</span>
<span class="go">  jmp $BB0_1</span>
<span class="go">  nop</span>
<span class="gp">$</span>BB0_4:
<span class="go">  ld  $2, 4($fp)</span>
<span class="go">  move    $sp, $fp</span>
<span class="go">  ld  $fp, 20($sp)            # 4-byte Folded Reload</span>
<span class="go">  addiu $sp, $sp, 24</span>
<span class="go">  ret $lr</span>
<span class="go">  .set  macro</span>
<span class="go">  .set  reorder</span>
<span class="go">  .end  _Z5sum_iiz</span>
<span class="gp">$</span>tmp1:
<span class="go">  .size _Z5sum_iiz, ($tmp1)-_Z5sum_iiz</span>

<span class="go">  .globl  _Z11test_varargv</span>
<span class="go">  .align  2</span>
<span class="go">  .type _Z11test_varargv,@function</span>
<span class="go">  .ent  _Z11test_varargv                    # @_Z11test_varargv</span>
<span class="go">_Z11test_varargv:</span>
<span class="go">  .frame  $sp,88,$lr</span>
<span class="go">  .mask   0x00004000,-4</span>
<span class="go">  .set  noreorder</span>
<span class="go">  .cpload $t9</span>
<span class="go">  .set  nomacro</span>
<span class="gp">#</span> BB#0:
<span class="go">  addiu $sp, $sp, -48</span>
<span class="go">  st  $lr, 44($sp)            # 4-byte Folded Spill</span>
<span class="go">  st  $fp, 40($sp)            # 4-byte Folded Spill</span>
<span class="go">  move    $fp, $sp</span>
<span class="go">  .cprestore  32</span>
<span class="go">  addiu $2, $zero, 5</span>
<span class="go">  st  $2, 24($sp)</span>
<span class="go">  addiu $2, $zero, 4</span>
<span class="go">  st  $2, 20($sp)</span>
<span class="go">  addiu $2, $zero, 3</span>
<span class="go">  st  $2, 16($sp)</span>
<span class="go">  addiu $2, $zero, 2</span>
<span class="go">  st  $2, 12($sp)</span>
<span class="go">  addiu $2, $zero, 1</span>
<span class="go">  st  $2, 8($sp)</span>
<span class="go">  addiu $2, $zero, 0</span>
<span class="go">  st  $2, 4($sp)</span>
<span class="go">  addiu $2, $zero, 6</span>
<span class="go">  st  $2, 0($sp)</span>
<span class="go">  ld  $t9, %call16(_Z5sum_iiz)($gp)</span>
<span class="go">  jalr  $t9</span>
<span class="go">  nop</span>
<span class="go">  ld  $gp, 28($fp)</span>
<span class="go">  st  $2, 36($fp)</span>
<span class="go">  move    $sp, $fp</span>
<span class="go">  ld  $fp, 40($sp)            # 4-byte Folded Reload</span>
<span class="go">  ld  $lr, 44($sp)            # 4-byte Folded Reload</span>
<span class="go">  addiu $sp, $sp, 48</span>
<span class="go">  ret $lr</span>
<span class="go">  nop</span>
<span class="go">  .set  macro</span>
<span class="go">  .set  reorder</span>
<span class="go">  .end  _Z11test_varargv</span>
<span class="gp">$</span>tmp1:
<span class="go">  .size _Z11test_varargv, ($tmp1)-_Z11test_varargv</span>
</pre></div>
</div>
<p>The analysis of output ch9_3_vararg.cpu0.s as above in comment.
As above code in # BB#0, we get the first argument <strong>“amount”</strong> from
<strong>“ld $2, 24($fp)”</strong> since the stack size of the callee function
<strong>“_Z5sum_iiz()”</strong> is 24. And then setting argument pointer, arg_ptr, to 0($fp),
&amp;arg[1].
Next, checking i &lt; amount in block $BB0_1. If i &lt; amount, than entering into $BB0_2.
In $BB0_2, it does sum += *arg_ptr and arg_ptr+=4.
In # BB#3, it does i+=1.</p>
<p>To support variable number of arguments, the following code needed to
add in Chapter9_3/.
The ch9_3_template.cpp is C++ template example code, it can be translated into cpu0
backend code too.</p>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0ISelLowering.h</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="k">class</span> <span class="nc">Cpu0TargetLowering</span> <span class="p">:</span> <span class="n">public</span> <span class="n">TargetLowering</span>  <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>    <span class="o">///</span> <span class="n">Cpu0CC</span> <span class="o">-</span> <span class="n">This</span> <span class="k">class</span> <span class="nc">provides</span> <span class="n">methods</span> <span class="n">used</span> <span class="n">to</span> <span class="n">analyze</span> <span class="n">formal</span> <span class="ow">and</span> <span class="n">call</span>
    <span class="o">///</span> <span class="n">arguments</span> <span class="ow">and</span> <span class="n">inquire</span> <span class="n">about</span> <span class="n">calling</span> <span class="n">convention</span> <span class="n">information</span><span class="o">.</span>
    <span class="k">class</span> <span class="nc">Cpu0CC</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>      <span class="o">///</span> <span class="n">Return</span> <span class="n">the</span> <span class="n">function</span> <span class="n">that</span> <span class="n">analyzes</span> <span class="n">variable</span> <span class="n">argument</span> <span class="nb">list</span> <span class="n">functions</span><span class="o">.</span>
      <span class="n">llvm</span><span class="p">::</span><span class="n">CCAssignFn</span> <span class="o">*</span><span class="n">varArgFn</span><span class="p">()</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>      <span class="p">...</span>
<span class="p">.</span>   <span class="p">};</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>    <span class="n">SDValue</span> <span class="n">lowerVASTART</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
    <span class="n">SDValue</span> <span class="n">lowerFRAMEADDR</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
    <span class="n">SDValue</span> <span class="n">lowerRETURNADDR</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
    <span class="n">SDValue</span> <span class="n">lowerEH_RETURN</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
    <span class="n">SDValue</span> <span class="n">lowerADD</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>    <span class="o">///</span> <span class="n">writeVarArgRegs</span> <span class="o">-</span> <span class="n">Write</span> <span class="n">variable</span> <span class="n">function</span> <span class="n">arguments</span> <span class="n">passed</span> <span class="ow">in</span> <span class="n">registers</span>
    <span class="o">///</span> <span class="n">to</span> <span class="n">the</span> <span class="n">stack</span><span class="o">.</span> <span class="n">Also</span> <span class="n">create</span> <span class="n">a</span> <span class="n">stack</span> <span class="n">frame</span> <span class="nb">object</span> <span class="k">for</span> <span class="n">the</span> <span class="n">first</span> <span class="n">variable</span>
    <span class="o">///</span> <span class="n">argument</span><span class="o">.</span>
    <span class="n">void</span> <span class="n">writeVarArgRegs</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">OutChains</span><span class="p">,</span> <span class="n">const</span> <span class="n">Cpu0CC</span> <span class="o">&amp;</span><span class="n">CC</span><span class="p">,</span>
                         <span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">const</span> <span class="n">SDLoc</span> <span class="o">&amp;</span><span class="n">DL</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>    <span class="p">...</span>
<span class="p">.</span> <span class="p">};</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0ISelLowering.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="n">const</span> <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">,</span>
                                       <span class="n">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span>
    <span class="p">:</span> <span class="n">TargetLowering</span><span class="p">(</span><span class="n">TM</span><span class="p">),</span> <span class="n">Subtarget</span><span class="p">(</span><span class="n">STI</span><span class="p">),</span> <span class="n">ABI</span><span class="p">(</span><span class="n">TM</span><span class="o">.</span><span class="n">getABI</span><span class="p">())</span> <span class="p">{</span>

</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">VASTART</span><span class="p">,</span>            <span class="n">MVT</span><span class="p">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Custom</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="o">//</span> <span class="n">Support</span> <span class="n">va_arg</span><span class="p">():</span> <span class="n">variable</span> <span class="n">numbers</span> <span class="p">(</span><span class="ow">not</span> <span class="n">fixed</span> <span class="n">numbers</span><span class="p">)</span> <span class="n">of</span> <span class="n">arguments</span> 
  <span class="o">//</span>  <span class="p">(</span><span class="n">parameters</span><span class="p">)</span> <span class="k">for</span> <span class="n">function</span> <span class="nb">all</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">VAARG</span><span class="p">,</span>             <span class="n">MVT</span><span class="p">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">VACOPY</span><span class="p">,</span>            <span class="n">MVT</span><span class="p">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">VAEND</span><span class="p">,</span>             <span class="n">MVT</span><span class="p">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
  
  <span class="o">//</span><span class="nd">@llvm</span><span class="o">.</span><span class="n">stacksave</span>
  <span class="o">//</span> <span class="n">Use</span> <span class="n">the</span> <span class="n">default</span> <span class="k">for</span> <span class="n">now</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">STACKSAVE</span><span class="p">,</span>         <span class="n">MVT</span><span class="p">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">STACKRESTORE</span><span class="p">,</span>      <span class="n">MVT</span><span class="p">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="p">::</span>
<span class="n">LowerOperation</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span>
<span class="p">{</span>
  <span class="n">switch</span> <span class="p">(</span><span class="n">Op</span><span class="o">.</span><span class="n">getOpcode</span><span class="p">())</span>
  <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="n">case</span> <span class="n">ISD</span><span class="p">::</span><span class="n">VASTART</span><span class="p">:</span>            <span class="k">return</span> <span class="n">lowerVASTART</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="p">}</span>
  <span class="k">return</span> <span class="n">SDValue</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">lowerVASTART</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getMachineFunction</span><span class="p">();</span>
  <span class="n">Cpu0FunctionInfo</span> <span class="o">*</span><span class="n">FuncInfo</span> <span class="o">=</span> <span class="n">MF</span><span class="o">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="n">SDLoc</span> <span class="n">DL</span> <span class="o">=</span> <span class="n">SDLoc</span><span class="p">(</span><span class="n">Op</span><span class="p">);</span>
  <span class="n">SDValue</span> <span class="n">FI</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getFrameIndex</span><span class="p">(</span><span class="n">FuncInfo</span><span class="o">-&gt;</span><span class="n">getVarArgsFrameIndex</span><span class="p">(),</span>
                                 <span class="n">getPointerTy</span><span class="p">(</span><span class="n">MF</span><span class="o">.</span><span class="n">getDataLayout</span><span class="p">()));</span>

  <span class="o">//</span> <span class="n">vastart</span> <span class="n">just</span> <span class="n">stores</span> <span class="n">the</span> <span class="n">address</span> <span class="n">of</span> <span class="n">the</span> <span class="n">VarArgsFrameIndex</span> <span class="n">slot</span> <span class="n">into</span> <span class="n">the</span>
  <span class="o">//</span> <span class="n">memory</span> <span class="n">location</span> <span class="n">argument</span><span class="o">.</span>
  <span class="n">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">SV</span> <span class="o">=</span> <span class="n">cast</span><span class="o">&lt;</span><span class="n">SrcValueSDNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Op</span><span class="o">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getStore</span><span class="p">(</span><span class="n">Op</span><span class="o">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">DL</span><span class="p">,</span> <span class="n">FI</span><span class="p">,</span> <span class="n">Op</span><span class="o">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                      <span class="n">MachinePointerInfo</span><span class="p">(</span><span class="n">SV</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">///</span> <span class="n">LowerFormalArguments</span> <span class="o">-</span> <span class="n">transform</span> <span class="n">physical</span> <span class="n">registers</span> <span class="n">into</span> <span class="n">virtual</span> <span class="n">registers</span>
<span class="o">///</span> <span class="ow">and</span> <span class="n">generate</span> <span class="n">load</span> <span class="n">operations</span> <span class="k">for</span> <span class="n">arguments</span> <span class="n">places</span> <span class="n">on</span> <span class="n">the</span> <span class="n">stack</span><span class="o">.</span>
<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">LowerFormalArguments</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span>
                                         <span class="n">CallingConv</span><span class="p">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span>
                                         <span class="nb">bool</span> <span class="n">IsVarArg</span><span class="p">,</span>
                                         <span class="n">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="p">::</span><span class="n">InputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ins</span><span class="p">,</span>
                                         <span class="n">const</span> <span class="n">SDLoc</span> <span class="o">&amp;</span><span class="n">DL</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span>
                                         <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span>
                                          <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="k">if</span> <span class="p">(</span><span class="n">IsVarArg</span><span class="p">)</span>
    <span class="n">writeVarArgRegs</span><span class="p">(</span><span class="n">OutChains</span><span class="p">,</span> <span class="n">Cpu0CCInfo</span><span class="p">,</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">DAG</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">Cpu0CC</span><span class="p">::</span>
<span class="n">analyzeCallOperands</span><span class="p">(</span><span class="n">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="p">::</span><span class="n">OutputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Args</span><span class="p">,</span>
                    <span class="nb">bool</span> <span class="n">IsVarArg</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">IsSoftFloat</span><span class="p">,</span> <span class="n">const</span> <span class="n">SDNode</span> <span class="o">*</span><span class="n">CallNode</span><span class="p">,</span>
                    <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ArgListEntry</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">FuncArgs</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="n">llvm</span><span class="p">::</span><span class="n">CCAssignFn</span> <span class="o">*</span><span class="n">VarFn</span> <span class="o">=</span> <span class="n">varArgFn</span><span class="p">();</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="k">for</span> <span class="p">(</span><span class="n">unsigned</span> <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">I</span> <span class="o">!=</span> <span class="n">NumOpnds</span><span class="p">;</span> <span class="o">++</span><span class="n">I</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>    if (IsVarArg &amp;&amp; !Args[I].IsFixed)
      R = VarFn(I, ArgVT, ArgVT, CCValAssign::Full, ArgFlags, CCInfo);
    else
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>    <span class="p">...</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">llvm</span><span class="p">::</span><span class="n">CCAssignFn</span> <span class="o">*</span><span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">Cpu0CC</span><span class="p">::</span><span class="n">varArgFn</span><span class="p">()</span> <span class="n">const</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">IsO32</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">CC_Cpu0O32</span><span class="p">;</span>
  <span class="k">else</span> <span class="o">//</span> <span class="n">IsS32</span>
    <span class="k">return</span> <span class="n">CC_Cpu0S32</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">writeVarArgRegs</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">OutChains</span><span class="p">,</span>
                                         <span class="n">const</span> <span class="n">Cpu0CC</span> <span class="o">&amp;</span><span class="n">CC</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span>
                                         <span class="n">const</span> <span class="n">SDLoc</span> <span class="o">&amp;</span><span class="n">DL</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="n">unsigned</span> <span class="n">NumRegs</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">numIntArgRegs</span><span class="p">();</span>
  <span class="n">const</span> <span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">MCPhysReg</span><span class="o">&gt;</span> <span class="n">ArgRegs</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">intArgRegs</span><span class="p">();</span>
  <span class="n">const</span> <span class="n">CCState</span> <span class="o">&amp;</span><span class="n">CCInfo</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">getCCInfo</span><span class="p">();</span>
  <span class="n">unsigned</span> <span class="n">Idx</span> <span class="o">=</span> <span class="n">CCInfo</span><span class="o">.</span><span class="n">getFirstUnallocated</span><span class="p">(</span><span class="n">ArgRegs</span><span class="p">);</span>
  <span class="n">unsigned</span> <span class="n">RegSize</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">regSize</span><span class="p">();</span>
  <span class="n">MVT</span> <span class="n">RegTy</span> <span class="o">=</span> <span class="n">MVT</span><span class="p">::</span><span class="n">getIntegerVT</span><span class="p">(</span><span class="n">RegSize</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>
  <span class="n">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span><span class="n">RC</span> <span class="o">=</span> <span class="n">getRegClassFor</span><span class="p">(</span><span class="n">RegTy</span><span class="p">);</span>
  <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getMachineFunction</span><span class="p">();</span>
  <span class="n">MachineFrameInfo</span> <span class="o">*</span><span class="n">MFI</span> <span class="o">=</span> <span class="n">MF</span><span class="o">.</span><span class="n">getFrameInfo</span><span class="p">();</span>
  <span class="n">Cpu0FunctionInfo</span> <span class="o">*</span><span class="n">Cpu0FI</span> <span class="o">=</span> <span class="n">MF</span><span class="o">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="o">//</span> <span class="n">Offset</span> <span class="n">of</span> <span class="n">the</span> <span class="n">first</span> <span class="n">variable</span> <span class="n">argument</span> <span class="kn">from</span> <span class="nn">stack</span> <span class="n">pointer</span><span class="o">.</span>
  <span class="nb">int</span> <span class="n">VaArgOffset</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">NumRegs</span> <span class="o">==</span> <span class="n">Idx</span><span class="p">)</span>
    <span class="n">VaArgOffset</span> <span class="o">=</span> <span class="n">alignTo</span><span class="p">(</span><span class="n">CCInfo</span><span class="o">.</span><span class="n">getNextStackOffset</span><span class="p">(),</span> <span class="n">RegSize</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">VaArgOffset</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="n">CC</span><span class="o">.</span><span class="n">reservedArgArea</span><span class="p">()</span> <span class="o">-</span> <span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="n">RegSize</span> <span class="o">*</span> <span class="p">(</span><span class="n">NumRegs</span> <span class="o">-</span> <span class="n">Idx</span><span class="p">));</span>

  <span class="o">//</span> <span class="n">Record</span> <span class="n">the</span> <span class="n">frame</span> <span class="n">index</span> <span class="n">of</span> <span class="n">the</span> <span class="n">first</span> <span class="n">variable</span> <span class="n">argument</span>
  <span class="o">//</span> <span class="n">which</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">value</span> <span class="n">necessary</span> <span class="n">to</span> <span class="n">VASTART</span><span class="o">.</span>
  <span class="nb">int</span> <span class="n">FI</span> <span class="o">=</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">CreateFixedObject</span><span class="p">(</span><span class="n">RegSize</span><span class="p">,</span> <span class="n">VaArgOffset</span><span class="p">,</span> <span class="n">true</span><span class="p">);</span>
  <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">setVarArgsFrameIndex</span><span class="p">(</span><span class="n">FI</span><span class="p">);</span>

  <span class="o">//</span> <span class="n">Copy</span> <span class="n">the</span> <span class="n">integer</span> <span class="n">registers</span> <span class="n">that</span> <span class="n">have</span> <span class="ow">not</span> <span class="n">been</span> <span class="n">used</span> <span class="k">for</span> <span class="n">argument</span> <span class="n">passing</span>
  <span class="o">//</span> <span class="n">to</span> <span class="n">the</span> <span class="n">argument</span> <span class="n">register</span> <span class="n">save</span> <span class="n">area</span><span class="o">.</span> <span class="n">For</span> <span class="n">O32</span><span class="p">,</span> <span class="n">the</span> <span class="n">save</span> <span class="n">area</span> <span class="ow">is</span> <span class="n">allocated</span>
  <span class="o">//</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">caller</span><span class="s1">&#39;s stack frame, while for N32/64, it is allocated in the</span>
  <span class="o">//</span> <span class="n">callee</span><span class="s1">&#39;s stack frame.</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">unsigned</span> <span class="n">I</span> <span class="o">=</span> <span class="n">Idx</span><span class="p">;</span> <span class="n">I</span> <span class="o">&lt;</span> <span class="n">NumRegs</span><span class="p">;</span> <span class="o">++</span><span class="n">I</span><span class="p">,</span> <span class="n">VaArgOffset</span> <span class="o">+=</span> <span class="n">RegSize</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unsigned</span> <span class="n">Reg</span> <span class="o">=</span> <span class="n">addLiveIn</span><span class="p">(</span><span class="n">MF</span><span class="p">,</span> <span class="n">ArgRegs</span><span class="p">[</span><span class="n">I</span><span class="p">],</span> <span class="n">RC</span><span class="p">);</span>
    <span class="n">SDValue</span> <span class="n">ArgValue</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getCopyFromReg</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Reg</span><span class="p">,</span> <span class="n">RegTy</span><span class="p">);</span>
    <span class="n">FI</span> <span class="o">=</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">CreateFixedObject</span><span class="p">(</span><span class="n">RegSize</span><span class="p">,</span> <span class="n">VaArgOffset</span><span class="p">,</span> <span class="n">true</span><span class="p">);</span>
    <span class="n">SDValue</span> <span class="n">PtrOff</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getFrameIndex</span><span class="p">(</span><span class="n">FI</span><span class="p">,</span> <span class="n">getPointerTy</span><span class="p">(</span><span class="n">DAG</span><span class="o">.</span><span class="n">getDataLayout</span><span class="p">()));</span>
    <span class="n">SDValue</span> <span class="n">Store</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getStore</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">ArgValue</span><span class="p">,</span> <span class="n">PtrOff</span><span class="p">,</span>
                                 <span class="n">MachinePointerInfo</span><span class="p">());</span>
    <span class="n">cast</span><span class="o">&lt;</span><span class="n">StoreSDNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Store</span><span class="o">.</span><span class="n">getNode</span><span class="p">())</span><span class="o">-&gt;</span><span class="n">getMemOperand</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">setValue</span><span class="p">(</span>
        <span class="p">(</span><span class="n">Value</span> <span class="o">*</span><span class="p">)</span><span class="n">nullptr</span><span class="p">);</span>
    <span class="n">OutChains</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Store</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/input/ch9_3_template.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1">#include &lt;stdarg.h&gt;</span>

<span class="n">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="nb">sum</span><span class="p">(</span><span class="n">T</span> <span class="n">amount</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">T</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">T</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">T</span> <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	
  <span class="n">va_list</span> <span class="n">vl</span><span class="p">;</span>
  <span class="n">va_start</span><span class="p">(</span><span class="n">vl</span><span class="p">,</span> <span class="n">amount</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">amount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">vl</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>
    <span class="nb">sum</span> <span class="o">+=</span> <span class="n">val</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">va_end</span><span class="p">(</span><span class="n">vl</span><span class="p">);</span>
  
  <span class="k">return</span> <span class="nb">sum</span><span class="p">;</span> 
<span class="p">}</span>

<span class="nb">int</span> <span class="n">test_template</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="nb">sum</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
	
  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Mips qemu reference <a class="footnote-reference" href="#mipsqemu" id="id10">[8]</a>, you can download and run it with gcc to
verify the result with printf() function at this point.
We will verify the correction of the code in chapter &#8220;Verify backend on
Verilog simulator&#8221; through the CPU0 Verilog language machine.</p>
</div>
<div class="section" id="dynamic-stack-allocation-support">
<h3><a class="toc-backref" href="#id38">Dynamic stack allocation support</a><a class="headerlink" href="#dynamic-stack-allocation-support" title="Permalink to this headline">¶</a></h3>
<p>Even though C language is very rare using dynamic stack allocation, there are
languages use it frequently. The following C example code uses it.</p>
<p>Chapter9_3 supports dynamic stack allocation with the following code added.</p>
<p class="rubric">lbdex/chapters/Chapter9_2/Cpu0FrameLowering.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>// Eliminate ADJCALLSTACKDOWN, ADJCALLSTACKUP pseudo instructions
MachineBasicBlock::iterator Cpu0FrameLowering::
eliminateCallFramePseudoInstr(MachineFunction &amp;MF, MachineBasicBlock &amp;MBB,
                              MachineBasicBlock::iterator I) const {
#if CH &gt;= CH9_3 // dynamic alloc
  unsigned SP = Cpu0::SP;

  if (!hasReservedCallFrame(MF)) {
    int64_t Amount = I-&gt;getOperand(0).getImm();
    if (I-&gt;getOpcode() == Cpu0::ADJCALLSTACKDOWN)
      Amount = -Amount;

    STI.getInstrInfo()-&gt;adjustStackPtr(SP, Amount, MBB, I);
  }
#endif // dynamic alloc

  return MBB.erase(I);
}
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0SEFrameLowering.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">Cpu0SEFrameLowering</span><span class="p">::</span><span class="n">emitPrologue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                       <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="n">unsigned</span> <span class="n">FP</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">FP</span><span class="p">;</span>
  <span class="n">unsigned</span> <span class="n">ZERO</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">ZERO</span><span class="p">;</span>
  <span class="n">unsigned</span> <span class="n">ADDu</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">ADDu</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="o">//</span> <span class="k">if</span> <span class="n">framepointer</span> <span class="n">enabled</span><span class="p">,</span> <span class="nb">set</span> <span class="n">it</span> <span class="n">to</span> <span class="n">point</span> <span class="n">to</span> <span class="n">the</span> <span class="n">stack</span> <span class="n">pointer</span><span class="o">.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">hasFP</span><span class="p">(</span><span class="n">MF</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">callsEhDwarf</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MBBI</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">TII</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ADDu</span><span class="p">),</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">V0</span><span class="p">)</span><span class="o">.</span><span class="n">addReg</span><span class="p">(</span><span class="n">FP</span><span class="p">)</span><span class="o">.</span><span class="n">addReg</span><span class="p">(</span><span class="n">ZERO</span><span class="p">)</span>
        <span class="o">.</span><span class="n">setMIFlag</span><span class="p">(</span><span class="n">MachineInstr</span><span class="p">::</span><span class="n">FrameSetup</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="o">//@</span> <span class="n">Insert</span> <span class="n">instruction</span> <span class="s2">&quot;move $fp, $sp&quot;</span> <span class="n">at</span> <span class="n">this</span> <span class="n">location</span><span class="o">.</span>
    <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MBBI</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">TII</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ADDu</span><span class="p">),</span> <span class="n">FP</span><span class="p">)</span><span class="o">.</span><span class="n">addReg</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span><span class="o">.</span><span class="n">addReg</span><span class="p">(</span><span class="n">ZERO</span><span class="p">)</span>
      <span class="o">.</span><span class="n">setMIFlag</span><span class="p">(</span><span class="n">MachineInstr</span><span class="p">::</span><span class="n">FrameSetup</span><span class="p">);</span>

    <span class="o">//</span> <span class="n">emit</span> <span class="s2">&quot;.cfi_def_cfa_register $fp&quot;</span>
    <span class="n">unsigned</span> <span class="n">CFIIndex</span> <span class="o">=</span> <span class="n">MMI</span><span class="o">.</span><span class="n">addFrameInst</span><span class="p">(</span><span class="n">MCCFIInstruction</span><span class="p">::</span><span class="n">createDefCfaRegister</span><span class="p">(</span>
        <span class="n">nullptr</span><span class="p">,</span> <span class="n">MRI</span><span class="o">-&gt;</span><span class="n">getDwarfRegNum</span><span class="p">(</span><span class="n">FP</span><span class="p">,</span> <span class="n">true</span><span class="p">)));</span>
    <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MBBI</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">TII</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">TargetOpcode</span><span class="p">::</span><span class="n">CFI_INSTRUCTION</span><span class="p">))</span>
        <span class="o">.</span><span class="n">addCFIIndex</span><span class="p">(</span><span class="n">CFIIndex</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">Cpu0SEFrameLowering</span><span class="p">::</span><span class="n">emitEpilogue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                 <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="n">unsigned</span> <span class="n">FP</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">FP</span><span class="p">;</span>
  <span class="n">unsigned</span> <span class="n">ZERO</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">ZERO</span><span class="p">;</span>
  <span class="n">unsigned</span> <span class="n">ADDu</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">ADDu</span><span class="p">;</span>

  <span class="o">//</span> <span class="k">if</span> <span class="n">framepointer</span> <span class="n">enabled</span><span class="p">,</span> <span class="n">restore</span> <span class="n">the</span> <span class="n">stack</span> <span class="n">pointer</span><span class="o">.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">hasFP</span><span class="p">(</span><span class="n">MF</span><span class="p">))</span> <span class="p">{</span>
    <span class="o">//</span> <span class="n">Find</span> <span class="n">the</span> <span class="n">first</span> <span class="n">instruction</span> <span class="n">that</span> <span class="n">restores</span> <span class="n">a</span> <span class="n">callee</span><span class="o">-</span><span class="n">saved</span> <span class="n">register</span><span class="o">.</span>
    <span class="n">MachineBasicBlock</span><span class="p">::</span><span class="n">iterator</span> <span class="n">I</span> <span class="o">=</span> <span class="n">MBBI</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">getCalleeSavedInfo</span><span class="p">()</span><span class="o">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
      <span class="o">--</span><span class="n">I</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Insert</span> <span class="n">instruction</span> <span class="s2">&quot;move $sp, $fp&quot;</span> <span class="n">at</span> <span class="n">this</span> <span class="n">location</span><span class="o">.</span>
    <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">TII</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ADDu</span><span class="p">),</span> <span class="n">SP</span><span class="p">)</span><span class="o">.</span><span class="n">addReg</span><span class="p">(</span><span class="n">FP</span><span class="p">)</span><span class="o">.</span><span class="n">addReg</span><span class="p">(</span><span class="n">ZERO</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  unsigned FP = Cpu0::FP;

  // Mark $fp as used if function has dedicated frame pointer.
  if (hasFP(MF))
    setAliasRegs(MF, SavedRegs, FP);

</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0ISelLowering.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="n">const</span> <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">,</span>
                                       <span class="n">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span>
    <span class="p">:</span> <span class="n">TargetLowering</span><span class="p">(</span><span class="n">TM</span><span class="p">),</span> <span class="n">Subtarget</span><span class="p">(</span><span class="n">STI</span><span class="p">),</span> <span class="n">ABI</span><span class="p">(</span><span class="n">TM</span><span class="o">.</span><span class="n">getABI</span><span class="p">())</span> <span class="p">{</span>

</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">DYNAMIC_STACKALLOC</span><span class="p">,</span> <span class="n">MVT</span><span class="p">::</span><span class="n">i32</span><span class="p">,</span>  <span class="n">Expand</span><span class="p">);</span>

</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="n">setStackPointerRegisterToSaveRestore</span><span class="p">(</span><span class="n">Cpu0</span><span class="p">::</span><span class="n">SP</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0RegisterInfo.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">BitVector</span> <span class="n">Cpu0RegisterInfo</span><span class="p">::</span>
<span class="n">getReservedRegs</span><span class="p">(</span><span class="n">const</span> <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="o">//</span> <span class="n">Reserve</span> <span class="n">FP</span> <span class="k">if</span> <span class="n">this</span> <span class="n">function</span> <span class="n">should</span> <span class="n">have</span> <span class="n">a</span> <span class="n">dedicated</span> <span class="n">frame</span> <span class="n">pointer</span> <span class="n">register</span><span class="o">.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">MF</span><span class="o">.</span><span class="n">getSubtarget</span><span class="p">()</span><span class="o">.</span><span class="n">getFrameLowering</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">hasFP</span><span class="p">(</span><span class="n">MF</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">Reserved</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">Cpu0</span><span class="p">::</span><span class="n">FP</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//-</span> <span class="n">If</span> <span class="n">no</span> <span class="n">eliminateFrameIndex</span><span class="p">(),</span> <span class="n">it</span> <span class="n">will</span> <span class="n">hang</span> <span class="n">on</span> <span class="n">run</span><span class="o">.</span> 
<span class="o">//</span> <span class="n">pure</span> <span class="n">virtual</span> <span class="n">method</span>
<span class="o">//</span> <span class="n">FrameIndex</span> <span class="n">represent</span> <span class="n">objects</span> <span class="n">inside</span> <span class="n">a</span> <span class="n">abstract</span> <span class="n">stack</span><span class="o">.</span>
<span class="o">//</span> <span class="n">We</span> <span class="n">must</span> <span class="n">replace</span> <span class="n">FrameIndex</span> <span class="k">with</span> <span class="n">an</span> <span class="n">stack</span><span class="o">/</span><span class="n">frame</span> <span class="n">pointer</span>
<span class="o">//</span> <span class="n">direct</span> <span class="n">reference</span><span class="o">.</span>
<span class="n">void</span> <span class="n">Cpu0RegisterInfo</span><span class="p">::</span>
<span class="n">eliminateFrameIndex</span><span class="p">(</span><span class="n">MachineBasicBlock</span><span class="p">::</span><span class="n">iterator</span> <span class="n">II</span><span class="p">,</span> <span class="nb">int</span> <span class="n">SPAdj</span><span class="p">,</span>
                    <span class="n">unsigned</span> <span class="n">FIOperandNum</span><span class="p">,</span> <span class="n">RegScavenger</span> <span class="o">*</span><span class="n">RS</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">isOutArgFI</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">)</span> <span class="o">||</span> <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">isGPFI</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">)</span> <span class="o">||</span>
      <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">isDynAllocFI</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">))</span>
    <span class="n">Offset</span> <span class="o">=</span> <span class="n">spOffset</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="p">}</span>
</pre></div>
</div>
<p>Run Chapter9_3 with ch9_3_alloc.cpp will get the following correct result.</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">118-165-72-242:input Jonathan$</span> clang -target mips-unknown-linux-gnu -c
<span class="go">ch9_3_alloc.cpp -emit-llvm -o ch9_3_alloc.bc</span>
<span class="gp">118-165-72-242:input Jonathan$</span> llvm-dis ch9_3_alloc.bc -o ch9_3_alloc.ll
<span class="gp">118-165-72-242:input Jonathan$</span> cat ch9_3_alloc.ll
<span class="go">; ModuleID = &#39;ch9_3_alloc.bc&#39;</span>
<span class="go">target datalayout = &quot;e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-</span>
<span class="go">f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:</span>
<span class="go">32:64-S128&quot;</span>
<span class="go">target triple = &quot;x86_64-apple-macosx10.8.0&quot;</span>

<span class="go">define i32 @_Z5sum_iiiiiii(i32 %x1, i32 %x2, i32 %x3, i32 %x4, i32 %x5, i32 %x6)</span>
<span class="go"> nounwind uwtable ssp {</span>
<span class="go">  ...</span>
<span class="gp">  %</span><span class="nv">9</span> <span class="o">=</span> alloca i8, i32 %8      // int* <span class="nv">b</span> <span class="o">=</span> <span class="o">(</span>int*<span class="o">)</span>__builtin_alloca<span class="o">(</span>sizeof<span class="o">(</span>int<span class="o">)</span> * <span class="m">1</span> * x1<span class="o">)</span><span class="p">;</span>
<span class="gp">  %</span><span class="nv">10</span> <span class="o">=</span> bitcast i8* %9 to i32*
<span class="go">  store i32* %10, i32** %b, align 4</span>
<span class="go">  ...</span>
<span class="go">}</span>
<span class="go">...</span>

<span class="gp">118-165-72-242:input Jonathan$</span> /Users/Jonathan/llvm/test/cmake_debug_build/
<span class="go">Debug/bin/llc -march=cpu0 -mcpu=cpu032I -cpu0-s32-calls=false</span>
<span class="go">-relocation-model=pic -filetype=asm ch9_3_alloc.bc -o ch9_3_alloc.cpu0.s</span>
<span class="gp">118-165-72-242:input Jonathan$</span> cat ch9_3_alloc.cpu0.s
<span class="go">...</span>
<span class="go">    .globl  _Z10weight_sumiiiiii</span>
<span class="go">  .align  2</span>
<span class="go">  .type _Z10weight_sumiiiiii,@function</span>
<span class="go">  .ent  _Z10weight_sumiiiiii    # @_Z10weight_sumiiiiii</span>
<span class="go">_Z10weight_sumiiiiii:</span>
<span class="go">  .frame  $fp,48,$lr</span>
<span class="go">  .mask   0x00005000,-4</span>
<span class="go">  .set  noreorder</span>
<span class="go">  .cpload $t9</span>
<span class="go">  .set  nomacro</span>
<span class="gp">#</span> BB#0:
<span class="go">  addiu $sp, $sp, -48</span>
<span class="go">  st  $lr, 44($sp)            # 4-byte Folded Spill</span>
<span class="go">  st  $fp, 40($sp)            # 4-byte Folded Spill</span>
<span class="go">  move   $fp, $sp</span>
<span class="go">  .cprestore  24</span>
<span class="go">  ld  $2, 68($fp)</span>
<span class="go">  ld  $3, 64($fp)</span>
<span class="go">  ld  $t9, 60($fp)</span>
<span class="go">  ld  $7, 56($fp)</span>
<span class="go">  st  $4, 36($fp)</span>
<span class="go">  st  $5, 32($fp)</span>
<span class="go">  st  $7, 28($fp)</span>
<span class="go">  st  $t9, 24($fp)</span>
<span class="go">  st  $3, 20($fp)</span>
<span class="go">  st  $2, 16($fp)</span>
<span class="go">  shl $2, $2, 2    // $2 = sizeof(int) * 1 * x2;</span>
<span class="go">  addiu $2, $2, 7</span>
<span class="go">  addiu $3, $zero, -8</span>
<span class="go">  and $2, $2, $3</span>
<span class="go">  addiu $sp, $sp, 0</span>
<span class="go">  subu  $2, $sp, $2</span>
<span class="go">  addu  $sp, $zero, $2  // set sp to the bottom of alloca area</span>
<span class="go">  addiu $sp, $sp, 0</span>
<span class="go">  st  $2, 12($fp)</span>
<span class="go">  st  $2, 8($fp)</span>
<span class="go">  ld  $2, 12($fp)</span>
<span class="go">  ld  $3, 28($fp)</span>
<span class="go">  st  $3, 0($2)    // *b = x3</span>
<span class="go">  ld  $5, 32($fp)</span>
<span class="go">  ld  $2, 36($fp)</span>
<span class="go">  ld  $3, 20($fp)</span>
<span class="go">  ld  $4, 28($fp)</span>
<span class="go">  ld  $t9, 24($fp)</span>
<span class="go">  ld  $7, 16($fp)</span>
<span class="go">  addiu $sp, $sp, -24</span>
<span class="go">  st  $7, 20($sp)</span>
<span class="go">  st  $t9, 12($sp)</span>
<span class="go">  st  $4, 8($sp)</span>
<span class="go">  shl $3, $3, 1</span>
<span class="go">  st  $3, 16($sp)</span>
<span class="go">  addiu $3, $zero, 3</span>
<span class="go">  mul $4, $2, $3</span>
<span class="go">  ld  $t9, %call16(_Z3sumiiiiii)($gp)</span>
<span class="go">  jalr  $t9</span>
<span class="go">  nop</span>
<span class="go">  ld  $gp, 24($fp)</span>
<span class="go">  addiu $sp, $sp, 24</span>
<span class="go">  st  $2, 4($fp)</span>
<span class="go">  ld  $3, 8($fp)</span>
<span class="go">  ld  $3, 0($3)</span>
<span class="go">  addu  $2, $2, $3</span>
<span class="go">  move   $sp, $fp</span>
<span class="go">  ld  $fp, 40($sp)            # 4-byte Folded Reload</span>
<span class="go">  ld  $lr, 44($sp)            # 4-byte Folded Reload</span>
<span class="go">  addiu $sp, $sp, 48</span>
<span class="go">  ret $lr</span>
<span class="go">  nop</span>
<span class="go">  .set  macro</span>
<span class="go">  .set  reorder</span>
<span class="go">  .end  _Z10weight_sumiiiiii</span>
<span class="gp">$</span>func_end1:
<span class="go">  .size _Z10weight_sumiiiiii, ($func_end1)-_Z10weight_sumiiiiii</span>
<span class="go">...</span>
</pre></div>
</div>
<p>As you can see, the dynamic stack allocation needs frame pointer register <strong>fp</strong>
support. As above assembly, the sp is adjusted to (sp - 48) when it
enter the function as usual by instruction <strong>addiu $sp, $sp, -48</strong>.
Next, the fp is set to sp where the position is just above alloca() spaces area
as <a class="reference internal" href="#funccall-f4"><span class="std std-numref">Fig. 26</span></a> when meets instruction <strong>move $fp, $sp</strong>.
After that, the sp is changed to the area just below of alloca().
Remind, the alloca() area where the b point to,
<strong>&#8220;*b = (int*)__builtin_alloca(sizeof(int) * 2 * x6)&#8221;</strong>, is
allocated at run time since the size of the space which depends on x1
variable and cannot be calculated at link time.</p>
<p><a class="reference internal" href="#funccall-f5"><span class="std std-numref">Fig. 27</span></a> depict how the stack pointer changes back to the
caller stack bottom. As above, the <strong>fp</strong> is set to the address just above of
alloca().
The first step is changing the sp to fp by instruction <strong>move $sp, $fp</strong>.
Next, sp is changed back to caller stack bottom by instruction
<strong>addiu $sp, $sp, 40</strong>.</p>
<div class="figure align-center" id="id20">
<span id="funccall-f4"></span><a class="reference internal image-reference" href="_images/4.png"><img alt="_images/4.png" src="_images/4.png" style="width: 267.5px; height: 139.5px;" /></a>
<p class="caption"><span class="caption-number">Fig. 26 </span><span class="caption-text">Frame pointer changes when enter function</span></p>
</div>
<div class="figure align-center" id="id21">
<span id="funccall-f5"></span><a class="reference internal image-reference" href="_images/5.png"><img alt="_images/5.png" src="_images/5.png" style="width: 264.0px; height: 132.0px;" /></a>
<p class="caption"><span class="caption-number">Fig. 27 </span><span class="caption-text">Stack pointer changes when exit function</span></p>
</div>
<div class="figure align-center" id="id22">
<span id="funccall-f6"></span><a class="reference internal image-reference" href="_images/6.png"><img alt="_images/6.png" src="_images/6.png" style="width: 269.5px; height: 197.0px;" /></a>
<p class="caption"><span class="caption-number">Fig. 28 </span><span class="caption-text">fp and sp access areas</span></p>
</div>
<p>Using fp to keep the old stack pointer value is not the only solution.
Actually, we can keep the size of alloca() spaces on a specific memory address
and the sp can be set back to the the old sp by adding the size of alloca() spaces.
Most ABI like Mips
and ARM access the above area of alloca() by fp and the below area of alloca()
by sp, as <a class="reference internal" href="#funccall-f6"><span class="std std-numref">Fig. 28</span></a> depicted. The reason for this definition
is the speed for local variable access. Since the RISC CPU use immediate offset
for load and store as below, using fp and sp for access both areas of
local variables have better performance comparing to use the sp only.</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">ld      $2, 64($fp)</span>
<span class="go">st      $3, 4($sp)</span>
</pre></div>
</div>
<p>Cpu0 uses fp and sp to access the above and below areas of alloca() too.
As ch9_3_alloc.cpu0.s, it accesses local variables (above of alloca()) by fp
offset and outgoing arguments (below of alloca()) by sp offset.</p>
<p>And more, the &#8220;move $sp, $fp&#8221; is the alias instruction of &#8220;addu $fp, $sp, $zero&#8221;.
The machine code is the latter one, and the former is only for easy understanding by
user. This alias comes from code added in Chapter3_2 and Chapter3_5 as
follows,</p>
<p class="rubric">lbdex/chapters/Chapter3_2/InstPrinter/Cpu0InstPrinter.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>void Cpu0InstPrinter::printInst(const MCInst *MI, raw_ostream &amp;O,
                                StringRef Annot, const MCSubtargetInfo &amp;STI) {
  // Try to print any aliases first.
  if (!printAliasInstr(MI, O))
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter3_5/Cpu0InstrInfo.td</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Cpu0InstAlias</span><span class="o">&lt;</span><span class="n">string</span> <span class="n">Asm</span><span class="p">,</span> <span class="n">dag</span> <span class="n">Result</span><span class="p">,</span> <span class="n">bit</span> <span class="n">Emit</span> <span class="o">=</span> <span class="mb">0b1</span><span class="o">&gt;</span> <span class="p">:</span>
  <span class="n">InstAlias</span><span class="o">&lt;</span><span class="n">Asm</span><span class="p">,</span> <span class="n">Result</span><span class="p">,</span> <span class="n">Emit</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>let Predicates = [Ch3_5] in {
//===----------------------------------------------------------------------===//
// Instruction aliases
//===----------------------------------------------------------------------===//
def : Cpu0InstAlias&lt;&quot;move $dst, $src&quot;,
                    (ADDu GPROut:$dst, GPROut:$src,ZERO), 1&gt;;
}
</pre></div>
</div>
<p>Finally the MFI-&gt;hasVarSizedObjects() defined in hasReservedCallFrame() of
Cpu0SEFrameLowering.cpp is true when it meets &#8220;%9 = alloca i8, i32 %8&#8221; of IR
which corresponding &#8220;(int*)__builtin_alloca(sizeof(int) * 1 * x1);&#8221; of C.
It will generate asm &#8220;addiu     $sp, $sp, -24&#8221; for ch9_3_alloc.cpp by calling
&#8220;adjustStackPtr()&#8221; in eliminateCallFramePseudoInstr() of Cpu0FrameLowering.cpp.</p>
<p>File ch9_3_longlongshift.cpp is for type &#8220;long long shift operations&#8221;
which can be tested now as follows.</p>
<p class="rubric">lbdex/input/ch9_3_longlongshift.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1">#include &quot;debug.h&quot;</span>

<span class="n">long</span> <span class="n">long</span> <span class="n">test_longlong_shift1</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">long</span> <span class="n">long</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
  <span class="n">long</span> <span class="n">long</span> <span class="n">b</span> <span class="o">=</span> <span class="mh">0x12</span><span class="p">;</span>
  <span class="n">long</span> <span class="n">long</span> <span class="n">c</span><span class="p">;</span>
  <span class="n">long</span> <span class="n">long</span> <span class="n">d</span><span class="p">;</span>
  
  <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">);</span>  <span class="o">//</span> <span class="n">cc</span> <span class="o">=</span> <span class="mh">0x1</span>
  <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">);</span>  <span class="o">//</span> <span class="n">cc</span> <span class="o">=</span> <span class="mh">0x120</span>

  <span class="k">return</span> <span class="p">(</span><span class="n">c</span><span class="o">+</span><span class="n">d</span><span class="p">);</span> <span class="o">//</span> <span class="mh">0x121</span> <span class="o">=</span> <span class="mi">289</span>
<span class="p">}</span>

<span class="n">long</span> <span class="n">long</span> <span class="n">test_longlong_shift2</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">long</span> <span class="n">long</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">48</span><span class="p">;</span>
  <span class="n">long</span> <span class="n">long</span> <span class="n">b</span> <span class="o">=</span> <span class="mh">0x001666660000000a</span><span class="p">;</span>
  <span class="n">long</span> <span class="n">long</span> <span class="n">c</span><span class="p">;</span>
  
  <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">c</span><span class="p">;</span> <span class="o">//</span> <span class="mi">22</span>
<span class="p">}</span>

</pre></div>
</div>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">114-37-150-209:input Jonathan$</span> clang -O0 -target mips-unknown-linux-gnu
<span class="go">-c ch9_3_longlongshift.cpp -emit-llvm -o ch9_3_longlongshift.bc</span>

<span class="gp">114-37-150-209:input Jonathan$</span> ~/llvm/test/cmake_debug_build/Debug/bin/
<span class="go">llvm-dis ch9_3_longlongshift.bc -o -</span>
<span class="go">...</span>
<span class="go">; Function Attrs: nounwind</span>
<span class="go">define i64 @_Z19test_longlong_shiftv() #0 {</span>
<span class="gp">  %</span><span class="nv">a</span> <span class="o">=</span> alloca i64, align 8
<span class="gp">  %</span><span class="nv">b</span> <span class="o">=</span> alloca i64, align 8
<span class="gp">  %</span><span class="nv">c</span> <span class="o">=</span> alloca i64, align 8
<span class="gp">  %</span><span class="nv">d</span> <span class="o">=</span> alloca i64, align 8
<span class="go">  store i64 4, i64* %a, align 8</span>
<span class="go">  store i64 18, i64* %b, align 8</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> load i64* %b, align 8
<span class="gp">  %</span><span class="nv">2</span> <span class="o">=</span> load i64* %a, align 8
<span class="gp">  %</span><span class="nv">3</span> <span class="o">=</span> ashr i64 %1, %2
<span class="go">  store i64 %3, i64* %c, align 8</span>
<span class="gp">  %</span><span class="nv">4</span> <span class="o">=</span> load i64* %b, align 8
<span class="gp">  %</span><span class="nv">5</span> <span class="o">=</span> load i64* %a, align 8
<span class="gp">  %</span><span class="nv">6</span> <span class="o">=</span> shl i64 %4, %5
<span class="go">  store i64 %6, i64* %d, align 8</span>
<span class="gp">  %</span><span class="nv">7</span> <span class="o">=</span> load i64* %c, align 8
<span class="gp">  %</span><span class="nv">8</span> <span class="o">=</span> load i64* %d, align 8
<span class="gp">  %</span><span class="nv">9</span> <span class="o">=</span> add nsw i64 %7, %8
<span class="go">  ret i64 %9</span>
<span class="go">}</span>
<span class="go">...</span>
<span class="gp">114-37-150-209:input Jonathan$</span> ~/llvm/test/cmake_debug_build/Debug/bin/llc
<span class="go">-march=cpu0 -mcpu=cpu032I -relocation-model=static -filetype=asm</span>
<span class="go">ch9_3_longlongshift.bc -o -</span>
<span class="go">  .text</span>
<span class="go">  .section .mdebug.abi32</span>
<span class="go">  .previous</span>
<span class="go">  .file &quot;ch9_3_longlongshift.bc&quot;</span>
<span class="go">  .globl  _Z20test_longlong_shift1v</span>
<span class="go">  .align  2</span>
<span class="go">  .type _Z20test_longlong_shift1v,@function</span>
<span class="go">  .ent  _Z20test_longlong_shift1v # @_Z20test_longlong_shift1v</span>
<span class="go">_Z20test_longlong_shift1v:</span>
<span class="go">  .frame  $fp,56,$lr</span>
<span class="go">  .mask   0x00005000,-4</span>
<span class="go">  .set  noreorder</span>
<span class="go">  .set  nomacro</span>
<span class="gp">#</span> BB#0:
<span class="go">  addiu $sp, $sp, -56</span>
<span class="go">  st  $lr, 52($sp)            # 4-byte Folded Spill</span>
<span class="go">  st  $fp, 48($sp)            # 4-byte Folded Spill</span>
<span class="go">  move   $fp, $sp</span>
<span class="go">  addiu $2, $zero, 4</span>
<span class="go">  st  $2, 44($fp)</span>
<span class="go">  addiu $4, $zero, 0</span>
<span class="go">  st  $4, 40($fp)</span>
<span class="go">  addiu $5, $zero, 18</span>
<span class="go">  st  $5, 36($fp)</span>
<span class="go">  st  $4, 32($fp)</span>
<span class="go">  ld  $2, 44($fp)</span>
<span class="go">  st  $2, 8($sp)</span>
<span class="go">  jsub  __lshrdi3</span>
<span class="go">  nop</span>
<span class="go">  st  $3, 28($fp)</span>
<span class="go">  st  $2, 24($fp)</span>
<span class="go">  ld  $2, 44($fp)</span>
<span class="go">  st  $2, 8($sp)</span>
<span class="go">  ld  $4, 32($fp)</span>
<span class="go">  ld  $5, 36($fp)</span>
<span class="go">  jsub  __ashldi3</span>
<span class="go">  nop</span>
<span class="go">  st  $3, 20($fp)</span>
<span class="go">  st  $2, 16($fp)</span>
<span class="go">  ld  $4, 28($fp)</span>
<span class="go">  addu  $4, $4, $3</span>
<span class="go">  cmp $sw, $4, $3</span>
<span class="go">  andi  $3, $sw, 1</span>
<span class="go">  addu  $2, $3, $2</span>
<span class="go">  ld  $3, 24($fp)</span>
<span class="go">  addu  $2, $3, $2</span>
<span class="go">  addu  $3, $zero, $4</span>
<span class="go">  move   $sp, $fp</span>
<span class="go">  ld  $fp, 48($sp)            # 4-byte Folded Reload</span>
<span class="go">  ld  $lr, 52($sp)            # 4-byte Folded Reload</span>
<span class="go">  addiu $sp, $sp, 56</span>
<span class="go">  ret $lr</span>
<span class="go">  nop</span>
<span class="go">  .set  macro</span>
<span class="go">  .set  reorder</span>
<span class="go">  .end  _Z20test_longlong_shift1v</span>
<span class="gp">$</span>tmp0:
<span class="go">  .size _Z20test_longlong_shift1v, ($tmp0)-_Z20test_longlong_shift1v</span>

<span class="go">  .globl  _Z20test_longlong_shift2v</span>
<span class="go">  .align  2</span>
<span class="go">  .type _Z20test_longlong_shift2v,@function</span>
<span class="go">  .ent  _Z20test_longlong_shift2v # @_Z20test_longlong_shift2v</span>
<span class="go">_Z20test_longlong_shift2v:</span>
<span class="go">  .frame  $fp,48,$lr</span>
<span class="go">  .mask   0x00005000,-4</span>
<span class="go">  .set  noreorder</span>
<span class="go">  .set  nomacro</span>
<span class="gp">#</span> BB#0:
<span class="go">  addiu $sp, $sp, -48</span>
<span class="go">  st  $lr, 44($sp)            # 4-byte Folded Spill</span>
<span class="go">  st  $fp, 40($sp)            # 4-byte Folded Spill</span>
<span class="go">  move   $fp, $sp</span>
<span class="go">  addiu $2, $zero, 48</span>
<span class="go">  st  $2, 36($fp)</span>
<span class="go">  addiu $2, $zero, 0</span>
<span class="go">  st  $2, 32($fp)</span>
<span class="go">  addiu $5, $zero, 10</span>
<span class="go">  st  $5, 28($fp)</span>
<span class="go">  lui $2, 22</span>
<span class="go">  ori $4, $2, 26214</span>
<span class="go">  st  $4, 24($fp)</span>
<span class="go">  ld  $2, 36($fp)</span>
<span class="go">  st  $2, 8($sp)</span>
<span class="go">  jsub  __lshrdi3</span>
<span class="go">  nop</span>
<span class="go">  st  $3, 20($fp)</span>
<span class="go">  st  $2, 16($fp)</span>
<span class="go">  move   $sp, $fp</span>
<span class="go">  ld  $fp, 40($sp)            # 4-byte Folded Reload</span>
<span class="go">  ld  $lr, 44($sp)            # 4-byte Folded Reload</span>
<span class="go">  addiu $sp, $sp, 48</span>
<span class="go">  ret $lr</span>
<span class="go">  nop</span>
<span class="go">  .set  macro</span>
<span class="go">  .set  reorder</span>
<span class="go">  .end  _Z20test_longlong_shift2v</span>
<span class="gp">$</span>tmp1:
<span class="go">  .size _Z20test_longlong_shift2v, ($tmp1)-_Z20test_longlong_shift2v</span>
</pre></div>
</div>
</div>
<div class="section" id="variable-sized-array-support">
<h3><a class="toc-backref" href="#id39">Variable sized array support</a><a class="headerlink" href="#variable-sized-array-support" title="Permalink to this headline">¶</a></h3>
<p>LLVM supports variable sized arrays in C99 <a class="footnote-reference" href="#stacksave" id="id11">[9]</a>. The following code
added for this support. Set them to expand, meaning llvm uses other DAGs
replace them.</p>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0ISelLowering.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="p">::</span>
<span class="n">LowerOperation</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span>
<span class="p">{</span>
  <span class="n">switch</span> <span class="p">(</span><span class="n">Op</span><span class="o">.</span><span class="n">getOpcode</span><span class="p">())</span>
  <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="o">//</span> <span class="n">Use</span> <span class="n">the</span> <span class="n">default</span> <span class="k">for</span> <span class="n">now</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">STACKSAVE</span><span class="p">,</span>         <span class="n">MVT</span><span class="p">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">STACKRESTORE</span><span class="p">,</span>      <span class="n">MVT</span><span class="p">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>    <span class="p">...</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/input/ch9_3_stacksave.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">test_stacksaverestore</span><span class="p">(</span><span class="n">unsigned</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">//</span> <span class="n">CHECK</span><span class="p">:</span> <span class="n">call</span> <span class="n">i8</span><span class="o">*</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">stacksave</span><span class="p">()</span>
  <span class="n">char</span> <span class="n">s1</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
  <span class="n">s1</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="n">s1</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
  <span class="o">//</span> <span class="n">CHECK</span><span class="p">:</span> <span class="n">call</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">stackrestore</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$</span> clang -target mips-unknown-linux-gnu -c
<span class="go">ch9_3_stacksave.cpp -emit-llvm -o ch9_3_stacksave.bc</span>
<span class="gp">JonathantekiiMac:input Jonathan$</span> llvm-dis ch9_3_stacksave.bc -o -

<span class="go">define i32 @_Z21test_stacksaverestorej(i32 zeroext %x) #0 {</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> alloca i32, align 4
<span class="gp">  %</span><span class="nv">2</span> <span class="o">=</span> alloca i8*
<span class="gp">  %</span><span class="nv">3</span> <span class="o">=</span> alloca i32
<span class="go">  store i32 %x, i32* %1, align 4</span>
<span class="gp">  %</span><span class="nv">4</span> <span class="o">=</span> load i32, i32* %1, align 4
<span class="gp">  %</span><span class="nv">5</span> <span class="o">=</span> call i8* @llvm.stacksave<span class="o">()</span>
<span class="go">  store i8* %5, i8** %2</span>
<span class="gp">  %</span><span class="nv">6</span> <span class="o">=</span> alloca i8, i32 %4, align 1
<span class="gp">  %</span><span class="nv">7</span> <span class="o">=</span> load i32, i32* %1, align 4
<span class="gp">  %</span><span class="nv">8</span> <span class="o">=</span> getelementptr inbounds i8, i8* %6, i32 %7
<span class="go">  store i8 5, i8* %8, align 1</span>
<span class="gp">  %</span><span class="nv">9</span> <span class="o">=</span> load i32, i32* %1, align 4
<span class="gp">  %</span><span class="nv">10</span> <span class="o">=</span> getelementptr inbounds i8, i8* %6, i32 %9
<span class="gp">  %</span><span class="nv">11</span> <span class="o">=</span> load i8, i8* %10, align 1
<span class="gp">  %</span><span class="nv">12</span> <span class="o">=</span> sext i8 %11 to i32
<span class="go">  store i32 1, i32* %3</span>
<span class="gp">  %</span><span class="nv">13</span> <span class="o">=</span> load i8*, i8** %2
<span class="go">  call void @llvm.stackrestore(i8* %13)</span>
<span class="go">  ret i32 %12</span>
<span class="go">}</span>

<span class="gp">JonathantekiiMac:input Jonathan$</span> ~/llvm/test/cmake_debug_build/Debug/bin/llc
<span class="go">-march=cpu0 -mcpu=cpu032I -relocation-model=static -filetype=asm</span>
<span class="go">ch9_3_stacksave.bc -o -</span>
<span class="go">...</span>
</pre></div>
</div>
</div>
<div class="section" id="function-related-intrinsics-support">
<h3><a class="toc-backref" href="#id40">Function related Intrinsics support</a><a class="headerlink" href="#function-related-intrinsics-support" title="Permalink to this headline">¶</a></h3>
<p>I think these llvm instinsic IRs are for the implementation of exception handle
<a class="footnote-reference" href="#excepthandle" id="id12">[10]</a> [#returnaddr]. With these IRs, programmer can record the
frame address and return address to be used in implementing program of
exception handler by C++ as the example below. In order to support these llvm
intrinsic IRs, the following code added to Cpu0 backend.</p>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0ISelLowering.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="n">const</span> <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">,</span>
                                       <span class="n">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span>
    <span class="p">:</span> <span class="n">TargetLowering</span><span class="p">(</span><span class="n">TM</span><span class="p">),</span> <span class="n">Subtarget</span><span class="p">(</span><span class="n">STI</span><span class="p">),</span> <span class="n">ABI</span><span class="p">(</span><span class="n">TM</span><span class="o">.</span><span class="n">getABI</span><span class="p">())</span> <span class="p">{</span>

</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">EH_RETURN</span><span class="p">,</span> <span class="n">MVT</span><span class="p">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Custom</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">ADD</span><span class="p">,</span>                <span class="n">MVT</span><span class="p">::</span><span class="n">i32</span><span class="p">,</span>   <span class="n">Custom</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="p">::</span>
<span class="n">LowerOperation</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span>
<span class="p">{</span>
  <span class="n">switch</span> <span class="p">(</span><span class="n">Op</span><span class="o">.</span><span class="n">getOpcode</span><span class="p">())</span>
  <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="n">case</span> <span class="n">ISD</span><span class="p">::</span><span class="n">FRAMEADDR</span><span class="p">:</span>          <span class="k">return</span> <span class="n">lowerFRAMEADDR</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">);</span>
  <span class="n">case</span> <span class="n">ISD</span><span class="p">::</span><span class="n">RETURNADDR</span><span class="p">:</span>         <span class="k">return</span> <span class="n">lowerRETURNADDR</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">);</span>
  <span class="n">case</span> <span class="n">ISD</span><span class="p">::</span><span class="n">EH_RETURN</span><span class="p">:</span>          <span class="k">return</span> <span class="n">lowerEH_RETURN</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">);</span>
  <span class="n">case</span> <span class="n">ISD</span><span class="p">::</span><span class="n">ADD</span><span class="p">:</span>                <span class="k">return</span> <span class="n">lowerADD</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>    <span class="p">...</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="p">::</span>
<span class="n">lowerFRAMEADDR</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="o">//</span> <span class="n">check</span> <span class="n">the</span> <span class="n">depth</span>
  <span class="k">assert</span><span class="p">((</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">ConstantSDNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Op</span><span class="o">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">getZExtValue</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
         <span class="s2">&quot;Frame address can only be determined for current frame.&quot;</span><span class="p">);</span>

  <span class="n">MachineFrameInfo</span> <span class="o">*</span><span class="n">MFI</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getMachineFunction</span><span class="p">()</span><span class="o">.</span><span class="n">getFrameInfo</span><span class="p">();</span>
  <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">setFrameAddressIsTaken</span><span class="p">(</span><span class="n">true</span><span class="p">);</span>
  <span class="n">EVT</span> <span class="n">VT</span> <span class="o">=</span> <span class="n">Op</span><span class="o">.</span><span class="n">getValueType</span><span class="p">();</span>
  <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">(</span><span class="n">Op</span><span class="p">);</span>
  <span class="n">SDValue</span> <span class="n">FrameAddr</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getCopyFromReg</span><span class="p">(</span>
      <span class="n">DAG</span><span class="o">.</span><span class="n">getEntryNode</span><span class="p">(),</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">FP</span><span class="p">,</span> <span class="n">VT</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">FrameAddr</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">lowerRETURNADDR</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span>
                                            <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">verifyReturnAddressArgumentIsConstant</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">SDValue</span><span class="p">();</span>

  <span class="o">//</span> <span class="n">check</span> <span class="n">the</span> <span class="n">depth</span>
  <span class="k">assert</span><span class="p">((</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">ConstantSDNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Op</span><span class="o">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">getZExtValue</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
         <span class="s2">&quot;Return address can be determined only for current frame.&quot;</span><span class="p">);</span>

  <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getMachineFunction</span><span class="p">();</span>
  <span class="n">MachineFrameInfo</span> <span class="o">*</span><span class="n">MFI</span> <span class="o">=</span> <span class="n">MF</span><span class="o">.</span><span class="n">getFrameInfo</span><span class="p">();</span>
  <span class="n">MVT</span> <span class="n">VT</span> <span class="o">=</span> <span class="n">Op</span><span class="o">.</span><span class="n">getSimpleValueType</span><span class="p">();</span>
  <span class="n">unsigned</span> <span class="n">LR</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">LR</span><span class="p">;</span>
  <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">setReturnAddressIsTaken</span><span class="p">(</span><span class="n">true</span><span class="p">);</span>

  <span class="o">//</span> <span class="n">Return</span> <span class="n">LR</span><span class="p">,</span> <span class="n">which</span> <span class="n">contains</span> <span class="n">the</span> <span class="k">return</span> <span class="n">address</span><span class="o">.</span> <span class="n">Mark</span> <span class="n">it</span> <span class="n">an</span> <span class="n">implicit</span> <span class="n">live</span><span class="o">-</span><span class="ow">in</span><span class="o">.</span>
  <span class="n">unsigned</span> <span class="n">Reg</span> <span class="o">=</span> <span class="n">MF</span><span class="o">.</span><span class="n">addLiveIn</span><span class="p">(</span><span class="n">LR</span><span class="p">,</span> <span class="n">getRegClassFor</span><span class="p">(</span><span class="n">VT</span><span class="p">));</span>
  <span class="k">return</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getCopyFromReg</span><span class="p">(</span><span class="n">DAG</span><span class="o">.</span><span class="n">getEntryNode</span><span class="p">(),</span> <span class="n">SDLoc</span><span class="p">(</span><span class="n">Op</span><span class="p">),</span> <span class="n">Reg</span><span class="p">,</span> <span class="n">VT</span><span class="p">);</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">An</span> <span class="n">EH_RETURN</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">result</span> <span class="n">of</span> <span class="n">lowering</span> <span class="n">llvm</span><span class="o">.</span><span class="n">eh</span><span class="o">.</span><span class="k">return</span> <span class="n">which</span> <span class="ow">in</span> <span class="n">turn</span> <span class="ow">is</span>
<span class="o">//</span> <span class="n">generated</span> <span class="kn">from</span> <span class="nn">__builtin_eh_return</span> <span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">handler</span><span class="p">)</span>
<span class="o">//</span> <span class="n">The</span> <span class="n">effect</span> <span class="n">of</span> <span class="n">this</span> <span class="ow">is</span> <span class="n">to</span> <span class="n">adjust</span> <span class="n">the</span> <span class="n">stack</span> <span class="n">pointer</span> <span class="n">by</span> <span class="s2">&quot;offset&quot;</span>
<span class="o">//</span> <span class="ow">and</span> <span class="n">then</span> <span class="n">branch</span> <span class="n">to</span> <span class="s2">&quot;handler&quot;</span><span class="o">.</span>
<span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">lowerEH_RETURN</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span>
                                                                     <span class="n">const</span> <span class="p">{</span>
  <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getMachineFunction</span><span class="p">();</span>
  <span class="n">Cpu0FunctionInfo</span> <span class="o">*</span><span class="n">Cpu0FI</span> <span class="o">=</span> <span class="n">MF</span><span class="o">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">setCallsEhReturn</span><span class="p">();</span>
  <span class="n">SDValue</span> <span class="n">Chain</span>     <span class="o">=</span> <span class="n">Op</span><span class="o">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">SDValue</span> <span class="n">Offset</span>    <span class="o">=</span> <span class="n">Op</span><span class="o">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">SDValue</span> <span class="n">Handler</span>   <span class="o">=</span> <span class="n">Op</span><span class="o">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">(</span><span class="n">Op</span><span class="p">);</span>
  <span class="n">EVT</span> <span class="n">Ty</span> <span class="o">=</span> <span class="n">MVT</span><span class="p">::</span><span class="n">i32</span><span class="p">;</span>

  <span class="o">//</span> <span class="n">Store</span> <span class="n">stack</span> <span class="n">offset</span> <span class="ow">in</span> <span class="n">V1</span><span class="p">,</span> <span class="n">store</span> <span class="n">jump</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">V0</span><span class="o">.</span> <span class="n">Glue</span> <span class="n">CopyToReg</span> <span class="ow">and</span>
  <span class="o">//</span> <span class="n">EH_RETURN</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">so</span> <span class="n">that</span> <span class="n">instructions</span> <span class="n">are</span> <span class="n">emitted</span> <span class="n">back</span><span class="o">-</span><span class="n">to</span><span class="o">-</span><span class="n">back</span><span class="o">.</span>
  <span class="n">unsigned</span> <span class="n">OffsetReg</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">V1</span><span class="p">;</span>
  <span class="n">unsigned</span> <span class="n">AddrReg</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">V0</span><span class="p">;</span>
  <span class="n">Chain</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getCopyToReg</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">OffsetReg</span><span class="p">,</span> <span class="n">Offset</span><span class="p">,</span> <span class="n">SDValue</span><span class="p">());</span>
  <span class="n">Chain</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getCopyToReg</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">AddrReg</span><span class="p">,</span> <span class="n">Handler</span><span class="p">,</span> <span class="n">Chain</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
  <span class="k">return</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">Cpu0ISD</span><span class="p">::</span><span class="n">EH_RETURN</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">MVT</span><span class="p">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Chain</span><span class="p">,</span>
                     <span class="n">DAG</span><span class="o">.</span><span class="n">getRegister</span><span class="p">(</span><span class="n">OffsetReg</span><span class="p">,</span> <span class="n">Ty</span><span class="p">),</span>
                     <span class="n">DAG</span><span class="o">.</span><span class="n">getRegister</span><span class="p">(</span><span class="n">AddrReg</span><span class="p">,</span> <span class="n">getPointerTy</span><span class="p">(</span><span class="n">MF</span><span class="o">.</span><span class="n">getDataLayout</span><span class="p">())),</span>
                     <span class="n">Chain</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">lowerADD</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Op</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">getOpcode</span><span class="p">()</span> <span class="o">!=</span> <span class="n">ISD</span><span class="p">::</span><span class="n">FRAMEADDR</span>
      <span class="o">||</span> <span class="n">cast</span><span class="o">&lt;</span><span class="n">ConstantSDNode</span><span class="o">&gt;</span>
        <span class="p">(</span><span class="n">Op</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">getZExtValue</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span>
      <span class="o">||</span> <span class="n">Op</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">getOpcode</span><span class="p">()</span> <span class="o">!=</span> <span class="n">ISD</span><span class="p">::</span><span class="n">FRAME_TO_ARGS_OFFSET</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">SDValue</span><span class="p">();</span>

  <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getMachineFunction</span><span class="p">();</span>
  <span class="n">Cpu0FunctionInfo</span> <span class="o">*</span><span class="n">Cpu0FI</span> <span class="o">=</span> <span class="n">MF</span><span class="o">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">setCallsEhDwarf</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">Op</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="frameaddress-and-returnaddress-intrinsics">
<h4><a class="toc-backref" href="#id41">frameaddress and returnaddress intrinsics</a><a class="headerlink" href="#frameaddress-and-returnaddress-intrinsics" title="Permalink to this headline">¶</a></h4>
<p>Run with the following input to get the following result.</p>
<p class="rubric">lbdex/input/ch9_3_frame_return_addr.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">display_frameaddress</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="n">__builtin_frame_address</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">extern</span> <span class="nb">int</span> <span class="n">fn</span><span class="p">();</span>

<span class="nb">int</span> <span class="n">display_returnaddress</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">fn</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$</span> ~/llvm/test/cmake_debug_build/Debug/bin/
<span class="go">llvm-dis ch9_3_frame_return_addr.bc -o -</span>
<span class="go">...</span>
<span class="go">; Function Attrs: nounwind</span>
<span class="go">define i32 @_Z20display_frameaddressv() #0 {</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> call i8* @llvm.frameaddress<span class="o">(</span>i32 0<span class="o">)</span>
<span class="gp">  %</span><span class="nv">2</span> <span class="o">=</span> ptrtoint i8* %1 to i32
<span class="go">  ret i32 %2</span>
<span class="go">}</span>

<span class="go">; Function Attrs: nounwind readnone</span>
<span class="go">declare i8* @llvm.frameaddress(i32) #1</span>

<span class="go">define i32 @_Z22display_returnaddressv() #2 {</span>
<span class="gp">  %</span><span class="nv">a</span> <span class="o">=</span> alloca i32, align 4
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> call i8* @llvm.returnaddress<span class="o">(</span>i32 0<span class="o">)</span>
<span class="gp">  %</span><span class="nv">2</span> <span class="o">=</span> ptrtoint i8* %1 to i32
<span class="go">  store i32 %2, i32* %a, align 4</span>
<span class="gp">  %</span><span class="nv">3</span> <span class="o">=</span> call i32 @_Z2fnv<span class="o">()</span>
<span class="gp">  %</span><span class="nv">4</span> <span class="o">=</span> load i32, i32* %a, align 4
<span class="go">  ret i32 %4</span>
<span class="go">}</span>

<span class="gp">JonathantekiiMac:input Jonathan$</span> ~/llvm/test/cmake_debug_build/Debug/bin/llc
<span class="go">-march=cpu0 -relocation-model=static -filetype=asm ch9_3_frame_return_addr.bc</span>
<span class="go">-o -</span>
<span class="go">      .text</span>
<span class="go">      .section .mdebug.abiO32</span>
<span class="go">      .previous</span>
<span class="go">      .file &quot;ch9_3_frame_return_addr.bc&quot;</span>
<span class="go">      .globl  _Z20display_frameaddressv</span>
<span class="go">      .align  2</span>
<span class="go">      .type _Z20display_frameaddressv,@function</span>
<span class="go">      .ent    _Z20display_frameaddressv # @_Z20display_frameaddressv</span>
<span class="go">_Z20display_frameaddressv:</span>
<span class="go">      .frame  $fp,8,$lr</span>
<span class="go">      .mask           0x00001000,-4</span>
<span class="go">      .set    noreorder</span>
<span class="go">      .set    nomacro</span>
<span class="gp">#</span> BB#0:
<span class="go">      addiu $sp, $sp, -8</span>
<span class="go">      st      $fp, 4($sp)                                                     # 4-byte Folded Spill</span>
<span class="go">      move     $fp, $sp</span>
<span class="go">      addu    $2, $zero, $fp</span>
<span class="go">      move     $sp, $fp</span>
<span class="go">      ld      $fp, 4($sp)                                                     # 4-byte Folded Reload</span>
<span class="go">      addiu $sp, $sp, 8</span>
<span class="go">      ret $lr</span>
<span class="go">      nop</span>
<span class="go">      .set    macro</span>
<span class="go">      .set    reorder</span>
<span class="go">      .end    _Z20display_frameaddressv</span>
<span class="gp">$</span>func_end0:
<span class="go">      .size _Z20display_frameaddressv, ($func_end0)-_Z20display_frameaddressv</span>

<span class="go">      .globl  _Z22display_returnaddress1v</span>
<span class="go">      .align  2</span>
<span class="go">      .type _Z22display_returnaddress1v,@function</span>
<span class="go">      .ent    _Z22display_returnaddress1v # @_Z22display_returnaddress1v</span>
<span class="go">_Z22display_returnaddress1v:</span>
<span class="go">      .cfi_startproc</span>
<span class="go">      .frame  $fp,24,$lr</span>
<span class="go">      .mask           0x00005000,-4</span>
<span class="go">      .set    noreorder</span>
<span class="go">      .set    nomacro</span>
<span class="gp">#</span> BB#0:
<span class="go">      addiu $sp, $sp, -24</span>
<span class="gp">$</span>tmp0:
<span class="go">      .cfi_def_cfa_offset 24</span>
<span class="go">      st      $lr, 20($sp)                                            # 4-byte Folded Spill</span>
<span class="go">      st      $fp, 16($sp)                                            # 4-byte Folded Spill</span>
<span class="gp">$</span>tmp1:
<span class="go">      .cfi_offset 14, -4</span>
<span class="gp">$</span>tmp2:
<span class="go">      .cfi_offset 12, -8</span>
<span class="go">      move     $fp, $sp</span>
<span class="gp">$</span>tmp3:
<span class="go">      .cfi_def_cfa_register 12</span>
<span class="go">      st      $lr, 12($fp)</span>
<span class="go">      jsub    _Z2fnv</span>
<span class="go">      nop</span>
<span class="go">      ld      $2, 12($fp)</span>
<span class="go">      move     $sp, $fp</span>
<span class="go">      ld      $fp, 16($sp)                                            # 4-byte Folded Reload</span>
<span class="go">      ld      $lr, 20($sp)                                            # 4-byte Folded Reload</span>
<span class="go">      addiu $sp, $sp, 24</span>
<span class="go">      ret $lr</span>
<span class="go">      nop</span>
<span class="go">      .set    macro</span>
<span class="go">      .set    reorder</span>
<span class="go">      .end    _Z22display_returnaddress1v</span>
<span class="gp">$</span>func_end1:
<span class="go">      .size _Z22display_returnaddress1v, ($func_end1)-_Z22display_returnaddress1v</span>
<span class="go">      .cfi_endproc</span>
</pre></div>
</div>
<p>The asm &#8220;ld     $2, 12($fp)&#8221; in function _Z22display_returnaddress1v reloads $lr
to $2 after &#8220;jsub _Z3fnv&#8221;. The reason that Cpu0 doesn&#8217;t produce
&#8220;addiu $2, $zero, $lr&#8221; is if a bug program in _Z3fnv changes $lr value without
following ABI then it will get the wrong $lr to $2.
The following code kills $lr register and make the reference to $lr by
loading from stack slot rather than uses register directly.</p>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0SEFrameLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">Cpu0SEFrameLowering</span><span class="o">::</span>
<span class="n">spillCalleeSavedRegisters</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span>
                          <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">MI</span><span class="p">,</span>
                          <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">CalleeSavedInfo</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">CSI</span><span class="p">,</span>
                          <span class="k">const</span> <span class="n">TargetRegisterInfo</span> <span class="o">*</span><span class="n">TRI</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">CSI</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Add the callee-saved register as live-in. Do not add if the register is</span>
    <span class="c1">// LR and return address is taken, because it has already been added in</span>
    <span class="c1">// method Cpu0TargetLowering::LowerRETURNADDR.</span>
    <span class="c1">// It&#39;s killed at the spill, unless the register is LR and return address</span>
    <span class="c1">// is taken.</span>
    <span class="kt">unsigned</span> <span class="n">Reg</span> <span class="o">=</span> <span class="n">CSI</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getReg</span><span class="p">();</span>
    <span class="kt">bool</span> <span class="n">IsRAAndRetAddrIsTaken</span> <span class="o">=</span> <span class="p">(</span><span class="n">Reg</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">LR</span><span class="p">)</span>
        <span class="o">&amp;&amp;</span> <span class="n">MF</span><span class="o">-&gt;</span><span class="n">getFrameInfo</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">isReturnAddressTaken</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IsRAAndRetAddrIsTaken</span><span class="p">)</span>
      <span class="n">EntryBlock</span><span class="o">-&gt;</span><span class="n">addLiveIn</span><span class="p">(</span><span class="n">Reg</span><span class="p">);</span>

    <span class="c1">// Insert the spill to the stack frame.</span>
    <span class="kt">bool</span> <span class="n">IsKill</span> <span class="o">=</span> <span class="o">!</span><span class="n">IsRAAndRetAddrIsTaken</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span><span class="n">RC</span> <span class="o">=</span> <span class="n">TRI</span><span class="o">-&gt;</span><span class="n">getMinimalPhysRegClass</span><span class="p">(</span><span class="n">Reg</span><span class="p">);</span>
    <span class="n">TII</span><span class="p">.</span><span class="n">storeRegToStackSlot</span><span class="p">(</span><span class="o">*</span><span class="n">EntryBlock</span><span class="p">,</span> <span class="n">MI</span><span class="p">,</span> <span class="n">Reg</span><span class="p">,</span> <span class="n">IsKill</span><span class="p">,</span>
                            <span class="n">CSI</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getFrameIdx</span><span class="p">(),</span> <span class="n">RC</span><span class="p">,</span> <span class="n">TRI</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="eh-return-intrinsic">
<h4><a class="toc-backref" href="#id42">eh.return intrinsic</a><a class="headerlink" href="#eh-return-intrinsic" title="Permalink to this headline">¶</a></h4>
<p>Beside lowerRETURNADDR() in Cpu0ISelLowering, the following code is for
eh.return supporting only, and it can run with input ch9_3_detect_exception.cpp
as below.</p>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0SEFrameLowering.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">Cpu0SEFrameLowering</span><span class="p">::</span><span class="n">emitPrologue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                       <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  if (Cpu0FI-&gt;callsEhReturn()) {
    // Insert instructions that spill eh data registers.
    for (int I = 0; I &lt; ABI.EhDataRegSize(); ++I) {
      if (!MBB.isLiveIn(ABI.GetEhDataReg(I)))
        MBB.addLiveIn(ABI.GetEhDataReg(I));
      TII.storeRegToStackSlot(MBB, MBBI, ABI.GetEhDataReg(I), false,
                              Cpu0FI-&gt;getEhDataRegFI(I), RC, &amp;RegInfo);
    }

    // Emit .cfi_offset directives for eh data registers.
    for (int I = 0; I &lt; ABI.EhDataRegSize(); ++I) {
      int64_t Offset = MFI-&gt;getObjectOffset(Cpu0FI-&gt;getEhDataRegFI(I));
      unsigned Reg = MRI-&gt;getDwarfRegNum(ABI.GetEhDataReg(I), true);
      unsigned CFIIndex = MMI.addFrameInst(
          MCCFIInstruction::createOffset(nullptr, Reg, Offset));
      BuildMI(MBB, MBBI, dl, TII.get(TargetOpcode::CFI_INSTRUCTION))
          .addCFIIndex(CFIIndex);
    }
  }
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">Cpu0SEFrameLowering</span><span class="p">::</span><span class="n">emitEpilogue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                 <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">callsEhReturn</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span><span class="n">RC</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Cpu0</span><span class="p">::</span><span class="n">GPROutRegClass</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Find</span> <span class="n">first</span> <span class="n">instruction</span> <span class="n">that</span> <span class="n">restores</span> <span class="n">a</span> <span class="n">callee</span><span class="o">-</span><span class="n">saved</span> <span class="n">register</span><span class="o">.</span>
    <span class="n">MachineBasicBlock</span><span class="p">::</span><span class="n">iterator</span> <span class="n">I</span> <span class="o">=</span> <span class="n">MBBI</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">getCalleeSavedInfo</span><span class="p">()</span><span class="o">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
      <span class="o">--</span><span class="n">I</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Insert</span> <span class="n">instructions</span> <span class="n">that</span> <span class="n">restore</span> <span class="n">eh</span> <span class="n">data</span> <span class="n">registers</span><span class="o">.</span>
    <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">J</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">J</span> <span class="o">&lt;</span> <span class="n">ABI</span><span class="o">.</span><span class="n">EhDataRegSize</span><span class="p">();</span> <span class="o">++</span><span class="n">J</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">TII</span><span class="o">.</span><span class="n">loadRegFromStackSlot</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">ABI</span><span class="o">.</span><span class="n">GetEhDataReg</span><span class="p">(</span><span class="n">J</span><span class="p">),</span>
                               <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getEhDataRegFI</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="n">RC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">RegInfo</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">This</span> <span class="n">method</span> <span class="ow">is</span> <span class="n">called</span> <span class="n">immediately</span> <span class="n">before</span> <span class="n">PrologEpilogInserter</span> <span class="n">scans</span> <span class="n">the</span> 
<span class="o">//</span>  <span class="n">physical</span> <span class="n">registers</span> <span class="n">used</span> <span class="n">to</span> <span class="n">determine</span> <span class="n">what</span> <span class="n">callee</span> <span class="n">saved</span> <span class="n">registers</span> <span class="n">should</span> <span class="n">be</span> 
<span class="o">//</span>  <span class="n">spilled</span><span class="o">.</span> <span class="n">This</span> <span class="n">method</span> <span class="ow">is</span> <span class="n">optional</span><span class="o">.</span> 
<span class="n">void</span> <span class="n">Cpu0SEFrameLowering</span><span class="p">::</span><span class="n">determineCalleeSaves</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                               <span class="n">BitVector</span> <span class="o">&amp;</span><span class="n">SavedRegs</span><span class="p">,</span>
                                               <span class="n">RegScavenger</span> <span class="o">*</span><span class="n">RS</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="o">//</span> <span class="n">Create</span> <span class="n">spill</span> <span class="n">slots</span> <span class="k">for</span> <span class="n">eh</span> <span class="n">data</span> <span class="n">registers</span> <span class="k">if</span> <span class="n">function</span> <span class="n">calls</span> <span class="n">eh_return</span><span class="o">.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">callsEhReturn</span><span class="p">())</span>
    <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">createEhDataRegsFI</span><span class="p">();</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0InstrInfo.td</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>// Exception handling related node and instructions.
// The conversion sequence is:
// ISD::EH_RETURN -&gt; Cpu0ISD::EH_RETURN -&gt;
// CPU0eh_return -&gt; (stack change + indirect branch)
//
// CPU0eh_return takes the place of regular return instruction
// but takes two arguments (V1, V0) which are used for storing
// the offset and return address respectively.
def SDT_Cpu0EHRET : SDTypeProfile&lt;0, 2, [SDTCisInt&lt;0&gt;, SDTCisPtrTy&lt;1&gt;]&gt;;

def CPU0ehret : SDNode&lt;&quot;Cpu0ISD::EH_RETURN&quot;, SDT_Cpu0EHRET,
                      [SDNPHasChain, SDNPOptInGlue, SDNPVariadic]&gt;;

let Uses = [V0, V1], isTerminator = 1, isReturn = 1, isBarrier = 1 in {
  def CPU0eh_return32 : Cpu0Pseudo&lt;(outs), (ins GPROut:$spoff, GPROut:$dst), &quot;&quot;,
                                [(CPU0ehret GPROut:$spoff, GPROut:$dst)]&gt;;
}
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0SEInstrInfo.h</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="n">void</span> <span class="n">expandEhReturn</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span>
                      <span class="n">MachineBasicBlock</span><span class="p">::</span><span class="n">iterator</span> <span class="n">I</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0SEInstrInfo.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">///</span> <span class="n">Expand</span> <span class="n">Pseudo</span> <span class="n">instructions</span> <span class="n">into</span> <span class="n">real</span> <span class="n">backend</span> <span class="n">instructions</span>
<span class="nb">bool</span> <span class="n">Cpu0SEInstrInfo</span><span class="p">::</span><span class="n">expandPostRAPseudo</span><span class="p">(</span><span class="n">MachineInstr</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="n">case</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">CPU0eh_return32</span><span class="p">:</span>
    <span class="n">expandEhReturn</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MI</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>void Cpu0SEInstrInfo::expandEhReturn(MachineBasicBlock &amp;MBB,
                                     MachineBasicBlock::iterator I) const {
  // This pseudo instruction is generated as part of the lowering of
  // ISD::EH_RETURN. We convert it to a stack increment by OffsetReg, and
  // indirect jump to TargetReg
  unsigned ADDU = Cpu0::ADDu;
  unsigned SP = Cpu0::SP;
  unsigned LR = Cpu0::LR;
  unsigned T9 = Cpu0::T9;
  unsigned ZERO = Cpu0::ZERO;
  unsigned OffsetReg = I-&gt;getOperand(0).getReg();
  unsigned TargetReg = I-&gt;getOperand(1).getReg();

  // addu $lr, $v0, $zero
  // addu $sp, $sp, $v1
  // jr   $lr (via RetLR)
  const TargetMachine &amp;TM = MBB.getParent()-&gt;getTarget();
  if (TM.isPositionIndependent())
    BuildMI(MBB, I, I-&gt;getDebugLoc(), get(ADDU), T9)
        .addReg(TargetReg)
        .addReg(ZERO);
  BuildMI(MBB, I, I-&gt;getDebugLoc(), get(ADDU), LR)
      .addReg(TargetReg)
      .addReg(ZERO);
  BuildMI(MBB, I, I-&gt;getDebugLoc(), get(ADDU), SP).addReg(SP).addReg(OffsetReg);
  expandRetLR(MBB, I);
}
</pre></div>
</div>
<p class="rubric">lbdex/input/ch9_3_detect_exception.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">bool</span> <span class="n">exceptionOccur</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
<span class="n">void</span><span class="o">*</span> <span class="n">returnAddr</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Even</span> <span class="n">though</span> <span class="n">__builtin_frame_address</span> <span class="ow">is</span> <span class="n">useless</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">example</span><span class="p">,</span> <span class="n">I</span> <span class="n">believe</span>
<span class="o">//</span> <span class="n">it</span> <span class="n">will</span> <span class="n">be</span> <span class="n">used</span> <span class="ow">in</span> <span class="n">real</span> <span class="n">exception</span> <span class="n">handler</span> <span class="n">implementation</span><span class="o">.</span> <span class="n">Because</span> <span class="ow">in</span> <span class="n">real</span>
<span class="o">//</span> <span class="n">implementation</span><span class="p">,</span> <span class="n">the</span> <span class="n">exception</span> <span class="n">handler</span> <span class="n">keeps</span> <span class="n">a</span> <span class="n">table</span> <span class="ow">and</span> <span class="n">decide</span> <span class="n">which</span> <span class="n">function</span>
<span class="o">//</span> <span class="n">should</span> <span class="n">be</span> <span class="n">triggered</span> <span class="k">for</span> <span class="n">a</span> <span class="n">specific</span> <span class="n">exception</span> <span class="ow">and</span> <span class="n">hand</span> <span class="n">over</span> <span class="n">to</span> <span class="n">it</span><span class="o">.</span>
<span class="o">//</span> <span class="n">The</span> <span class="n">hand</span> <span class="n">over</span> <span class="n">process</span> <span class="n">needs</span> <span class="n">unwinding</span> <span class="n">the</span> <span class="n">stack</span> <span class="n">frame</span><span class="o">.</span> <span class="n">The</span> <span class="n">stack</span> <span class="n">frame</span> <span class="n">address</span>
<span class="o">//</span> <span class="n">can</span> <span class="n">be</span> <span class="n">gotten</span> <span class="n">by</span> <span class="n">calling</span> <span class="n">__builtin_frame_address</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">charged</span> <span class="n">function</span><span class="o">.</span>
<span class="n">void</span> <span class="n">exception_handler</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">exceptionOccur</span> <span class="o">=</span> <span class="n">true</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">frameaddr</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="n">__builtin_frame_address</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">__builtin_eh_return</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">returnAddr</span><span class="p">);</span> <span class="o">//</span> <span class="n">no</span> <span class="n">warning</span><span class="p">,</span> <span class="n">eh_return</span> <span class="n">never</span> <span class="n">returns</span><span class="o">.</span>
<span class="p">}</span>

<span class="n">__attribute__</span> <span class="p">((</span><span class="n">weak</span><span class="p">))</span> 
<span class="nb">int</span> <span class="n">test_detect_exception</span><span class="p">(</span><span class="nb">bool</span> <span class="n">exception</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">exceptionOccur</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">void</span><span class="o">*</span> <span class="n">handler</span> <span class="o">=</span> <span class="p">(</span><span class="n">void</span><span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">exception_handler</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">exception</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">returnAddr</span> <span class="o">=</span> <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">__builtin_eh_return</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">handler</span><span class="p">);</span> <span class="o">//</span> <span class="n">no</span> <span class="n">warning</span><span class="p">,</span> <span class="n">eh_return</span> <span class="n">never</span> <span class="n">returns</span><span class="o">.</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

</pre></div>
</div>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">114-37-150-48:input Jonathan$</span> clang -target mips-unknown-linux-gnu -c
<span class="go">ch9_3_detect_exception.cpp -emit-llvm -o ch9_3_detect_exception.bc</span>
<span class="gp">114-37-150-48:input Jonathan$</span> ~/llvm/test/cmake_debug_build/Debug/bin/llvm-dis
<span class="go">ch9_3_detect_exception.bc -o -</span>
<span class="go">; ModuleID = &#39;ch9_3_detect_exception.bc&#39;</span>
<span class="go">target datalayout = &quot;E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64&quot;</span>
<span class="go">target triple = &quot;mips-unknown-linux-gnu&quot;</span>

<span class="go">@exceptionOccur = global i8 0, align 1</span>
<span class="go">@returnAddr = global i8* null, align 4</span>

<span class="go">; Function Attrs: nounwind</span>
<span class="go">define void @_Z17exception_handlerv() #0 {</span>
<span class="gp">  %</span><span class="nv">frameaddr</span> <span class="o">=</span> alloca i32, align 4
<span class="go">  store i8 1, i8* @exceptionOccur, align 1</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> call i8* @llvm.frameaddress<span class="o">(</span>i32 0<span class="o">)</span>
<span class="gp">  %</span><span class="nv">2</span> <span class="o">=</span> ptrtoint i8* %1 to i32
<span class="go">  store i32 %2, i32* %frameaddr, align 4</span>
<span class="gp">  %</span><span class="nv">3</span> <span class="o">=</span> load i8*, i8** @returnAddr, align 4
<span class="go">  call void @llvm.eh.return.i32(i32 0, i8* %3)</span>
<span class="go">  unreachable</span>
<span class="go">                                                  ; No predecessors!</span>
<span class="go">  ret void</span>
<span class="go">}</span>

<span class="go">; Function Attrs: nounwind readnone</span>
<span class="go">declare i8* @llvm.frameaddress(i32) #1</span>

<span class="go">; Function Attrs: nounwind</span>
<span class="go">declare void @llvm.eh.return.i32(i32, i8*) #2</span>

<span class="go">define weak i32 @_Z21test_detect_exceptionb(i1 zeroext %exception) #3 {</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> alloca i8, align 1
<span class="gp">  %</span><span class="nv">handler</span> <span class="o">=</span> alloca i8*, align 4
<span class="gp">  %</span><span class="nv">2</span> <span class="o">=</span> zext i1 %exception to i8
<span class="go">  store i8 %2, i8* %1, align 1</span>
<span class="go">  store i8 0, i8* @exceptionOccur, align 1</span>
<span class="go">  store i8* bitcast (void ()* @_Z17exception_handlerv to i8*), i8** %handler, align 4</span>
<span class="gp">  %</span><span class="nv">3</span> <span class="o">=</span> load i8, i8* %1, align 1
<span class="gp">  %</span><span class="nv">4</span> <span class="o">=</span> trunc i8 %3 to i1
<span class="go">  br i1 %4, label %5, label %8</span>

<span class="go">; &lt;label&gt;:5                                       ; preds = %0</span>
<span class="gp">  %</span><span class="nv">6</span> <span class="o">=</span> call i8* @llvm.returnaddress<span class="o">(</span>i32 0<span class="o">)</span>
<span class="go">  store i8* %6, i8** @returnAddr, align 4</span>
<span class="gp">  %</span><span class="nv">7</span> <span class="o">=</span> load i8*, i8** %handler, align 4
<span class="go">  call void @llvm.eh.return.i32(i32 0, i8* %7)</span>
<span class="go">  unreachable</span>

<span class="go">; &lt;label&gt;:8                                       ; preds = %0</span>
<span class="go">  ret i32 0</span>
<span class="go">}</span>

<span class="go">; Function Attrs: nounwind readnone</span>
<span class="go">declare i8* @llvm.returnaddress(i32) #1</span>

<span class="go">attributes #0 = { nounwind ... }</span>
<span class="go">attributes #1 = { nounwind readnone }</span>
<span class="go">attributes #2 = { nounwind }</span>
<span class="go">attributes #3 = { &quot;less-precise-fpmad&quot;=&quot;false&quot; ... }</span>
<span class="go">...</span>

<span class="gp">114-37-150-48:input Jonathan$</span> ~/llvm/test/cmake_debug_build/Debug/bin/llc
<span class="go">-march=cpu0 -mcpu=cpu032II -relocation-model=pic -filetype=asm</span>
<span class="go">ch9_3_detect_exception.bc -o -</span>
<span class="go">  .text</span>
<span class="go">  .section .mdebug.abiO32</span>
<span class="go">  .previous</span>
<span class="go">  .file &quot;ch9_3_detect_exception.bc&quot;</span>
<span class="go">  .globl  _Z17exception_handlerv</span>
<span class="go">  .align  2</span>
<span class="go">  .type _Z17exception_handlerv,@function</span>
<span class="go">  .ent  _Z17exception_handlerv  # @_Z17exception_handlerv</span>
<span class="go">_Z17exception_handlerv:</span>
<span class="go">  .frame  $fp,16,$lr</span>
<span class="go">  .mask   0x00001000,-4</span>
<span class="go">  .set  noreorder</span>
<span class="go">  .cpload $t9</span>
<span class="go">  .set  nomacro</span>
<span class="gp">#</span> BB#0:
<span class="go">  addiu $sp, $sp, -16</span>
<span class="go">  st  $fp, 12($sp)            # 4-byte Folded Spill</span>
<span class="go">  st  $4, 4($fp)</span>
<span class="go">  st  $5, 0($fp)</span>
<span class="go">  move   $fp, $sp</span>
<span class="go">  lui $2, %got_hi(exceptionOccur)</span>
<span class="go">  addu  $2, $2, $gp</span>
<span class="go">  ld  $2, %got_lo(exceptionOccur)($2)</span>
<span class="go">  addiu $3, $zero, 1</span>
<span class="go">  sb  $3, 0($2)</span>
<span class="go">  st  $fp, 8($fp)</span>
<span class="go">  lui $2, %got_hi(returnAddr)</span>
<span class="go">  addu  $2, $2, $gp</span>
<span class="go">  ld  $2, %got_lo(returnAddr)($2)</span>
<span class="go">  ld  $2, 0($2)</span>
<span class="go">  addiu $3, $zero, 0</span>
<span class="go">  move   $sp, $fp</span>
<span class="go">  ld  $4, 4($fp)</span>
<span class="go">  ld  $5, 0($fp)</span>
<span class="go">  ld  $fp, 12($sp)            # 4-byte Folded Reload</span>
<span class="go">  addiu $sp, $sp, 16</span>
<span class="go">  move   $t9, $2</span>
<span class="go">  move   $lr, $2</span>
<span class="go">  addu  $sp, $sp, $3</span>
<span class="go">  ret $lr</span>
<span class="go">  nop</span>
<span class="go">  .set  macro</span>
<span class="go">  .set  reorder</span>
<span class="go">  .end  _Z17exception_handlerv</span>
<span class="gp">$</span>func_end0:
<span class="go">  .size _Z17exception_handlerv, ($func_end0)-_Z17exception_handlerv</span>

<span class="go">  .weak _Z21test_detect_exceptionb</span>
<span class="go">  .align  2</span>
<span class="go">  .type _Z21test_detect_exceptionb,@function</span>
<span class="go">  .ent  _Z21test_detect_exceptionb # @_Z21test_detect_exceptionb</span>
<span class="go">_Z21test_detect_exceptionb:</span>
<span class="go">  .cfi_startproc</span>
<span class="go">  .frame  $fp,24,$lr</span>
<span class="go">  .mask   0x00001000,-4</span>
<span class="go">  .set  noreorder</span>
<span class="go">  .cpload $t9</span>
<span class="go">  .set  nomacro</span>
<span class="gp">#</span> BB#0:
<span class="go">  addiu $sp, $sp, -24</span>
<span class="gp">$</span>tmp0:
<span class="go">  .cfi_def_cfa_offset 24</span>
<span class="go">  st  $fp, 20($sp)            # 4-byte Folded Spill</span>
<span class="gp">$</span>tmp1:
<span class="go">  .cfi_offset 12, -4</span>
<span class="go">  st  $4, 8($fp)</span>
<span class="go">  st  $5, 4($fp)</span>
<span class="gp">$</span>tmp2:
<span class="go">  .cfi_offset 4, -16</span>
<span class="gp">$</span>tmp3:
<span class="go">  .cfi_offset 5, -20</span>
<span class="go">  move   $fp, $sp</span>
<span class="gp">$</span>tmp4:
<span class="go">  .cfi_def_cfa_register 12</span>
<span class="go">  sb  $4, 16($fp)</span>
<span class="go">  lui $2, %got_hi(exceptionOccur)</span>
<span class="go">  addu  $2, $2, $gp</span>
<span class="go">  ld  $2, %got_lo(exceptionOccur)($2)</span>
<span class="go">  addiu $3, $zero, 0</span>
<span class="go">  sb  $3, 0($2)</span>
<span class="go">  lui $2, %got_hi(_Z17exception_handlerv)</span>
<span class="go">  addu  $2, $2, $gp</span>
<span class="go">  ld  $2, %got_lo(_Z17exception_handlerv)($2)</span>
<span class="go">  st  $2, 12($fp)</span>
<span class="go">  lbu $2, 16($fp)</span>
<span class="go">  andi  $2, $2, 1</span>
<span class="go">  beq $2, $zero, .LBB1_2</span>
<span class="go">  nop</span>
<span class="go">  jmp .LBB1_1</span>
<span class="go">  nop</span>
<span class="go">.LBB1_2:</span>
<span class="go">  addiu $2, $zero, 0</span>
<span class="go">  move   $sp, $fp</span>
<span class="go">  ld  $4, 8($fp)</span>
<span class="go">  ld  $5, 4($fp)</span>
<span class="go">  ld  $fp, 20($sp)            # 4-byte Folded Reload</span>
<span class="go">  addiu $sp, $sp, 24</span>
<span class="go">  ret $lr</span>
<span class="go">  nop</span>
<span class="go">.LBB1_1:</span>
<span class="go">  lui $2, %got_hi(returnAddr)</span>
<span class="go">  addu  $2, $2, $gp</span>
<span class="go">  ld  $2, %got_lo(returnAddr)($2)</span>
<span class="go">  st  $lr, 0($2)</span>
<span class="go">  ld  $2, 12($fp)</span>
<span class="go">  addiu $3, $zero, 0</span>
<span class="go">  move   $sp, $fp</span>
<span class="go">  ld  $4, 8($fp)</span>
<span class="go">  ld  $5, 4($fp)</span>
<span class="go">  ld  $fp, 20($sp)            # 4-byte Folded Reload</span>
<span class="go">  addiu $sp, $sp, 24</span>
<span class="go">  move   $t9, $2</span>
<span class="go">  move   $lr, $2</span>
<span class="go">  addu  $sp, $sp, $3</span>
<span class="go">  ret $lr</span>
<span class="go">  nop</span>
<span class="go">  .set  macro</span>
<span class="go">  .set  reorder</span>
<span class="go">  .end  _Z21test_detect_exceptionb</span>
<span class="gp">$</span>func_end1:
<span class="go">  .size _Z21test_detect_exceptionb, ($func_end1)-_Z21test_detect_exceptionb</span>
<span class="go">  .cfi_endproc</span>

<span class="go">  .type exceptionOccur,@object  # @exceptionOccur</span>
<span class="go">  .bss</span>
<span class="go">  .globl  exceptionOccur</span>
<span class="go">exceptionOccur:</span>
<span class="go">  .byte 0                       # 0x0</span>
<span class="go">  .size exceptionOccur, 1</span>

<span class="go">  .type returnAddr,@object      # @returnAddr</span>
<span class="go">  .globl  returnAddr</span>
<span class="go">  .align  2</span>
<span class="go">returnAddr:</span>
<span class="go">  .4byte  0</span>
<span class="go">  .size returnAddr, 4</span>
<span class="go">  ...</span>
</pre></div>
</div>
<p>If you disable &#8220;__attribute__ ((weak))&#8221; in the C file, then the IR will has
&#8220;nounwind&#8221; in attributes #3. The side effect in asm output is &#8220;No .cfi_offset
issued&#8221; like function exception_handler().</p>
<p>This example code of exception handler implementation can get frame, return and
call exception handler by call __builtin_xxx in clang in C language, without
introducing any assembly instruction.
And this example can be verified in the Chapter &#8220;Cpu0 ELF linker&#8221; of the other
book &#8220;llvm tool chain for Cpu0&#8221; <a class="footnote-reference" href="#cpu0lld" id="id13">[12]</a>.
Through examining global variable, exceptionOccur, is true or false, program
will set the control flow to exception_handler() or not to correctly.</p>
</div>
<div class="section" id="eh-dwarf-intrinsic">
<h4><a class="toc-backref" href="#id43">eh.dwarf intrinsic</a><a class="headerlink" href="#eh-dwarf-intrinsic" title="Permalink to this headline">¶</a></h4>
<p>Beside lowerADD() in Cpu0ISelLowering, the following code is for the eh.dwarf
supporting only, and it can run with input eh-dwarf-cfa.ll as below.</p>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0SEFrameLowering.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="o">//</span> <span class="k">if</span> <span class="n">framepointer</span> <span class="n">enabled</span><span class="p">,</span> <span class="nb">set</span> <span class="n">it</span> <span class="n">to</span> <span class="n">point</span> <span class="n">to</span> <span class="n">the</span> <span class="n">stack</span> <span class="n">pointer</span><span class="o">.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">hasFP</span><span class="p">(</span><span class="n">MF</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">callsEhDwarf</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MBBI</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">TII</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ADDu</span><span class="p">),</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">V0</span><span class="p">)</span><span class="o">.</span><span class="n">addReg</span><span class="p">(</span><span class="n">FP</span><span class="p">)</span><span class="o">.</span><span class="n">addReg</span><span class="p">(</span><span class="n">ZERO</span><span class="p">)</span>
        <span class="o">.</span><span class="n">setMIFlag</span><span class="p">(</span><span class="n">MachineInstr</span><span class="p">::</span><span class="n">FrameSetup</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/input/eh-dwarf-cfa.ll</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>; RUN: llc -march=cpu0el -mcpu=cpu032II &lt; %s | FileCheck %s

declare i8* @llvm.eh.dwarf.cfa(i32) nounwind
declare i8* @llvm.frameaddress(i32) nounwind readnone

define i8* @f1() nounwind {
entry:
  %x = alloca [32 x i8], align 1
  %0 = call i8* @llvm.eh.dwarf.cfa(i32 0)
  ret i8* %0

; CHECK:        addiu   $sp, $sp, -40
; CHECK:        addu    $2,  $zero, $fp
}


define i8* @f2() nounwind {
entry:
  %x = alloca [65536 x i8], align 1
  %0 = call i8* @llvm.eh.dwarf.cfa(i32 0)
  ret i8* %0

; check stack size (65536 + 8)
; CHECK:        lui     $[[R0:[a-z0-9]+]], 65535
; CHECK:        addiu   $[[R0]], $[[R0]], -8
; CHECK:        addu    $sp, $sp, $[[R0]]

; check return value ($sp + stack size)
; CHECK:        addu    $2,  $zero, $fp
}


define i32 @f3() nounwind {
entry:
  %x = alloca [32 x i8], align 1
  %0 = call i8* @llvm.eh.dwarf.cfa(i32 0)
  %1 = ptrtoint i8* %0 to i32
  %2 = call i8* @llvm.frameaddress(i32 0)
  %3 = ptrtoint i8* %2 to i32
  %add = add i32 %1, %3
  ret i32 %add

; CHECK:        addiu   $sp, $sp, -40

; check return value ($fp + stack size + $fp)
; CHECK:        move     $fp, $sp
; CHECK:        addu    $2, $fp, $fp
}

</pre></div>
</div>
</div>
<div class="section" id="bswap-intrinsic">
<h4><a class="toc-backref" href="#id44">bswap intrinsic</a><a class="headerlink" href="#bswap-intrinsic" title="Permalink to this headline">¶</a></h4>
<p>Cpu0 supports llvm instrinsics bswap intrinsic <a class="footnote-reference" href="#bswapintrnsic" id="id14">[13]</a>.</p>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0ISelLowering.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="n">const</span> <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">,</span>
                                       <span class="n">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span>
    <span class="p">:</span> <span class="n">TargetLowering</span><span class="p">(</span><span class="n">TM</span><span class="p">),</span> <span class="n">Subtarget</span><span class="p">(</span><span class="n">STI</span><span class="p">),</span> <span class="n">ABI</span><span class="p">(</span><span class="n">TM</span><span class="o">.</span><span class="n">getABI</span><span class="p">())</span> <span class="p">{</span>

</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">BSWAP</span><span class="p">,</span> <span class="n">MVT</span><span class="p">::</span><span class="n">i32</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">BSWAP</span><span class="p">,</span> <span class="n">MVT</span><span class="p">::</span><span class="n">i64</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/input/ch9_3_bswap.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">test_bswap16</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">volatile</span> <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mh">0x1234</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">__builtin_bswap16</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">^</span> <span class="mh">0x3412</span><span class="p">);</span>
  
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">test_bswap32</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">volatile</span> <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mh">0x1234</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">__builtin_bswap32</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">^</span> <span class="mh">0x34120000</span><span class="p">);</span>
  
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">test_bswap64</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">volatile</span> <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mh">0x1234</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">__builtin_bswap64</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">^</span> <span class="mh">0x3412000000000000</span><span class="p">);</span>
  
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">test_bswap</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">test_bswap16</span><span class="p">()</span> <span class="o">+</span> <span class="n">test_bswap32</span><span class="p">()</span> <span class="o">+</span> <span class="n">test_bswap64</span><span class="p">();</span>
  
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">114-37-150-48:input Jonathan$</span> clang -target mips-unknown-linux-gnu -c
<span class="go">ch9_3_bswap.cpp -emit-llvm -o ch9_3_bswap.bc</span>
<span class="gp">114-37-150-48:input Jonathan$</span> ~/llvm/test/cmake_debug_build/Debug/bin/llvm-dis
<span class="go">ch9_3_bswap.bc -o -</span>
<span class="go">...</span>
<span class="go">define i32 @_Z12test_bswap16v() #0 {</span>
<span class="gp">  %</span><span class="nv">a</span> <span class="o">=</span> alloca i32, align 4
<span class="gp">  %</span><span class="nv">result</span> <span class="o">=</span> alloca i32, align 4
<span class="go">  store volatile i32 4660, i32* %a, align 4</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> load volatile i32, i32* %a, align 4
<span class="gp">  %</span><span class="nv">2</span> <span class="o">=</span> trunc i32 %1 to i16
<span class="gp">  %</span><span class="nv">3</span> <span class="o">=</span> call i16 @llvm.bswap.i16<span class="o">(</span>i16 %2<span class="o">)</span>
<span class="gp">  %</span><span class="nv">4</span> <span class="o">=</span> zext i16 %3 to i32
<span class="gp">  %</span><span class="nv">5</span> <span class="o">=</span> xor i32 %4, 13330
<span class="go">  store i32 %5, i32* %result, align 4</span>
<span class="gp">  %</span><span class="nv">6</span> <span class="o">=</span> load i32, i32* %result, align 4
<span class="go">  ret i32 %6</span>
<span class="go">}</span>
<span class="go">...</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="add-specific-backend-intrinsic-function">
<h3><a class="toc-backref" href="#id45">Add specific backend intrinsic function</a><a class="headerlink" href="#add-specific-backend-intrinsic-function" title="Permalink to this headline">¶</a></h3>
<p>LLVM intrinsic functions is designed to extend llvm IRs for hardware
acceleration in compiler design <a class="footnote-reference" href="#extendintrnsic" id="id15">[14]</a>.
Many cpu implement their intrinsic functions for their speedup hardware
instructions.
Some gpu apply llvm infrastructure as their OpenGL/CL backend compiler using
many llvm extended intrinsic functions.
To demonstrate how to use backend proprietary intrinsic functions to support
their specific instructions to getting better performance in some domain
language, Cpu0 add a intrinsic function &#64;llvm.cpu0.gcd for its
gcd(greatest common divider) instruction. This instruction explaining
how to do it in llvm only, it is not added in Verilog Cpu0 implementation.
The code as follows,</p>
<p class="rubric">lbdex/src/modify/src/include/llvm/IR/Intrinsics.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="n">include</span> <span class="s">&quot;llvm/IR/IntrinsicsCpu0.td&quot;</span>
<span class="p">...</span>
</pre></div>
</div>
<p class="rubric">lbdex/src/modify/src/include/llvm/IR/IntrinsicsCpu0.td</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//===-</span> <span class="n">IntrinsicsCpu0</span><span class="o">.</span><span class="n">td</span> <span class="o">-</span> <span class="n">Defines</span> <span class="n">Mips</span> <span class="n">intrinsics</span> <span class="o">---------*-</span> <span class="n">tablegen</span> <span class="o">-*-===//</span>
<span class="o">//</span>
<span class="o">//</span>                     <span class="n">The</span> <span class="n">LLVM</span> <span class="n">Compiler</span> <span class="n">Infrastructure</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">This</span> <span class="n">file</span> <span class="ow">is</span> <span class="n">distributed</span> <span class="n">under</span> <span class="n">the</span> <span class="n">University</span> <span class="n">of</span> <span class="n">Illinois</span> <span class="n">Open</span> <span class="n">Source</span>
<span class="o">//</span> <span class="n">License</span><span class="o">.</span> <span class="n">See</span> <span class="n">LICENSE</span><span class="o">.</span><span class="n">TXT</span> <span class="k">for</span> <span class="n">details</span><span class="o">.</span>
<span class="o">//</span>
<span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">This</span> <span class="n">file</span> <span class="n">defines</span> <span class="nb">all</span> <span class="n">of</span> <span class="n">the</span> <span class="n">CPU0</span><span class="o">-</span><span class="n">specific</span> <span class="n">intrinsics</span><span class="o">.</span>
<span class="o">//</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="k">def</span> <span class="nf">int_cpu0_gcd</span> <span class="p">:</span> <span class="n">GCCBuiltin</span><span class="o">&lt;</span><span class="s2">&quot;__builtin_cpu0_gcd&quot;</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">Intrinsic</span><span class="o">&lt;</span><span class="p">[</span><span class="n">llvm_i32_ty</span><span class="p">],</span> <span class="p">[</span><span class="n">llvm_i32_ty</span><span class="p">,</span> <span class="n">llvm_i32_ty</span><span class="p">],</span>
  <span class="p">[</span><span class="n">Commutative</span><span class="p">,</span> <span class="n">IntrNoMem</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>

</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0InstrInfo.td</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>class IntrinArithLogicR&lt;bits&lt;8&gt; op, string instr_asm, SDPatternOperator OpNode,
                  InstrItinClass itin, RegisterClass RC, bit isComm = 0&gt;:
  FA&lt;op, (outs GPROut:$ra), (ins RC:$rb, RC:$rc),
     !strconcat(instr_asm, &quot;\t$ra, $rb, $rc&quot;),
     [(set GPROut:$ra, (OpNode RC:$rb, RC:$rc))], itin&gt; {
  let shamt = 0;
  let isCommutable = isComm;	// e.g. add rb rc =  add rc rb
  let isReMaterializable = 1;
}
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">GCD</span> <span class="p">:</span> <span class="n">IntrinArithLogicR</span><span class="o">&lt;</span><span class="mh">0x60</span><span class="p">,</span> <span class="s2">&quot;gcd&quot;</span><span class="p">,</span> <span class="n">int_cpu0_gcd</span><span class="p">,</span> <span class="n">IIAlu</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>When running llc with cpu0_gcd.ll, it gets the gcd machine instruction,
meanwhile, when running cpu0_gcd_soft.ll, it gets the &#8220;call llvm.cpu0.gcd.soft&#8221;
function.
In other words, &#8220;&#64;llvm.cpu0.gcd&#8221; is intrinsic function for &#8220;gcd&#8221; machine
instruction; &#8220;&#64;llvm.cpu0.gcd.soft&#8221; is intrinsic function for hand-written
function code.</p>
</div>
</div>
<div class="section" id="summary">
<h2><a class="toc-backref" href="#id46">Summary</a><a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<p>Now, Cpu0 backend code can take care both the integer function call and
control statement just like the example code of llvm frontend tutorial does.
It can translate some of the C++ OOP language into Cpu0 instructions also
without much effort in backend,
because the most complex things in language, such as C++ syntax, is handled by
frontend.
LLVM is a real structure following the compiler theory, any backend of LLVM can
get benefit from this structure.
The best part of 3 tiers compiler structure is that backend will grow up
automatically in languages support as the frontend supporting languages more
and more when the frontend doesn&#8217;t add any new IR for a new language.</p>
<table class="docutils footnote" frame="void" id="computer-arch-interface" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Computer Organization and Design: The Hardware/Software Interface 1st edition (The Morgan Kaufmann Series in Computer Architecture and Design)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="mipsasm" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id9">2</a>)</em> <a class="reference external" href="http://math-atlas.sourceforge.net/devel/assembly/007-2418-003.pdf">http://math-atlas.sourceforge.net/devel/assembly/007-2418-003.pdf</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="abi" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id4">2</a>)</em> <a class="reference external" href="http://www.linux-mips.org/pub/linux/mips/doc/ABI/mipsabi.pdf">http://www.linux-mips.org/pub/linux/mips/doc/ABI/mipsabi.pdf</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="secglobal" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[4]</a></td><td><a class="reference external" href="http://jonathan2251.github.io/lbd/globalvar.html#global-variable">http://jonathan2251.github.io/lbd/globalvar.html#global-variable</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="wikitailcall" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[5]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Tail_call">http://en.wikipedia.org/wiki/Tail_call</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="tailcallopt" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[6]</a></td><td><a class="reference external" href="http://llvm.org/docs/CodeGenerator.html#tail-call-optimization">http://llvm.org/docs/CodeGenerator.html#tail-call-optimization</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="callconv" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[7]</a></td><td><a class="reference external" href="http://llvm.org/docs/LangRef.html#calling-conventions">http://llvm.org/docs/LangRef.html#calling-conventions</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="mipsqemu" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[8]</a></td><td><a class="reference external" href="http://developer.mips.com/clang-llvm/">http://developer.mips.com/clang-llvm/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="stacksave" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[9]</a></td><td><a class="reference external" href="http://www.llvm.org/docs/LangRef.html#llvm-stacksave-intrinsic">http://www.llvm.org/docs/LangRef.html#llvm-stacksave-intrinsic</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="excepthandle" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[10]</a></td><td><a class="reference external" href="http://llvm.org/docs/ExceptionHandling.html#overview">http://llvm.org/docs/ExceptionHandling.html#overview</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="returnaddr" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[11]</td><td><a class="reference external" href="http://llvm.org/docs/LangRef.html#llvm-returnaddress-intrinsic">http://llvm.org/docs/LangRef.html#llvm-returnaddress-intrinsic</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="cpu0lld" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[12]</a></td><td><a class="reference external" href="http://jonathan2251.github.io/lbt/lld.html">http://jonathan2251.github.io/lbt/lld.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="bswapintrnsic" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[13]</a></td><td><a class="reference external" href="http://llvm.org/docs/LangRef.html#llvm-bswap-intrinsics">http://llvm.org/docs/LangRef.html#llvm-bswap-intrinsics</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="extendintrnsic" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[14]</a></td><td><a class="reference external" href="https://llvm.org/docs/ExtendingLLVM.html">https://llvm.org/docs/ExtendingLLVM.html</a></td></tr>
</tbody>
</table>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="ctrlflow.html">Control flow statements</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="elf.html">ELF Support</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2016, Chen Chung-Shu.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.4.
    </div>
  </body>
</html>