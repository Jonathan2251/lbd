.. _sec-elf:

ELF Support
===========

.. contents::
   :local:
   :depth: 4

Cpu0 backend generated the ELF format of object files.

The ELF (Executable and Linkable Format) is a common standard file format for 
executables, object code, shared libraries and core dumps. 
First published in the System V Application Binary Interface specification, 
and later in the Tool Interface Standard, it was quickly accepted among 
different vendors of Unixsystems. 
In 1999 it was chosen as the standard binary file format for Unix and 
Unix-like systems on x86 by the x86open project. 
Please reference [#wiki-elf]_.

The binary encoding of the Cpu0 instruction set in object files has been
verified in previous chapters. However, we did not delve into the ELF file
format, such as the ELF header and relocation records, at that time.

In this chapter, you will learn how to use tools such as ``llvm-objdump``,
``llvm-readelf``, and others to analyze ELF files generated by Cpu0. Through
these tools, you will also understand the ELF file format itself.

This chapter introduces these tools to readers because understanding the popular
ELF format and analysis tools is valuable. An LLVM compiler engineer is
responsible for ensuring that their backend generates correct object files.

With these tools, you can verify the correctness of the generated ELF format.

The Cpu0 author has published a book titled “System Software,” which introduces
topics such as assemblers, linkers, loaders, compilers, and operating systems in
both concept and practice. It demonstrates how to analyze ELF files using
binutils and gcc, and includes example code. This is a Chinese-language book on
“System Software.”

The book "System Software" [#beck]_ written by Beck is a well-known resource for
explaining what the compiler, linker, and loader produce, and how they work
together conceptually. You may refer to it to understand how **Relocation
Records** work if you need a refresher or are learning this topic for the first
time.

[#lk-out]_, [#lk-obj]_, [#lk-elf]_ are Chinese documents about this topic,
available on the Cpu0 author's website.


ELF format
----------

ELF is a format used in both object and executable files. Therefore, there are
two views of it, as shown in :numref:`elf-f1`.

.. _elf-f1:
.. figure:: ../Fig/elf/1.png
    :height: 320 px
    :width: 213 px
    :scale: 100 %
    :align: center

    ELF file format overview

As shown in :numref:`elf-f1`, the "Section header table" includes sections
.text, .rodata, ..., .data, which are used for code, read-only data, and
read/write data, respectively. The "Program header table" includes segments
used at run time for code and data.

The definition of segments describes the run-time layout of code and data,
while sections describe the link-time layout.


ELF header and Section header table
***********************************

Let's run Chapter9_3/ with ch6_1.cpp, and dump ELF header information using
``llvm-readelf -h`` to see what the ELF header contains.

.. code-block:: console

  input$ ~/llvm/test/build/bin/llc -march=cpu0 
  -relocation-model=pic -filetype=obj ch6_1.bc -o ch6_1.cpu0.o
  
  input$ llvm-readelf -h ch6_1.cpu0.o 
    Magic:   7f 45 4c 46 01 02 01 03 00 00 00 00 00 00 00 00 
    Class:                             ELF32
    Data:                              2's complement, big endian
    Version:                           1 (current)
    OS/ABI:                            UNIX - GNU
    ABI Version:                       0
    Type:                              REL (Relocatable file)
    Machine:                           <unknown>: 0xc9
    Version:                           0x1
    Entry point address:               0x0
    Start of program headers:          0 (bytes into file)
    Start of section headers:          176 (bytes into file)
    Flags:                             0x0
    Size of this header:               52 (bytes)
    Size of program headers:           0 (bytes)
    Number of program headers:         0
    Size of section headers:           40 (bytes)
    Number of section headers:         8
    Section header string table index: 5
  input$ 

  input$ ~/llvm/test/build/bin/llc 
  -march=mips -relocation-model=pic -filetype=obj ch6_1.bc -o ch6_1.mips.o
  
  input$ llvm-readelf -h ch6_1.mips.o 
  ELF Header:
    Magic:   7f 45 4c 46 01 02 01 03 00 00 00 00 00 00 00 00 
    Class:                             ELF32
    Data:                              2's complement, big endian
    Version:                           1 (current)
    OS/ABI:                            UNIX - GNU
    ABI Version:                       0
    Type:                              REL (Relocatable file)
    Machine:                           MIPS R3000
    Version:                           0x1
    Entry point address:               0x0
    Start of program headers:          0 (bytes into file)
    Start of section headers:          200 (bytes into file)
    Flags:                             0x50001007, noreorder, pic, cpic, o32, mips32
    Size of this header:               52 (bytes)
    Size of program headers:           0 (bytes)
    Number of program headers:         0
    Size of section headers:           40 (bytes)
    Number of section headers:         9
    Section header string table index: 6
  input$ 

.. code-block:: console

  input$ llvm-readelf -l ch6_1.cpu0.o 
  
  There are no program headers in this file.
  input$ 

As shown in the ELF header above, it contains information such as the magic
number, version, ABI, and more. The `Machine` field for Cpu0 is listed as
unknown, whereas MIPS is recognized as `MIPSR3000`.

This happens because Cpu0 is a unknown CPU supported by the
`llvm-readelf` utility.

Let's check the ELF segments information with the following command:

.. code-block:: console

  input$ llvm-readelf -l ch6_1.cpu0.o

  There are no program headers in this file.
  input$

This result is expected because the Cpu0 object file is meant for linking only,
not execution because we don't implement linker at this point yet. 
Therefore, the segment table is empty.

Next, let’s check the ELF sections. Each section includes offset and size
information.

.. code-block:: console

  input$ llvm-readelf -S ch6_1.cpu0.o 
  There are 10 section headers, starting at offset 0xd4:
  
  Section Headers:
    [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
    [ 0]                   NULL            00000000 000000 000000 00      0   0  0
    [ 1] .text             PROGBITS        00000000 000034 000034 00  AX  0   0  4
    [ 2] .rel.text         REL             00000000 000310 000018 08      8   1  4
    [ 3] .data             PROGBITS        00000000 000068 000004 00  WA  0   0  4
    [ 4] .bss              NOBITS          00000000 00006c 000000 00  WA  0   0  4
    [ 5] .eh_frame         PROGBITS        00000000 00006c 000028 00   A  0   0  4
    [ 6] .rel.eh_frame     REL             00000000 000328 000008 08      8   5  4
    [ 7] .shstrtab         STRTAB          00000000 000094 00003e 00      0   0  1
    [ 8] .symtab           SYMTAB          00000000 000264 000090 10      9   6  4
    [ 9] .strtab           STRTAB          00000000 0002f4 00001b 00      0   0  1
  Key to Flags:
    W (write), A (alloc), X (execute), M (merge), S (strings)
    I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
    O (extra OS processing required) o (OS specific), p (processor specific)
  input$ 



Relocation Record
*****************

Cpu0 backend translates global variables as follows:

.. code-block:: console

  input$ clang -target mips-unknown-linux-gnu -c ch6_1.cpp 
  -emit-llvm -o ch6_1.bc
  input$ ~/llvm/test/build/
  bin/llc -march=cpu0 -relocation-model=pic -filetype=asm ch6_1.bc -o ch6_1.cpu0.s
  input$ cat ch6_1.cpu0.s 
    .section .mdebug.abi32
    .previous
    .file "ch6_1.bc"
    .text
    ...
    .cfi_startproc
    .frame  $sp,8,$lr
    .mask   0x00000000,0
    .set  noreorder
    .cpload $t9
    ...
    lui $2, %got_hi(gI)
    addu $2, $2, $gp
    ld $2, %got_lo(gI)($2)
    ...
    .type gI,@object              # @gI
    .data
    .globl  gI
    .align  2
  gI:
    .4byte  100                     # 0x64
    .size gI, 4
  
  
  input$ ~/llvm/test/build/
  bin/llc -march=cpu0 -relocation-model=pic -filetype=obj ch6_1.bc -o ch6_1.cpu0.o
  input$ llvm-objdump -s ch6_1.cpu0.o
  
  ch6_1.cpu0.o:     file format elf32-big
  
  Contents of section .text:
  // .cpload machine instruction
   0000 0fa00000 0daa0000 13aa6000 ........  ..............`.
   ...
   0020 002a0000 00220000 012d0000 0ddd0008  .*..."...-......
   ...
  input$
  
  input$ llvm-readelf -tr ch6_1.cpu0.o 
  There are 8 section headers, starting at offset 0xb0:

  Section Headers:
    [Nr] Name
         Type            Addr     Off    Size   ES   Lk Inf Al
         Flags
    [ 0] 
         NULL            00000000 000000 000000 00   0   0  0
         [00000000]: 
    [ 1] .text
         PROGBITS        00000000 000034 000044 00   0   0  4
         [00000006]: ALLOC, EXEC
    [ 2] .rel.text
         REL             00000000 0002a8 000020 08   6   1  4
         [00000000]: 
    [ 3] .data
         PROGBITS        00000000 000078 000008 00   0   0  4
         [00000003]: WRITE, ALLOC
    [ 4] .bss
         NOBITS          00000000 000080 000000 00   0   0  4
         [00000003]: WRITE, ALLOC
    [ 5] .shstrtab
         STRTAB          00000000 000080 000030 00   0   0  1
         [00000000]: 
    [ 6] .symtab
         SYMTAB          00000000 0001f0 000090 10   7   5  4
         [00000000]: 
    [ 7] .strtab
         STRTAB          00000000 000280 000025 00   0   0  1
         [00000000]: 

  Relocation section '.rel.text' at offset 0x2a8 contains 4 entries:
   Offset     Info    Type            Sym.Value  Sym. Name
  00000000  00000805 unrecognized: 5       00000000   _gp_disp
  00000004  00000806 unrecognized: 6       00000000   _gp_disp
  00000020  00000616 unrecognized: 16      00000004   gI
  00000028  00000617 unrecognized: 17      00000004   gI

  
  input$ llvm-readelf -tr ch6_1.mips.o 
  There are 9 section headers, starting at offset 0xc8:

  Section Headers:
    [Nr] Name
         Type            Addr     Off    Size   ES   Lk Inf Al
         Flags
    [ 0] 
         NULL            00000000 000000 000000 00   0   0  0
         [00000000]: 
    [ 1] .text
         PROGBITS        00000000 000034 000038 00   0   0  4
         [00000006]: ALLOC, EXEC
    [ 2] .rel.text
         REL             00000000 0002f8 000018 08   7   1  4
         [00000000]: 
    [ 3] .data
         PROGBITS        00000000 00006c 000008 00   0   0  4
         [00000003]: WRITE, ALLOC
    [ 4] .bss
         NOBITS          00000000 000074 000000 00   0   0  4
         [00000003]: WRITE, ALLOC
    [ 5] .reginfo
         MIPS_REGINFO    00000000 000074 000018 00   0   0  1
         [00000002]: ALLOC
    [ 6] .shstrtab
         STRTAB          00000000 00008c 000039 00   0   0  1
         [00000000]: 
    [ 7] .symtab
         SYMTAB          00000000 000230 0000a0 10   8   6  4
         [00000000]: 
    [ 8] .strtab
         STRTAB          00000000 0002d0 000025 00   0   0  1
         [00000000]: 

  Relocation section '.rel.text' at offset 0x2f8 contains 3 entries:
   Offset     Info    Type            Sym.Value  Sym. Name
  00000000  00000905 R_MIPS_HI16       00000000   _gp_disp
  00000004  00000906 R_MIPS_LO16       00000000   _gp_disp
  0000001c  00000709 R_MIPS_GOT16      00000004   gI

As depicted in 
:ref:`subsection Gloabal Variables Accessing In PIC Addressing Mode <global-var-pic-func>`, 
it translates **“.cpload %reg”** into the following.

.. code-block:: c++

  // Lower ".cpload $reg" to
  //  "lui   $gp, %hi(_gp_disp)"
  //  "ori $gp, $gp, %lo(_gp_disp)"
  //  "addu  $gp, $gp, $t9"

The _gp_disp value is determined by the loader, so it's undefined in the obj
file. You can find both the relocation records for offset 0 and 4 of the `.text`
section referring to the _gp_disp symbol.

The offset 0 and 4 of the `.text` section correspond to the instructions
``lui $gp, %hi(_gp_disp)`` and ``ori $gp, $gp, %lo(_gp_disp)``, whose encoded
object representations are `0fa00000` and `0daa0000`, respectively.

The object file sets the `%hi(_gp_disp)` and `%lo(_gp_disp)` fields to zero,
since the loader will determine the actual _gp_disp value at runtime and patch
these two relocation entries accordingly.

You can verify the correctness of Cpu0’s handling of `%hi(_gp_disp)` and
`%lo(_gp_disp)` by comparing them to the MIPS relocation records
`R_MIPS_HI(_gp_disp)` and `R_MIPS_LO(_gp_disp)`, even though Cpu0 is not a
recognized CPU target by the `llvm-readelf` utility.

The instruction ``ld $2, %got(gI)($gp)`` behaves similarly. Because the actual
address of the `.data` section variable `gI` is unknown at compile time, Cpu0
sets its address to 0 and creates a relocation record at offset 0x00000020 of
the `.text` section.

The linker or loader will patch this address at link time (for static linking)
or load time (for dynamic linking), depending on how the program is built.


Cpu0 ELF related files
**********************

The files `Cpu0ELFObjectWriter.cpp` and `Cpu0MC*.cpp` are responsible for
generating object files (`.o`) in ELF format for the Cpu0 backend.

Most instruction-specific encoding logic is defined in the `Cpu0InstrInfo.td`
and `Cpu0RegisterInfo.td` TableGen files. Based on these `.td` descriptions,
LLVM automatically translates Cpu0 instructions into the correct binary format
for object files.


llvm-objdump
-------------

llvm-objdump -t -r
******************

The `llvm-objdump -tr` command displays symbol table and relocation record
information, similar to the output of `llvm-readelf -tr`.

To examine the differences, try running `llvm-objdump` with and without enabling
the Cpu0 backend, as shown in the following example:

.. code-block:: console

  118-165-83-12:input Jonathan$ clang -target mips-unknown-linux-gnu -c 
  ch9_3.cpp -emit-llvm -o ch9_3.bc
  118-165-83-10:input Jonathan$ /Users/Jonathan/llvm/test/build/
  bin/llc -march=cpu0 -relocation-model=pic -filetype=obj ch9_3.bc -o 
  ch9_3.cpu0.o

  118-165-78-12:input Jonathan$ objdump -t -r ch9_3.cpu0.o
  
  ch9_3.cpu0.o:     file format elf32-big

  SYMBOL TABLE:
  00000000 l    df *ABS*	00000000 ch9_3.bc
  00000000 l    d  .text	00000000 .text
  00000000 l    d  .data	00000000 .data
  00000000 l    d  .bss	00000000 .bss
  00000000 g     F .text	00000084 _Z5sum_iiz
  00000084 g     F .text	00000080 main
  00000000         *UND*	00000000 _gp_disp


  RELOCATION RECORDS FOR [.text]:
  OFFSET   TYPE              VALUE 
  00000084 UNKNOWN           _gp_disp
  00000088 UNKNOWN           _gp_disp
  000000e0 UNKNOWN           _Z5sum_iiz


  118-165-83-10:input Jonathan$ /Users/Jonathan/llvm/test/build/
  bin/llvm-objdump -t -r ch9_3.cpu0.o
  
  ch9_3.cpu0.o:	file format ELF32-CPU0

  RELOCATION RECORDS FOR [.text]:
  132 R_CPU0_HI16 _gp_disp
  136 R_CPU0_LO16 _gp_disp
  224 R_CPU0_CALL16 _Z5sum_iiz

  SYMBOL TABLE:
  00000000 l    df *ABS*	00000000 ch9_3.bc
  00000000 l    d  .text	00000000 .text
  00000000 l    d  .data	00000000 .data
  00000000 l    d  .bss	00000000 .bss
  00000000 g     F .text	00000084 _Z5sum_iiz
  00000084 g     F .text	00000080 main
  00000000         *UND*	00000000 _gp_disp


The `llvm-objdump` tool can correctly display the file format and relocation
record information, whereas the GNU `objdump` cannot. This is because the
Cpu0-specific relocation record definitions have been added to `ELF.h` within
LLVM's source code, enabling `llvm-objdump` to recognize and interpret them
properly.

.. rubric:: include/llvm/support/ELF.h
.. code-block:: c++

  // Machine architectures
  enum {
    ...
    EM_CPU0          = 998, // Document LLVM Backend Tutorial Cpu0
    EM_CPU0_LE       = 999  // EM_CPU0_LE: little endian; EM_CPU0: big endian
  }
  

.. rubric:: lib/object/ELF.cpp
.. code-block:: c++

  ...

  StringRef getELFRelocationTypeName(uint32_t Machine, uint32_t Type) {
    switch (Machine) {
    ...
    case ELF::EM_CPU0:
      switch (Type) {
  #include "llvm/Support/ELFRelocs/Cpu0.def"
      default:
        break;
      }
      break;
    ...
    }
  

.. rubric:: include/llvm/Support/ELFRelocs/Cpu0.def
.. literalinclude:: ../lbdex/llvm/modify/llvm/include/llvm/BinaryFormat/ELFRelocs/Cpu0.def

.. rubric:: include/llvm/Object/ELFObjectFile.h
.. code-block:: c++
  
  template<support::endianness target_endianness, bool is64Bits>
  error_code ELFObjectFile<target_endianness, is64Bits>
              ::getRelocationValueString(DataRefImpl Rel,
                        SmallVectorImpl<char> &Result) const {
    ...
    case ELF::EM_CPU0:  // llvm-objdump -t -r
    res = symname;
    break;
    ...
  }
  
  template<support::endianness target_endianness, bool is64Bits>
  StringRef ELFObjectFile<target_endianness, is64Bits>
               ::getFileFormatName() const {
    switch(Header->e_ident[ELF::EI_CLASS]) {
    case ELF::ELFCLASS32:
    switch(Header->e_machine) {
    ...
    case ELF::EM_CPU0:  // llvm-objdump -t -r
      return "ELF32-CPU0";
    ...
  }
  
  template<support::endianness target_endianness, bool is64Bits>
  unsigned ELFObjectFile<target_endianness, is64Bits>::getArch() const {
    switch(Header->e_machine) {
    ...
    case ELF::EM_CPU0:  // llvm-objdump -t -r
    return (target_endianness == support::little) ?
         Triple::cpu0el : Triple::cpu0;
    ...
  }

In addition to ``llvm-objdump -t -r``, the ``llvm-readobj -h`` command can be
used to display the Cpu0 ELF header information, thanks to the `EM_CPU0`
definition added earlier.

llvm-objdump -d
***************

Run the example code from the previous chapter using the command
``llvm-objdump -d`` to disassemble the ELF file and view its contents in
hexadecimal format as shown below:

.. code-block:: console

  JonathantekiiMac:input Jonathan$ clang -target mips-unknown-linux-gnu -c 
  ch8_1_1.cpp -emit-llvm -o ch8_1_1.bc
  JonathantekiiMac:input Jonathan$ /Users/Jonathan/llvm/test/build/
  bin/llc -march=cpu0 -relocation-model=pic -filetype=obj ch8_1_1.bc 
  -o ch8_1_1.cpu0.o
  JonathantekiiMac:input Jonathan$ /Users/Jonathan/llvm/test/build/
  bin/llvm-objdump -d ch8_1_1.cpu0.o
  
  ch8_1_1.cpu0.o: file format ELF32-unknown
  
  Disassembly of section .text:error: no disassembler for target cpu0-unknown-
  unknown

To support ``llvm-objdump``, the following code is added in Chapter10_1/.
(Note: The ``DecoderMethod`` for ``brtarget24`` was added in a previous chapter.)

.. rubric:: lbdex/chapters/Chapter10_1/CMakeLists.txt
.. literalinclude:: ../lbdex/Cpu0/CMakeLists.txt
    :start-after: #if CH >= CH10_1 1
    :end-before: #endif
.. literalinclude:: ../lbdex/Cpu0/CMakeLists.txt
    :start-after: #if CH >= CH10_1 2
    :end-before: #endif
.. literalinclude:: ../lbdex/Cpu0/CMakeLists.txt
    :start-after: #if CH >= CH10_1 3
    :end-before: #endif
  
.. rubric:: lbdex/chapters/Chapter10_1/Cpu0InstrInfo.td
.. literalinclude:: ../lbdex/Cpu0/Cpu0InstrInfo.td
    :start-after: //@JumpFR {
    :end-before: //@JumpFR }
.. literalinclude:: ../lbdex/Cpu0/Cpu0InstrInfo.td
    :start-after: //@JumpLink {
    :end-before: //@JumpLink }
  
.. rubric:: lbdex/chapters/Chapter10_1/Disassembler/CMakeLists.txt
.. literalinclude:: ../lbdex/Cpu0/Disassembler/CMakeLists.txt
  
.. rubric:: lbdex/chapters/Chapter10_1/Disassembler/Cpu0Disassembler.cpp
.. literalinclude:: ../lbdex/chapters/Chapter10_1/Disassembler/Cpu0Disassembler.cpp
  
As shown in the above code, it adds the ``Disassembler`` directory to handle
the reverse translation from obj to assembly. Therefore, ``Disassembler/Cpu0Disassembler.cpp``
is added, and the ``CMakeLists.txt`` is modified to build the ``Disassembler`` directory
and enable the disassembler table generated by setting ``has_disassembler = 1``.
Most of the code is handled by the table defined in ``*.td`` files.

Not every instruction in the ``*.td`` files can be disassembled without trouble,
even though they can be successfully translated into assembly and obj. For those
that cannot be disassembled, LLVM provides the ``"let DecoderMethod"`` keyword to
allow programmers to implement their own decode functions. 

For example, in Cpu0, we define functions such as ``DecodeBranch24Target()``,
``DecodeJumpTarget()``, and ``DecodeJumpFR()`` in ``Cpu0Disassembler.cpp``. We
then inform ``llvm-tblgen`` by writing ``"let DecoderMethod = ..."`` in the
corresponding instruction definitions or ISD nodes of ``Cpu0InstrInfo.td``.

LLVM will call these ``DecoderMethods`` when the user uses disassembler tools,
such as ``llvm-objdump -d``.

Finally, ``cpu032II`` includes all instructions from ``cpu032I`` and adds some new
instructions. When ``llvm-objdump -d`` is invoked, the function
``selectCpu0ArchFeature()`` will be called through ``createCpu0MCSubtargetInfo()``.
Since ``llvm-objdump`` cannot set CPU options like ``llc -mcpu=cpu032I``, the
variable ``CPU`` in ``selectCpu0ArchFeature()`` is empty when invoked by
``llvm-objdump -d``. To ensure that all instructions are disassembled, we set
``Cpu0ArchFeature`` to ``"+cpu032II"`` so that it can disassemble all instructions
from ``cpu032II`` (which includes all instructions from ``cpu032I`` and adds new ones).

.. rubric:: lbdex/chapters/Chapter10_1/MCTargetDesc/Cpu0MCTargetDesc.cpp
.. literalinclude:: ../lbdex/Cpu0/MCTargetDesc/Cpu0MCTargetDesc.cpp
    :start-after: //@1 {
    :end-before: //@1 }

Now, run Chapter10_1/ with command ``llvm-objdump -d ch8_1_1.cpu0.o`` will get 
the following result.

.. code-block:: console

  JonathantekiiMac:input Jonathan$ /Users/Jonathan/llvm/test/build/
  bin/llc -march=cpu0 -relocation-model=pic -filetype=obj 
  ch8_1_1.bc -o ch8_1_1.cpu0.o
  JonathantekiiMac:input Jonathan$ /Users/Jonathan/llvm/test/build/
  bin/llvm-objdump -d ch8_1_1.cpu0.o
  
  ch8_1_1.cpu0.o:	file format ELF32-CPU0

  Disassembly of section .text:
  _Z13test_control1v:
         0: 09 dd ff d8                                   addiu $sp, $sp, -40
         4: 09 30 00 00                                   addiu $3, $zero, 0
         8: 02 3d 00 24                                   st  $3, 36($sp)
         c: 09 20 00 01                                   addiu $2, $zero, 1
        10: 02 2d 00 20                                   st  $2, 32($sp)
        14: 09 40 00 02                                   addiu $4, $zero, 2
        18: 02 4d 00 1c                                   st  $4, 28($sp)
        ...


Disassembler Structure
----------------------

The flow of disassembly is shown in :numref:`disas`.

.. _disas:
.. graphviz:: ../Fig/elf/disas.gv
   :caption: The flow of disassembly. 

- After getInstruction() of Cpu0Disassembler.cpp, disassembleObject() of 
  llvm-objdump.cpp call printInst() of Cpu0InstPrinter.cpp to print 
  (address: binary assembly) for the instruction, for example 
  "(4: 09 30 00 00 addiu $3, $zero, 0)".

  - printInst() of Cpu0InstPrinter.cpp: reference :numref:`print-asm`.

- Bytes: 4-byte (32-bits) for Cpu0. insn: Convert Bytes to big or little endian 
  of 32-bit (unsigned int) binary instruction.

List `DecoderTableCpu032` and `decodeInstruction()` as follows:

.. rubric:: build/lib/Target/Cpu0/Cpu0GenDisassemblerTables.inc
.. literalinclude:: ../lbdex/Cpu0Gen/Cpu0GenDisassemblerTables.inc
   :start-at: static const uint8_t DecoderTableCpu032[] = {
   :end-at: /* 112 */
   :append: ...
.. literalinclude:: ../lbdex/Cpu0Gen/Cpu0GenDisassemblerTables.inc
   :prepend: template <typename InsnType>
   :start-at: static DecodeStatus decodeInstruction
   :end-before: } // end namespace llvm

List the tracing of `decodeInstruction()` by enabling "#if 1" in
`Cpu0Disassembler.cpp` and running `llvm-objdump` as follows:

.. rubric:: lbdex/chapters/Chapter10_1/Disassembler/Cpu0Disassembler.cpp
.. code-block:: c++

  #if 1
  #undef LLVM_DEBUG(X)
  #define LLVM_DEBUG(X) X
  #endif
  #include "Cpu0GenDisassemblerTables.inc"


.. literalinclude:: ../References/ch3.disas.log


Based on the debug log above, pick the example "addiu $sp, $sp, -8", 
which has an opcode of 9, to explain `decodeInstruction()` as shown in the 
table and explanation below:

.. table:: The state transformation of decodeInstruction() for "addiu $sp, $sp, -8"

  ===================  =============================================
  state                result
  ===================  =============================================
  OPC_ExtractField     CurFieldValue <- Opcode:9
  OPC_FilterValue      Match entries of DecodeTable == CurFieldValue
  OPC_Decode           setOpcode(9) and decode operands by calling decodeToMCInst()
  ===================  =============================================

- For "move $fp, $sp" and "ret $lr", they have state OPC_CheckField before 
  OPC_Decode since they are R type of Cpu0 instruction format and 
  "let shamt = 0;" is set in "class ArithLogic" of Cpu0InstrInfo.td. 

  - For "move $fp, $sp", fieldFromInstruction(0x11cd0000, 0, 12) = (0x11cd0000 
    & 0x00000fff). Check bits(20..31) is 0.

- DecodeBranch16Target() and DecodeBranch24Target(): decode immediate value 
  to MCInst.operand and set the type of MCInst.operand to immediate type, 
  with value being either positive or negative. Operand of MCInst can be 
  either immediate or register type.


.. [#wiki-elf] http://en.wikipedia.org/wiki/Executable_and_Linkable_Format

.. [#beck] Leland Beck, System Software: An Introduction to Systems Programming. 

.. [#lk-out] http://ccckmit.wikidot.com/lk:aout

.. [#lk-obj] http://ccckmit.wikidot.com/lk:objfile

.. [#lk-elf] http://ccckmit.wikidot.com/lk:elffile

