
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Verify backend on Verilog simulator &#8212; Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Appendix A: Getting Started: Installing LLVM and the Cpu0 example code" href="install.html" />
    <link rel="prev" title="C++ support" href="c%2B%2B.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</span></a></h1>
        <h2 class="heading"><span>Verify backend on Verilog simulator</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="c%2B%2B.html">C++ support</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="install.html">Appendix A: Getting Started: Installing LLVM and the Cpu0 example code</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="verify-backend-on-verilog-simulator">
<span id="sec-verilog"></span><h1>Verify backend on Verilog simulator<a class="headerlink" href="#verify-backend-on-verilog-simulator" title="Permalink to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#create-verilog-simulator-of-cpu0" id="id8">Create verilog simulator of Cpu0</a></p></li>
<li><p><a class="reference internal" href="#verify-backend" id="id9">Verify backend</a></p></li>
<li><p><a class="reference internal" href="#other-llvm-based-tools-for-cpu0-processor" id="id10">Other llvm based tools for Cpu0 processor</a></p></li>
</ul>
</nav>
<p>Until now, we have an llvm backend to compile C or assembly as the white part of
the following figure. If without global variable, the elf obj can be
dumped to hex file via <code class="docutils literal notranslate"><span class="pre">llvm-objdump</span> <span class="pre">-d</span></code> which finished in Chapter ELF Support.</p>
<div class="graphviz"><img src="_images/graphviz-00fb829f5101e41c988df69aac68285e3bdffcfd.png" alt="digraph G {
  rankdir=LR;
  &quot;Verilog machine&quot; [style=filled, color=gray];
  &quot;clang&quot; -&gt; &quot;llc&quot; [label=&quot;IR&quot;];
  &quot;llvm backend asm parser&quot; -&gt; &quot;llc&quot; [label=&quot;asm&quot;];
  &quot;llc&quot; -&gt; &quot;llvm-objdump -d&quot; [label=&quot;obj&quot;];
  &quot;llvm-objdump -d&quot; -&gt; &quot;Verilog machine&quot; [label=&quot;hex&quot;];
  
  label = &quot;Figure: Cpu0 backend without linker&quot;;
}" class="graphviz" /></div>
<p>This chapter will implement Cpu0 instructions by Verilog language as the gray
part of above figure.
With this Verilog machine, we can run this hex program on the Cpu0 Verilog
machine on PC and see the Cpu0 instructions execution result.</p>
<section id="create-verilog-simulator-of-cpu0">
<h2><a class="toc-backref" href="#id8" role="doc-backlink">Create verilog simulator of Cpu0</a><a class="headerlink" href="#create-verilog-simulator-of-cpu0" title="Permalink to this heading">¶</a></h2>
<p>Verilog language is an IEEE standard in IC design. There are a lot of books and
documents for this language. Free documents exist in Web sites <a class="footnote-reference brackets" href="#free-doc1" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>
<a class="footnote-reference brackets" href="#free-doc2" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#free-doc3" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#free-doc4" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#free-doc5" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a>.
Verilog also called as Verilog HDL but not VHDL.
VHDL is the same purpose language which compete against Verilog.
About VHDL reference here <a class="footnote-reference brackets" href="#vhdl" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a>.
Example code, lbdex/verilog/cpu0.v, is the Cpu0 design in Verilog.
In Appendix A, we have downloaded and installed Icarus Verilog tool both on
iMac and Linux. The cpu0.v is a simple design
with only few hundreds lines of code totally.
This implementation hasn’t the pipeline features, but through implement
the delay slot simulation (SIMULATE_DELAY_SLOT part of code), the exact pipeline
machine cycles can be calculated.</p>
<p>Verilog is a C like language in syntex and
this book is a compiler book, so we list the cpu0.v as well as the building
command without explanation as below.
We expect readers can understand the Verilog code just with a little patience in
reading it.
There are two type of I/O according computer architecture.
One is memory mapped I/O, the other is instruction I/O.
Cpu0 uses memory mapped I/O where memory address 0x80000 as the output port.
When meet the instruction <strong>“st $ra, cx($rb)”</strong>, where cx($rb) is
0x80000, Cpu0 displays the content as follows,</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="n">ST</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">begin</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">+</span><span class="n">c16</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="no">`IOADDR</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">    </span><span class="n">outw</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">a</span><span class="p">]);</span>
</pre></div>
</div>
<p class="rubric">lbdex/verilog/cpu0.v</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// https://www.francisz.cn/download/IEEE_Standard_1800-2012%20SystemVerilog.pdf

// configuable value below
`define SIMULATE_DELAY_SLOT
// cpu032I memory limit, jsub:24-bit
`define MEMSIZE   &#39;h1000000
`define MEMEMPTY   8&#39;hFF
`define NULL       8&#39;h00
`define IOADDR    &#39;hff000000  // IO mapping address
`define TIMEOUT   #3000000000


// Operand width
`define INT32 2&#39;b11     // 32 bits
`define INT24 2&#39;b10     // 24 bits
`define INT16 2&#39;b01     // 16 bits
`define BYTE  2&#39;b00     // 8  bits

`define EXE 3&#39;b000
`define RESET 3&#39;b001
`define ABORT 3&#39;b010
`define IRQ 3&#39;b011
`define ERROR 3&#39;b100

// Reference web: http://ccckmit.wikidot.com/ocs:cpu0
module cpu0(input clock, reset, input [2:0] itype, output reg [2:0] tick, 
            output reg [31:0] ir, pc, mar, mdr, inout [31:0] dbus, 
            output reg m_en, m_rw, output reg [1:0] m_size, 
            input cfg);
  reg signed [31:0] R [0:15];
  reg signed [31:0] C0R [0:1]; // co-processor 0 register
  // High and Low part of 64 bit result
  reg [7:0] op;
  reg [3:0] a, b, c;
  reg [4:0] c5;
  reg signed [31:0] c12, c16, c24, Ra, Rb, Rc, pc0; // pc0: instruction pc
  reg [31:0] uc16, URa, URb, URc, HI, LO, CF, tmp;
  reg [63:0] cycles;

  // register name
  `define SP   R[13]   // Stack Pointer
  `define LR   R[14]   // Link Register
  `define SW   R[15]   // Status Word

  // C0 register name
  `define PC   C0R[0]   // Program Counter
  `define EPC  C0R[1]  // exception PC value

  // SW Flage
  `define I2   `SW[16] // Hardware Interrupt 1, IO1 interrupt, status, 
                      // 1: in interrupt
  `define I1   `SW[15] // Hardware Interrupt 0, timer interrupt, status, 
                      // 1: in interrupt
  `define I0   `SW[14] // Software interrupt, status, 1: in interrupt
  `define I    `SW[13] // Interrupt, 1: in interrupt
  `define I2E  `SW[12]  // Hardware Interrupt 1, IO1 interrupt, Enable
  `define I1E  `SW[11]  // Hardware Interrupt 0, timer interrupt, Enable
  `define I0E  `SW[10]  // Software Interrupt Enable
  `define IE   `SW[9]  // Interrupt Enable
  `define M    `SW[8:6]  // Mode bits, itype
  `define D    `SW[5]  // Debug Trace
  `define V    `SW[3]  // Overflow
  `define C    `SW[2]  // Carry
  `define Z    `SW[1]  // Zero
  `define N    `SW[0]  // Negative flag
  
  `define LE   CF[0]  // Endian bit, Big Endian:0, Little Endian:1
  // Instruction Opcode 
  parameter [7:0] NOP=8&#39;h00,LD=8&#39;h01,ST=8&#39;h02,LB=8&#39;h03,LBu=8&#39;h04,SB=8&#39;h05,
  LH=8&#39;h06,LHu=8&#39;h07,SH=8&#39;h08,ADDiu=8&#39;h09,MOVZ=8&#39;h0A,MOVN=8&#39;h0B,ANDi=8&#39;h0C,
  ORi=8&#39;h0D,XORi=8&#39;h0E,LUi=8&#39;h0F,
  ADDu=8&#39;h11,SUBu=8&#39;h12,ADD=8&#39;h13,SUB=8&#39;h14,CLZ=8&#39;h15,CLO=8&#39;h16,MUL=8&#39;h17,
  AND=8&#39;h18,OR=8&#39;h19,XOR=8&#39;h1A,NOR=8&#39;h1B,
  ROL=8&#39;h1C,ROR=8&#39;h1D,SHL=8&#39;h1E,SHR=8&#39;h1F,
  SRA=8&#39;h20,SRAV=8&#39;h21,SHLV=8&#39;h22,SHRV=8&#39;h23,ROLV=8&#39;h24,RORV=8&#39;h25,
`ifdef CPU0II
  SLTi=8&#39;h26,SLTiu=8&#39;h27, SLT=8&#39;h28,SLTu=8&#39;h29,
`endif
  CMP=8&#39;h2A,
  CMPu=8&#39;h2B,
  JEQ=8&#39;h30,JNE=8&#39;h31,JLT=8&#39;h32,JGT=8&#39;h33,JLE=8&#39;h34,JGE=8&#39;h35,
  JMP=8&#39;h36,
`ifdef CPU0II
  BEQ=8&#39;h37,BNE=8&#39;h38,
`endif
  JALR=8&#39;h39,BAL=8&#39;h3A,JSUB=8&#39;h3B,RET=8&#39;h3C,
  MULT=8&#39;h41,MULTu=8&#39;h42,DIV=8&#39;h43,DIVu=8&#39;h44,
  MFHI=8&#39;h46,MFLO=8&#39;h47,MTHI=8&#39;h48,MTLO=8&#39;h49,
  MFC0=8&#39;h50,MTC0=8&#39;h51,C0MOV=8&#39;h52;

  reg [0:0] inExe = 0;
  reg [2:0] state, next_state; 
  reg [2:0] st_taskInt, ns_taskInt; 
  parameter Reset=3&#39;h0, Fetch=3&#39;h1, Decode=3&#39;h2, Execute=3&#39;h3, MemAccess=3&#39;h4, 
            WriteBack=3&#39;h5;
  integer i;
`ifdef SIMULATE_DELAY_SLOT
  reg [0:0] nextInstIsDelaySlot;
  reg [0:0] isDelaySlot;
  reg signed [31:0] delaySlotNextPC;
`endif

  //transform data from the memory to little-endian form
  task changeEndian(input [31:0] value, output [31:0] changeEndian); begin
    changeEndian = {value[7:0], value[15:8], value[23:16], value[31:24]};
  end endtask

  // Read Memory Word
  task memReadStart(input [31:0] addr, input [1:0] size); begin 
    mar = addr;     // read(m[addr])
    m_rw = 1;     // Access Mode: read 
    m_en = 1;     // Enable read
    m_size = size;
  end endtask

  // Read Memory Finish, get data
  task memReadEnd(output [31:0] data); begin
    mdr = dbus; // get momory, dbus = m[addr]
    data = mdr; // return to data
    m_en = 0; // read complete
  end endtask

  // Write memory -- addr: address to write, data: date to write
  task memWriteStart(input [31:0] addr, input [31:0] data, input [1:0] size); 
  begin 
    mar = addr;    // write(m[addr], data)
    mdr = data;
    m_rw = 0;    // access mode: write
    m_en = 1;     // Enable write
    m_size  = size;
  end endtask

  task memWriteEnd; begin // Write Memory Finish
    m_en = 0; // write complete
  end endtask

  task regSet(input [3:0] i, input [31:0] data); begin
    if (i != 0) R[i] = data;
  end endtask

  task C0regSet(input [3:0] i, input [31:0] data); begin
    if (i &lt; 2) C0R[i] = data;
  end endtask

  task PCSet(input [31:0] data); begin
  `ifdef SIMULATE_DELAY_SLOT
    nextInstIsDelaySlot = 1;
    delaySlotNextPC = data;
  `else
    `PC = data;
  `endif
  end endtask

  task retValSet(input [3:0] i, input [31:0] data); begin
    if (i != 0)
    `ifdef SIMULATE_DELAY_SLOT
      R[i] = data + 4;
    `else
      R[i] = data;
    `endif
  end endtask
  
  task regHILOSet(input [31:0] data1, input [31:0] data2); begin
    HI = data1;
    LO = data2;
  end endtask

  // output a word to Output port (equal to display the word to terminal)
  task outw(input [31:0] data); begin
    if (`LE) begin // Little Endian
      changeEndian(data, data);
    end 
    if (data[7:0] != 8&#39;h00) begin
      $write(&quot;%c&quot;, data[7:0]);
      if (data[15:8] != 8&#39;h00) 
        $write(&quot;%c&quot;, data[15:8]);
      if (data[23:16] != 8&#39;h00) 
        $write(&quot;%c&quot;, data[23:16]);
      if (data[31:24] != 8&#39;h00) 
        $write(&quot;%c&quot;, data[31:24]);
    end
  end endtask

  // output a character (a byte)
  task outc(input [7:0] data); begin
    $write(&quot;%c&quot;, data);
  end endtask

  task taskInterrupt(input [2:0] iMode); begin
  if (inExe == 0) begin
    case (iMode)
      `RESET: begin 
        `PC = 0; tick = 0; R[0] = 0; `SW = 0; `LR = -1;
        `IE = 0; `I0E = 1; `I1E = 1; `I2E = 1;
        `I = 0; `I0 = 0; `I1 = 0; `I2 = 0; inExe = 1;
        `LE = cfg;
        cycles = 0;
      end
      `ABORT: begin `PC = 4; end
      `IRQ:   begin `PC = 8; `IE = 0; inExe = 1; end
      `ERROR: begin `PC = 12; end
    endcase
  end
  $display(&quot;taskInterrupt(%3b)&quot;, iMode);
  end endtask

  task taskExecute; begin
    tick = tick+1;
    case (state)
    Fetch: begin  // Tick 1 : instruction fetch, throw PC to address bus, 
                  // memory.read(m[PC])
      memReadStart(`PC, `INT32);
      pc0  = `PC;
   `ifdef SIMULATE_DELAY_SLOT
     if (nextInstIsDelaySlot == 1) begin
       isDelaySlot = 1;
       nextInstIsDelaySlot = 0;
       `PC = delaySlotNextPC;
     end
     else begin
       if (isDelaySlot == 1) isDelaySlot = 0;
       `PC = `PC+4;
     end
   `else
     `PC = `PC+4;
   `endif
      next_state = Decode;
    end
    Decode: begin  // Tick 2 : instruction decode, ir = m[PC]
      memReadEnd(ir); // IR = dbus = m[PC]
      {op,a,b,c} = ir[31:12];
      c24 = $signed(ir[23:0]);
      c16 = $signed(ir[15:0]);
      uc16 = ir[15:0];
      c12 = $signed(ir[11:0]);
      c5  = ir[4:0];
      Ra = R[a];
      Rb = R[b];
      Rc = R[c];
      URa = R[a];
      URb = R[b];
      URc = R[c];
      next_state = Execute;
    end
    Execute: begin // Tick 3 : instruction execution
      case (op)
      NOP:   ;
      // load and store instructions
      LD:    memReadStart(Rb+c16, `INT32);      // LD Ra,[Rb+Cx]; Ra&lt;=[Rb+Cx]
      ST:    memWriteStart(Rb+c16, Ra, `INT32); // ST Ra,[Rb+Cx]; Ra=&gt;[Rb+Cx]
      // LB Ra,[Rb+Cx]; Ra&lt;=(byte)[Rb+Cx]
      LB:    memReadStart(Rb+c16, `BYTE);
      // LBu Ra,[Rb+Cx]; Ra&lt;=(byte)[Rb+Cx]
      LBu:   memReadStart(Rb+c16, `BYTE);
      // SB Ra,[Rb+Cx]; Ra=&gt;(byte)[Rb+Cx]
      SB:    memWriteStart(Rb+c16, Ra, `BYTE);
      LH:    memReadStart(Rb+c16, `INT16); // LH Ra,[Rb+Cx]; Ra&lt;=(2bytes)[Rb+Cx]
      LHu:   memReadStart(Rb+c16, `INT16); // LHu Ra,[Rb+Cx]; Ra&lt;=(2bytes)[Rb+Cx]
      // SH Ra,[Rb+Cx]; Ra=&gt;(2bytes)[Rb+Cx]
      SH:    memWriteStart(Rb+c16, Ra, `INT16);
      // Conditional move
      MOVZ:  if (Rc==0) regSet(a, Rb);             // move if Rc equal to 0
      MOVN:  if (Rc!=0) regSet(a, Rb);             // move if Rc not equal to 0
      // Mathematic 
      ADDiu: regSet(a, Rb+c16);                   // ADDiu Ra, Rb+Cx; Ra&lt;=Rb+Cx
      CMP:  begin 
        if (Rb &lt; Rc) `N=1; else `N=0;
        // `N=(Rb-Rc&lt;0); // why not work for bash make.sh cpu032I el Makefile.builtins?
       `Z=(Rb-Rc==0); 
      end // CMP Rb, Rc; SW=(Rb &gt;=&lt; Rc)
      CMPu:  begin 
        if (URb &lt; URc) `N=1; else `N=0; 
       `Z=(URb-URc==0); 
      end // CMPu URb, URc; SW=(URb &gt;=&lt; URc)
      ADDu:  regSet(a, Rb+Rc);               // ADDu Ra,Rb,Rc; Ra&lt;=Rb+Rc
      ADD:   begin regSet(a, Rb+Rc); if (a &lt; Rb) `V = 1; else `V = 0; 
        if (`V) begin `I0 = 1; `I = 1; end
      end
                                             // ADD Ra,Rb,Rc; Ra&lt;=Rb+Rc
      SUBu:  regSet(a, Rb-Rc);               // SUBu Ra,Rb,Rc; Ra&lt;=Rb-Rc
      SUB:   begin regSet(a, Rb-Rc); if (Rb &lt; 0 &amp;&amp; Rc &gt; 0 &amp;&amp; a &gt;= 0) 
             `V = 1; else `V =0; 
        if (`V) begin `I0 = 1; `I = 1; end
      end         // SUB Ra,Rb,Rc; Ra&lt;=Rb-Rc
      CLZ:   begin
        for (i=0; (i&lt;32)&amp;&amp;((Rb&amp;32&#39;h80000000)==32&#39;h00000000); i=i+1) begin
            Rb=Rb&lt;&lt;1;
        end
        regSet(a, i);
      end
      CLO:   begin
        for (i=0; (i&lt;32)&amp;&amp;((Rb&amp;32&#39;h80000000)==32&#39;h80000000); i=i+1) begin
            Rb=Rb&lt;&lt;1;
        end
        regSet(a, i);
      end
      MUL:   regSet(a, Rb*Rc);               // MUL Ra,Rb,Rc;     Ra&lt;=Rb*Rc
      DIVu:  regHILOSet(URa%URb, URa/URb);   // DIVu URa,URb; HI&lt;=URa%URb; 
                                             // LO&lt;=URa/URb
                                             // without exception overflow
      DIV:   begin regHILOSet(Ra%Rb, Ra/Rb); 
             if ((Ra &lt; 0 &amp;&amp; Rb &lt; 0) || (Ra == 0)) `V = 1; 
             else `V =0; end  // DIV Ra,Rb; HI&lt;=Ra%Rb; LO&lt;=Ra/Rb; With overflow
      AND:   regSet(a, Rb&amp;Rc);               // AND Ra,Rb,Rc; Ra&lt;=(Rb and Rc)
      ANDi:  regSet(a, Rb&amp;uc16);             // ANDi Ra,Rb,c16; Ra&lt;=(Rb and c16)
      OR:    regSet(a, Rb|Rc);               // OR Ra,Rb,Rc; Ra&lt;=(Rb or Rc)
      ORi:   regSet(a, Rb|uc16);             // ORi Ra,Rb,c16; Ra&lt;=(Rb or c16)
      XOR:   regSet(a, Rb^Rc);               // XOR Ra,Rb,Rc; Ra&lt;=(Rb xor Rc)
      NOR:   regSet(a, ~(Rb|Rc));            // NOR Ra,Rb,Rc; Ra&lt;=(Rb nor Rc)
      XORi:  regSet(a, Rb^uc16);             // XORi Ra,Rb,c16; Ra&lt;=(Rb xor c16)
      LUi:   regSet(a, uc16&lt;&lt;16);
      SHL:   regSet(a, Rb&lt;&lt;c5);     // Shift Left; SHL Ra,Rb,Cx; Ra&lt;=(Rb &lt;&lt; Cx)
      SRA:   regSet(a, (Rb&gt;&gt;&gt;c5));  // Shift Right with signed bit fill;
        // https://stackoverflow.com/questions/39911655/how-to-synthesize-hardware-for-sra-instruction
      SHR:   regSet(a, Rb&gt;&gt;c5);     // Shift Right with 0 fill; 
                                    // SHR Ra,Rb,Cx; Ra&lt;=(Rb &gt;&gt; Cx)
      SHLV:  regSet(a, Rb&lt;&lt;Rc);     // Shift Left; SHLV Ra,Rb,Rc; Ra&lt;=(Rb &lt;&lt; Rc)
      SRAV:  regSet(a, (Rb&gt;&gt;&gt;Rc));  // Shift Right with signed bit fill;
      SHRV:  regSet(a, Rb&gt;&gt;Rc);     // Shift Right with 0 fill; 
                                    // SHRV Ra,Rb,Rc; Ra&lt;=(Rb &gt;&gt; Rc)
      ROL:   regSet(a, (Rb&lt;&lt;c5)|(Rb&gt;&gt;(32-c5)));     // Rotate Left;
      ROR:   regSet(a, (Rb&gt;&gt;c5)|(Rb&lt;&lt;(32-c5)));     // Rotate Right;
      ROLV:  begin // Can set Rc to -32&lt;=Rc&lt;=32 more efficently.
        while (Rc &lt; -32) Rc=Rc+32;
        while (Rc &gt; 32) Rc=Rc-32;
        regSet(a, (Rb&lt;&lt;Rc)|(Rb&gt;&gt;(32-Rc)));     // Rotate Left;
      end
      RORV:  begin 
        while (Rc &lt; -32) Rc=Rc+32;
        while (Rc &gt; 32) Rc=Rc-32;
        regSet(a, (Rb&gt;&gt;Rc)|(Rb&lt;&lt;(32-Rc)));     // Rotate Right;
      end
      MFLO:  regSet(a, LO);         // MFLO Ra; Ra&lt;=LO
      MFHI:  regSet(a, HI);         // MFHI Ra; Ra&lt;=HI
      MTLO:  LO = Ra;               // MTLO Ra; LO&lt;=Ra
      MTHI:  HI = Ra;               // MTHI Ra; HI&lt;=Ra
      MULT:  {HI, LO}=Ra*Rb;        // MULT Ra,Rb; HI&lt;=((Ra*Rb)&gt;&gt;32); 
                                    // LO&lt;=((Ra*Rb) and 0x00000000ffffffff);
                                    // with exception overflow
      MULTu: {HI, LO}=URa*URb;      // MULT URa,URb; HI&lt;=((URa*URb)&gt;&gt;32); 
                                    // LO&lt;=((URa*URb) and 0x00000000ffffffff);
                                    // without exception overflow
      MFC0:  regSet(a, C0R[b]);     // MFC0 a, b; Ra&lt;=C0R[Rb]
      MTC0:  C0regSet(a, Rb);       // MTC0 a, b; C0R[a]&lt;=Rb
      C0MOV: C0regSet(a, C0R[b]);   // C0MOV a, b; C0R[a]&lt;=C0R[b]
   `ifdef CPU0II
      // set
      SLT:   if (Rb &lt; Rc) R[a]=1; else R[a]=0;
      SLTu:  if (URb &lt; URc) R[a]=1; else R[a]=0;
      SLTi:  if (Rb &lt; c16) R[a]=1; else R[a]=0;
      SLTiu: if (URb &lt; uc16) R[a]=1; else R[a]=0;
      // Branch Instructions
      BEQ:   if (Ra==Rb) PCSet(`PC+c16);
      BNE:   if (Ra!=Rb) PCSet(`PC+c16);
    `endif
      // Jump Instructions
      JEQ:   if (`Z) PCSet(`PC+c24);            // JEQ Cx; if SW(=) PC  PC+Cx
      JNE:   if (!`Z) PCSet(`PC+c24);           // JNE Cx; if SW(!=) PC PC+Cx
      JLT:   if (`N) PCSet(`PC+c24);            // JLT Cx; if SW(&lt;) PC  PC+Cx
      JGT:   if (!`N&amp;&amp;!`Z) PCSet(`PC+c24);      // JGT Cx; if SW(&gt;) PC  PC+Cx
      JLE:   if (`N || `Z) PCSet(`PC+c24);      // JLE Cx; if SW(&lt;=) PC PC+Cx    
      JGE:   if (!`N || `Z) PCSet(`PC+c24);     // JGE Cx; if SW(&gt;=) PC PC+Cx
      JMP:   `PC = `PC+c24;                     // JMP Cx; PC &lt;= PC+Cx
      JALR:  begin retValSet(a, `PC); PCSet(Rb); end    // JALR Ra,Rb; Ra&lt;=PC; PC&lt;=Rb
      BAL:   begin `LR = `PC; `PC = `PC+c24; end // BAL Cx; LR&lt;=PC; PC&lt;=PC+Cx
      JSUB:  begin retValSet(14, `PC); PCSet(`PC+c24); end // JSUB Cx; LR&lt;=PC; PC&lt;=PC+Cx
      RET:   begin PCSet(Ra); end               // RET; PC &lt;= Ra
      default : 
        $display(&quot;%4dns %8x : OP code %8x not support&quot;, $stime, pc0, op);
      endcase
      if (`IE &amp;&amp; `I &amp;&amp; (`I0E &amp;&amp; `I0 || `I1E &amp;&amp; `I1 || `I2E &amp;&amp; `I2)) begin
        `EPC = `PC;
        next_state = Fetch;
        inExe = 0;
      end else
        next_state = MemAccess;
    end
    MemAccess: begin
      case (op)
      ST, SB, SH  :
        memWriteEnd();                // write memory complete
      endcase
      next_state = WriteBack;
    end
    WriteBack: begin // Read/Write finish, close memory
      case (op)
      LB, LBu  :
        memReadEnd(R[a]);        //read memory complete
      LH, LHu  :
        memReadEnd(R[a]);
      LD  : begin
        memReadEnd(R[a]);
        if (`D)
          $display(&quot;%4dns %8x : %8x m[%-04x+%-04x]=%8x  SW=%8x&quot;, $stime, pc0, 
                   ir, R[b], c16, R[a], `SW);
      end
      endcase
      case (op)
      LB  : begin 
        if (R[a] &gt; 8&#39;h7f) R[a]=R[a]|32&#39;hffffff80;
      end
      LH  : begin 
        if (R[a] &gt; 16&#39;h7fff) R[a]=R[a]|32&#39;hffff8000;
      end
      endcase
      case (op)
      MULT, MULTu, DIV, DIVu, MTHI, MTLO :
        if (`D)
          $display(&quot;%4dns %8x : %8x HI=%8x LO=%8x SW=%8x&quot;, $stime, pc0, ir, HI, 
                   LO, `SW);
      ST : begin
        if (`D)
          $display(&quot;%4dns %8x : %8x m[%-04x+%-04x]=%8x  SW=%8x&quot;, $stime, pc0, 
                   ir, R[b], c16, R[a], `SW);
        if (R[b]+c16 == `IOADDR) begin
          outw(R[a]);
        end
      end
      SB : begin
        if (`D)
          $display(&quot;%4dns %8x : %8x m[%-04x+%-04x]=%c  SW=%8x, R[a]=%8x&quot;, 
                   $stime, pc0, ir, R[b], c16, R[a][7:0], `SW, R[a]);
        if (R[b]+c16 == `IOADDR) begin
          if (`LE)
            outc(R[a][7:0]);
          else
            outc(R[a][7:0]);
        end
      end
      MFC0, MTC0 :
        if (`D)
          $display(&quot;%4dns %8x : %8x R[%02d]=%-8x  C0R[%02d]=%-8x SW=%8x&quot;, 
                   $stime, pc0, ir, a, R[a], a, C0R[a], `SW);
      C0MOV :
        if (`D)
          $display(&quot;%4dns %8x : %8x C0R[%02d]=%-8x C0R[%02d]=%-8x SW=%8x&quot;, 
                   $stime, pc0, ir, a, C0R[a], b, C0R[b], `SW);
      default :
        if (`D) // Display the written register content
          $display(&quot;%4dns %8x : %8x R[%02d]=%-8x SW=%8x&quot;, $stime, pc0, ir, 
                   a, R[a], `SW);
      endcase
      if (`PC &lt; 0) begin
        $display(&quot;total cpu cycles = %-d&quot;, cycles);
        $display(&quot;RET to PC &lt; 0, finished!&quot;);
        $finish;
      end
      next_state = Fetch;
    end
    endcase
  end endtask

  always @(posedge clock) begin
    if (inExe == 0 &amp;&amp; (state == Fetch) &amp;&amp; (`IE &amp;&amp; `I) &amp;&amp; (`I0E &amp;&amp; `I0)) begin
    // software int
      `M = `IRQ;
      taskInterrupt(`IRQ);
      m_en = 0;
      state = Fetch;
    end else if (inExe == 0 &amp;&amp; (state == Fetch) &amp;&amp; (`IE &amp;&amp; `I) &amp;&amp; 
                 ((`I1E &amp;&amp; `I1) || (`I2E &amp;&amp; `I2)) ) begin
      `M = `IRQ;
      taskInterrupt(`IRQ);
      m_en = 0;
      state = Fetch;
    end else if (inExe == 0 &amp;&amp; itype == `RESET) begin
    // Condition itype == `RESET must after the other `IE condition
      taskInterrupt(`RESET);
      `M = `RESET;
      state = Fetch;
    end else begin
    `ifdef TRACE
      `D = 1; // Trace register content at beginning
    `endif
      taskExecute();
      state = next_state;
    end
    pc = `PC;
    cycles = cycles + 1;
  end
endmodule

module memory0(input clock, reset, en, rw, input [1:0] m_size, 
               input [31:0] abus, dbus_in, output [31:0] dbus_out, 
               output cfg);
  reg [31:0] mconfig [0:0];
  reg [7:0] m [0:`MEMSIZE-1];
  reg [31:0] data;

  integer i;

  `define LE  mconfig[0][0:0]   // Endian bit, Big Endian:0, Little Endian:1

  initial begin
  // erase memory
    for (i=0; i &lt; `MEMSIZE; i=i+1) begin
       m[i] = `MEMEMPTY;
    end
  // load config from file to memory
    $readmemh(&quot;cpu0.config&quot;, mconfig);
  // load program from file to memory
    $readmemh(&quot;cpu0.hex&quot;, m);
  // display memory contents
    `ifdef TRACE
      for (i=0; i &lt; `MEMSIZE &amp;&amp; (m[i] != `MEMEMPTY || m[i+1] != `MEMEMPTY || 
         m[i+2] != `MEMEMPTY || m[i+3] != `MEMEMPTY); i=i+4) begin
        $display(&quot;%8x: %8x&quot;, i, {m[i], m[i+1], m[i+2], m[i+3]});
      end
    `endif
  end

  always @(clock or abus or en or rw or dbus_in) 
  begin
    if (abus &gt;= 0 &amp;&amp; abus &lt;= `MEMSIZE-4) begin
      if (en == 1 &amp;&amp; rw == 0) begin // r_w==0:write
        data = dbus_in;
        if (`LE) begin // Little Endian
          case (m_size)
          `BYTE:  {m[abus]} = dbus_in[7:0];
          `INT16: {m[abus], m[abus+1] } = {dbus_in[7:0], dbus_in[15:8]};
          `INT24: {m[abus], m[abus+1], m[abus+2]} = 
                  {dbus_in[7:0], dbus_in[15:8], dbus_in[23:16]};
          `INT32: {m[abus], m[abus+1], m[abus+2], m[abus+3]} = 
                  {dbus_in[7:0], dbus_in[15:8], dbus_in[23:16], dbus_in[31:24]};
          endcase
        end else begin // Big Endian
          case (m_size)
          `BYTE:  {m[abus]} = dbus_in[7:0];
          `INT16: {m[abus], m[abus+1] } = dbus_in[15:0];
          `INT24: {m[abus], m[abus+1], m[abus+2]} = dbus_in[23:0];
          `INT32: {m[abus], m[abus+1], m[abus+2], m[abus+3]} = dbus_in;
          endcase
        end
      end else if (en == 1 &amp;&amp; rw == 1) begin // r_w==1:read
        if (`LE) begin // Little Endian
          case (m_size)
          `BYTE:  data = {8&#39;h00,     8&#39;h00,     8&#39;h00,     m[abus]};
          `INT16: data = {8&#39;h00,     8&#39;h00,     m[abus+1], m[abus]};
          `INT24: data = {8&#39;h00,     m[abus+2], m[abus+1], m[abus]};
          `INT32: data = {m[abus+3], m[abus+2], m[abus+1], m[abus]};
          endcase
        end else begin // Big Endian
          case (m_size)
          `BYTE:  data = {8&#39;h00  , 8&#39;h00,     8&#39;h00,     m[abus]  };
          `INT16: data = {8&#39;h00  , 8&#39;h00,     m[abus],   m[abus+1]};
          `INT24: data = {8&#39;h00  , m[abus],   m[abus+1], m[abus+2]};
          `INT32: data = {m[abus], m[abus+1], m[abus+2], m[abus+3]};
          endcase
        end
      end else
        data = 32&#39;hZZZZZZZZ;
    end else 
      data = 32&#39;hZZZZZZZZ;
  end
  assign dbus_out = data;
  assign cfg = mconfig[0][0:0];
endmodule

module main;
  reg clock;
  reg [2:0] itype;
  wire [2:0] tick;
  wire [31:0] pc, ir, mar, mdr, dbus;
  wire m_en, m_rw;
  wire [1:0] m_size;
  wire cfg;

  cpu0 cpu(.clock(clock), .itype(itype), .pc(pc), .tick(tick), .ir(ir),
  .mar(mar), .mdr(mdr), .dbus(dbus), .m_en(m_en), .m_rw(m_rw), .m_size(m_size),
  .cfg(cfg));

  memory0 mem(.clock(clock), .reset(reset), .en(m_en), .rw(m_rw), 
  .m_size(m_size), .abus(mar), .dbus_in(mdr), .dbus_out(dbus), .cfg(cfg));

  initial
  begin
    clock = 0;
    itype = `RESET;
    `TIMEOUT $finish;
  end

  always #10 clock=clock+1;

endmodule
</pre></div>
</div>
<p class="rubric">lbdex/verilog/Makefile</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#TRACE=-D TRACE
all:
	iverilog ${TRACE} -o cpu0Is cpu0.v 
	iverilog ${TRACE} -D CPU0II -o cpu0IIs cpu0.v 

.PHONY: clean
clean:
	rm -rf cpu0.hex cpu0Is cpu0IIs 
	rm -f *~ cpu0.config

</pre></div>
</div>
<p>Since Cpu0 Verilog machine supports both big and little endian, the memory
and cpu module both have a wire connectting each other.
The endian information stored in ROM of memory module, and memory module send
the information when it is up according the following code,</p>
<p class="rubric">lbdex/verilog/cpu0.v</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">assign cfg = mconfig[0][0:0];</span>
<span class="go">...</span>
<span class="go">wire cfg;</span>

<span class="go">cpu0 cpu(.clock(clock), .itype(itype), .pc(pc), .tick(tick), .ir(ir),</span>
<span class="go">.mar(mar), .mdr(mdr), .dbus(dbus), .m_en(m_en), .m_rw(m_rw), .m_size(m_size),</span>
<span class="go">.cfg(cfg));</span>

<span class="go">memory0 mem(.clock(clock), .reset(reset), .en(m_en), .rw(m_rw),</span>
<span class="go">.m_size(m_size), .abus(mar), .dbus_in(mdr), .dbus_out(dbus), .cfg(cfg));</span>
</pre></div>
</div>
<p>Instead of setting endian tranfer in memory module, the endian transfer can
also be set in CPU module, and memory moudle always return with big endian.
I am not an professional engineer in FPGA/CPU hardware design.
But according book “Computer
Architecture: A Quantitative Approach”, some operations may have no tolerance
in time of execution stage. Any endian swap will make the clock cycle time
longer and affect the CPU performance. So, I set the endian transfer in memory
module. In system with bus, it will be set in bus system I think.</p>
</section>
<section id="verify-backend">
<h2><a class="toc-backref" href="#id9" role="doc-backlink">Verify backend</a><a class="headerlink" href="#verify-backend" title="Permalink to this heading">¶</a></h2>
<p>Now let’s compile ch_run_backend.cpp as below. Since code size grows up from
low to high address and stack grows up from high to low address. $sp is set
at 0x7fffc because assuming cpu0.v uses 0x80000 bytes of memory.</p>
<p class="rubric">lbdex/input/start.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="c1">#ifndef _START_H_</span>
<span class="c1">#define _START_H_</span>

<span class="c1">#include &quot;config.h&quot;</span>

<span class="c1">#define SET_SW \</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;andi $sw, $zero, 0&quot;</span><span class="p">);</span> \
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;ori  $sw, $sw, 0x1e00&quot;</span><span class="p">);</span> <span class="o">//</span> <span class="n">enable</span> <span class="nb">all</span> <span class="n">interrupts</span>

<span class="c1">#define initRegs() \</span>
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;addiu $1,  $zero, 0&quot;</span><span class="p">);</span> \
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;addiu $2,  $zero, 0&quot;</span><span class="p">);</span> \
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;addiu $3,  $zero, 0&quot;</span><span class="p">);</span> \
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;addiu $4,  $zero, 0&quot;</span><span class="p">);</span> \
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;addiu $5,  $zero, 0&quot;</span><span class="p">);</span> \
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;addiu $t9, $zero, 0&quot;</span><span class="p">);</span> \
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;addiu $7,  $zero, 0&quot;</span><span class="p">);</span> \
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;addiu $8,  $zero, 0&quot;</span><span class="p">);</span> \
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;addiu $9,  $zero, 0&quot;</span><span class="p">);</span> \
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;addiu $10, $zero, 0&quot;</span><span class="p">);</span> \
  <span class="n">SET_SW</span><span class="p">;</span>                     \
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;addiu $fp, $zero, 0&quot;</span><span class="p">);</span>

<span class="c1">#endif</span>
</pre></div>
</div>
<p class="rubric">lbdex/input/boot.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="c1">#include &quot;start.h&quot;</span>

<span class="o">//</span> <span class="n">boot</span><span class="p">:</span>
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;boot:&quot;</span><span class="p">);</span>
<span class="o">//</span>  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;_start:&quot;</span><span class="p">);</span>
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;jmp 12&quot;</span><span class="p">);</span> <span class="o">//</span> <span class="n">RESET</span><span class="p">:</span> <span class="n">jmp</span> <span class="n">RESET_START</span><span class="p">;</span>
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;jmp 4&quot;</span><span class="p">);</span>  <span class="o">//</span> <span class="n">ERROR</span><span class="p">:</span> <span class="n">jmp</span> <span class="n">ERR_HANDLE</span><span class="p">;</span>
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;jmp 4&quot;</span><span class="p">);</span>  <span class="o">//</span> <span class="n">IRQ</span><span class="p">:</span> <span class="n">jmp</span> <span class="n">IRQ_HANDLE</span><span class="p">;</span>
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;jmp -4&quot;</span><span class="p">);</span> <span class="o">//</span> <span class="n">ERR_HANDLE</span><span class="p">:</span> <span class="n">jmp</span> <span class="n">ERR_HANDLE</span><span class="p">;</span> <span class="p">(</span><span class="n">loop</span> <span class="n">forever</span><span class="p">)</span>

<span class="o">//</span> <span class="n">RESET_START</span><span class="p">:</span>
  <span class="n">initRegs</span><span class="p">();</span>
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;addiu $gp, $ZERO, 0&quot;</span><span class="p">);</span>
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;addiu $lr, $ZERO, -1&quot;</span><span class="p">);</span>
  
  <span class="n">INIT_SP</span><span class="p">;</span>
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;mfc0 $3, $pc&quot;</span><span class="p">);</span>
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;addiu $3, $3, 0x8&quot;</span><span class="p">);</span> <span class="o">//</span> <span class="n">Assume</span> <span class="n">main</span><span class="p">()</span> <span class="n">entry</span> <span class="n">point</span> <span class="ow">is</span> <span class="n">at</span> <span class="n">the</span> <span class="nb">next</span> <span class="nb">next</span> 
                             <span class="o">//</span> <span class="n">instruction</span><span class="o">.</span>
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;jr $3&quot;</span><span class="p">);</span>
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;nop&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">lbdex/input/print.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#ifndef _PRINT_H_</span>
<span class="c1">#define _PRINT_H_</span>

<span class="c1">#include &quot;start.h&quot;</span>

<span class="n">void</span> <span class="n">print_char</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="n">c</span><span class="p">);</span>
<span class="n">void</span> <span class="n">dump_mem</span><span class="p">(</span><span class="n">unsigned</span> <span class="n">char</span> <span class="o">*</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span> <span class="n">n</span><span class="p">);</span>
<span class="n">void</span> <span class="n">print_string</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="nb">str</span><span class="p">);</span>
<span class="n">void</span> <span class="n">print_integer</span><span class="p">(</span><span class="nb">int</span> <span class="n">x</span><span class="p">);</span>
<span class="c1">#endif</span>
</pre></div>
</div>
<p class="rubric">lbdex/input/print.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &quot;print.h&quot;</span>
<span class="c1">#include &quot;itoa.cpp&quot;</span>

<span class="o">//</span> <span class="n">For</span> <span class="n">memory</span> <span class="n">IO</span>
<span class="n">void</span> <span class="n">print_char</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">char</span><span class="o">*</span><span class="p">)</span><span class="n">IOADDR</span><span class="p">;</span>
  <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>

  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">print_string</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="nb">str</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="nb">str</span><span class="p">;</span> <span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="s1">&#39;</span><span class="se">\0</span><span class="s1">&#39;</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span>
    <span class="n">print_char</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
  <span class="n">print_char</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
  <span class="n">print_char</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">);</span>

  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">For</span> <span class="n">memory</span> <span class="n">IO</span>
<span class="n">void</span> <span class="n">print_integer</span><span class="p">(</span><span class="nb">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">char</span> <span class="nb">str</span><span class="p">[</span><span class="n">INT_DIGITS</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
  <span class="n">itoa</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
  <span class="n">print_string</span><span class="p">(</span><span class="nb">str</span><span class="p">);</span>

  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

</pre></div>
</div>
<p class="rubric">lbdex/input/ch_nolld.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="c1">#include &quot;debug.h&quot;</span>
<span class="c1">#include &quot;boot.cpp&quot;</span>

<span class="c1">#include &quot;print.h&quot;</span>

<span class="nb">int</span> <span class="n">test_nolld</span><span class="p">();</span>
</pre></div>
</div>
<p class="rubric">lbdex/input/ch_nolld.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#define TEST_ROXV</span>
<span class="c1">#define RUN_ON_VERILOG</span>

<span class="c1">#include &quot;print.cpp&quot;</span>

<span class="c1">#include &quot;ch4_1_math.cpp&quot;</span>
<span class="c1">#include &quot;ch4_1_rotate.cpp&quot;</span>
<span class="c1">#include &quot;ch4_1_mult2.cpp&quot;</span>
<span class="c1">#include &quot;ch4_1_mod.cpp&quot;</span>
<span class="c1">#include &quot;ch4_1_div.cpp&quot;</span>
<span class="c1">#include &quot;ch4_2_logic.cpp&quot;</span>
<span class="c1">#include &quot;ch7_1_localpointer.cpp&quot;</span>
<span class="c1">#include &quot;ch7_1_char_short.cpp&quot;</span>
<span class="c1">#include &quot;ch7_1_bool.cpp&quot;</span>
<span class="c1">#include &quot;ch7_1_longlong.cpp&quot;</span>
<span class="c1">#include &quot;ch7_1_vector.cpp&quot;</span>
<span class="c1">#include &quot;ch8_1_ctrl.cpp&quot;</span>
<span class="c1">#include &quot;ch8_2_deluselessjmp.cpp&quot;</span>
<span class="c1">#include &quot;ch8_2_select.cpp&quot;</span>
<span class="c1">#include &quot;ch9_1_longlong.cpp&quot;</span>
<span class="c1">#include &quot;ch9_3_vararg.cpp&quot;</span>
<span class="c1">#include &quot;ch9_3_stacksave.cpp&quot;</span>
<span class="c1">#include &quot;ch9_3_bswap.cpp&quot;</span>
<span class="c1">#include &quot;ch9_3_alloc.cpp&quot;</span>
<span class="c1">#include &quot;ch11_2.cpp&quot;</span>

<span class="o">//</span> <span class="n">Test</span> <span class="n">build</span> <span class="n">only</span> <span class="k">for</span> <span class="n">the</span> <span class="n">following</span> <span class="n">files</span> <span class="n">on</span> <span class="n">build</span><span class="o">-</span><span class="n">run_backend</span><span class="o">.</span><span class="n">sh</span> <span class="n">since</span> <span class="n">it</span> 
<span class="o">//</span> <span class="n">needs</span> <span class="n">lld</span> <span class="n">linker</span> <span class="n">support</span><span class="o">.</span>
<span class="o">//</span> <span class="n">Test</span> <span class="ow">in</span> <span class="n">build</span><span class="o">-</span><span class="n">slink</span><span class="o">.</span><span class="n">sh</span>
<span class="c1">#include &quot;ch6_1.cpp&quot;</span>
<span class="c1">#include &quot;ch9_1_struct.cpp&quot;</span>
<span class="c1">#include &quot;ch9_1_constructor.cpp&quot;</span>
<span class="c1">#include &quot;ch9_3_template.cpp&quot;</span>
<span class="c1">#include &quot;ch12_inherit.cpp&quot;</span>

<span class="n">void</span> <span class="n">test_asm_build</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">#include &quot;ch11_1.cpp&quot;</span>
<span class="c1">#ifdef CPU032II</span>
  <span class="c1">#include &quot;ch11_1_2.cpp&quot;</span>
<span class="c1">#endif</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">test_rotate</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">test_rotate_left1</span><span class="p">();</span> <span class="o">//</span> <span class="n">rolv</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">30</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="nb">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">test_rotate_left</span><span class="p">();</span> <span class="o">//</span> <span class="n">rol</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">30</span>  <span class="o">=</span> <span class="mi">2</span>
  <span class="nb">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">test_rotate_right</span><span class="p">();</span> <span class="o">//</span> <span class="n">rorv</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">30</span> <span class="o">=</span> <span class="mi">4</span>
  
  <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">test_nolld</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">bool</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">true</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">a</span> <span class="o">=</span> <span class="n">test_math</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">68</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">68</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_rotate</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">7</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">7</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_mult</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_mod</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_div</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">253</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">253</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_local_pointer</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">3</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="n">test_load_bool</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_andorxornotcomplement</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">13</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">13</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_setxx</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">3</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_signed_char</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mi">126</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">126</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_unsigned_char</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">130</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">130</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_signed_short</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mi">32766</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">32766</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_unsigned_short</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">32770</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">32770</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">long</span> <span class="n">long</span> <span class="n">b</span> <span class="o">=</span> <span class="n">test_longlong</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">((</span><span class="nb">int</span><span class="p">)(</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">));</span> <span class="o">//</span> <span class="mi">393307</span>
  <span class="k">if</span> <span class="p">((</span><span class="nb">int</span><span class="p">)(</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">393307</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">print_integer</span><span class="p">((</span><span class="nb">int</span><span class="p">)</span><span class="n">b</span><span class="p">);</span> <span class="o">//</span> <span class="mi">16777218</span>
  <span class="k">if</span> <span class="p">((</span><span class="nb">int</span><span class="p">)(</span><span class="n">b</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">16777218</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_cmplt_short</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">3</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_cmplt_long</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mi">4</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">4</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_control1</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>	<span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">51</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">51</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_DelUselessJMP</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_movx_1</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">3</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_movx_2</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="mi">2147483647</span><span class="p">);</span> <span class="o">//</span> <span class="n">test</span> <span class="n">mod</span> <span class="o">%</span> <span class="p">(</span><span class="n">mult</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">itoa.cpp</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="o">-</span><span class="mi">2147483648</span><span class="p">);</span> <span class="o">//</span> <span class="n">test</span> <span class="n">mod</span> <span class="o">%</span> <span class="p">(</span><span class="n">multu</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">itoa.cpp</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_sum_longlong</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">9</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">9</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_va_arg</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">12</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">12</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_stacksaverestore</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">5</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_bswap</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_alloc</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">31</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">31</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_inlineasm</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">49</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">49</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>

  <span class="k">return</span> <span class="k">pass</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/input/ch_run_backend.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="c1">#include &quot;ch_nolld.h&quot;</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">bool</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">true</span><span class="p">;</span>
  <span class="k">pass</span> <span class="o">=</span> <span class="n">test_nolld</span><span class="p">();</span>

  <span class="k">return</span> <span class="k">pass</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">#include &quot;ch_nolld.cpp&quot;</span>
</pre></div>
</div>
<p class="rubric">lbdex/input/functions.sh</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>prologue() {
  if [ $ARG_NUM == 0 ]; then
    echo &quot;useage: bash $sh_name cpu_type endian&quot;
    echo &quot;  cpu_type: cpu032I or cpu032II&quot;
    echo &quot;  endian: eb (big endian, default) or el (little endian)&quot;
    echo &quot;for example:&quot;
    echo &quot;  bash build-slinker.sh cpu032I be&quot;
    exit 1;
  fi
  if [ $CPU != cpu032I ] &amp;&amp; [ $CPU != cpu032II ]; then
    echo &quot;1st argument is cpu032I or cpu032II&quot;
    exit 1
  fi

  OS=`uname -s`
  echo &quot;OS =&quot; ${OS}

  TOOLDIR=~/llvm/test/build/bin
  CLANG=~/llvm/test/build/bin/clang

  CPU=$CPU
  echo &quot;CPU =&quot; &quot;${CPU}&quot;

  if [ &quot;$ENDIAN&quot; != &quot;&quot; ] &amp;&amp; [ $ENDIAN != el ] &amp;&amp; [ $ENDIAN != eb ]; then
    echo &quot;2nd argument is eb (big endian, default) or el (little endian)&quot;
    exit 1
  fi
  if [ $ENDIAN == eb ]; then
    ENDIAN=
  fi
  echo &quot;ENDIAN =&quot; &quot;${ENDIAN}&quot;

  bash clean.sh
}

isLittleEndian() {
  echo &quot;ENDIAN = &quot; &quot;$ENDIAN&quot;
  if [ &quot;$ENDIAN&quot; == &quot;LittleEndian&quot; ] ; then
    LE=&quot;true&quot;
  elif [ &quot;$ENDIAN&quot; == &quot;BigEndian&quot; ] ; then
    LE=&quot;false&quot;
  else
    echo &quot;!ENDIAN unknown&quot;
    exit 1
  fi
}

elf2hex() {
  ${TOOLDIR}/llvm-objdump -elf2hex -le=$LE a.out &gt; ../verilog/cpu0.hex
  if [ $LE == &quot;true&quot; ] ; then
    echo &quot;1   /* 0: big endian, 1: little endian */&quot; &gt; ../verilog/cpu0.config
  else
    echo &quot;0   /* 0: big endian, 1: little endian */&quot; &gt; ../verilog/cpu0.config
  fi
  cat ../verilog/cpu0.config
}

epilogue() {
  endian=`${TOOLDIR}/llvm-readobj -h a.out|grep &quot;DataEncoding&quot;|awk &#39;{print $2}&#39;`
  isLittleEndian;
  elf2hex;
}
</pre></div>
</div>
<p class="rubric">lbdex/input/build-run_backend.sh</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#!/usr/bin/env bash

# for example:
# bash build-run_backend.sh cpu032I el
# bash build-run_backend.sh cpu032II eb

source functions.sh

sh_name=build-run_backend.sh
ARG_NUM=$#
CPU=$1
ENDIAN=$2

DEFFLAGS=&quot;&quot;
if [ &quot;$CPU&quot; == cpu032II ] ; then
  DEFFLAGS=${DEFFLAGS}&quot; -DCPU032II&quot;
fi
echo ${DEFFLAGS}

prologue;

# ch8_2_select_global_pic.cpp just for compile build test only, without running 
# on verilog.
$CLANG ${DEFFLAGS} -target mips-unknown-linux-gnu -c ch8_2_select_global_pic.cpp \
-emit-llvm -o ch8_2_select_global_pic.bc
${TOOLDIR}/llc -march=cpu0${ENDIAN} -mcpu=${CPU} -relocation-model=pic \
-filetype=obj ch8_2_select_global_pic.bc -o ch8_2_select_global_pic.cpu0.o

$CLANG ${DEFFLAGS} -target mips-unknown-linux-gnu -c ch_run_backend.cpp \
-emit-llvm -o ch_run_backend.bc
echo &quot;${TOOLDIR}/llc -march=cpu0${ENDIAN} -mcpu=${CPU} -relocation-model=static \
-filetype=obj -enable-cpu0-tail-calls ch_run_backend.bc -o ch_run_backend.cpu0.o&quot;
${TOOLDIR}/llc -march=cpu0${ENDIAN} -mcpu=${CPU} -relocation-model=static \
-filetype=obj -enable-cpu0-tail-calls ch_run_backend.bc -o ch_run_backend.cpu0.o
# print must at the same line, otherwise it will spilt into 2 lines
${TOOLDIR}/llvm-objdump --section=.text -d ch_run_backend.cpu0.o | tail -n +8| awk \
&#39;{print &quot;/* &quot; $1 &quot; */\t&quot; $2 &quot; &quot; $3 &quot; &quot; $4 &quot; &quot; $5 &quot;\t/* &quot; $6&quot;\t&quot; $7&quot; &quot; $8&quot; &quot; $9&quot; &quot; $10 &quot;\t*/&quot;}&#39; \
 &gt; ../verilog/cpu0.hex

ENDIAN=`${TOOLDIR}/llvm-readobj -h ch_run_backend.cpu0.o|grep &quot;DataEncoding&quot;|awk &#39;{print $2}&#39;`
isLittleEndian;

if [ $LE == &quot;true&quot; ] ; then
  echo &quot;1   /* 0: big ENDIAN, 1: little ENDIAN */&quot; &gt; ../verilog/cpu0.config
else
  echo &quot;0   /* 0: big ENDIAN, 1: little ENDIAN */&quot; &gt; ../verilog/cpu0.config
fi
cat ../verilog/cpu0.config
</pre></div>
</div>
<p>To run program without linker implementation at this point, the boot.cpp must be
set at the beginning of code, and the main() of ch_run_backend.cpp comes
immediately after it.
Let’s run Chapter11_2/ with <code class="docutils literal notranslate"><span class="pre">llvm-objdump</span> <span class="pre">-d</span></code> for input file
ch_run_backend.cpp to generate the hex file via build-run_bacekend.sh, then
feed hex file to cpu0Is Verilog simulator to get the output result as below.
Remind ch_run_backend.cpp have to be compiled with option
<code class="docutils literal notranslate"><span class="pre">clang</span> <span class="pre">-target</span> <span class="pre">mips-unknown-linux-gnu</span></code> since the example code
ch9_3_vararg.cpp which uses the vararg needs to be compiled with this option.
Other example codes have no differences between this option and default option.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span><span class="nb">pwd</span>
<span class="go">/Users/Jonathan/llvm/test/lbdex/input</span>
<span class="gp">JonathantekiiMac:input Jonathan$ </span>bash<span class="w"> </span>build-run_backend.sh<span class="w"> </span>cpu032I<span class="w"> </span>eb
<span class="gp">JonathantekiiMac:input Jonathan$ </span><span class="nb">cd</span><span class="w"> </span>../verilog<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>../verilog
<span class="gp">JonathantekiiMac:input Jonathan$ </span><span class="nb">pwd</span>
<span class="go">/Users/Jonathan/llvm/test/lbdex/verilog</span>
<span class="gp">JonathantekiiMac:verilog Jonathan$ </span>make
<span class="gp">JonathantekiiMac:verilog Jonathan$ </span>./cpu0Is
<span class="go">WARNING: cpu0Is.v:386: $readmemh(cpu0.hex): Not enough words in the file for the</span>
<span class="go">taskInterrupt(001)</span>
<span class="go">68</span>
<span class="go">7</span>
<span class="go">0</span>
<span class="go">0</span>
<span class="go">253</span>
<span class="go">3</span>
<span class="go">1</span>
<span class="go">13</span>
<span class="go">3</span>
<span class="go">-126</span>
<span class="go">130</span>
<span class="go">-32766</span>
<span class="go">32770</span>
<span class="go">393307</span>
<span class="go">16777218</span>
<span class="go">3</span>
<span class="go">4</span>
<span class="go">51</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="go">1</span>
<span class="go">2147483647</span>
<span class="go">-2147483648</span>
<span class="go">15</span>
<span class="go">5</span>
<span class="go">0</span>
<span class="go">31</span>
<span class="go">49</span>
<span class="go">total cpu cycles = 50645</span>
<span class="go">RET to PC &lt; 0, finished!</span>

<span class="gp">JonathantekiiMac:input Jonathan$ </span>bash<span class="w"> </span>build-run_backend.sh<span class="w"> </span>cpu032II<span class="w"> </span>eb
<span class="gp">JonathantekiiMac:input Jonathan$ </span><span class="nb">cd</span><span class="w"> </span>../verilog
<span class="gp">JonathantekiiMac:verilog Jonathan$ </span>./cpu0IIs
<span class="go">...</span>
<span class="go">total cpu cycles = 48335</span>
<span class="go">RET to PC &lt; 0, finished!</span>
</pre></div>
</div>
<p>The “total cpu cycles” is calculated in this verilog simualtor so that the
backend compiler and CPU performance can be reviewed.
Only the CPU cycles are counted in this implemenation since I/O
cycles time is unknown.
As explained in chapter “Control flow statements”, cpu032II which uses
instructions slt and beq
has better performance than cmp and jeq in cpu032I.
Instructions “jmp” has no delay slot so it is better used in dynamic linker
implementation.</p>
<p>You can trace the memory binary code and destination
register changed at every instruction execution by unmark TRACE in Makefile as
below,</p>
<p class="rubric">lbdex/verilog/Makefile</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">TRACE</span><span class="o">=-</span><span class="n">D</span><span class="w"> </span><span class="n">TRACE</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:raw Jonathan$ </span>./cpu0Is
<span class="go">WARNING: cpu0.v:386: $readmemh(cpu0.hex): Not enough words in the file for the</span>
<span class="go">requested range [0:28671].</span>
<span class="go">00000000: 2600000c</span>
<span class="go">00000004: 26000004</span>
<span class="go">00000008: 26000004</span>
<span class="go">0000000c: 26fffffc</span>
<span class="go">00000010: 09100000</span>
<span class="go">00000014: 09200000</span>
<span class="go">...</span>
<span class="go">taskInterrupt(001)</span>
<span class="go">1530ns 00000054 : 02ed002c m[28620+44  ]=-1          SW=00000000</span>
<span class="go">1610ns 00000058 : 02bd0028 m[28620+40  ]=0           SW=00000000</span>
<span class="go">...</span>
<span class="go">RET to PC &lt; 0, finished!</span>
</pre></div>
</div>
<p>As above result, cpu0.v dumps the memory first after reading input file cpu0.hex.
Next, it runs instructions from address 0 and print each destination
register value in the fourth column.
The first column is the nano seconds of timing. The second
is instruction address. The third is instruction content.
Now, most example codes depicted in the previous chapters are verified by
print the variable with print_integer().</p>
<p>Since the cpu0.v machine is created by Verilog language, suppose it can run on
real FPGA device (but I never do it).
The real output hardware
interface/port is hardware output device dependent, such as RS232, speaker,
LED, …. You should implement the I/O interface/port when you want to program
FPGA and wire I/O device to the I/O port.
Through running the compiled code on Verilog simulator, Cpu0 backend compiled
result and CPU cycles are verified and calculated.
Currently, this Cpu0 Verilog program is not a pipeline architecture, but
according the instruction set it can be implemented as a pipeline model.
The cycle time of Cpu0 pipeline model is more than 1/5 of “total cpu cycles”
displayed as above since there are dependences exist between instructions.
Though the Verilog simulator is slow in running the whole system program and
not include the cycles counting in cache and I/O, it is a simple and easy way
to verify your idea about CPU design at early stage with small program pattern.
The overall system simulator is complex to create. Even wiki web site here
<a class="footnote-reference brackets" href="#wiki-sim" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a> include tools for creating the simulator, it needs a lot of effort.</p>
<p>To generate cpu032I as well as little endian code, you can run with the
following command. File build-run_backend.sh write the endian information to
../verilog/cpu0.config as below.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>bash<span class="w"> </span>build-run_backend.sh<span class="w"> </span>cpu032I<span class="w"> </span>el
</pre></div>
</div>
<p class="rubric">../verilog/cpu0.config</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="w">   </span><span class="cm">/* 0: big endian, 1: little endian */</span>
</pre></div>
</div>
<p>The following files test more features.</p>
<p class="rubric">lbdex/input/ch_nolld2.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="c1">#include &quot;debug.h&quot;</span>
<span class="c1">#include &quot;boot.cpp&quot;</span>

<span class="c1">#include &quot;print.h&quot;</span>

<span class="nb">int</span> <span class="n">test_nolld2</span><span class="p">();</span>
</pre></div>
</div>
<p class="rubric">lbdex/input/ch_nolld2.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="c1">#include &quot;print.cpp&quot;</span>

<span class="c1">#include &quot;ch9_3_alloc.cpp&quot;</span>

<span class="nb">int</span> <span class="n">test_nolld2</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">bool</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">true</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">a</span> <span class="o">=</span> <span class="n">test_alloc</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">31</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">31</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="k">return</span> <span class="k">pass</span><span class="p">;</span>
<span class="p">}</span>

</pre></div>
</div>
<p class="rubric">lbdex/input/ch_run_backend2.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="c1">#include &quot;ch_nolld2.h&quot;</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">bool</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">true</span><span class="p">;</span>
  <span class="k">pass</span> <span class="o">=</span> <span class="n">test_nolld2</span><span class="p">();</span>

  <span class="k">return</span> <span class="k">pass</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">#include &quot;ch_nolld2.cpp&quot;</span>
</pre></div>
</div>
<p class="rubric">lbdex/input/build-run_backend2.sh</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#!/usr/bin/env bash

source functions.sh

sh_name=build-run_backend.sh
ARG_NUM=$#
CPU=$1
ENDIAN=$2

DEFFLAGS=&quot;&quot;
if [ &quot;$arg1&quot; == cpu032II ] ; then
  DEFFLAGS=${DEFFLAGS}&quot; -DCPU032II&quot;
fi
echo ${DEFFLAGS}

prologue;

${CLANG} ${DEFFLAGS} -c ch_run_backend2.cpp \
-emit-llvm -o ch_run_backend2.bc
${TOOLDIR}/llc -march=cpu0${ENDIAN} -mcpu=${CPU} -relocation-model=static \
-filetype=obj ch_run_backend2.bc -o ch_run_backend2.cpu0.o
${TOOLDIR}/llvm-objdump -d ch_run_backend2.cpu0.o | tail -n +8| awk \
&#39;{print &quot;/* &quot; $1 &quot; */\t&quot; $2 &quot; &quot; $3 &quot; &quot; $4 &quot; &quot; $5 &quot;\t/* &quot; $6&quot;\t&quot; $7&quot; &quot; $8&quot; \
&quot; $9&quot; &quot; $10 &quot;\t*/&quot;}&#39; &gt; ../verilog/cpu0.hex

ENDIAN=`${TOOLDIR}/llvm-readobj -h ch_run_backend2.cpu0.o|grep &quot;DataEncoding&quot;|awk &#39;{print $2}&#39;`
isLittleEndian;

if [ $LE == &quot;true&quot; ] ; then
  echo &quot;1   /* 0: big endian, 1: little endian */&quot; &gt; ../verilog/cpu0.config
else
  echo &quot;0   /* 0: big endian, 1: little endian */&quot; &gt; ../verilog/cpu0.config
fi
cat ../verilog/cpu0.config
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>bash<span class="w"> </span>build-run_backend.sh<span class="w"> </span>cpu032II<span class="w"> </span>el
<span class="go">...</span>
<span class="gp">JonathantekiiMac:input Jonathan$ </span><span class="nb">cd</span><span class="w"> </span>../verilog
<span class="gp">JonathantekiiMac:verilog Jonathan$ </span>./cpu0IIs
<span class="go">...</span>
<span class="go">31</span>
<span class="go">...</span>
</pre></div>
</div>
</section>
<section id="other-llvm-based-tools-for-cpu0-processor">
<h2><a class="toc-backref" href="#id10" role="doc-backlink">Other llvm based tools for Cpu0 processor</a><a class="headerlink" href="#other-llvm-based-tools-for-cpu0-processor" title="Permalink to this heading">¶</a></h2>
<p>You can find the Cpu0 ELF linker implementation based on lld which is the
llvm official linker project, as well as elf2hex which modified from llvm-objdump
driver at web: <a class="reference external" href="http://jonathan2251.github.io/lbt/index.html">http://jonathan2251.github.io/lbt/index.html</a>.</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="free-doc1" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://ccckmit.wikidot.com/ve:main">http://ccckmit.wikidot.com/ve:main</a></p>
</aside>
<aside class="footnote brackets" id="free-doc2" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://www.ece.umd.edu/courses/enee359a/">http://www.ece.umd.edu/courses/enee359a/</a></p>
</aside>
<aside class="footnote brackets" id="free-doc3" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">3</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://www.ece.umd.edu/courses/enee359a/verilog_tutorial.pdf">http://www.ece.umd.edu/courses/enee359a/verilog_tutorial.pdf</a></p>
</aside>
<aside class="footnote brackets" id="free-doc4" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">4</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://d1.amobbs.com/bbs_upload782111/files_33/ourdev_585395BQ8J9A.pdf">http://d1.amobbs.com/bbs_upload782111/files_33/ourdev_585395BQ8J9A.pdf</a></p>
</aside>
<aside class="footnote brackets" id="free-doc5" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">5</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://en.wikipedia.org/wiki/Verilog">http://en.wikipedia.org/wiki/Verilog</a></p>
</aside>
<aside class="footnote brackets" id="vhdl" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">6</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://en.wikipedia.org/wiki/VHDL">http://en.wikipedia.org/wiki/VHDL</a></p>
</aside>
<aside class="footnote brackets" id="wiki-sim" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">7</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Computer_architecture_simulator">https://en.wikipedia.org/wiki/Computer_architecture_simulator</a></p>
</aside>
</aside>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="c%2B%2B.html">C++ support</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="install.html">Appendix A: Getting Started: Installing LLVM and the Cpu0 example code</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Chen Chung-Shu.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 6.1.3.
    </div>
  </body>
</html>