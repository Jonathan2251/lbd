<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Verify backend on Verilog simulator &#8212; Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css?v=fce32b03" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css?v=4ae1632d" />
    <script src="_static/documentation_options.js?v=4745d852"></script>
    <script src="_static/doctools.js?v=fd6eb6e6"></script>
    <script src="_static/sphinx_highlight.js?v=6ffebe34"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="The Concept of GPU Compiler" href="gpu.html" />
    <link rel="prev" title="C++ support" href="c%2B%2B.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</span></a></h1>
        <h2 class="heading"><span>Verify backend on Verilog simulator</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="Top">
      
        <p>
        «&#160;&#160;<a href="c%2B%2B.html">C++ support</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="gpu.html">The Concept of GPU Compiler</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="verify-backend-on-verilog-simulator">
<span id="sec-verilog"></span><h1>Verify backend on Verilog simulator<a class="headerlink" href="#verify-backend-on-verilog-simulator" title="Link to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#create-verilog-simulator-of-cpu0" id="id9">Create Verilog Simulator of Cpu0</a></p></li>
<li><p><a class="reference internal" href="#verify-backend" id="id10">Verify backend</a></p></li>
<li><p><a class="reference internal" href="#other-llvm-based-tools-for-cpu0-processor" id="id11">Other LLVM-Based Tools for Cpu0 Processor</a></p></li>
</ul>
</nav>
<p>Until now, we have developed an LLVM backend capable of compiling C or
assembly code, as illustrated in the white part of <a class="reference internal" href="#runbackend-f1"><span class="std std-numref">Fig. 61</span></a>.
If the program does not contain global variables, the ELF object file can
be dumped to a hex file using the following command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>llvm-objdump<span class="w"> </span>-d
</pre></div>
</div>
<p>This functionality was completed in Chapter <em>ELF Support</em>.</p>
<figure class="align-default" id="id8">
<span id="runbackend-f1"></span><div class="graphviz"><img src="_images/graphviz-13704224915954defdb50e85b2acbfbd1b9779c0.png" alt="digraph G {
  rankdir=LR;
  &quot;Verilog machine&quot; [style=filled, color=gray];
  &quot;clang&quot; -&gt; &quot;llc&quot; [label=&quot;IR&quot;];
  &quot;llvm backend asm parser&quot; -&gt; &quot;llc&quot; [label=&quot;asm&quot;];
  &quot;llc&quot; -&gt; &quot;llvm-objdump -d&quot; [label=&quot;obj&quot;];
  &quot;llvm-objdump -d&quot; -&gt; &quot;Verilog machine&quot; [label=&quot;hex&quot;];
  
//  label = &quot;Figure: Cpu0 backend without linker&quot;;
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 61 </span><span class="caption-text">Cpu0 backend without linker</span><a class="headerlink" href="#id8" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>This chapter implements the Cpu0 instructions using the Verilog language,
as represented by the gray part in the figure above.</p>
<p>With this Verilog-based machine, we can execute the hex program generated
by the LLVM backend on the Cpu0 Verilog simulator running on a PC.
This allows us to observe and verify the execution results of Cpu0 instructions
directly on the hardware model.</p>
<section id="create-verilog-simulator-of-cpu0">
<h2><a class="toc-backref" href="#id9" role="doc-backlink">Create Verilog Simulator of Cpu0</a><a class="headerlink" href="#create-verilog-simulator-of-cpu0" title="Link to this heading">¶</a></h2>
<p>Verilog is an IEEE-standard language widely used in IC design. There are many
books and free online resources available for learning Verilog <a class="footnote-reference brackets" href="#free-doc1" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>
<a class="footnote-reference brackets" href="#free-doc2" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#free-doc3" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#free-doc4" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#free-doc5" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a>.</p>
<p>Verilog is also known as Verilog HDL (Hardware Description Language), not to be
confused with <strong>VHDL</strong>, which serves the same purpose but is a competing
language <a class="footnote-reference brackets" href="#vhdl" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a>.</p>
<p>An example implementation, <code class="docutils literal notranslate"><span class="pre">lbdex/verilog/cpu0.v</span></code>, contains the Cpu0 processor
design written in Verilog. As described in Appendix A, we have installed the
Icarus Verilog tool on both iMac and Linux systems. The <code class="docutils literal notranslate"><span class="pre">cpu0.v</span></code> design is
relatively simple, with only a few hundred lines of code in total.</p>
<p>Although this implementation does not include pipelining, it simulates delay
slots (via the <code class="docutils literal notranslate"><span class="pre">SIMULATE_DELAY_SLOT</span></code> section of the code) to accurately
estimate pipeline machine cycles.</p>
<p>Verilog has a C-like syntax, and since this book focuses on compiler
implementation, we present the <code class="docutils literal notranslate"><span class="pre">cpu0.v</span></code> code and the build commands below
<strong>without an in-depth explanation</strong>. We expect that readers with some patience
and curiosity will be able to understand the Verilog code.</p>
<p>Cpu0 supports <strong>memory-mapped I/O</strong>, one of the two primary I/O models in
computer architecture (the other being <strong>instruction-based I/O</strong>). Cpu0 maps the
output port to memory address <code class="docutils literal notranslate"><span class="pre">0x80000</span></code>. When executing the instruction:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>st $ra, cx($rb)
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">cx($rb)</span></code> equals <code class="docutils literal notranslate"><span class="pre">0x80000</span></code>, the Cpu0 processor outputs the content to
that I/O port, as demonstrated below.</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="n">ST</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">begin</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">+</span><span class="n">c16</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="no">`IOADDR</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">    </span><span class="n">outw</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">a</span><span class="p">]);</span>
</pre></div>
</div>
<p class="rubric">lbdex/verilog/cpu0.v</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// https://www.francisz.cn/download/IEEE_Standard_1800-2012%20SystemVerilog.pdf

// configuable value below
`define SIMULATE_DELAY_SLOT
// cpu032I memory limit, jsub:24-bit
`define MEMSIZE   &#39;h1000000
`define MEMEMPTY   8&#39;hFF
`define NULL       8&#39;h00
`define IOADDR    &#39;hff000000  // IO mapping address
`define TIMEOUT   #3000000000


// Operand width
`define INT32 2&#39;b11     // 32 bits
`define INT24 2&#39;b10     // 24 bits
`define INT16 2&#39;b01     // 16 bits
`define BYTE  2&#39;b00     // 8  bits

`define EXE 3&#39;b000
`define RESET 3&#39;b001
`define ABORT 3&#39;b010
`define IRQ 3&#39;b011
`define ERROR 3&#39;b100

// Reference web: http://ccckmit.wikidot.com/ocs:cpu0
module cpu0(input clock, reset, input [2:0] itype, output reg [2:0] tick, 
            output reg [31:0] ir, pc, mar, mdr, inout [31:0] dbus, 
            output reg m_en, m_rw, output reg [1:0] m_size, 
            input cfg);
  reg signed [31:0] R [0:15];
  reg signed [31:0] C0R [0:1]; // co-processor 0 register
  // High and Low part of 64 bit result
  reg [7:0] op;
  reg [3:0] a, b, c;
  reg [4:0] c5;
  reg signed [31:0] c12, c16, c24, Ra, Rb, Rc, pc0; // pc0: instruction pc
  reg [31:0] uc16, URa, URb, URc, HI, LO, CF, tmp;
  reg [63:0] cycles;

  // register name
  `define SP   R[13]   // Stack Pointer
  `define LR   R[14]   // Link Register
  `define SW   R[15]   // Status Word

  // C0 register name
  `define PC   C0R[0]   // Program Counter
  `define EPC  C0R[1]  // exception PC value

  // SW Flage
  `define I2   `SW[16] // Hardware Interrupt 1, IO1 interrupt, status, 
                      // 1: in interrupt
  `define I1   `SW[15] // Hardware Interrupt 0, timer interrupt, status, 
                      // 1: in interrupt
  `define I0   `SW[14] // Software interrupt, status, 1: in interrupt
  `define I    `SW[13] // Interrupt, 1: in interrupt
  `define I2E  `SW[12]  // Hardware Interrupt 1, IO1 interrupt, Enable
  `define I1E  `SW[11]  // Hardware Interrupt 0, timer interrupt, Enable
  `define I0E  `SW[10]  // Software Interrupt Enable
  `define IE   `SW[9]  // Interrupt Enable
  `define M    `SW[8:6]  // Mode bits, itype
  `define D    `SW[5]  // Debug Trace
  `define V    `SW[3]  // Overflow
  `define C    `SW[2]  // Carry
  `define Z    `SW[1]  // Zero
  `define N    `SW[0]  // Negative flag
  
  `define LE   CF[0]  // Endian bit, Big Endian:0, Little Endian:1
  // Instruction Opcode 
  parameter [7:0] NOP=8&#39;h00,LD=8&#39;h01,ST=8&#39;h02,LB=8&#39;h03,LBu=8&#39;h04,SB=8&#39;h05,
  LH=8&#39;h06,LHu=8&#39;h07,SH=8&#39;h08,ADDiu=8&#39;h09,MOVZ=8&#39;h0A,MOVN=8&#39;h0B,ANDi=8&#39;h0C,
  ORi=8&#39;h0D,XORi=8&#39;h0E,LUi=8&#39;h0F,
  ADDu=8&#39;h11,SUBu=8&#39;h12,ADD=8&#39;h13,SUB=8&#39;h14,CLZ=8&#39;h15,CLO=8&#39;h16,MUL=8&#39;h17,
  AND=8&#39;h18,OR=8&#39;h19,XOR=8&#39;h1A,NOR=8&#39;h1B,
  ROL=8&#39;h1C,ROR=8&#39;h1D,SHL=8&#39;h1E,SHR=8&#39;h1F,
  SRA=8&#39;h20,SRAV=8&#39;h21,SHLV=8&#39;h22,SHRV=8&#39;h23,ROLV=8&#39;h24,RORV=8&#39;h25,
`ifdef CPU0II
  SLTi=8&#39;h26,SLTiu=8&#39;h27, SLT=8&#39;h28,SLTu=8&#39;h29,
`endif
  CMP=8&#39;h2A,
  CMPu=8&#39;h2B,
  JEQ=8&#39;h30,JNE=8&#39;h31,JLT=8&#39;h32,JGT=8&#39;h33,JLE=8&#39;h34,JGE=8&#39;h35,
  JMP=8&#39;h36,
`ifdef CPU0II
  BEQ=8&#39;h37,BNE=8&#39;h38,
`endif
  JALR=8&#39;h39,BAL=8&#39;h3A,JSUB=8&#39;h3B,RET=8&#39;h3C,
  MULT=8&#39;h41,MULTu=8&#39;h42,DIV=8&#39;h43,DIVu=8&#39;h44,
  MFHI=8&#39;h46,MFLO=8&#39;h47,MTHI=8&#39;h48,MTLO=8&#39;h49,
  MFC0=8&#39;h50,MTC0=8&#39;h51,C0MOV=8&#39;h52;

  reg [0:0] inExe = 0;
  reg [2:0] state, next_state; 
  reg [2:0] st_taskInt, ns_taskInt; 
  parameter Reset=3&#39;h0, Fetch=3&#39;h1, Decode=3&#39;h2, Execute=3&#39;h3, MemAccess=3&#39;h4, 
            WriteBack=3&#39;h5;
  integer i;
`ifdef SIMULATE_DELAY_SLOT
  reg [0:0] nextInstIsDelaySlot;
  reg [0:0] isDelaySlot;
  reg signed [31:0] delaySlotNextPC;
`endif

  //transform data from the memory to little-endian form
  task changeEndian(input [31:0] value, output [31:0] changeEndian); begin
    changeEndian = {value[7:0], value[15:8], value[23:16], value[31:24]};
  end endtask

  // Read Memory Word
  task memReadStart(input [31:0] addr, input [1:0] size); begin 
    mar = addr;     // read(m[addr])
    m_rw = 1;     // Access Mode: read 
    m_en = 1;     // Enable read
    m_size = size;
  end endtask

  // Read Memory Finish, get data
  task memReadEnd(output [31:0] data); begin
    mdr = dbus; // get momory, dbus = m[addr]
    data = mdr; // return to data
    m_en = 0; // read complete
  end endtask

  // Write memory -- addr: address to write, data: date to write
  task memWriteStart(input [31:0] addr, input [31:0] data, input [1:0] size); 
  begin 
    mar = addr;    // write(m[addr], data)
    mdr = data;
    m_rw = 0;    // access mode: write
    m_en = 1;     // Enable write
    m_size  = size;
  end endtask

  task memWriteEnd; begin // Write Memory Finish
    m_en = 0; // write complete
  end endtask

  task regSet(input [3:0] i, input [31:0] data); begin
    if (i != 0) R[i] = data;
  end endtask

  task C0regSet(input [3:0] i, input [31:0] data); begin
    if (i &lt; 2) C0R[i] = data;
  end endtask

  task PCSet(input [31:0] data); begin
  `ifdef SIMULATE_DELAY_SLOT
    nextInstIsDelaySlot = 1;
    delaySlotNextPC = data;
  `else
    `PC = data;
  `endif
  end endtask

  task retValSet(input [3:0] i, input [31:0] data); begin
    if (i != 0)
    `ifdef SIMULATE_DELAY_SLOT
      R[i] = data + 4;
    `else
      R[i] = data;
    `endif
  end endtask
  
  task regHILOSet(input [31:0] data1, input [31:0] data2); begin
    HI = data1;
    LO = data2;
  end endtask

  // output a word to Output port (equal to display the word to terminal)
  task outw(input [31:0] data); begin
    if (`LE) begin // Little Endian
      changeEndian(data, data);
    end 
    if (data[7:0] != 8&#39;h00) begin
      $write(&quot;%c&quot;, data[7:0]);
      if (data[15:8] != 8&#39;h00) 
        $write(&quot;%c&quot;, data[15:8]);
      if (data[23:16] != 8&#39;h00) 
        $write(&quot;%c&quot;, data[23:16]);
      if (data[31:24] != 8&#39;h00) 
        $write(&quot;%c&quot;, data[31:24]);
    end
  end endtask

  // output a character (a byte)
  task outc(input [7:0] data); begin
    $write(&quot;%c&quot;, data);
  end endtask

  task taskInterrupt(input [2:0] iMode); begin
  if (inExe == 0) begin
    case (iMode)
      `RESET: begin 
        `PC = 0; tick = 0; R[0] = 0; `SW = 0; `LR = -1;
        `IE = 0; `I0E = 1; `I1E = 1; `I2E = 1;
        `I = 0; `I0 = 0; `I1 = 0; `I2 = 0; inExe = 1;
        `LE = cfg;
        cycles = 0;
      end
      `ABORT: begin `PC = 4; end
      `IRQ:   begin `PC = 8; `IE = 0; inExe = 1; end
      `ERROR: begin `PC = 12; end
    endcase
  end
  $display(&quot;taskInterrupt(%3b)&quot;, iMode);
  end endtask

  task taskExecute; begin
    tick = tick+1;
    case (state)
    Fetch: begin  // Tick 1 : instruction fetch, throw PC to address bus, 
                  // memory.read(m[PC])
      memReadStart(`PC, `INT32);
      pc0  = `PC;
   `ifdef SIMULATE_DELAY_SLOT
     if (nextInstIsDelaySlot == 1) begin
       isDelaySlot = 1;
       nextInstIsDelaySlot = 0;
       `PC = delaySlotNextPC;
     end
     else begin
       if (isDelaySlot == 1) isDelaySlot = 0;
       `PC = `PC+4;
     end
   `else
     `PC = `PC+4;
   `endif
      next_state = Decode;
    end
    Decode: begin  // Tick 2 : instruction decode, ir = m[PC]
      memReadEnd(ir); // IR = dbus = m[PC]
      {op,a,b,c} = ir[31:12];
      c24 = $signed(ir[23:0]);
      c16 = $signed(ir[15:0]);
      uc16 = ir[15:0];
      c12 = $signed(ir[11:0]);
      c5  = ir[4:0];
      Ra = R[a];
      Rb = R[b];
      Rc = R[c];
      URa = R[a];
      URb = R[b];
      URc = R[c];
      next_state = Execute;
    end
    Execute: begin // Tick 3 : instruction execution
      case (op)
      NOP:   ;
      // load and store instructions
      LD:    memReadStart(Rb+c16, `INT32);      // LD Ra,[Rb+Cx]; Ra&lt;=[Rb+Cx]
      ST:    memWriteStart(Rb+c16, Ra, `INT32); // ST Ra,[Rb+Cx]; Ra=&gt;[Rb+Cx]
      // LB Ra,[Rb+Cx]; Ra&lt;=(byte)[Rb+Cx]
      LB:    memReadStart(Rb+c16, `BYTE);
      // LBu Ra,[Rb+Cx]; Ra&lt;=(byte)[Rb+Cx]
      LBu:   memReadStart(Rb+c16, `BYTE);
      // SB Ra,[Rb+Cx]; Ra=&gt;(byte)[Rb+Cx]
      SB:    memWriteStart(Rb+c16, Ra, `BYTE);
      LH:    memReadStart(Rb+c16, `INT16); // LH Ra,[Rb+Cx]; Ra&lt;=(2bytes)[Rb+Cx]
      LHu:   memReadStart(Rb+c16, `INT16); // LHu Ra,[Rb+Cx]; Ra&lt;=(2bytes)[Rb+Cx]
      // SH Ra,[Rb+Cx]; Ra=&gt;(2bytes)[Rb+Cx]
      SH:    memWriteStart(Rb+c16, Ra, `INT16);
      // Conditional move
      MOVZ:  if (Rc==0) regSet(a, Rb);             // move if Rc equal to 0
      MOVN:  if (Rc!=0) regSet(a, Rb);             // move if Rc not equal to 0
      // Mathematic 
      ADDiu: regSet(a, Rb+c16);                   // ADDiu Ra, Rb+Cx; Ra&lt;=Rb+Cx
      CMP:  begin 
        if (Rb &lt; Rc) `N=1; else `N=0;
        // `N=(Rb-Rc&lt;0); // why not work for bash make.sh cpu032I el Makefile.builtins?
       `Z=(Rb-Rc==0); 
      end // CMP Rb, Rc; SW=(Rb &gt;=&lt; Rc)
      CMPu:  begin 
        if (URb &lt; URc) `N=1; else `N=0; 
       `Z=(URb-URc==0); 
      end // CMPu URb, URc; SW=(URb &gt;=&lt; URc)
      ADDu:  regSet(a, Rb+Rc);               // ADDu Ra,Rb,Rc; Ra&lt;=Rb+Rc
      ADD:   begin regSet(a, Rb+Rc); if (a &lt; Rb) `V = 1; else `V = 0; 
        if (`V) begin `I0 = 1; `I = 1; end
      end
                                             // ADD Ra,Rb,Rc; Ra&lt;=Rb+Rc
      SUBu:  regSet(a, Rb-Rc);               // SUBu Ra,Rb,Rc; Ra&lt;=Rb-Rc
      SUB:   begin regSet(a, Rb-Rc); if (Rb &lt; 0 &amp;&amp; Rc &gt; 0 &amp;&amp; a &gt;= 0) 
             `V = 1; else `V =0; 
        if (`V) begin `I0 = 1; `I = 1; end
      end         // SUB Ra,Rb,Rc; Ra&lt;=Rb-Rc
      CLZ:   begin
        for (i=0; (i&lt;32)&amp;&amp;((Rb&amp;32&#39;h80000000)==32&#39;h00000000); i=i+1) begin
            Rb=Rb&lt;&lt;1;
        end
        regSet(a, i);
      end
      CLO:   begin
        for (i=0; (i&lt;32)&amp;&amp;((Rb&amp;32&#39;h80000000)==32&#39;h80000000); i=i+1) begin
            Rb=Rb&lt;&lt;1;
        end
        regSet(a, i);
      end
      MUL:   regSet(a, Rb*Rc);               // MUL Ra,Rb,Rc;     Ra&lt;=Rb*Rc
      DIVu:  regHILOSet(URa%URb, URa/URb);   // DIVu URa,URb; HI&lt;=URa%URb; 
                                             // LO&lt;=URa/URb
                                             // without exception overflow
      DIV:   begin regHILOSet(Ra%Rb, Ra/Rb); 
             if ((Ra &lt; 0 &amp;&amp; Rb &lt; 0) || (Ra == 0)) `V = 1; 
             else `V =0; end  // DIV Ra,Rb; HI&lt;=Ra%Rb; LO&lt;=Ra/Rb; With overflow
      AND:   regSet(a, Rb&amp;Rc);               // AND Ra,Rb,Rc; Ra&lt;=(Rb and Rc)
      ANDi:  regSet(a, Rb&amp;uc16);             // ANDi Ra,Rb,c16; Ra&lt;=(Rb and c16)
      OR:    regSet(a, Rb|Rc);               // OR Ra,Rb,Rc; Ra&lt;=(Rb or Rc)
      ORi:   regSet(a, Rb|uc16);             // ORi Ra,Rb,c16; Ra&lt;=(Rb or c16)
      XOR:   regSet(a, Rb^Rc);               // XOR Ra,Rb,Rc; Ra&lt;=(Rb xor Rc)
      NOR:   regSet(a, ~(Rb|Rc));            // NOR Ra,Rb,Rc; Ra&lt;=(Rb nor Rc)
      XORi:  regSet(a, Rb^uc16);             // XORi Ra,Rb,c16; Ra&lt;=(Rb xor c16)
      LUi:   regSet(a, uc16&lt;&lt;16);
      SHL:   regSet(a, Rb&lt;&lt;c5);     // Shift Left; SHL Ra,Rb,Cx; Ra&lt;=(Rb &lt;&lt; Cx)
      SRA:   regSet(a, (Rb&gt;&gt;&gt;c5));  // Shift Right with signed bit fill;
        // https://stackoverflow.com/questions/39911655/how-to-synthesize-hardware-for-sra-instruction
      SHR:   regSet(a, Rb&gt;&gt;c5);     // Shift Right with 0 fill; 
                                    // SHR Ra,Rb,Cx; Ra&lt;=(Rb &gt;&gt; Cx)
      SHLV:  regSet(a, Rb&lt;&lt;Rc);     // Shift Left; SHLV Ra,Rb,Rc; Ra&lt;=(Rb &lt;&lt; Rc)
      SRAV:  regSet(a, (Rb&gt;&gt;&gt;Rc));  // Shift Right with signed bit fill;
      SHRV:  regSet(a, Rb&gt;&gt;Rc);     // Shift Right with 0 fill; 
                                    // SHRV Ra,Rb,Rc; Ra&lt;=(Rb &gt;&gt; Rc)
      ROL:   regSet(a, (Rb&lt;&lt;c5)|(Rb&gt;&gt;(32-c5)));     // Rotate Left;
      ROR:   regSet(a, (Rb&gt;&gt;c5)|(Rb&lt;&lt;(32-c5)));     // Rotate Right;
      ROLV:  begin // Can set Rc to -32&lt;=Rc&lt;=32 more efficently.
        while (Rc &lt; -32) Rc=Rc+32;
        while (Rc &gt; 32) Rc=Rc-32;
        regSet(a, (Rb&lt;&lt;Rc)|(Rb&gt;&gt;(32-Rc)));     // Rotate Left;
      end
      RORV:  begin 
        while (Rc &lt; -32) Rc=Rc+32;
        while (Rc &gt; 32) Rc=Rc-32;
        regSet(a, (Rb&gt;&gt;Rc)|(Rb&lt;&lt;(32-Rc)));     // Rotate Right;
      end
      MFLO:  regSet(a, LO);         // MFLO Ra; Ra&lt;=LO
      MFHI:  regSet(a, HI);         // MFHI Ra; Ra&lt;=HI
      MTLO:  LO = Ra;               // MTLO Ra; LO&lt;=Ra
      MTHI:  HI = Ra;               // MTHI Ra; HI&lt;=Ra
      MULT:  {HI, LO}=Ra*Rb;        // MULT Ra,Rb; HI&lt;=((Ra*Rb)&gt;&gt;32); 
                                    // LO&lt;=((Ra*Rb) and 0x00000000ffffffff);
                                    // with exception overflow
      MULTu: {HI, LO}=URa*URb;      // MULT URa,URb; HI&lt;=((URa*URb)&gt;&gt;32); 
                                    // LO&lt;=((URa*URb) and 0x00000000ffffffff);
                                    // without exception overflow
      MFC0:  regSet(a, C0R[b]);     // MFC0 a, b; Ra&lt;=C0R[Rb]
      MTC0:  C0regSet(a, Rb);       // MTC0 a, b; C0R[a]&lt;=Rb
      C0MOV: C0regSet(a, C0R[b]);   // C0MOV a, b; C0R[a]&lt;=C0R[b]
   `ifdef CPU0II
      // set
      SLT:   if (Rb &lt; Rc) R[a]=1; else R[a]=0;
      SLTu:  if (URb &lt; URc) R[a]=1; else R[a]=0;
      SLTi:  if (Rb &lt; c16) R[a]=1; else R[a]=0;
      SLTiu: if (URb &lt; uc16) R[a]=1; else R[a]=0;
      // Branch Instructions
      BEQ:   if (Ra==Rb) PCSet(`PC+c16);
      BNE:   if (Ra!=Rb) PCSet(`PC+c16);
    `endif
      // Jump Instructions
      JEQ:   if (`Z) PCSet(`PC+c24);            // JEQ Cx; if SW(=) PC  PC+Cx
      JNE:   if (!`Z) PCSet(`PC+c24);           // JNE Cx; if SW(!=) PC PC+Cx
      JLT:   if (`N) PCSet(`PC+c24);            // JLT Cx; if SW(&lt;) PC  PC+Cx
      JGT:   if (!`N&amp;&amp;!`Z) PCSet(`PC+c24);      // JGT Cx; if SW(&gt;) PC  PC+Cx
      JLE:   if (`N || `Z) PCSet(`PC+c24);      // JLE Cx; if SW(&lt;=) PC PC+Cx    
      JGE:   if (!`N || `Z) PCSet(`PC+c24);     // JGE Cx; if SW(&gt;=) PC PC+Cx
      JMP:   `PC = `PC+c24;                     // JMP Cx; PC &lt;= PC+Cx
      JALR:  begin retValSet(a, `PC); PCSet(Rb); end    // JALR Ra,Rb; Ra&lt;=PC; PC&lt;=Rb
      BAL:   begin `LR = `PC; `PC = `PC+c24; end // BAL Cx; LR&lt;=PC; PC&lt;=PC+Cx
      JSUB:  begin retValSet(14, `PC); PCSet(`PC+c24); end // JSUB Cx; LR&lt;=PC; PC&lt;=PC+Cx
      RET:   begin PCSet(Ra); end               // RET; PC &lt;= Ra
      default : 
        $display(&quot;%4dns %8x : OP code %8x not support&quot;, $stime, pc0, op);
      endcase
      if (`IE &amp;&amp; `I &amp;&amp; (`I0E &amp;&amp; `I0 || `I1E &amp;&amp; `I1 || `I2E &amp;&amp; `I2)) begin
        `EPC = `PC;
        next_state = Fetch;
        inExe = 0;
      end else
        next_state = MemAccess;
    end
    MemAccess: begin
      case (op)
      ST, SB, SH  :
        memWriteEnd();                // write memory complete
      endcase
      next_state = WriteBack;
    end
    WriteBack: begin // Read/Write finish, close memory
      case (op)
      LB, LBu  :
        memReadEnd(R[a]);        //read memory complete
      LH, LHu  :
        memReadEnd(R[a]);
      LD  : begin
        memReadEnd(R[a]);
        if (`D)
          $display(&quot;%4dns %8x : %8x m[%-04x+%-04x]=%8x  SW=%8x&quot;, $stime, pc0, 
                   ir, R[b], c16, R[a], `SW);
      end
      endcase
      case (op)
      LB  : begin 
        if (R[a] &gt; 8&#39;h7f) R[a]=R[a]|32&#39;hffffff80;
      end
      LH  : begin 
        if (R[a] &gt; 16&#39;h7fff) R[a]=R[a]|32&#39;hffff8000;
      end
      endcase
      case (op)
      MULT, MULTu, DIV, DIVu, MTHI, MTLO :
        if (`D)
          $display(&quot;%4dns %8x : %8x HI=%8x LO=%8x SW=%8x&quot;, $stime, pc0, ir, HI, 
                   LO, `SW);
      ST : begin
        if (`D)
          $display(&quot;%4dns %8x : %8x m[%-04x+%-04x]=%8x  SW=%8x&quot;, $stime, pc0, 
                   ir, R[b], c16, R[a], `SW);
        if (R[b]+c16 == `IOADDR) begin
          outw(R[a]);
        end
      end
      SB : begin
        if (`D)
          $display(&quot;%4dns %8x : %8x m[%-04x+%-04x]=%c  SW=%8x, R[a]=%8x&quot;, 
                   $stime, pc0, ir, R[b], c16, R[a][7:0], `SW, R[a]);
        if (R[b]+c16 == `IOADDR) begin
          if (`LE)
            outc(R[a][7:0]);
          else
            outc(R[a][7:0]);
        end
      end
      MFC0, MTC0 :
        if (`D)
          $display(&quot;%4dns %8x : %8x R[%02d]=%-8x  C0R[%02d]=%-8x SW=%8x&quot;, 
                   $stime, pc0, ir, a, R[a], a, C0R[a], `SW);
      C0MOV :
        if (`D)
          $display(&quot;%4dns %8x : %8x C0R[%02d]=%-8x C0R[%02d]=%-8x SW=%8x&quot;, 
                   $stime, pc0, ir, a, C0R[a], b, C0R[b], `SW);
      default :
        if (`D) // Display the written register content
          $display(&quot;%4dns %8x : %8x R[%02d]=%-8x SW=%8x&quot;, $stime, pc0, ir, 
                   a, R[a], `SW);
      endcase
      if (`PC &lt; 0) begin
        $display(&quot;total cpu cycles = %-d&quot;, cycles);
        $display(&quot;RET to PC &lt; 0, finished!&quot;);
        $finish;
      end
      next_state = Fetch;
    end
    endcase
  end endtask

  always @(posedge clock) begin
    if (inExe == 0 &amp;&amp; (state == Fetch) &amp;&amp; (`IE &amp;&amp; `I) &amp;&amp; (`I0E &amp;&amp; `I0)) begin
    // software int
      `M = `IRQ;
      taskInterrupt(`IRQ);
      m_en = 0;
      state = Fetch;
    end else if (inExe == 0 &amp;&amp; (state == Fetch) &amp;&amp; (`IE &amp;&amp; `I) &amp;&amp; 
                 ((`I1E &amp;&amp; `I1) || (`I2E &amp;&amp; `I2)) ) begin
      `M = `IRQ;
      taskInterrupt(`IRQ);
      m_en = 0;
      state = Fetch;
    end else if (inExe == 0 &amp;&amp; itype == `RESET) begin
    // Condition itype == `RESET must after the other `IE condition
      taskInterrupt(`RESET);
      `M = `RESET;
      state = Fetch;
    end else begin
    `ifdef TRACE
      `D = 1; // Trace register content at beginning
    `endif
      taskExecute();
      state = next_state;
    end
    pc = `PC;
    cycles = cycles + 1;
  end
endmodule

module memory0(input clock, reset, en, rw, input [1:0] m_size, 
               input [31:0] abus, dbus_in, output [31:0] dbus_out, 
               output cfg);
  reg [31:0] mconfig [0:0];
  reg [7:0] m [0:`MEMSIZE-1];
  reg [31:0] data;

  integer i;

  `define LE  mconfig[0][0:0]   // Endian bit, Big Endian:0, Little Endian:1

  initial begin
  // erase memory
    for (i=0; i &lt; `MEMSIZE; i=i+1) begin
       m[i] = `MEMEMPTY;
    end
  // load config from file to memory
    $readmemh(&quot;cpu0.config&quot;, mconfig);
  // load program from file to memory
    $readmemh(&quot;cpu0.hex&quot;, m);
  // display memory contents
    `ifdef TRACE
      for (i=0; i &lt; `MEMSIZE &amp;&amp; (m[i] != `MEMEMPTY || m[i+1] != `MEMEMPTY || 
         m[i+2] != `MEMEMPTY || m[i+3] != `MEMEMPTY); i=i+4) begin
        $display(&quot;%8x: %8x&quot;, i, {m[i], m[i+1], m[i+2], m[i+3]});
      end
    `endif
  end

  always @(clock or abus or en or rw or dbus_in) 
  begin
    if (abus &gt;= 0 &amp;&amp; abus &lt;= `MEMSIZE-4) begin
      if (en == 1 &amp;&amp; rw == 0) begin // r_w==0:write
        data = dbus_in;
        if (`LE) begin // Little Endian
          case (m_size)
          `BYTE:  {m[abus]} = dbus_in[7:0];
          `INT16: {m[abus], m[abus+1] } = {dbus_in[7:0], dbus_in[15:8]};
          `INT24: {m[abus], m[abus+1], m[abus+2]} = 
                  {dbus_in[7:0], dbus_in[15:8], dbus_in[23:16]};
          `INT32: {m[abus], m[abus+1], m[abus+2], m[abus+3]} = 
                  {dbus_in[7:0], dbus_in[15:8], dbus_in[23:16], dbus_in[31:24]};
          endcase
        end else begin // Big Endian
          case (m_size)
          `BYTE:  {m[abus]} = dbus_in[7:0];
          `INT16: {m[abus], m[abus+1] } = dbus_in[15:0];
          `INT24: {m[abus], m[abus+1], m[abus+2]} = dbus_in[23:0];
          `INT32: {m[abus], m[abus+1], m[abus+2], m[abus+3]} = dbus_in;
          endcase
        end
      end else if (en == 1 &amp;&amp; rw == 1) begin // r_w==1:read
        if (`LE) begin // Little Endian
          case (m_size)
          `BYTE:  data = {8&#39;h00,     8&#39;h00,     8&#39;h00,     m[abus]};
          `INT16: data = {8&#39;h00,     8&#39;h00,     m[abus+1], m[abus]};
          `INT24: data = {8&#39;h00,     m[abus+2], m[abus+1], m[abus]};
          `INT32: data = {m[abus+3], m[abus+2], m[abus+1], m[abus]};
          endcase
        end else begin // Big Endian
          case (m_size)
          `BYTE:  data = {8&#39;h00  , 8&#39;h00,     8&#39;h00,     m[abus]  };
          `INT16: data = {8&#39;h00  , 8&#39;h00,     m[abus],   m[abus+1]};
          `INT24: data = {8&#39;h00  , m[abus],   m[abus+1], m[abus+2]};
          `INT32: data = {m[abus], m[abus+1], m[abus+2], m[abus+3]};
          endcase
        end
      end else
        data = 32&#39;hZZZZZZZZ;
    end else 
      data = 32&#39;hZZZZZZZZ;
  end
  assign dbus_out = data;
  assign cfg = mconfig[0][0:0];
endmodule

module main;
  reg clock;
  reg [2:0] itype;
  wire [2:0] tick;
  wire [31:0] pc, ir, mar, mdr, dbus;
  wire m_en, m_rw;
  wire [1:0] m_size;
  wire cfg;

  cpu0 cpu(.clock(clock), .itype(itype), .pc(pc), .tick(tick), .ir(ir),
  .mar(mar), .mdr(mdr), .dbus(dbus), .m_en(m_en), .m_rw(m_rw), .m_size(m_size),
  .cfg(cfg));

  memory0 mem(.clock(clock), .reset(reset), .en(m_en), .rw(m_rw), 
  .m_size(m_size), .abus(mar), .dbus_in(mdr), .dbus_out(dbus), .cfg(cfg));

  initial
  begin
    clock = 0;
    itype = `RESET;
    `TIMEOUT $finish;
  end

  always #10 clock=clock+1;

endmodule
</pre></div>
</div>
<p class="rubric">lbdex/verilog/Makefile</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#TRACE=-D TRACE
all:
	iverilog ${TRACE} -o cpu0Is cpu0.v 
	iverilog ${TRACE} -D CPU0II -o cpu0IIs cpu0.v 

.PHONY: clean
clean:
	rm -rf cpu0.hex cpu0Is cpu0IIs 
	rm -f *~ cpu0.config

</pre></div>
</div>
<p>Since the Cpu0 Verilog machine supports both big-endian and little-endian
modes, the memory and CPU modules communicate this configuration through
a dedicated wire.</p>
<p>The endian information is stored in the ROM of the memory module. Upon
system startup, the memory module reads this configuration and sends the
endian setting to the CPU via the connected wire.</p>
<p>This mechanism is implemented according to the following code snippet:</p>
<p class="rubric">lbdex/verilog/cpu0.v</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">assign cfg = mconfig[0][0:0];</span>
<span class="go">...</span>
<span class="go">wire cfg;</span>

<span class="go">cpu0 cpu(.clock(clock), .itype(itype), .pc(pc), .tick(tick), .ir(ir),</span>
<span class="go">.mar(mar), .mdr(mdr), .dbus(dbus), .m_en(m_en), .m_rw(m_rw), .m_size(m_size),</span>
<span class="go">.cfg(cfg));</span>

<span class="go">memory0 mem(.clock(clock), .reset(reset), .en(m_en), .rw(m_rw),</span>
<span class="go">.m_size(m_size), .abus(mar), .dbus_in(mdr), .dbus_out(dbus), .cfg(cfg));</span>
</pre></div>
</div>
</section>
<section id="verify-backend">
<h2><a class="toc-backref" href="#id10" role="doc-backlink">Verify backend</a><a class="headerlink" href="#verify-backend" title="Link to this heading">¶</a></h2>
<p>Now let’s compile <code class="docutils literal notranslate"><span class="pre">ch_run_backend.cpp</span></code> as shown below. Since code size grows
from low to high addresses and the stack grows from high to low addresses, the
<code class="docutils literal notranslate"><span class="pre">$sp</span></code> register is set to <code class="docutils literal notranslate"><span class="pre">0x7fffc</span></code>. This is because <code class="docutils literal notranslate"><span class="pre">cpu0.v</span></code> is assumed to
use <code class="docutils literal notranslate"><span class="pre">0x80000</span></code> bytes of memory.</p>
<p class="rubric">lbdex/input/start.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="c1">#ifndef _START_H_</span>
<span class="c1">#define _START_H_</span>

<span class="c1">#include &quot;config.h&quot;</span>

<span class="c1">#define SET_SW \</span>
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;andi $sw, $zero, 0&quot;</span><span class="p">);</span> \
<span class="n">asm</span><span class="p">(</span><span class="s2">&quot;ori  $sw, $sw, 0x1e00&quot;</span><span class="p">);</span> <span class="o">//</span> <span class="n">enable</span> <span class="nb">all</span> <span class="n">interrupts</span>

<span class="c1">#define initRegs() \</span>
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;addiu $1,  $zero, 0&quot;</span><span class="p">);</span> \
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;addiu $2,  $zero, 0&quot;</span><span class="p">);</span> \
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;addiu $3,  $zero, 0&quot;</span><span class="p">);</span> \
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;addiu $4,  $zero, 0&quot;</span><span class="p">);</span> \
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;addiu $5,  $zero, 0&quot;</span><span class="p">);</span> \
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;addiu $t9, $zero, 0&quot;</span><span class="p">);</span> \
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;addiu $7,  $zero, 0&quot;</span><span class="p">);</span> \
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;addiu $8,  $zero, 0&quot;</span><span class="p">);</span> \
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;addiu $9,  $zero, 0&quot;</span><span class="p">);</span> \
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;addiu $10, $zero, 0&quot;</span><span class="p">);</span> \
  <span class="n">SET_SW</span><span class="p">;</span>                     \
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;addiu $fp, $zero, 0&quot;</span><span class="p">);</span>

<span class="c1">#endif</span>
</pre></div>
</div>
<p class="rubric">lbdex/input/boot.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="c1">#include &quot;start.h&quot;</span>

<span class="o">//</span> <span class="n">boot</span><span class="p">:</span>
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;boot:&quot;</span><span class="p">);</span>
<span class="o">//</span>  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;_start:&quot;</span><span class="p">);</span>
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;jmp 12&quot;</span><span class="p">);</span> <span class="o">//</span> <span class="n">RESET</span><span class="p">:</span> <span class="n">jmp</span> <span class="n">RESET_START</span><span class="p">;</span>
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;jmp 4&quot;</span><span class="p">);</span>  <span class="o">//</span> <span class="n">ERROR</span><span class="p">:</span> <span class="n">jmp</span> <span class="n">ERR_HANDLE</span><span class="p">;</span>
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;jmp 4&quot;</span><span class="p">);</span>  <span class="o">//</span> <span class="n">IRQ</span><span class="p">:</span> <span class="n">jmp</span> <span class="n">IRQ_HANDLE</span><span class="p">;</span>
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;jmp -4&quot;</span><span class="p">);</span> <span class="o">//</span> <span class="n">ERR_HANDLE</span><span class="p">:</span> <span class="n">jmp</span> <span class="n">ERR_HANDLE</span><span class="p">;</span> <span class="p">(</span><span class="n">loop</span> <span class="n">forever</span><span class="p">)</span>

<span class="o">//</span> <span class="n">RESET_START</span><span class="p">:</span>
  <span class="n">initRegs</span><span class="p">();</span>
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;addiu $gp, $ZERO, 0&quot;</span><span class="p">);</span>
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;addiu $lr, $ZERO, -1&quot;</span><span class="p">);</span>
  
  <span class="n">INIT_SP</span><span class="p">;</span>
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;mfc0 $3, $pc&quot;</span><span class="p">);</span>
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;addiu $3, $3, 0x8&quot;</span><span class="p">);</span> <span class="o">//</span> <span class="n">Assume</span> <span class="n">main</span><span class="p">()</span> <span class="n">entry</span> <span class="n">point</span> <span class="ow">is</span> <span class="n">at</span> <span class="n">the</span> <span class="nb">next</span> <span class="nb">next</span> 
                             <span class="o">//</span> <span class="n">instruction</span><span class="o">.</span>
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;jr $3&quot;</span><span class="p">);</span>
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;nop&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">lbdex/input/print.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#ifndef _PRINT_H_</span>
<span class="c1">#define _PRINT_H_</span>

<span class="c1">#include &quot;start.h&quot;</span>

<span class="n">void</span> <span class="n">print_char</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="n">c</span><span class="p">);</span>
<span class="n">void</span> <span class="n">dump_mem</span><span class="p">(</span><span class="n">unsigned</span> <span class="n">char</span> <span class="o">*</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span> <span class="n">n</span><span class="p">);</span>
<span class="n">void</span> <span class="n">print_string</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="nb">str</span><span class="p">);</span>
<span class="n">void</span> <span class="n">print_integer</span><span class="p">(</span><span class="nb">int</span> <span class="n">x</span><span class="p">);</span>
<span class="c1">#endif</span>
</pre></div>
</div>
<p class="rubric">lbdex/input/print.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &quot;print.h&quot;</span>
<span class="c1">#include &quot;itoa.cpp&quot;</span>

<span class="o">//</span> <span class="n">For</span> <span class="n">memory</span> <span class="n">IO</span>
<span class="n">void</span> <span class="n">print_char</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">char</span><span class="o">*</span><span class="p">)</span><span class="n">IOADDR</span><span class="p">;</span>
  <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>

  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">print_string</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="nb">str</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="nb">str</span><span class="p">;</span> <span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="s1">&#39;</span><span class="se">\0</span><span class="s1">&#39;</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span>
    <span class="n">print_char</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
  <span class="n">print_char</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
  <span class="n">print_char</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">);</span>

  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">For</span> <span class="n">memory</span> <span class="n">IO</span>
<span class="n">void</span> <span class="n">print_integer</span><span class="p">(</span><span class="nb">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">char</span> <span class="nb">str</span><span class="p">[</span><span class="n">INT_DIGITS</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
  <span class="n">itoa</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
  <span class="n">print_string</span><span class="p">(</span><span class="nb">str</span><span class="p">);</span>

  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

</pre></div>
</div>
<p class="rubric">lbdex/input/ch_nolld.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="c1">#include &quot;debug.h&quot;</span>
<span class="c1">#include &quot;boot.cpp&quot;</span>

<span class="c1">#include &quot;print.h&quot;</span>

<span class="nb">int</span> <span class="n">test_nolld</span><span class="p">();</span>
</pre></div>
</div>
<p class="rubric">lbdex/input/ch_nolld.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#define TEST_ROXV</span>
<span class="c1">#define RUN_ON_VERILOG</span>

<span class="c1">#include &quot;print.cpp&quot;</span>

<span class="c1">#include &quot;ch4_1_math.cpp&quot;</span>
<span class="c1">#include &quot;ch4_1_rotate.cpp&quot;</span>
<span class="c1">#include &quot;ch4_1_mult2.cpp&quot;</span>
<span class="c1">#include &quot;ch4_1_mod.cpp&quot;</span>
<span class="c1">#include &quot;ch4_1_div.cpp&quot;</span>
<span class="c1">#include &quot;ch4_2_logic.cpp&quot;</span>
<span class="c1">#include &quot;ch7_1_localpointer.cpp&quot;</span>
<span class="c1">#include &quot;ch7_1_char_short.cpp&quot;</span>
<span class="c1">#include &quot;ch7_1_bool.cpp&quot;</span>
<span class="c1">#include &quot;ch7_1_longlong.cpp&quot;</span>
<span class="c1">#include &quot;ch7_1_vector.cpp&quot;</span>
<span class="c1">#include &quot;ch8_1_ctrl.cpp&quot;</span>
<span class="c1">#include &quot;ch8_2_deluselessjmp.cpp&quot;</span>
<span class="c1">#include &quot;ch8_2_select.cpp&quot;</span>
<span class="c1">#include &quot;ch9_1_longlong.cpp&quot;</span>
<span class="c1">#include &quot;ch9_3_vararg.cpp&quot;</span>
<span class="c1">#include &quot;ch9_3_stacksave.cpp&quot;</span>
<span class="c1">#include &quot;ch9_3_bswap.cpp&quot;</span>
<span class="c1">#include &quot;ch9_3_alloc.cpp&quot;</span>
<span class="c1">#include &quot;ch11_2.cpp&quot;</span>

<span class="o">//</span> <span class="n">Test</span> <span class="n">build</span> <span class="n">only</span> <span class="k">for</span> <span class="n">the</span> <span class="n">following</span> <span class="n">files</span> <span class="n">on</span> <span class="n">build</span><span class="o">-</span><span class="n">run_backend</span><span class="o">.</span><span class="n">sh</span> <span class="n">since</span> <span class="n">it</span> 
<span class="o">//</span> <span class="n">needs</span> <span class="n">lld</span> <span class="n">linker</span> <span class="n">support</span><span class="o">.</span>
<span class="o">//</span> <span class="n">Test</span> <span class="ow">in</span> <span class="n">build</span><span class="o">-</span><span class="n">slink</span><span class="o">.</span><span class="n">sh</span>
<span class="c1">#include &quot;ch6_1.cpp&quot;</span>
<span class="c1">#include &quot;ch9_1_struct.cpp&quot;</span>
<span class="c1">#include &quot;ch9_1_constructor.cpp&quot;</span>
<span class="c1">#include &quot;ch9_3_template.cpp&quot;</span>
<span class="c1">#include &quot;ch12_inherit.cpp&quot;</span>

<span class="n">void</span> <span class="n">test_asm_build</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">#include &quot;ch11_1.cpp&quot;</span>
<span class="c1">#ifdef CPU032II</span>
  <span class="c1">#include &quot;ch11_1_2.cpp&quot;</span>
<span class="c1">#endif</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">test_rotate</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">test_rotate_left1</span><span class="p">();</span> <span class="o">//</span> <span class="n">rolv</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">30</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="nb">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">test_rotate_left</span><span class="p">();</span> <span class="o">//</span> <span class="n">rol</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">30</span>  <span class="o">=</span> <span class="mi">2</span>
  <span class="nb">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">test_rotate_right</span><span class="p">();</span> <span class="o">//</span> <span class="n">rorv</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">30</span> <span class="o">=</span> <span class="mi">4</span>
  
  <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">test_nolld</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">bool</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">true</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">a</span> <span class="o">=</span> <span class="n">test_math</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">68</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">68</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_rotate</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">7</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">7</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_mult</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_mod</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_div</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">253</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">253</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_local_pointer</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">3</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="n">test_load_bool</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_andorxornotcomplement</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">13</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">13</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_setxx</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">3</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_signed_char</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mi">126</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">126</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_unsigned_char</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">130</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">130</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_signed_short</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mi">32766</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">32766</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_unsigned_short</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">32770</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">32770</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">long</span> <span class="n">long</span> <span class="n">b</span> <span class="o">=</span> <span class="n">test_longlong</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">((</span><span class="nb">int</span><span class="p">)(</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">));</span> <span class="o">//</span> <span class="mi">393307</span>
  <span class="k">if</span> <span class="p">((</span><span class="nb">int</span><span class="p">)(</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">393307</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">print_integer</span><span class="p">((</span><span class="nb">int</span><span class="p">)</span><span class="n">b</span><span class="p">);</span> <span class="o">//</span> <span class="mi">16777218</span>
  <span class="k">if</span> <span class="p">((</span><span class="nb">int</span><span class="p">)(</span><span class="n">b</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">16777218</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_cmplt_short</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">3</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_cmplt_long</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mi">4</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">4</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_control1</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>	<span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">51</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">51</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_DelUselessJMP</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_movx_1</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">3</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_movx_2</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="mi">2147483647</span><span class="p">);</span> <span class="o">//</span> <span class="n">test</span> <span class="n">mod</span> <span class="o">%</span> <span class="p">(</span><span class="n">mult</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">itoa.cpp</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="o">-</span><span class="mi">2147483648</span><span class="p">);</span> <span class="o">//</span> <span class="n">test</span> <span class="n">mod</span> <span class="o">%</span> <span class="p">(</span><span class="n">multu</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">itoa.cpp</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_sum_longlong</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">9</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">9</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_va_arg</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">12</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">12</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_stacksaverestore</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">5</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_bswap</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_alloc</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">31</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">31</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_inlineasm</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">49</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">49</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>

  <span class="k">return</span> <span class="k">pass</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/input/ch_run_backend.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="c1">#include &quot;ch_nolld.h&quot;</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">bool</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">true</span><span class="p">;</span>
  <span class="k">pass</span> <span class="o">=</span> <span class="n">test_nolld</span><span class="p">();</span>

  <span class="k">return</span> <span class="k">pass</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">#include &quot;ch_nolld.cpp&quot;</span>
</pre></div>
</div>
<p class="rubric">lbdex/input/functions.sh</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>prologue() {
  if [ $ARG_NUM == 0 ]; then
    echo &quot;useage: bash $sh_name cpu_type endian&quot;
    echo &quot;  cpu_type: cpu032I or cpu032II&quot;
    echo &quot;  endian: eb (big endian, default) or el (little endian)&quot;
    echo &quot;for example:&quot;
    echo &quot;  bash build-slinker.sh cpu032I be&quot;
    exit 1;
  fi
  if [ $CPU != cpu032I ] &amp;&amp; [ $CPU != cpu032II ]; then
    echo &quot;1st argument is cpu032I or cpu032II&quot;
    exit 1
  fi

  OS=`uname -s`
  echo &quot;OS =&quot; ${OS}

  TOOLDIR=~/llvm/test/build/bin
  CLANG=~/llvm/test/build/bin/clang

  CPU=$CPU
  echo &quot;CPU =&quot; &quot;${CPU}&quot;

  if [ &quot;$ENDIAN&quot; != &quot;&quot; ] &amp;&amp; [ $ENDIAN != el ] &amp;&amp; [ $ENDIAN != eb ]; then
    echo &quot;2nd argument is eb (big endian, default) or el (little endian)&quot;
    exit 1
  fi
  if [ $ENDIAN == eb ]; then
    ENDIAN=
  fi
  echo &quot;ENDIAN =&quot; &quot;${ENDIAN}&quot;

  bash clean.sh
}

isLittleEndian() {
  echo &quot;ENDIAN = &quot; &quot;$ENDIAN&quot;
  if [ &quot;$ENDIAN&quot; == &quot;LittleEndian&quot; ] ; then
    LE=&quot;true&quot;
  elif [ &quot;$ENDIAN&quot; == &quot;BigEndian&quot; ] ; then
    LE=&quot;false&quot;
  else
    echo &quot;!ENDIAN unknown&quot;
    exit 1
  fi
}

elf2hex() {
  ${TOOLDIR}/llvm-objdump -elf2hex -le=$LE a.out &gt; ../verilog/cpu0.hex
  if [ $LE == &quot;true&quot; ] ; then
    echo &quot;1   /* 0: big endian, 1: little endian */&quot; &gt; ../verilog/cpu0.config
  else
    echo &quot;0   /* 0: big endian, 1: little endian */&quot; &gt; ../verilog/cpu0.config
  fi
  cat ../verilog/cpu0.config
}

epilogue() {
  endian=`${TOOLDIR}/llvm-readobj -h a.out|grep &quot;DataEncoding&quot;|awk &#39;{print $2}&#39;`
  isLittleEndian;
  elf2hex;
}
</pre></div>
</div>
<p class="rubric">lbdex/input/build-run_backend.sh</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#!/usr/bin/env bash

# for example:
# bash build-run_backend.sh cpu032I el
# bash build-run_backend.sh cpu032II eb

source functions.sh

sh_name=build-run_backend.sh
ARG_NUM=$#
CPU=$1
ENDIAN=$2

DEFFLAGS=&quot;&quot;
if [ &quot;$CPU&quot; == cpu032II ] ; then
  DEFFLAGS=${DEFFLAGS}&quot; -DCPU032II&quot;
fi
echo ${DEFFLAGS}

prologue;

# ch8_2_select_global_pic.cpp just for compile build test only, without running 
# on verilog.
$CLANG ${DEFFLAGS} -target mips-unknown-linux-gnu -c ch8_2_select_global_pic.cpp \
-emit-llvm -o ch8_2_select_global_pic.bc
${TOOLDIR}/llc -march=cpu0${ENDIAN} -mcpu=${CPU} -relocation-model=pic \
-filetype=obj ch8_2_select_global_pic.bc -o ch8_2_select_global_pic.cpu0.o

$CLANG ${DEFFLAGS} -target mips-unknown-linux-gnu -c ch_run_backend.cpp \
-emit-llvm -o ch_run_backend.bc
echo &quot;${TOOLDIR}/llc -march=cpu0${ENDIAN} -mcpu=${CPU} -relocation-model=static \
-filetype=obj -enable-cpu0-tail-calls ch_run_backend.bc -o ch_run_backend.cpu0.o&quot;
${TOOLDIR}/llc -march=cpu0${ENDIAN} -mcpu=${CPU} -relocation-model=static \
-filetype=obj -enable-cpu0-tail-calls ch_run_backend.bc -o ch_run_backend.cpu0.o
# print must at the same line, otherwise it will spilt into 2 lines
${TOOLDIR}/llvm-objdump --section=.text -d ch_run_backend.cpu0.o | tail -n +8| awk \
&#39;{print &quot;/* &quot; $1 &quot; */\t&quot; $2 &quot; &quot; $3 &quot; &quot; $4 &quot; &quot; $5 &quot;\t/* &quot; $6&quot;\t&quot; $7&quot; &quot; $8&quot; &quot; $9&quot; &quot; $10 &quot;\t*/&quot;}&#39; \
 &gt; ../verilog/cpu0.hex

ENDIAN=`${TOOLDIR}/llvm-readobj -h ch_run_backend.cpu0.o|grep &quot;DataEncoding&quot;|awk &#39;{print $2}&#39;`
isLittleEndian;

if [ $LE == &quot;true&quot; ] ; then
  echo &quot;1   /* 0: big ENDIAN, 1: little ENDIAN */&quot; &gt; ../verilog/cpu0.config
else
  echo &quot;0   /* 0: big ENDIAN, 1: little ENDIAN */&quot; &gt; ../verilog/cpu0.config
fi
cat ../verilog/cpu0.config
</pre></div>
</div>
<p>To run program without linker implementation at this point, the <code class="docutils literal notranslate"><span class="pre">boot.cpp</span></code> must
be set at the beginning of code, and the <code class="docutils literal notranslate"><span class="pre">main()</span></code> of <code class="docutils literal notranslate"><span class="pre">ch_run_backend.cpp</span></code>
comes immediately after it.</p>
<p>Let’s run <code class="docutils literal notranslate"><span class="pre">Chapter11_2/</span></code> with <code class="docutils literal notranslate"><span class="pre">llvm-objdump</span> <span class="pre">-d</span></code> for input file
<code class="docutils literal notranslate"><span class="pre">ch_run_backend.cpp</span></code> to generate the hex file via <code class="docutils literal notranslate"><span class="pre">build-run_bacekend.sh</span></code>,
then feed the hex file to <code class="docutils literal notranslate"><span class="pre">cpu0</span></code>’s Verilog simulator to get the output result
as below.</p>
<p>Remind that <code class="docutils literal notranslate"><span class="pre">ch_run_backend.cpp</span></code> has to be compiled with the option
<code class="docutils literal notranslate"><span class="pre">clang</span> <span class="pre">-target</span> <span class="pre">mips-unknown-linux-gnu</span></code> since the example code
<code class="docutils literal notranslate"><span class="pre">ch9_3_vararg.cpp</span></code>, which uses vararg, needs to be compiled with this option.
Other example codes have no differences between this option and the default
option.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span><span class="nb">pwd</span>
<span class="go">/Users/Jonathan/llvm/test/lbdex/input</span>
<span class="gp">JonathantekiiMac:input Jonathan$ </span>bash<span class="w"> </span>build-run_backend.sh<span class="w"> </span>cpu032I<span class="w"> </span>eb
<span class="gp">JonathantekiiMac:input Jonathan$ </span><span class="nb">cd</span><span class="w"> </span>../verilog<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>../verilog
<span class="gp">JonathantekiiMac:input Jonathan$ </span><span class="nb">pwd</span>
<span class="go">/Users/Jonathan/llvm/test/lbdex/verilog</span>
<span class="gp">JonathantekiiMac:verilog Jonathan$ </span>make
<span class="gp">JonathantekiiMac:verilog Jonathan$ </span>./cpu0Is
<span class="go">WARNING: cpu0Is.v:386: $readmemh(cpu0.hex): Not enough words in the file for the</span>
<span class="go">taskInterrupt(001)</span>
<span class="go">68</span>
<span class="go">7</span>
<span class="go">0</span>
<span class="go">0</span>
<span class="go">253</span>
<span class="go">3</span>
<span class="go">1</span>
<span class="go">13</span>
<span class="go">3</span>
<span class="go">-126</span>
<span class="go">130</span>
<span class="go">-32766</span>
<span class="go">32770</span>
<span class="go">393307</span>
<span class="go">16777218</span>
<span class="go">3</span>
<span class="go">4</span>
<span class="go">51</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="go">1</span>
<span class="go">2147483647</span>
<span class="go">-2147483648</span>
<span class="go">15</span>
<span class="go">5</span>
<span class="go">0</span>
<span class="go">31</span>
<span class="go">49</span>
<span class="go">total cpu cycles = 50645</span>
<span class="go">RET to PC &lt; 0, finished!</span>

<span class="gp">JonathantekiiMac:input Jonathan$ </span>bash<span class="w"> </span>build-run_backend.sh<span class="w"> </span>cpu032II<span class="w"> </span>eb
<span class="gp">JonathantekiiMac:input Jonathan$ </span><span class="nb">cd</span><span class="w"> </span>../verilog
<span class="gp">JonathantekiiMac:verilog Jonathan$ </span>./cpu0IIs
<span class="go">...</span>
<span class="go">total cpu cycles = 48335</span>
<span class="go">RET to PC &lt; 0, finished!</span>
</pre></div>
</div>
<p>The “total CPU cycles” are calculated in this Verilog simulator to allow
performance review of both the backend compiler and the CPU.</p>
<p>Only CPU cycles are counted in this implementation, as I/O cycle times are
unknown.</p>
<p>As explained in Chapter “Control Flow Statements”, <code class="docutils literal notranslate"><span class="pre">cpu032II</span></code>, which uses
instructions <code class="docutils literal notranslate"><span class="pre">slt</span></code> and <code class="docutils literal notranslate"><span class="pre">beq</span></code>, performs better than <code class="docutils literal notranslate"><span class="pre">cmp</span></code> and <code class="docutils literal notranslate"><span class="pre">jeq</span></code> in
<code class="docutils literal notranslate"><span class="pre">cpu032I</span></code>.</p>
<p>The instruction <code class="docutils literal notranslate"><span class="pre">jmp</span></code> has no delay slot, making it preferable for use in
dynamic linker implementations.</p>
<p>You can trace memory binary code and changes to destination registers at every
instruction execution by unmarking <code class="docutils literal notranslate"><span class="pre">TRACE</span></code> in the Makefile, as shown below:</p>
<p class="rubric">lbdex/verilog/Makefile</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">TRACE</span><span class="o">=-</span><span class="n">D</span><span class="w"> </span><span class="n">TRACE</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:raw Jonathan$ </span>./cpu0Is
<span class="go">WARNING: cpu0.v:386: $readmemh(cpu0.hex): Not enough words in the file for the</span>
<span class="go">requested range [0:28671].</span>
<span class="go">00000000: 2600000c</span>
<span class="go">00000004: 26000004</span>
<span class="go">00000008: 26000004</span>
<span class="go">0000000c: 26fffffc</span>
<span class="go">00000010: 09100000</span>
<span class="go">00000014: 09200000</span>
<span class="go">...</span>
<span class="go">taskInterrupt(001)</span>
<span class="go">1530ns 00000054 : 02ed002c m[28620+44  ]=-1          SW=00000000</span>
<span class="go">1610ns 00000058 : 02bd0028 m[28620+40  ]=0           SW=00000000</span>
<span class="go">...</span>
<span class="go">RET to PC &lt; 0, finished!</span>
</pre></div>
</div>
<p>As shown in the result above, <code class="docutils literal notranslate"><span class="pre">cpu0.v</span></code> dumps the memory content after reading
the input file <code class="docutils literal notranslate"><span class="pre">cpu0.hex</span></code>. Next, it runs instructions from address 0 and prints
each destination register value in the fourth column.</p>
<p>The first column is the timestamp in nanoseconds. The second column is the
instruction address. The third column is the instruction content.</p>
<p>Most of the example codes discussed in previous chapters are verified by printing
variables using <code class="docutils literal notranslate"><span class="pre">print_integer()</span></code>.</p>
<p>Since the <code class="docutils literal notranslate"><span class="pre">cpu0.v</span></code> machine is written in Verilog, it is assumed to be capable of
running on a real FPGA device (though I have not tested this myself). The actual
output hardware interface or port depends on the specific output device, such as
RS232, speaker, LED, etc. You must implement the I/O interface or port and wire
your I/O device accordingly when programming an FPGA.</p>
<p>By running the compiled code on the Verilog simulator, the compiled result from
the Cpu0 backend and the total CPU cycles can be verified and measured.</p>
<p>Currently, this Cpu0 Verilog implementation does not support pipeline
architecture. However, based on the instruction set, it can be extended to a
pipelined model.</p>
<p>The cycle time of the pipelined Cpu0 model is expected to be more than 1/5 of the
“total CPU cycles” shown above, due to dependencies between instructions.</p>
<p>Although the Verilog simulator is slow for running full system programs and does
not count cycles for cache and I/O operations, it provides a simple and effective
way to validate CPU design ideas in the early development stages using small
program patterns.</p>
<p>Creating a full system simulator is complex. While the Wiki website <a class="footnote-reference brackets" href="#wiki-sim" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a>
provides tools for building simulators, doing so requires significant effort.</p>
<p>To generate <code class="docutils literal notranslate"><span class="pre">cpu032I</span></code> code with little-endian format, you can run the following
command. The script <code class="docutils literal notranslate"><span class="pre">build-run_backend.sh</span></code> writes the endian configuration to
<code class="docutils literal notranslate"><span class="pre">../verilog/cpu0.config</span></code> as shown below.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>bash<span class="w"> </span>build-run_backend.sh<span class="w"> </span>cpu032I<span class="w"> </span>el
</pre></div>
</div>
<p class="rubric">../verilog/cpu0.config</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="w">   </span><span class="cm">/* 0: big endian, 1: little endian */</span>
</pre></div>
</div>
<p>The following files test more features.</p>
<p class="rubric">lbdex/input/ch_nolld2.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="c1">#include &quot;debug.h&quot;</span>
<span class="c1">#include &quot;boot.cpp&quot;</span>

<span class="c1">#include &quot;print.h&quot;</span>

<span class="nb">int</span> <span class="n">test_nolld2</span><span class="p">();</span>
</pre></div>
</div>
<p class="rubric">lbdex/input/ch_nolld2.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="c1">#include &quot;print.cpp&quot;</span>

<span class="c1">#include &quot;ch9_3_alloc.cpp&quot;</span>

<span class="nb">int</span> <span class="n">test_nolld2</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">bool</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">true</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">a</span> <span class="o">=</span> <span class="n">test_alloc</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">31</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">31</span><span class="p">)</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
  <span class="k">return</span> <span class="k">pass</span><span class="p">;</span>
<span class="p">}</span>

</pre></div>
</div>
<p class="rubric">lbdex/input/ch_run_backend2.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="c1">#include &quot;ch_nolld2.h&quot;</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">bool</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">true</span><span class="p">;</span>
  <span class="k">pass</span> <span class="o">=</span> <span class="n">test_nolld2</span><span class="p">();</span>

  <span class="k">return</span> <span class="k">pass</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">#include &quot;ch_nolld2.cpp&quot;</span>
</pre></div>
</div>
<p class="rubric">lbdex/input/build-run_backend2.sh</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#!/usr/bin/env bash

source functions.sh

sh_name=build-run_backend.sh
ARG_NUM=$#
CPU=$1
ENDIAN=$2

DEFFLAGS=&quot;&quot;
if [ &quot;$arg1&quot; == cpu032II ] ; then
  DEFFLAGS=${DEFFLAGS}&quot; -DCPU032II&quot;
fi
echo ${DEFFLAGS}

prologue;

${CLANG} ${DEFFLAGS} -c ch_run_backend2.cpp \
-emit-llvm -o ch_run_backend2.bc
${TOOLDIR}/llc -march=cpu0${ENDIAN} -mcpu=${CPU} -relocation-model=static \
-filetype=obj ch_run_backend2.bc -o ch_run_backend2.cpu0.o
${TOOLDIR}/llvm-objdump -d ch_run_backend2.cpu0.o | tail -n +8| awk \
&#39;{print &quot;/* &quot; $1 &quot; */\t&quot; $2 &quot; &quot; $3 &quot; &quot; $4 &quot; &quot; $5 &quot;\t/* &quot; $6&quot;\t&quot; $7&quot; &quot; $8&quot; \
&quot; $9&quot; &quot; $10 &quot;\t*/&quot;}&#39; &gt; ../verilog/cpu0.hex

ENDIAN=`${TOOLDIR}/llvm-readobj -h ch_run_backend2.cpu0.o|grep &quot;DataEncoding&quot;|awk &#39;{print $2}&#39;`
isLittleEndian;

if [ $LE == &quot;true&quot; ] ; then
  echo &quot;1   /* 0: big endian, 1: little endian */&quot; &gt; ../verilog/cpu0.config
else
  echo &quot;0   /* 0: big endian, 1: little endian */&quot; &gt; ../verilog/cpu0.config
fi
cat ../verilog/cpu0.config
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>bash<span class="w"> </span>build-run_backend.sh<span class="w"> </span>cpu032II<span class="w"> </span>el
<span class="go">...</span>
<span class="gp">JonathantekiiMac:input Jonathan$ </span><span class="nb">cd</span><span class="w"> </span>../verilog
<span class="gp">JonathantekiiMac:verilog Jonathan$ </span>./cpu0IIs
<span class="go">...</span>
<span class="go">31</span>
<span class="go">...</span>
</pre></div>
</div>
</section>
<section id="other-llvm-based-tools-for-cpu0-processor">
<h2><a class="toc-backref" href="#id11" role="doc-backlink">Other LLVM-Based Tools for Cpu0 Processor</a><a class="headerlink" href="#other-llvm-based-tools-for-cpu0-processor" title="Link to this heading">¶</a></h2>
<p>You can find the Cpu0 ELF linker implementation based on <code class="docutils literal notranslate"><span class="pre">lld</span></code>, which is the
official LLVM linker project, as well as <code class="docutils literal notranslate"><span class="pre">elf2hex</span></code>, which is modified from the
<code class="docutils literal notranslate"><span class="pre">llvm-objdump</span></code> driver, at the following website:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">jonathan2251</span><span class="o">.</span><span class="n">github</span><span class="o">.</span><span class="n">io</span><span class="o">/</span><span class="n">lbt</span><span class="o">/</span><span class="n">index</span><span class="o">.</span><span class="n">html</span>
</pre></div>
</div>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="free-doc1" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://ccckmit.wikidot.com/ve:main">http://ccckmit.wikidot.com/ve:main</a></p>
</aside>
<aside class="footnote brackets" id="free-doc2" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://www.ece.umd.edu/courses/enee359a/">http://www.ece.umd.edu/courses/enee359a/</a></p>
</aside>
<aside class="footnote brackets" id="free-doc3" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">3</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://www.ece.umd.edu/courses/enee359a/verilog_tutorial.pdf">http://www.ece.umd.edu/courses/enee359a/verilog_tutorial.pdf</a></p>
</aside>
<aside class="footnote brackets" id="free-doc4" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">4</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://d1.amobbs.com/bbs_upload782111/files_33/ourdev_585395BQ8J9A.pdf">http://d1.amobbs.com/bbs_upload782111/files_33/ourdev_585395BQ8J9A.pdf</a></p>
</aside>
<aside class="footnote brackets" id="free-doc5" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">5</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://en.wikipedia.org/wiki/Verilog">http://en.wikipedia.org/wiki/Verilog</a></p>
</aside>
<aside class="footnote brackets" id="vhdl" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">6</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://en.wikipedia.org/wiki/VHDL">http://en.wikipedia.org/wiki/VHDL</a></p>
</aside>
<aside class="footnote brackets" id="wiki-sim" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">7</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Computer_architecture_simulator">https://en.wikipedia.org/wiki/Computer_architecture_simulator</a></p>
</aside>
</aside>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="Bottom">
      
        <p>
        «&#160;&#160;<a href="c%2B%2B.html">C++ support</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="gpu.html">The Concept of GPU Compiler</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
    &#169; Copyright 2016, Chen Chung-Shu.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 9.1.0.
    </div>
  </body>
</html>