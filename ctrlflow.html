
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Control flow statements &#8212; Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Function call" href="funccall.html" />
    <link rel="prev" title="Other data type" href="othertype.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</span></a></h1>
        <h2 class="heading"><span>Control flow statements</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="othertype.html">Other data type</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="funccall.html">Function call</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="control-flow-statements">
<span id="sec-controlflow"></span><h1>Control flow statements<a class="headerlink" href="#control-flow-statements" title="Permalink to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#pipeline-architecture" id="id16">Pipeline architecture</a></p></li>
<li><p><a class="reference internal" href="#control-flow-statement" id="id17">Control flow statement</a></p></li>
<li><p><a class="reference internal" href="#long-branch-support" id="id18">Long branch support</a></p></li>
<li><p><a class="reference internal" href="#cpu0-backend-optimization-remove-useless-jmp" id="id19">Cpu0 backend Optimization: Remove useless JMP</a></p></li>
<li><p><a class="reference internal" href="#fill-branch-delay-slot" id="id20">Fill Branch Delay Slot</a></p></li>
<li><p><a class="reference internal" href="#conditional-instruction" id="id21">Conditional instruction</a></p></li>
<li><p><a class="reference internal" href="#phi-node" id="id22">Phi node</a></p></li>
<li><p><a class="reference internal" href="#risc-cpu-knowledge" id="id23">RISC CPU knowledge</a></p></li>
</ul>
</nav>
<p>This chapter illustrates the corresponding IR for control flow statements, such as
<strong>“if else”</strong>, <strong>“while”</strong> and <strong>“for”</strong> loop statements in C, and how to
translate these control flow statements of llvm IR into Cpu0 instructions in
section I. In <a class="reference external" href="http://jonathan2251.github.io/lbd/ctrlflow.html#cpu0-backend-optimization-remove-useless-jmp">section Remove useless JMP</a>,
an optimization pass of control flow for backend is introduced.
It’s a simple tutorial program to let readers know how to add a
backend optimization pass and program it.
<a class="reference external" href="http://jonathan2251.github.io/lbd/ctrlflow.html#conditional-instruction">section Conditional instruction</a>, includes the Conditional
Instructions Handling since clang will generate specific IRs, select and
select_cc, to support the backend optimiation in control flow statement.</p>
<section id="pipeline-architecture">
<h2><a class="toc-backref" href="#id16" role="doc-backlink">Pipeline architecture</a><a class="headerlink" href="#pipeline-architecture" title="Permalink to this heading">¶</a></h2>
<p>The following figures are from book “Computer Architecture A Quantitative
Approach Fourth Edition”.</p>
<figure class="align-center" id="id10">
<span id="ctrl-pipeline"></span><a class="reference internal image-reference" href="_images/5_stage_pipeline.png"><img alt="_images/5_stage_pipeline.png" src="_images/5_stage_pipeline.png" style="width: 966.0px; height: 396.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 23 </span><span class="caption-text">5 stages of pipeline</span><a class="headerlink" href="#id10" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<ul class="simple">
<li><p>IF: Instruction fetch cycle; ID: Instruction decode/register fetch cycle;
EX: Execution/effective address cycle; MEM: Memory access; WB: Write-back cycle.</p></li>
</ul>
<figure class="align-center" id="id11">
<span id="ctrl-super-pipeline"></span><a class="reference internal image-reference" href="_images/super_pipeline.png"><img alt="_images/super_pipeline.png" src="_images/super_pipeline.png" style="width: 947.0px; height: 492.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 24 </span><span class="caption-text">Super pipeline</span><a class="headerlink" href="#id11" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>Multibanked Caches as <a class="reference internal" href="#ctrlflow-cache-banks"><span class="std std-numref">Fig. 25</span></a> to Increase Cache Bandwidth.</p>
<figure class="align-center" id="id12">
<span id="ctrlflow-cache-banks"></span><a class="reference internal image-reference" href="_images/cache_banks.png"><img alt="_images/cache_banks.png" src="_images/cache_banks.png" style="width: 770.0px; height: 253.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 25 </span><span class="caption-text">Interleaved cache banks</span><a class="headerlink" href="#id12" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>Block size in cache L1 is usualy 16-256 bytes. Euipped with with multibanked
Caches can provide super-pipeline as <a class="reference internal" href="#ctrl-super-pipeline"><span class="std std-numref">Fig. 24</span></a> and
superscalar (multi-issues pipeline) archtectures for fetching
(4*block-size/instruction-size) instructions in a cycle.</p>
</section>
<section id="control-flow-statement">
<h2><a class="toc-backref" href="#id17" role="doc-backlink">Control flow statement</a><a class="headerlink" href="#control-flow-statement" title="Permalink to this heading">¶</a></h2>
<p>Run ch8_1_1.cpp with clang will get result as follows,</p>
<p class="rubric">lbdex/input/ch8_1_1.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">test_ifctrl</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">a</span><span class="o">++</span><span class="p">;</span> <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="p">}</span>
  
  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="nv nv-Anonymous">%0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span><span class="w"></span>
<span class="w">  </span><span class="nv">%cmp</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">eq</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv nv-Anonymous">%0</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="w"></span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cmp</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%if.then</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%if.end</span><span class="w"></span>

<span class="c">; &lt;label&gt;:3:                                      ; preds = %0</span>
<span class="w">  </span><span class="nv nv-Anonymous">%1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span><span class="w"></span>
<span class="w">  </span><span class="nv">%inc</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv nv-Anonymous">%1</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="w"></span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%inc</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span><span class="w"></span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%if.end</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
</pre></div>
</div>
<p>The <strong>“icmp ne”</strong> stands for integer compare NotEqual, <strong>“slt”</strong> stands for Set
Less Than, <strong>“sle”</strong> stands for Set Less or Equal.
Run version Chapter8_1/ with <code class="docutils literal notranslate"><span class="pre">llc</span>&#160; <span class="pre">-view-isel-dags</span></code> or <code class="docutils literal notranslate"><span class="pre">-debug</span></code> option, you
can see the <strong>if</strong> statement is translated into
(br (brcond (%1, setcc(%2, Constant&lt;c&gt;, setne)), BasicBlock_02), BasicBlock_01).
Ignore %1, then we will get the form (br (brcond (setcc(%2, Constant&lt;c&gt;, setne)),
BasicBlock_02), BasicBlock_01).
For explanation, listing the IR DAG as follows,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Optimized legalized selection DAG: BB#0 &#39;_Z11test_ifctrlv:entry&#39;</span>
<span class="go">  SelectionDAG has 12 nodes:</span>
<span class="go">    ...</span>
<span class="go">    t5: i32,ch = load&lt;Volatile LD4[%a]&gt; t4, FrameIndex:i32&lt;0&gt;, undef:i32</span>
<span class="go">        t16: i32 = setcc t5, Constant:i32&lt;0&gt;, setne:ch</span>
<span class="go">      t11: ch = brcond t5:1, t16, BasicBlock:ch&lt;if.end 0x10305a338&gt;</span>
<span class="go">    t13: ch = br t11, BasicBlock:ch&lt;if.then 0x10305a288&gt;</span>
</pre></div>
</div>
<p>We want to translate them into Cpu0 instruction DAGs as follows,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">addiu %3, ZERO, Constant&lt;c&gt;</span>
<span class="go">cmp %2, %3</span>
<span class="go">jne BasicBlock_02</span>
<span class="go">jmp BasicBlock_01</span>
</pre></div>
</div>
<p>For the last IR br, we translate unconditional branch (br BasicBlock_01) into
jmp BasicBlock_01 by the following pattern definition,</p>
<p class="rubric">lbdex/chapters/Chapter8_1/Cpu0InstrInfo.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// Unconditional branch, such as JMP
let Predicates = [Ch8_1] in {
class UncondBranch&lt;bits&lt;8&gt; op, string instr_asm&gt;:
  FJ&lt;op, (outs), (ins jmptarget:$addr),
             !strconcat(instr_asm, &quot;\t$addr&quot;), [(br bb:$addr)], IIBranch&gt; {
  let isBranch = 1;
  let isTerminator = 1;
  let isBarrier = 1;
  let hasDelaySlot = 0;
}
}
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">...</span>
<span class="go">def JMP     : UncondBranch&lt;0x26, &quot;jmp&quot;&gt;;</span>
</pre></div>
</div>
<p>The pattern [(br bb:$imm24)] in class UncondBranch is translated into jmp
machine instruction.
The translation for the pair Cpu0 instructions, <strong>cmp</strong> and <strong>jne</strong>, is not
happened before this chapter.
To solve this chained IR to machine instructions translation, we define the
following pattern,</p>
<p class="rubric">lbdex/chapters/Chapter8_1/Cpu0InstrInfo.td</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// brcond patterns</span>
<span class="n">multiclass</span><span class="w"> </span><span class="n">BrcondPatsCmp</span><span class="o">&lt;</span><span class="n">RegisterClass</span><span class="w"> </span><span class="n">RC</span><span class="p">,</span><span class="w"> </span><span class="n">Instruction</span><span class="w"> </span><span class="n">JEQOp</span><span class="p">,</span><span class="w"> </span><span class="n">Instruction</span><span class="w"> </span><span class="n">JNEOp</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">Instruction</span><span class="w"> </span><span class="n">JLTOp</span><span class="p">,</span><span class="w"> </span><span class="n">Instruction</span><span class="w"> </span><span class="n">JGTOp</span><span class="p">,</span><span class="w"> </span><span class="n">Instruction</span><span class="w"> </span><span class="n">JLEOp</span><span class="p">,</span><span class="w"> </span><span class="n">Instruction</span><span class="w"> </span><span class="n">JGEOp</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">Instruction</span><span class="w"> </span><span class="n">CMPOp</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="nl">def</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">Pat</span><span class="o">&lt;</span><span class="p">(</span><span class="n">brcond</span><span class="w"> </span><span class="p">(</span><span class="n">i32</span><span class="w"> </span><span class="p">(</span><span class="n">setne</span><span class="w"> </span><span class="n">RC</span><span class="o">:</span><span class="n">$lhs</span><span class="p">,</span><span class="w"> </span><span class="n">RC</span><span class="o">:</span><span class="n">$rhs</span><span class="p">)),</span><span class="w"> </span><span class="n">bb</span><span class="o">:</span><span class="n">$dst</span><span class="p">),</span><span class="w"></span>
<span class="w">          </span><span class="p">(</span><span class="n">JNEOp</span><span class="w"> </span><span class="p">(</span><span class="n">CMPOp</span><span class="w"> </span><span class="n">RC</span><span class="o">:</span><span class="n">$lhs</span><span class="p">,</span><span class="w"> </span><span class="n">RC</span><span class="o">:</span><span class="n">$rhs</span><span class="p">),</span><span class="w"> </span><span class="n">bb</span><span class="o">:</span><span class="n">$dst</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="nl">def</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">Pat</span><span class="o">&lt;</span><span class="p">(</span><span class="n">brcond</span><span class="w"> </span><span class="n">RC</span><span class="o">:</span><span class="n">$cond</span><span class="p">,</span><span class="w"> </span><span class="n">bb</span><span class="o">:</span><span class="n">$dst</span><span class="p">),</span><span class="w"></span>
<span class="w">          </span><span class="p">(</span><span class="n">JNEOp</span><span class="w"> </span><span class="p">(</span><span class="n">CMPOp</span><span class="w"> </span><span class="n">RC</span><span class="o">:</span><span class="n">$cond</span><span class="p">,</span><span class="w"> </span><span class="n">ZEROReg</span><span class="p">),</span><span class="w"> </span><span class="n">bb</span><span class="o">:</span><span class="n">$dst</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Since the aboved BrcondPats pattern uses RC (Register Class) as operand, the
following ADDiu pattern defined in Chapter2 will generate instruction
<strong>addiu</strong> before the instruction <strong>cmp</strong> for the first IR,
<strong>setcc(%2, Constant&lt;c&gt;, setne)</strong>, as above.</p>
<p class="rubric">lbdex/chapters/Chapter2/Cpu0InstrInfo.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// Small immediates
def : Pat&lt;(i32 immSExt16:$in),
          (ADDiu ZERO, imm:$in)&gt;;
</pre></div>
</div>
<p>The definition of BrcondPats supports setne, seteq, setlt, …, register operand
compare and setult, setugt, …, for unsigned int type. In addition to seteq
and setne, we define setueq and setune by refering Mips code, even though
we don’t find how to generate setune IR from C language.
We have tried to define unsigned int type, but clang still generates setne
instead of setune.
The order of Pattern Search is from the order of their appearing in context.
The last pattern (brcond RC:$cond, bb:$dst) means branch to $dst
if $cond != 0. So we set the corresponding translation to
(JNEOp (CMPOp RC:$cond, ZEROReg), bb:$dst).</p>
<p>The CMP instruction will set the result to register SW, and then JNE check the
condition based on SW status as <a class="reference internal" href="#ctrlflow-f1"><span class="std std-numref">Fig. 26</span></a>.
Since SW belongs to a different register class, it will be
correct even an instruction is inserted between CMP and JNE as follows,</p>
<figure class="align-center" id="id13">
<span id="ctrlflow-f1"></span><a class="reference internal image-reference" href="_images/11.png"><img alt="_images/11.png" src="_images/11.png" style="width: 223.0px; height: 232.5px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 26 </span><span class="caption-text">JNE (CMP $r2, $r3),</span><a class="headerlink" href="#id13" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">cmp %2, %3</span>
<span class="go">addiu $r1, $r2, 3   // $r1 register never be allocated to $SW because in</span>
<span class="go">                    //  class ArithLogicI, GPROut is the output register</span>
<span class="go">                    //  class and the GPROut is defined without $SW in</span>
<span class="go">                    //  Cpu0RegisterInforGPROutForOther.td</span>
<span class="go">jne BasicBlock_02</span>
</pre></div>
</div>
<p>The reserved registers setting by the following
function code we defined before,</p>
<p class="rubric">lbdex/chapters/Chapter3_1/Cpu0RegisterInfo.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BitVector</span> <span class="n">Cpu0RegisterInfo</span><span class="p">::</span>
<span class="n">getReservedRegs</span><span class="p">(</span><span class="n">const</span> <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
<span class="o">//</span><span class="nd">@getReservedRegs</span> <span class="n">body</span> <span class="p">{</span>
  <span class="n">static</span> <span class="n">const</span> <span class="n">uint16_t</span> <span class="n">ReservedCPURegs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">Cpu0</span><span class="p">::</span><span class="n">ZERO</span><span class="p">,</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">AT</span><span class="p">,</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">SP</span><span class="p">,</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">LR</span><span class="p">,</span> <span class="o">/*</span><span class="n">Cpu0</span><span class="p">::</span><span class="n">SW</span><span class="p">,</span> <span class="o">*/</span><span class="n">Cpu0</span><span class="p">::</span><span class="n">PC</span>
  <span class="p">};</span>
  <span class="n">BitVector</span> <span class="n">Reserved</span><span class="p">(</span><span class="n">getNumRegs</span><span class="p">());</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">unsigned</span> <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">I</span> <span class="o">&lt;</span> <span class="n">array_lengthof</span><span class="p">(</span><span class="n">ReservedCPURegs</span><span class="p">);</span> <span class="o">++</span><span class="n">I</span><span class="p">)</span>
    <span class="n">Reserved</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">ReservedCPURegs</span><span class="p">[</span><span class="n">I</span><span class="p">]);</span>

  <span class="k">return</span> <span class="n">Reserved</span><span class="p">;</span>
<span class="p">}</span>

</pre></div>
</div>
<p>Although the following definition in Cpu0RegisterInfo.td has no real effect in
Reserved Registers, it’s better to comment the Reserved Registers in it for
readability. Setting SW in both register classes CPURegs and SR to allow access
SW by RISC instructions like <code class="docutils literal notranslate"><span class="pre">andi</span></code>, and allow programmers use
traditional assembly instruction <code class="docutils literal notranslate"><span class="pre">cmp</span></code>.
The copyPhysReg() is called when both DestReg and SrcReg are belonging to
different Register Classes.</p>
<p class="rubric">lbdex/chapters/Chapter2/Cpu0RegisterInfo.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//===----------------------------------------------------------------------===//</span>

<span class="k">def</span> <span class="nf">CPURegs</span> <span class="p">:</span> <span class="n">RegisterClass</span><span class="o">&lt;</span><span class="s2">&quot;Cpu0&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">i32</span><span class="p">],</span> <span class="mi">32</span><span class="p">,</span> <span class="p">(</span><span class="n">add</span>
  <span class="o">//</span> <span class="n">Reserved</span>
  <span class="n">ZERO</span><span class="p">,</span> <span class="n">AT</span><span class="p">,</span> 
  <span class="o">//</span> <span class="n">Return</span> <span class="n">Values</span> <span class="ow">and</span> <span class="n">Arguments</span>
  <span class="n">V0</span><span class="p">,</span> <span class="n">V1</span><span class="p">,</span> <span class="n">A0</span><span class="p">,</span> <span class="n">A1</span><span class="p">,</span> 
  <span class="o">//</span> <span class="n">Not</span> <span class="n">preserved</span> <span class="n">across</span> <span class="n">procedure</span> <span class="n">calls</span>
  <span class="n">T9</span><span class="p">,</span> <span class="n">T0</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span>
  <span class="o">//</span> <span class="n">Callee</span> <span class="n">save</span>
  <span class="n">S0</span><span class="p">,</span> <span class="n">S1</span><span class="p">,</span>
  <span class="o">//</span> <span class="n">Reserved</span>
  <span class="n">GP</span><span class="p">,</span> <span class="n">FP</span><span class="p">,</span> 
  <span class="n">SP</span><span class="p">,</span> <span class="n">LR</span><span class="p">,</span> <span class="n">SW</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>

</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">SR</span>     <span class="p">:</span> <span class="n">RegisterClass</span><span class="o">&lt;</span><span class="s2">&quot;Cpu0&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">i32</span><span class="p">],</span> <span class="mi">32</span><span class="p">,</span> <span class="p">(</span><span class="n">add</span> <span class="n">SW</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>

</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter2/Cpu0RegisterInfoGPROutForOther.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">//</span> <span class="n">Register</span> <span class="n">Classes</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="k">def</span> <span class="nf">GPROut</span> <span class="p">:</span> <span class="n">RegisterClass</span><span class="o">&lt;</span><span class="s2">&quot;Cpu0&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">i32</span><span class="p">],</span> <span class="mi">32</span><span class="p">,</span> <span class="p">(</span><span class="n">add</span> <span class="p">(</span><span class="n">sub</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="n">SW</span><span class="p">))</span><span class="o">&gt;</span><span class="p">;</span>

</pre></div>
</div>
<p>Chapter8_1/ include support for control flow statement.
Run with it as well as the following <code class="docutils literal notranslate"><span class="pre">llc</span></code> option, you will get the obj file.
Dump it’s content by gobjdump or hexdump after as follows,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">  118-165-79-206:input Jonathan$ /Users/Jonathan/llvm/test/</span>
<span class="go">  build/bin/llc -march=cpu0 -mcpu=cpu032I -relocation-model=pic</span>
<span class="go">  -filetype=asm ch8_1_1.bc -o -</span>
<span class="go">  ...</span>
<span class="go">  ld  $4, 36($fp)</span>
<span class="go">  cmp $sw, $4, $3</span>
<span class="go">  jne $BB0_2</span>
<span class="go">  jmp $BB0_1</span>
<span class="gp">$</span>BB0_1:                                 <span class="c1"># %if.then</span>
<span class="go">  ld  $4, 36($fp)</span>
<span class="go">  addiu $4, $4, 1</span>
<span class="go">  st  $4, 36($fp)</span>
<span class="gp">$</span>BB0_2:                                 <span class="c1"># %if.end</span>
<span class="go">  ld  $4, 32($fp)</span>
<span class="go">  ...</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-79-206:input Jonathan$ </span>/Users/Jonathan/llvm/test/
<span class="go">build/bin/llc -march=cpu0 -mcpu=cpu032I -relocation-model=pic</span>
<span class="go">-filetype=obj ch8_1_1.bc -o ch8_1_1.cpu0.o</span>

<span class="gp">118-165-79-206:input Jonathan$ </span>hexdump ch8_1_1.cpu0.o
<span class="go">    // jmp offset is 0x10=16 bytes which is correct</span>
<span class="go">0000080 ...................................... 10 43 00 00</span>
<span class="go">0000090 31 00 00 10 36 00 00 00 ..........................</span>
</pre></div>
</div>
<p>The immediate value of jne (op 0x31) is 16; The offset between jne and $BB0_2
is 20 (5 words = 5*4 bytes). Suppose the jne address is X, then the label
$BB0_2 is X+20.
Cpu0’s instruction set is designed as a RISC CPU with 5 stages of pipeline just
like 5 stages of Mips.
Cpu0 do branch instruction execution at decode stage which like mips too.
After the jne instruction fetched, the PC (Program Counter) is X+4 since cpu0
update PC at fetch stage.
The $BB0_2 address is equal to PC+16 for the jne branch instruction execute at
decode stage.
List and explain this again as follows,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">              // Fetch instruction stage for jne instruction. The fetch stage</span>
<span class="go">              // can be divided into 2 cycles. First cycle fetch the</span>
<span class="go">              // instruction. Second cycle adjust PC = PC+4.</span>
<span class="go">  jne $BB0_2  // Do jne compare in decode stage. PC = X+4 at this stage.</span>
<span class="go">              // When jne immediate value is 16, PC = PC+16. It will fetch</span>
<span class="go">              //  X+20 which equal to label $BB0_2 instruction, ld $4, 32($sp).</span>
<span class="go">  nop</span>
<span class="gp">$</span>BB0_1:                                 <span class="c1"># %if.then</span>
<span class="go">  ld  $4, 36($fp)</span>
<span class="go">  addiu $4, $4, 1</span>
<span class="go">  st  $4, 36($fp)</span>
<span class="gp">$</span>BB0_2:                                 <span class="c1"># %if.end</span>
<span class="go">  ld  $4, 32($fp)</span>
</pre></div>
</div>
<p>If Cpu0 do <strong>“jne”</strong> in execution stage, then we should set PC=PC+12,
offset of ($BB0_2, jne $BB02) – 8, in this example.</p>
<p>In reality, the conditional branch is important in performance of CPU design.
According bench mark information, every 7 instructions will meet 1 branch
instruction in average.
The cpu032I spends 2 instructions in conditional branch, (jne(cmp…)), while
cpu032II use one instruction (bne) as follws,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>/Users/Jonathan/llvm/test/
<span class="go">build/bin/llc -march=cpu0 -mcpu=cpu032I -relocation-model=pic</span>
<span class="go">-filetype=asm ch8_1_1.bc -o -</span>
<span class="go">  ...</span>
<span class="go">      cmp     $sw, $4, $3</span>
<span class="go">      jne     $sw, $BB0_2</span>
<span class="go">      jmp     $BB0_1</span>
<span class="gp">$</span>BB0_1:

<span class="gp">JonathantekiiMac:input Jonathan$ </span>/Users/Jonathan/llvm/test/
<span class="go">build/bin/llc -march=cpu0 -mcpu=cpu032II -relocation-model=pic</span>
<span class="go">-filetype=asm ch8_1_1.bc -o -</span>
<span class="go">  ...</span>
<span class="go">      bne     $4, $zero, $BB0_2</span>
<span class="go">      jmp     $BB0_1</span>
<span class="gp">$</span>BB0_1:
</pre></div>
</div>
<p>Beside brcond explained in this section, above code also include DAG opcode
<strong>br_jt</strong> and label <strong>JumpTable</strong> which occurs during DAG translation for
some kind of program.</p>
<p>The ch8_1_ctrl.cpp include <strong>“nest if”</strong> <strong>“for loop”</strong>, <strong>“while loop”</strong>,
<strong>“continue”</strong>, <strong>“break”</strong> and <strong>“goto”</strong>.
The ch8_1_br_jt.cpp is for <strong>br_jt</strong> and <strong>JumpTable</strong> test.
The ch8_1_blockaddr.cpp is for <strong>blockaddress</strong> and <strong>indirectbr</strong> test.
You can run with them if you like to test more.</p>
<p>List the control flow statements of C, IR, DAG and Cpu0 instructions as the
following table.</p>
<table class="docutils align-default" id="id14">
<caption><span class="caption-number">Table 31 </span><span class="caption-text">Control flow statements of C, IR, DAG and Cpu0 instructions</span><a class="headerlink" href="#id14" title="Permalink to this table">¶</a></caption>
<tbody>
<tr class="row-odd"><td><p>C</p></td>
<td><p>if, else, for, while, goto, switch, break</p></td>
</tr>
<tr class="row-even"><td><p>IR</p></td>
<td><p>(icmp + (eq, ne, sgt, sge, slt, sle)0 + br</p></td>
</tr>
<tr class="row-odd"><td><p>DAG</p></td>
<td><p>(seteq, setne, setgt, setge, setlt, setle) + brcond,</p></td>
</tr>
<tr class="row-even"><td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>(setueq, setune, setugt, setuge, setult, setule) + brcond</p></td>
</tr>
<tr class="row-odd"><td><p>cpu032I</p></td>
<td><p>CMP + (JEQ, JNE, JGT, JGE, JLT, JLE)</p></td>
</tr>
<tr class="row-even"><td><p>cpu032II</p></td>
<td><p>(SLT, SLTu, SLTi, SLTiu) + (BEG, BNE)</p></td>
</tr>
</tbody>
</table>
</section>
<section id="long-branch-support">
<h2><a class="toc-backref" href="#id18" role="doc-backlink">Long branch support</a><a class="headerlink" href="#long-branch-support" title="Permalink to this heading">¶</a></h2>
<p>As last section, cpu032II uses beq and bne to improve performance but the jump
offset reduces from 24 bits to 16 bits. If program exists more than 16 bits,
cpu032II will fail to generate code. Mips backend has solution and Cpu0 hire
the solution from it.</p>
<p>To support long branch the following code added in Chapter8_1.</p>
<p class="rubric">lbdex/chapters/Chapter8_2/CMakeLists.txt</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">Cpu0LongBranch</span><span class="o">.</span><span class="n">cpp</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter8_2/Cpu0.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">FunctionPass</span> <span class="o">*</span><span class="n">createCpu0LongBranchPass</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter8_2/MCTargetDesc/Cpu0MCCodeEmitter.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">unsigned</span> <span class="n">Cpu0MCCodeEmitter</span><span class="p">::</span>
<span class="n">getJumpTargetOpValue</span><span class="p">(</span><span class="n">const</span> <span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">OpNo</span><span class="p">,</span>
                     <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCFixup</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Fixups</span><span class="p">,</span>
                     <span class="n">const</span> <span class="n">MCSubtargetInfo</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">if</span> <span class="p">(</span><span class="n">Opcode</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">JMP</span> <span class="o">||</span> <span class="n">Opcode</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">BAL</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter8_2/Cpu0AsmPrinter.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="nb">bool</span> <span class="n">isLongBranchPseudo</span><span class="p">(</span><span class="nb">int</span> <span class="n">Opcode</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter8_2/Cpu0AsmPrinter.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//-</span> <span class="n">emitInstruction</span><span class="p">()</span> <span class="n">must</span> <span class="n">exists</span> <span class="ow">or</span> <span class="n">will</span> <span class="n">have</span> <span class="n">run</span> <span class="n">time</span> <span class="n">error</span><span class="o">.</span>
<span class="n">void</span> <span class="n">Cpu0AsmPrinter</span><span class="p">::</span><span class="n">emitInstruction</span><span class="p">(</span><span class="n">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    if (I-&gt;isPseudo() &amp;&amp; !isLongBranchPseudo(I-&gt;getOpcode()))
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">bool</span> <span class="n">Cpu0AsmPrinter</span><span class="p">::</span><span class="n">isLongBranchPseudo</span><span class="p">(</span><span class="nb">int</span> <span class="n">Opcode</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">Opcode</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">LONG_BRANCH_LUi</span>
          <span class="o">||</span> <span class="n">Opcode</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">LONG_BRANCH_ADDiu</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter8_2/Cpu0InstrInfo.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">virtual</span> <span class="n">unsigned</span> <span class="n">getOppositeBranchOpc</span><span class="p">(</span><span class="n">unsigned</span> <span class="n">Opc</span><span class="p">)</span> <span class="n">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter8_2/Cpu0InstrInfo.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>let Predicates = [Ch8_2] in {
// We need these two pseudo instructions to avoid offset calculation for long
// branches.  See the comment in file Cpu0LongBranch.cpp for detailed
// explanation.

// Expands to: lui $dst, %hi($tgt - $baltgt)
def LONG_BRANCH_LUi : Cpu0Pseudo&lt;(outs GPROut:$dst),
  (ins jmptarget:$tgt, jmptarget:$baltgt), &quot;&quot;, []&gt;;

// Expands to: addiu $dst, $src, %lo($tgt - $baltgt)
def LONG_BRANCH_ADDiu : Cpu0Pseudo&lt;(outs GPROut:$dst),
  (ins GPROut:$src, jmptarget:$tgt, jmptarget:$baltgt), &quot;&quot;, []&gt;;
}
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>let isBranch = 1, isTerminator = 1, isBarrier = 1,
    hasDelaySlot = 0, Defs = [LR] in
def BAL: FJ&lt;0x3A, (outs), (ins jmptarget:$addr), &quot;bal\t$addr&quot;, [], IIBranch&gt;, 
             Requires&lt;[HasSlt]&gt;;
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter8_2/Cpu0LongBranch.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>//===-- Cpu0LongBranch.cpp - Emit long branches ---------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This pass expands a branch or jump instruction into a long branch if its
// offset is too large to fit into its immediate field.
//
// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.
//===----------------------------------------------------------------------===//

// In 9.0.0 rename MipsLongBranch.cpp to MipsBranchExpansion.cpp

#include &quot;Cpu0.h&quot;

#if CH &gt;= CH8_2

#include &quot;MCTargetDesc/Cpu0BaseInfo.h&quot;
#include &quot;Cpu0MachineFunction.h&quot;
#include &quot;Cpu0TargetMachine.h&quot;
#include &quot;llvm/ADT/Statistic.h&quot;
#include &quot;llvm/CodeGen/MachineFunctionPass.h&quot;
#include &quot;llvm/CodeGen/MachineInstrBuilder.h&quot;
#include &quot;llvm/CodeGen/TargetInstrInfo.h&quot;
#include &quot;llvm/CodeGen/TargetRegisterInfo.h&quot;
#include &quot;llvm/IR/Function.h&quot;
#include &quot;llvm/Support/CommandLine.h&quot;
#include &quot;llvm/Support/MathExtras.h&quot;
#include &quot;llvm/Target/TargetMachine.h&quot;

using namespace llvm;

#define DEBUG_TYPE &quot;cpu0-long-branch&quot;

STATISTIC(LongBranches, &quot;Number of long branches.&quot;);

static cl::opt&lt;bool&gt; ForceLongBranch(
  &quot;force-cpu0-long-branch&quot;,
  cl::init(false),
  cl::desc(&quot;CPU0: Expand all branches to long format.&quot;),
  cl::Hidden);

namespace {
  typedef MachineBasicBlock::iterator Iter;
  typedef MachineBasicBlock::reverse_iterator ReverseIter;

  struct MBBInfo {
    uint64_t Size, Address;
    bool HasLongBranch;
    MachineInstr *Br;

    MBBInfo() : Size(0), HasLongBranch(false), Br(nullptr) {}
  };

  class Cpu0LongBranch : public MachineFunctionPass {

  public:
    static char ID;
    Cpu0LongBranch(TargetMachine &amp;tm)
        : MachineFunctionPass(ID), TM(tm), IsPIC(TM.isPositionIndependent()),
          ABI(static_cast&lt;const Cpu0TargetMachine &amp;&gt;(TM).getABI()) {}

    StringRef getPassName() const override {
      return &quot;Cpu0 Long Branch&quot;;
    }

    bool runOnMachineFunction(MachineFunction &amp;F) override;

  private:
    void splitMBB(MachineBasicBlock *MBB);
    void initMBBInfo();
    int64_t computeOffset(const MachineInstr *Br);
    void replaceBranch(MachineBasicBlock &amp;MBB, Iter Br, const DebugLoc &amp;DL,
                       MachineBasicBlock *MBBOpnd);
    void expandToLongBranch(MBBInfo &amp;Info);

    const TargetMachine &amp;TM;
    MachineFunction *MF;
    SmallVector&lt;MBBInfo, 16&gt; MBBInfos;
    bool IsPIC;
    Cpu0ABIInfo ABI;
    unsigned LongBranchSeqSize;
  };

  char Cpu0LongBranch::ID = 0;
} // end of anonymous namespace

/// createCpu0LongBranchPass - Returns a pass that converts branches to long
/// branches.
FunctionPass *llvm::createCpu0LongBranchPass(Cpu0TargetMachine &amp;tm) {
  return new Cpu0LongBranch(tm);
}

/// Iterate over list of Br&#39;s operands and search for a MachineBasicBlock
/// operand.
static MachineBasicBlock *getTargetMBB(const MachineInstr &amp;Br) {
  for (unsigned I = 0, E = Br.getDesc().getNumOperands(); I &lt; E; ++I) {
    const MachineOperand &amp;MO = Br.getOperand(I);

    if (MO.isMBB())
      return MO.getMBB();
  }

  llvm_unreachable(&quot;This instruction does not have an MBB operand.&quot;);
}

// Traverse the list of instructions backwards until a non-debug instruction is
// found or it reaches E.
static ReverseIter getNonDebugInstr(ReverseIter B, const ReverseIter &amp;E) {
  for (; B != E; ++B)
    if (!B-&gt;isDebugValue())
      return B;

  return E;
}

// Split MBB if it has two direct jumps/branches.
void Cpu0LongBranch::splitMBB(MachineBasicBlock *MBB) {
  ReverseIter End = MBB-&gt;rend();
  ReverseIter LastBr = getNonDebugInstr(MBB-&gt;rbegin(), End);

  // Return if MBB has no branch instructions.
  if ((LastBr == End) ||
      (!LastBr-&gt;isConditionalBranch() &amp;&amp; !LastBr-&gt;isUnconditionalBranch()))
    return;

  ReverseIter FirstBr = getNonDebugInstr(std::next(LastBr), End);

  // MBB has only one branch instruction if FirstBr is not a branch
  // instruction.
  if ((FirstBr == End) ||
      (!FirstBr-&gt;isConditionalBranch() &amp;&amp; !FirstBr-&gt;isUnconditionalBranch()))
    return;

  assert(!FirstBr-&gt;isIndirectBranch() &amp;&amp; &quot;Unexpected indirect branch found.&quot;);

  // Create a new MBB. Move instructions in MBB to the newly created MBB.
  MachineBasicBlock *NewMBB =
    MF-&gt;CreateMachineBasicBlock(MBB-&gt;getBasicBlock());

  // Insert NewMBB and fix control flow.
  MachineBasicBlock *Tgt = getTargetMBB(*FirstBr);
  NewMBB-&gt;transferSuccessors(MBB);
  if (Tgt != getTargetMBB(*LastBr))
    NewMBB-&gt;removeSuccessor(Tgt, true);
  MBB-&gt;addSuccessor(NewMBB);
  MBB-&gt;addSuccessor(Tgt);
  MF-&gt;insert(std::next(MachineFunction::iterator(MBB)), NewMBB);

  NewMBB-&gt;splice(NewMBB-&gt;end(), MBB, LastBr.getReverse(), MBB-&gt;end());
}

// Fill MBBInfos.
void Cpu0LongBranch::initMBBInfo() {
  // Split the MBBs if they have two branches. Each basic block should have at
  // most one branch after this loop is executed.
  for (auto &amp;MBB : *MF)
    splitMBB(&amp;MBB);

  MF-&gt;RenumberBlocks();
  MBBInfos.clear();
  MBBInfos.resize(MF-&gt;size());

  const Cpu0InstrInfo *TII =
      static_cast&lt;const Cpu0InstrInfo *&gt;(MF-&gt;getSubtarget().getInstrInfo());
  for (unsigned I = 0, E = MBBInfos.size(); I &lt; E; ++I) {
    MachineBasicBlock *MBB = MF-&gt;getBlockNumbered(I);

    // Compute size of MBB.
    for (MachineBasicBlock::instr_iterator MI = MBB-&gt;instr_begin();
         MI != MBB-&gt;instr_end(); ++MI)
      MBBInfos[I].Size += TII-&gt;GetInstSizeInBytes(*MI);

    // Search for MBB&#39;s branch instruction.
    ReverseIter End = MBB-&gt;rend();
    ReverseIter Br = getNonDebugInstr(MBB-&gt;rbegin(), End);

    if ((Br != End) &amp;&amp; !Br-&gt;isIndirectBranch() &amp;&amp;
        (Br-&gt;isConditionalBranch() || (Br-&gt;isUnconditionalBranch() &amp;&amp; IsPIC)))
      MBBInfos[I].Br = &amp;(*Br.getReverse());
  }
}

// Compute offset of branch in number of bytes.
int64_t Cpu0LongBranch::computeOffset(const MachineInstr *Br) {
  int64_t Offset = 0;
  int ThisMBB = Br-&gt;getParent()-&gt;getNumber();
  int TargetMBB = getTargetMBB(*Br)-&gt;getNumber();

  // Compute offset of a forward branch.
  if (ThisMBB &lt; TargetMBB) {
    for (int N = ThisMBB + 1; N &lt; TargetMBB; ++N)
      Offset += MBBInfos[N].Size;

    return Offset + 4;
  }

  // Compute offset of a backward branch.
  for (int N = ThisMBB; N &gt;= TargetMBB; --N)
    Offset += MBBInfos[N].Size;

  return -Offset + 4;
}

// Replace Br with a branch which has the opposite condition code and a
// MachineBasicBlock operand MBBOpnd.
void Cpu0LongBranch::replaceBranch(MachineBasicBlock &amp;MBB, Iter Br,
                                   const DebugLoc &amp;DL,
                                   MachineBasicBlock *MBBOpnd) {
  const Cpu0InstrInfo *TII = static_cast&lt;const Cpu0InstrInfo *&gt;(
      MBB.getParent()-&gt;getSubtarget().getInstrInfo());
  unsigned NewOpc = TII-&gt;getOppositeBranchOpc(Br-&gt;getOpcode());
  const MCInstrDesc &amp;NewDesc = TII-&gt;get(NewOpc);

  MachineInstrBuilder MIB = BuildMI(MBB, Br, DL, NewDesc);

  for (unsigned I = 0, E = Br-&gt;getDesc().getNumOperands(); I &lt; E; ++I) {
    MachineOperand &amp;MO = Br-&gt;getOperand(I);

    if (!MO.isReg()) {
      assert(MO.isMBB() &amp;&amp; &quot;MBB operand expected.&quot;);
      break;
    }

    MIB.addReg(MO.getReg());
  }

  MIB.addMBB(MBBOpnd);

  if (Br-&gt;hasDelaySlot()) {
    // Bundle the instruction in the delay slot to the newly created branch
    // and erase the original branch.
    assert(Br-&gt;isBundledWithSucc());
    MachineBasicBlock::instr_iterator II = Br.getInstrIterator();
    MIBundleBuilder(&amp;*MIB).append((++II)-&gt;removeFromBundle());
  }
  Br-&gt;eraseFromParent();
}

// Expand branch instructions to long branches.
// TODO: This function has to be fixed for beqz16 and bnez16, because it
// currently assumes that all branches have 16-bit offsets, and will produce
// wrong code if branches whose allowed offsets are [-128, -126, ..., 126]
// are present.
void Cpu0LongBranch::expandToLongBranch(MBBInfo &amp;I) {
  MachineBasicBlock::iterator Pos;
  MachineBasicBlock *MBB = I.Br-&gt;getParent(), *TgtMBB = getTargetMBB(*I.Br);
  DebugLoc DL = I.Br-&gt;getDebugLoc();
  const BasicBlock *BB = MBB-&gt;getBasicBlock();
  MachineFunction::iterator FallThroughMBB = ++MachineFunction::iterator(MBB);
  MachineBasicBlock *LongBrMBB = MF-&gt;CreateMachineBasicBlock(BB);
  const Cpu0Subtarget &amp;Subtarget =
      static_cast&lt;const Cpu0Subtarget &amp;&gt;(MF-&gt;getSubtarget());
  const Cpu0InstrInfo *TII =
      static_cast&lt;const Cpu0InstrInfo *&gt;(Subtarget.getInstrInfo());

  MF-&gt;insert(FallThroughMBB, LongBrMBB);
  MBB-&gt;replaceSuccessor(TgtMBB, LongBrMBB);

  if (IsPIC) {
    MachineBasicBlock *BalTgtMBB = MF-&gt;CreateMachineBasicBlock(BB);
    MF-&gt;insert(FallThroughMBB, BalTgtMBB);
    LongBrMBB-&gt;addSuccessor(BalTgtMBB);
    BalTgtMBB-&gt;addSuccessor(TgtMBB);

    unsigned BalOp = Cpu0::BAL;

    // $longbr:
    //  addiu $sp, $sp, -8
    //  st $lr, 0($sp)
    //  lui $at, %hi($tgt - $baltgt)
    //  addiu $lr, $lr, %lo($tgt - $baltgt)
    //  bal $baltgt
    //  nop
    // $baltgt:
    //  addu $at, $lr, $at
    //  addiu $sp, $sp, 8
    //  ld $lr, 0($sp)
    //  jr $at
    //  nop
    // $fallthrough:
    //

    Pos = LongBrMBB-&gt;begin();

    BuildMI(*LongBrMBB, Pos, DL, TII-&gt;get(Cpu0::ADDiu), Cpu0::SP)
      .addReg(Cpu0::SP).addImm(-8);
    BuildMI(*LongBrMBB, Pos, DL, TII-&gt;get(Cpu0::ST)).addReg(Cpu0::LR)
      .addReg(Cpu0::SP).addImm(0);

    // LUi and ADDiu instructions create 32-bit offset of the target basic
    // block from the target of BAL instruction.  We cannot use immediate
    // value for this offset because it cannot be determined accurately when
    // the program has inline assembly statements.  We therefore use the
    // relocation expressions %hi($tgt-$baltgt) and %lo($tgt-$baltgt) which
    // are resolved during the fixup, so the values will always be correct.
    //
    // Since we cannot create %hi($tgt-$baltgt) and %lo($tgt-$baltgt)
    // expressions at this point (it is possible only at the MC layer),
    // we replace LUi and ADDiu with pseudo instructions
    // LONG_BRANCH_LUi and LONG_BRANCH_ADDiu, and add both basic
    // blocks as operands to these instructions.  When lowering these pseudo
    // instructions to LUi and ADDiu in the MC layer, we will create
    // %hi($tgt-$baltgt) and %lo($tgt-$baltgt) expressions and add them as
    // operands to lowered instructions.

    BuildMI(*LongBrMBB, Pos, DL, TII-&gt;get(Cpu0::LONG_BRANCH_LUi), Cpu0::AT)
      .addMBB(TgtMBB).addMBB(BalTgtMBB);
    BuildMI(*LongBrMBB, Pos, DL, TII-&gt;get(Cpu0::LONG_BRANCH_ADDiu), Cpu0::AT)
      .addReg(Cpu0::AT).addMBB(TgtMBB).addMBB(BalTgtMBB);
    MIBundleBuilder(*LongBrMBB, Pos)
        .append(BuildMI(*MF, DL, TII-&gt;get(BalOp)).addMBB(BalTgtMBB));

    Pos = BalTgtMBB-&gt;begin();

    BuildMI(*BalTgtMBB, Pos, DL, TII-&gt;get(Cpu0::ADDu), Cpu0::AT)
      .addReg(Cpu0::LR).addReg(Cpu0::AT);
    BuildMI(*BalTgtMBB, Pos, DL, TII-&gt;get(Cpu0::LD), Cpu0::LR)
      .addReg(Cpu0::SP).addImm(0);
    BuildMI(*BalTgtMBB, Pos, DL, TII-&gt;get(Cpu0::ADDiu), Cpu0::SP)
      .addReg(Cpu0::SP).addImm(8);

    MIBundleBuilder(*BalTgtMBB, Pos)
      .append(BuildMI(*MF, DL, TII-&gt;get(Cpu0::JR)).addReg(Cpu0::AT))
      .append(BuildMI(*MF, DL, TII-&gt;get(Cpu0::NOP)));

    assert(LongBrMBB-&gt;size() + BalTgtMBB-&gt;size() == LongBranchSeqSize);
  } else {
    // $longbr:
    //  jmp $tgt
    //  nop
    // $fallthrough:
    //
    Pos = LongBrMBB-&gt;begin();
    LongBrMBB-&gt;addSuccessor(TgtMBB);
    MIBundleBuilder(*LongBrMBB, Pos)
      .append(BuildMI(*MF, DL, TII-&gt;get(Cpu0::JMP)).addMBB(TgtMBB))
      .append(BuildMI(*MF, DL, TII-&gt;get(Cpu0::NOP)));

    assert(LongBrMBB-&gt;size() == LongBranchSeqSize);
  }

  if (I.Br-&gt;isUnconditionalBranch()) {
    // Change branch destination.
    assert(I.Br-&gt;getDesc().getNumOperands() == 1);
    I.Br-&gt;RemoveOperand(0);
    I.Br-&gt;addOperand(MachineOperand::CreateMBB(LongBrMBB));
  } else
    // Change branch destination and reverse condition.
    replaceBranch(*MBB, I.Br, DL, &amp;*FallThroughMBB);
}

static void emitGPDisp(MachineFunction &amp;F, const Cpu0InstrInfo *TII) {
  MachineBasicBlock &amp;MBB = F.front();
  MachineBasicBlock::iterator I = MBB.begin();
  DebugLoc DL = MBB.findDebugLoc(MBB.begin());
  BuildMI(MBB, I, DL, TII-&gt;get(Cpu0::LUi), Cpu0::V0)
    .addExternalSymbol(&quot;_gp_disp&quot;, Cpu0II::MO_ABS_HI);
  BuildMI(MBB, I, DL, TII-&gt;get(Cpu0::ADDiu), Cpu0::V0)
    .addReg(Cpu0::V0).addExternalSymbol(&quot;_gp_disp&quot;, Cpu0II::MO_ABS_LO);
  MBB.removeLiveIn(Cpu0::V0);
}

bool Cpu0LongBranch::runOnMachineFunction(MachineFunction &amp;F) {
  const Cpu0Subtarget &amp;STI =
      static_cast&lt;const Cpu0Subtarget &amp;&gt;(F.getSubtarget());
  const Cpu0InstrInfo *TII =
      static_cast&lt;const Cpu0InstrInfo *&gt;(STI.getInstrInfo());
  LongBranchSeqSize =
      !IsPIC ? 2 : 10;

  if (!STI.enableLongBranchPass())
    return false;
  if (IsPIC &amp;&amp; static_cast&lt;const Cpu0TargetMachine &amp;&gt;(TM).getABI().IsO32() &amp;&amp;
      F.getInfo&lt;Cpu0FunctionInfo&gt;()-&gt;globalBaseRegSet())
    emitGPDisp(F, TII);

  MF = &amp;F;
  initMBBInfo();

  SmallVectorImpl&lt;MBBInfo&gt;::iterator I, E = MBBInfos.end();
  bool EverMadeChange = false, MadeChange = true;

  while (MadeChange) {
    MadeChange = false;

    for (I = MBBInfos.begin(); I != E; ++I) {
      // Skip if this MBB doesn&#39;t have a branch or the branch has already been
      // converted to a long branch.
      if (!I-&gt;Br || I-&gt;HasLongBranch)
        continue;

      int ShVal = 4;
      int64_t Offset = computeOffset(I-&gt;Br) / ShVal;

      // Check if offset fits into 16-bit immediate field of branches.
      if (!ForceLongBranch &amp;&amp; isInt&lt;16&gt;(Offset))
        continue;

      I-&gt;HasLongBranch = true;
      I-&gt;Size += LongBranchSeqSize * 4;
      ++LongBranches;
      EverMadeChange = MadeChange = true;
    }
  }

  if (!EverMadeChange)
    return true;

  // Compute basic block addresses.
  if (IsPIC) {
    uint64_t Address = 0;

    for (I = MBBInfos.begin(); I != E; Address += I-&gt;Size, ++I)
      I-&gt;Address = Address;
  }

  // Do the expansion.
  for (I = MBBInfos.begin(); I != E; ++I)
    if (I-&gt;HasLongBranch)
      expandToLongBranch(*I);

  MF-&gt;RenumberBlocks();

  return true;
}

#endif //#if CH &gt;= CH8_2
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter8_2/Cpu0MCInstLower.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">MCOperand</span> <span class="n">createSub</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">BB1</span><span class="p">,</span> <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">BB2</span><span class="p">,</span>
                      <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">Cpu0ExprKind</span> <span class="n">Kind</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
  <span class="n">void</span> <span class="n">lowerLongBranchLUi</span><span class="p">(</span><span class="n">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">OutMI</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
  <span class="n">void</span> <span class="n">lowerLongBranchADDiu</span><span class="p">(</span><span class="n">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">OutMI</span><span class="p">,</span>
                            <span class="nb">int</span> <span class="n">Opcode</span><span class="p">,</span>
                            <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">Cpu0ExprKind</span> <span class="n">Kind</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
  <span class="nb">bool</span> <span class="n">lowerLongBranch</span><span class="p">(</span><span class="n">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">OutMI</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter8_2/Cpu0MCInstLower.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>MCOperand Cpu0MCInstLower::createSub(MachineBasicBlock *BB1,
                                     MachineBasicBlock *BB2,
                                     Cpu0MCExpr::Cpu0ExprKind Kind) const {
  const MCSymbolRefExpr *Sym1 = MCSymbolRefExpr::create(BB1-&gt;getSymbol(), *Ctx);
  const MCSymbolRefExpr *Sym2 = MCSymbolRefExpr::create(BB2-&gt;getSymbol(), *Ctx);
  const MCBinaryExpr *Sub = MCBinaryExpr::createSub(Sym1, Sym2, *Ctx);

  return MCOperand::createExpr(Cpu0MCExpr::create(Kind, Sub, *Ctx));
}

void Cpu0MCInstLower::
lowerLongBranchLUi(const MachineInstr *MI, MCInst &amp;OutMI) const {
  OutMI.setOpcode(Cpu0::LUi);

  // Lower register operand.
  OutMI.addOperand(LowerOperand(MI-&gt;getOperand(0)));

  // Create %hi($tgt-$baltgt).
  OutMI.addOperand(createSub(MI-&gt;getOperand(1).getMBB(),
                             MI-&gt;getOperand(2).getMBB(),
                             Cpu0MCExpr::CEK_ABS_HI));
}

void Cpu0MCInstLower::
lowerLongBranchADDiu(const MachineInstr *MI, MCInst &amp;OutMI, int Opcode,
                     Cpu0MCExpr::Cpu0ExprKind Kind) const {
  OutMI.setOpcode(Opcode);

  // Lower two register operands.
  for (unsigned I = 0, E = 2; I != E; ++I) {
    const MachineOperand &amp;MO = MI-&gt;getOperand(I);
    OutMI.addOperand(LowerOperand(MO));
  }

  // Create %lo($tgt-$baltgt) or %hi($tgt-$baltgt).
  OutMI.addOperand(createSub(MI-&gt;getOperand(2).getMBB(),
                             MI-&gt;getOperand(3).getMBB(), Kind));
}

bool Cpu0MCInstLower::lowerLongBranch(const MachineInstr *MI,
                                      MCInst &amp;OutMI) const {
  switch (MI-&gt;getOpcode()) {
  default:
    return false;
  case Cpu0::LONG_BRANCH_LUi:
    lowerLongBranchLUi(MI, OutMI);
    return true;
  case Cpu0::LONG_BRANCH_ADDiu:
    lowerLongBranchADDiu(MI, OutMI, Cpu0::ADDiu,
                         Cpu0MCExpr::CEK_ABS_LO);
    return true;
  }
}
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">Cpu0MCInstLower::Lower</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MachineInstr</span><span class="w"> </span><span class="o">*</span><span class="n">MI</span><span class="p">,</span><span class="w"> </span><span class="n">MCInst</span><span class="w"> </span><span class="o">&amp;</span><span class="n">OutMI</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">if</span> <span class="p">(</span><span class="n">lowerLongBranch</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span> <span class="n">OutMI</span><span class="p">))</span>
    <span class="k">return</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter8_2/Cpu0SEInstrInfo.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">unsigned</span> <span class="n">getOppositeBranchOpc</span><span class="p">(</span><span class="n">unsigned</span> <span class="n">Opc</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter8_2/Cpu0SEInstrInfo.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">///</span> <span class="n">getOppositeBranchOpc</span> <span class="o">-</span> <span class="n">Return</span> <span class="n">the</span> <span class="n">inverse</span> <span class="n">of</span> <span class="n">the</span> <span class="n">specified</span>
<span class="o">///</span> <span class="n">opcode</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">g</span><span class="o">.</span> <span class="n">turning</span> <span class="n">BEQ</span> <span class="n">to</span> <span class="n">BNE</span><span class="o">.</span>
<span class="n">unsigned</span> <span class="n">Cpu0SEInstrInfo</span><span class="p">::</span><span class="n">getOppositeBranchOpc</span><span class="p">(</span><span class="n">unsigned</span> <span class="n">Opc</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="n">switch</span> <span class="p">(</span><span class="n">Opc</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">default</span><span class="p">:</span>           <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s2">&quot;Illegal opcode!&quot;</span><span class="p">);</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">BEQ</span><span class="p">:</span>    <span class="k">return</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">BNE</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">BNE</span><span class="p">:</span>    <span class="k">return</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">BEQ</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter8_2/Cpu0TargetMachine.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">void</span> <span class="n">addPreEmitPass</span><span class="p">()</span> <span class="n">override</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Implemented</span> <span class="n">by</span> <span class="n">targets</span> <span class="n">that</span> <span class="n">want</span> <span class="n">to</span> <span class="n">run</span> <span class="n">passes</span> <span class="n">immediately</span> <span class="n">before</span>
<span class="o">//</span> <span class="n">machine</span> <span class="n">code</span> <span class="ow">is</span> <span class="n">emitted</span><span class="o">.</span> <span class="k">return</span> <span class="n">true</span> <span class="k">if</span> <span class="o">-</span><span class="nb">print</span><span class="o">-</span><span class="n">machineinstrs</span> <span class="n">should</span>
<span class="o">//</span> <span class="nb">print</span> <span class="n">out</span> <span class="n">the</span> <span class="n">code</span> <span class="n">after</span> <span class="n">the</span> <span class="n">passes</span><span class="o">.</span>
<span class="n">void</span> <span class="n">Cpu0PassConfig</span><span class="p">::</span><span class="n">addPreEmitPass</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span> <span class="o">=</span> <span class="n">getCpu0TargetMachine</span><span class="p">();</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">addPass</span><span class="p">(</span><span class="n">createCpu0LongBranchPass</span><span class="p">(</span><span class="n">TM</span><span class="p">));</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The code of Chapter8_2 will compile the following example as follows,</p>
<p class="rubric">lbdex/input/ch8_2_longbranch.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">test_longbranch</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">volatile</span> <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">volatile</span> <span class="nb">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-78-10:input Jonathan$ </span>~/llvm/test/build/bin/llc
<span class="go">-march=cpu0 -mcpu=cpu032II -relocation-model=pic -filetype=asm</span>
<span class="go">-force-cpu0-long-branch ch8_2_longbranch.bc -o -</span>
<span class="go">  ...</span>
<span class="go">        .text</span>
<span class="go">        .section .mdebug.abiO32</span>
<span class="go">        .previous</span>
<span class="go">        .file &quot;ch8_2_longbranch.bc&quot;</span>
<span class="go">        .globl        _Z15test_longbranchv</span>
<span class="go">        .align        2</span>
<span class="go">        .type _Z15test_longbranchv,@function</span>
<span class="go">        .ent  _Z15test_longbranchv    # @_Z15test_longbranchv</span>
<span class="go">_Z15test_longbranchv:</span>
<span class="go">        .frame        $fp,16,$lr</span>
<span class="go">        .mask         0x00001000,-4</span>
<span class="go">        .set  noreorder</span>
<span class="go">        .set  nomacro</span>
<span class="gp"># </span>BB#0:
<span class="go">        addiu $sp, $sp, -16</span>
<span class="go">        st    $fp, 12($sp)            # 4-byte Folded Spill</span>
<span class="go">        move   $fp, $sp</span>
<span class="go">        addiu $2, $zero, 1</span>
<span class="go">        st    $2, 8($fp)</span>
<span class="go">        addiu $3, $zero, 2</span>
<span class="go">        st    $3, 4($fp)</span>
<span class="go">        addiu $3, $zero, 0</span>
<span class="go">        st    $3, 0($fp)</span>
<span class="go">        ld    $3, 8($fp)</span>
<span class="go">        ld    $4, 4($fp)</span>
<span class="go">        slt   $3, $3, $4</span>
<span class="go">        bne   $3, $zero, .LBB0_3</span>
<span class="go">        nop</span>
<span class="gp"># </span>BB#1:
<span class="go">        addiu $sp, $sp, -8</span>
<span class="go">        st    $lr, 0($sp)</span>
<span class="go">        lui   $1, %hi(.LBB0_4-.LBB0_2)</span>
<span class="go">        addiu $1, $1, %lo(.LBB0_4-.LBB0_2)</span>
<span class="go">        bal   .LBB0_2</span>
<span class="go">.LBB0_2:</span>
<span class="go">        addu  $1, $lr, $1</span>
<span class="go">        ld    $lr, 0($sp)</span>
<span class="go">        addiu $sp, $sp, 8</span>
<span class="go">        jr    $1</span>
<span class="go">        nop</span>
<span class="go">.LBB0_3:</span>
<span class="go">        st    $2, 0($fp)</span>
<span class="go">.LBB0_4:</span>
<span class="go">        ld    $2, 0($fp)</span>
<span class="go">        move   $sp, $fp</span>
<span class="go">        ld    $fp, 12($sp)            # 4-byte Folded Reload</span>
<span class="go">        addiu $sp, $sp, 16</span>
<span class="go">        ret   $lr</span>
<span class="go">        nop</span>
<span class="go">        .set  macro</span>
<span class="go">        .set  reorder</span>
<span class="go">        .end  _Z15test_longbranchv</span>
<span class="gp">$</span>func_end0:
<span class="go">        .size _Z15test_longbranchv, ($func_end0)-_Z15test_longbranchv</span>
</pre></div>
</div>
</section>
<section id="cpu0-backend-optimization-remove-useless-jmp">
<h2><a class="toc-backref" href="#id19" role="doc-backlink">Cpu0 backend Optimization: Remove useless JMP</a><a class="headerlink" href="#cpu0-backend-optimization-remove-useless-jmp" title="Permalink to this heading">¶</a></h2>
<p>LLVM uses functional pass both in code generation and optimization.
Following the 3 tiers of compiler architecture, LLVM do most optimization in
middle tier of LLVM IR, SSA form.
Beyond middle tier optimization, there are opportunities in
optimization which depend on backend features.
The “fill delay slot” in Mips is an example of backend optimization used in
pipeline RISC machine.
You can port it from Mips if your backend is a pipeline RISC with
delay slot.
In this section, we apply the “delete useless jmp” in Cpu0
backend optimization.
This algorithm is simple and effective to be a perfect tutorial in optimization.
Through this example, you can understand how to add an optimization pass and
coding your complicated optimization algorithm on your backend in real project.</p>
<p>Chapter8_2/ supports “delete useless jmp” optimization algorithm which add
codes as follows,</p>
<p class="rubric">lbdex/chapters/Chapter8_2/CMakeLists.txt</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">Cpu0DelUselessJMP</span><span class="o">.</span><span class="n">cpp</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter8_2/Cpu0.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">FunctionPass</span> <span class="o">*</span><span class="n">createCpu0DelJmpPass</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter8_2/Cpu0TargetMachine.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Implemented</span> <span class="n">by</span> <span class="n">targets</span> <span class="n">that</span> <span class="n">want</span> <span class="n">to</span> <span class="n">run</span> <span class="n">passes</span> <span class="n">immediately</span> <span class="n">before</span>
<span class="o">//</span> <span class="n">machine</span> <span class="n">code</span> <span class="ow">is</span> <span class="n">emitted</span><span class="o">.</span> <span class="k">return</span> <span class="n">true</span> <span class="k">if</span> <span class="o">-</span><span class="nb">print</span><span class="o">-</span><span class="n">machineinstrs</span> <span class="n">should</span>
<span class="o">//</span> <span class="nb">print</span> <span class="n">out</span> <span class="n">the</span> <span class="n">code</span> <span class="n">after</span> <span class="n">the</span> <span class="n">passes</span><span class="o">.</span>
<span class="n">void</span> <span class="n">Cpu0PassConfig</span><span class="p">::</span><span class="n">addPreEmitPass</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span> <span class="o">=</span> <span class="n">getCpu0TargetMachine</span><span class="p">();</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">addPass</span><span class="p">(</span><span class="n">createCpu0DelJmpPass</span><span class="p">(</span><span class="n">TM</span><span class="p">));</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter8_2/Cpu0DelUselessJMP.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>//===-- Cpu0DelUselessJMP.cpp - Cpu0 DelJmp -------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// Simple pass to fills delay slots with useful instructions.
//
//===----------------------------------------------------------------------===//

#include &quot;Cpu0.h&quot;
#if CH &gt;= CH8_2

#include &quot;Cpu0TargetMachine.h&quot;
#include &quot;llvm/CodeGen/MachineFunctionPass.h&quot;
#include &quot;llvm/CodeGen/TargetInstrInfo.h&quot;
#include &quot;llvm/Support/CommandLine.h&quot;
#include &quot;llvm/Target/TargetMachine.h&quot;
#include &quot;llvm/ADT/SmallSet.h&quot;
#include &quot;llvm/ADT/Statistic.h&quot;

using namespace llvm;

#define DEBUG_TYPE &quot;del-jmp&quot;

STATISTIC(NumDelJmp, &quot;Number of useless jmp deleted&quot;);

static cl::opt&lt;bool&gt; EnableDelJmp(
  &quot;enable-cpu0-del-useless-jmp&quot;,
  cl::init(true),
  cl::desc(&quot;Delete useless jmp instructions: jmp 0.&quot;),
  cl::Hidden);

namespace {
  struct DelJmp : public MachineFunctionPass {
    static char ID;
    DelJmp(TargetMachine &amp;tm)
      : MachineFunctionPass(ID) { }

    StringRef getPassName() const override {
      return &quot;Cpu0 Del Useless jmp&quot;;
    }

    bool runOnMachineBasicBlock(MachineBasicBlock &amp;MBB, MachineBasicBlock &amp;MBBN);
    bool runOnMachineFunction(MachineFunction &amp;F) override {
      bool Changed = false;
      if (EnableDelJmp) {
        MachineFunction::iterator FJ = F.begin();
        if (FJ != F.end())
          FJ++;
        if (FJ == F.end())
          return Changed;
        for (MachineFunction::iterator FI = F.begin(), FE = F.end();
             FJ != FE; ++FI, ++FJ)
          // In STL style, F.end() is the dummy BasicBlock() like &#39;\0&#39; in 
          //  C string. 
          // FJ is the next BasicBlock of FI; When FI range from F.begin() to 
          //  the PreviousBasicBlock of F.end() call runOnMachineBasicBlock().
          Changed |= runOnMachineBasicBlock(*FI, *FJ);
      }
      return Changed;
    }

  };
  char DelJmp::ID = 0;
} // end of anonymous namespace

bool DelJmp::
runOnMachineBasicBlock(MachineBasicBlock &amp;MBB, MachineBasicBlock &amp;MBBN) {
  bool Changed = false;

  MachineBasicBlock::iterator I = MBB.end();
  if (I != MBB.begin())
    I--;	// set I to the last instruction
  else
    return Changed;
    
  if (I-&gt;getOpcode() == Cpu0::JMP &amp;&amp; I-&gt;getOperand(0).getMBB() == &amp;MBBN) {
    // I is the instruction of &quot;jmp #offset=0&quot;, as follows,
    //     jmp	$BB0_3
    // $BB0_3:
    //     ld	$4, 28($sp)
    ++NumDelJmp;
    MBB.erase(I);	// delete the &quot;JMP 0&quot; instruction
    Changed = true;	// Notify LLVM kernel Changed
  }
  return Changed;

}

/// createCpu0DelJmpPass - Returns a pass that DelJmp in Cpu0 MachineFunctions
FunctionPass *llvm::createCpu0DelJmpPass(Cpu0TargetMachine &amp;tm) {
  return new DelJmp(tm);
}

#endif
</pre></div>
</div>
<p>As above code, except Cpu0DelUselessJMP.cpp, other files are changed for
registering class DelJmp as a functional pass.
As the comment of above code, MBB is the current
block and MBBN is the next block. For each last instruction of every MBB, we
check whether or not it is the JMP instruction and its Operand is the next
basic block.
By getMBB() in MachineOperand, you can get the MBB address.
For the member functions of MachineOperand, please check
include/llvm/CodeGen/MachineOperand.h
Now, let’s run Chapter8_2/ with ch8_2_deluselessjmp.cpp for explanation.</p>
<p class="rubric">lbdex/input/ch8_2_deluselessjmp.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">test_DelUselessJMP</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nb">int</span> <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span> <span class="nb">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">a</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">b</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">b</span><span class="o">--</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">c</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>

</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-78-10:input Jonathan$ </span>clang -target mips-unknown-linux-gnu
<span class="go">-c ch8_2_deluselessjmp.cpp -emit-llvm -o ch8_2_deluselessjmp.bc</span>
<span class="gp">118-165-78-10:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llc -march=cpu0 -relocation-model=static -filetype=asm -stats</span>
<span class="go">ch8_2_deluselessjmp.bc -o -</span>
<span class="go">  ...</span>
<span class="go">        cmp   $sw, $4, $3</span>
<span class="go">        jne   $sw, $BB0_2</span>
<span class="go">        nop</span>
<span class="gp"># </span>BB#1:
<span class="go">  ...</span>
<span class="go">        cmp   $sw, $3, $2</span>
<span class="go">        jlt   $sw, $BB0_8</span>
<span class="go">        nop</span>
<span class="gp"># </span>BB#7:
<span class="go">...</span>
<span class="go">===-------------------------------------------------------------------------===</span>
<span class="go">                          ... Statistics Collected ...</span>
<span class="go">===-------------------------------------------------------------------------===</span>
<span class="go"> ...</span>
<span class="go"> 2 del-jmp        - Number of useless jmp deleted</span>
<span class="go"> ...</span>
</pre></div>
</div>
<p>The terminal displays “Number of useless jmp deleted” by <code class="docutils literal notranslate"><span class="pre">llc</span> <span class="pre">-stats</span></code> option
because we set the “STATISTIC(NumDelJmp, “Number of useless jmp deleted”)” in
code. It deletes 2 jmp instructions from block “# BB#0” and “$BB0_6”.
You can check it by <code class="docutils literal notranslate"><span class="pre">llc</span> <span class="pre">-enable-cpu0-del-useless-jmp=false</span></code> option to see
the difference to non-optimization version.
If you run with ch8_1_1.cpp, you will find 10 jmp instructions are deleted from
120 lines of assembly code, which meaning 8% improvement in speed and code size
<a class="footnote-reference brackets" href="#cache-speed" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>.</p>
</section>
<section id="fill-branch-delay-slot">
<h2><a class="toc-backref" href="#id20" role="doc-backlink">Fill Branch Delay Slot</a><a class="headerlink" href="#fill-branch-delay-slot" title="Permalink to this heading">¶</a></h2>
<p>Cpu0 instruction set is designed to be a classical RISC pipeline machine.
Classical RISC machine has many perfect features <a class="footnote-reference brackets" href="#quantitative" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#wiki-pipeline" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a>.
I change Cpu0 backend to a 5 stages of classical RISC pipeline machine with
one delay slot like some of Mips model (The original Cpu0 from its author, is a
3 stages of RISC machine).
With this change, the backend needs
filling the NOP instruction in the branch delay slot.
In order to make this tutorial simple for learning, Cpu0 backend code not
fill the branch delay slot with any useful instruction for optimization.
Readers can reference the MipsDelaySlotFiller.cpp to know how to insert useful
instructions in backend optimization.
Following code added in Chapter8_2 for NOP fill in Branch Delay Slot.</p>
<p class="rubric">lbdex/chapters/Chapter8_2/CMakeLists.txt</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">Cpu0DelaySlotFiller</span><span class="o">.</span><span class="n">cpp</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter8_2/Cpu0.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">FunctionPass</span> <span class="o">*</span><span class="n">createCpu0DelaySlotFillerPass</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter8_2/Cpu0TargetMachine.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Implemented</span> <span class="n">by</span> <span class="n">targets</span> <span class="n">that</span> <span class="n">want</span> <span class="n">to</span> <span class="n">run</span> <span class="n">passes</span> <span class="n">immediately</span> <span class="n">before</span>
<span class="o">//</span> <span class="n">machine</span> <span class="n">code</span> <span class="ow">is</span> <span class="n">emitted</span><span class="o">.</span> <span class="k">return</span> <span class="n">true</span> <span class="k">if</span> <span class="o">-</span><span class="nb">print</span><span class="o">-</span><span class="n">machineinstrs</span> <span class="n">should</span>
<span class="o">//</span> <span class="nb">print</span> <span class="n">out</span> <span class="n">the</span> <span class="n">code</span> <span class="n">after</span> <span class="n">the</span> <span class="n">passes</span><span class="o">.</span>
<span class="n">void</span> <span class="n">Cpu0PassConfig</span><span class="p">::</span><span class="n">addPreEmitPass</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span> <span class="o">=</span> <span class="n">getCpu0TargetMachine</span><span class="p">();</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">addPass</span><span class="p">(</span><span class="n">createCpu0DelaySlotFillerPass</span><span class="p">(</span><span class="n">TM</span><span class="p">));</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter8_2/Cpu0DelaySlotFiller.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>//===-- Cpu0DelaySlotFiller.cpp - Cpu0 Delay Slot Filler ------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// Simple pass to fill delay slots with useful instructions.
//
//===----------------------------------------------------------------------===//

#include &quot;Cpu0.h&quot;
#if CH &gt;= CH8_2

#include &quot;Cpu0InstrInfo.h&quot;
#include &quot;Cpu0TargetMachine.h&quot;
#include &quot;llvm/ADT/BitVector.h&quot;
#include &quot;llvm/ADT/SmallPtrSet.h&quot;
#include &quot;llvm/ADT/Statistic.h&quot;
#include &quot;llvm/Analysis/AliasAnalysis.h&quot;
#include &quot;llvm/Analysis/ValueTracking.h&quot;
#include &quot;llvm/CodeGen/MachineBranchProbabilityInfo.h&quot;
#include &quot;llvm/CodeGen/MachineFunctionPass.h&quot;
#include &quot;llvm/CodeGen/MachineInstrBuilder.h&quot;
#include &quot;llvm/CodeGen/PseudoSourceValue.h&quot;
#include &quot;llvm/CodeGen/TargetInstrInfo.h&quot;
#include &quot;llvm/Support/CommandLine.h&quot;
#include &quot;llvm/Target/TargetMachine.h&quot;
#include &quot;llvm/CodeGen/TargetRegisterInfo.h&quot;

using namespace llvm;

#define DEBUG_TYPE &quot;delay-slot-filler&quot;

STATISTIC(FilledSlots, &quot;Number of delay slots filled&quot;);

namespace {
  typedef MachineBasicBlock::iterator Iter;
  typedef MachineBasicBlock::reverse_iterator ReverseIter;

  class Filler : public MachineFunctionPass {
  public:
    Filler(TargetMachine &amp;tm)
      : MachineFunctionPass(ID) { }

    StringRef getPassName() const override {
      return &quot;Cpu0 Delay Slot Filler&quot;;
    }

    bool runOnMachineFunction(MachineFunction &amp;F) override {
      bool Changed = false;
      for (MachineFunction::iterator FI = F.begin(), FE = F.end();
           FI != FE; ++FI)
        Changed |= runOnMachineBasicBlock(*FI);
      return Changed;
    }
  private:
    bool runOnMachineBasicBlock(MachineBasicBlock &amp;MBB);

    static char ID;
  };
  char Filler::ID = 0;
} // end of anonymous namespace

static bool hasUnoccupiedSlot(const MachineInstr *MI) {
  return MI-&gt;hasDelaySlot() &amp;&amp; !MI-&gt;isBundledWithSucc();
}

/// runOnMachineBasicBlock - Fill in delay slots for the given basic block.
/// We assume there is only one delay slot per delayed instruction.
bool Filler::runOnMachineBasicBlock(MachineBasicBlock &amp;MBB) {
  bool Changed = false;
  const Cpu0Subtarget &amp;STI = MBB.getParent()-&gt;getSubtarget&lt;Cpu0Subtarget&gt;();
  const Cpu0InstrInfo *TII = STI.getInstrInfo();

  for (Iter I = MBB.begin(); I != MBB.end(); ++I) {
    if (!hasUnoccupiedSlot(&amp;*I))
      continue;

    ++FilledSlots;
    Changed = true;

    // Bundle the NOP to the instruction with the delay slot.
    BuildMI(MBB, std::next(I), I-&gt;getDebugLoc(), TII-&gt;get(Cpu0::NOP));
    MIBundleBuilder(MBB, I, std::next(I, 2));
  }

  return Changed;
}

/// createCpu0DelaySlotFillerPass - Returns a pass that fills in delay
/// slots in Cpu0 MachineFunctions
FunctionPass *llvm::createCpu0DelaySlotFillerPass(Cpu0TargetMachine &amp;tm) {
  return new Filler(tm);
}

#endif
</pre></div>
</div>
<p>To make the basic block label remains same, statement MIBundleBuilder() needs
to be inserted after the statement BuildMI(…, NOP) of Cpu0DelaySlotFiller.cpp.
MIBundleBuilder() make both the branch instruction and NOP bundled into one
instruction (first part is branch instruction and second part is NOP).</p>
<p class="rubric">lbdex/chapters/Chapter3_2/Cpu0AsmPrinter.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//-</span> <span class="n">emitInstruction</span><span class="p">()</span> <span class="n">must</span> <span class="n">exists</span> <span class="ow">or</span> <span class="n">will</span> <span class="n">have</span> <span class="n">run</span> <span class="n">time</span> <span class="n">error</span><span class="o">.</span>
<span class="n">void</span> <span class="n">Cpu0AsmPrinter</span><span class="p">::</span><span class="n">emitInstruction</span><span class="p">(</span><span class="n">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="o">//</span>  <span class="n">Print</span> <span class="n">out</span> <span class="n">both</span> <span class="n">ordinary</span> <span class="n">instruction</span> <span class="ow">and</span> <span class="n">boudle</span> <span class="n">instruction</span>
  <span class="n">MachineBasicBlock</span><span class="p">::</span><span class="n">const_instr_iterator</span> <span class="n">I</span> <span class="o">=</span> <span class="n">MI</span><span class="o">-&gt;</span><span class="n">getIterator</span><span class="p">();</span>
  <span class="n">MachineBasicBlock</span><span class="p">::</span><span class="n">const_instr_iterator</span> <span class="n">E</span> <span class="o">=</span> <span class="n">MI</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">instr_end</span><span class="p">();</span>

  <span class="n">do</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    if (I-&gt;isPseudo() &amp;&amp; !isLongBranchPseudo(I-&gt;getOpcode()))
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>      <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s2">&quot;Pseudo opcode found in emitInstruction()&quot;</span><span class="p">);</span>

    <span class="n">MCInst</span> <span class="n">TmpInst0</span><span class="p">;</span>
    <span class="n">MCInstLowering</span><span class="o">.</span><span class="n">Lower</span><span class="p">(</span><span class="o">&amp;*</span><span class="n">I</span><span class="p">,</span> <span class="n">TmpInst0</span><span class="p">);</span>
    <span class="n">OutStreamer</span><span class="o">-&gt;</span><span class="n">emitInstruction</span><span class="p">(</span><span class="n">TmpInst0</span><span class="p">,</span> <span class="n">getSubtargetInfo</span><span class="p">());</span>
  <span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="o">++</span><span class="n">I</span> <span class="o">!=</span> <span class="n">E</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">I</span><span class="o">-&gt;</span><span class="n">isInsideBundle</span><span class="p">());</span> <span class="o">//</span> <span class="n">Delay</span> <span class="n">slot</span> <span class="n">check</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In order to print the NOP, the Cpu0AsmPrinter.cpp of Chapter3_2 prints all
bundle instructions in loop.
Without the loop, only the first part of the bundle instruction
(branch instruction only) is printed.
In llvm 3.1 the basice block label remains same even if you didn’t do the bundle
after it.
But for some reasons, it changed in llvm at some later version and you need doing
“bundle” in order to keep block label unchanged at later llvm phase.</p>
</section>
<section id="conditional-instruction">
<h2><a class="toc-backref" href="#id21" role="doc-backlink">Conditional instruction</a><a class="headerlink" href="#conditional-instruction" title="Permalink to this heading">¶</a></h2>
<p class="rubric">lbdex/input/ch8_2_select.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
// The following files will generate IR select even compile with clang -O0.
int test_movx_1()
{
  volatile int a = 1;
  int c = 0;

  c = !a ? 1:3;

  return c;
}

int test_movx_2()
{
  volatile int a = 1;
  int c = 0;

  c = a ? 1:3;

  return c;
}

</pre></div>
</div>
<p>Run Chapter8_1 with ch8_2_select.cpp will get the following result.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">114-37-150-209:input Jonathan$ </span>clang -O1 -target mips-unknown-linux-gnu
<span class="go">-c ch8_2_select.cpp -emit-llvm -o ch8_2_select.bc</span>
<span class="gp">114-37-150-209:input Jonathan$ </span>~/llvm/test/build/bin/
<span class="go">llvm-dis ch8_2_select.bc -o -</span>
<span class="go">...</span>
<span class="go">; Function Attrs: nounwind uwtable</span>
<span class="go">define i32 @_Z11test_movx_1v() #0 {</span>
<span class="gp">  %</span><span class="nv">a</span> <span class="o">=</span> alloca i32, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">c</span> <span class="o">=</span> alloca i32, align <span class="m">4</span>
<span class="go">  store volatile i32 1, i32* %a, align 4</span>
<span class="go">  store i32 0, i32* %c, align 4</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> load volatile i32* %a, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">2</span> <span class="o">=</span> icmp ne i32 %1, <span class="m">0</span>
<span class="gp">  %</span><span class="nv">3</span> <span class="o">=</span> xor i1 %2, <span class="nb">true</span>
<span class="gp">  %</span><span class="nv">4</span> <span class="o">=</span> <span class="k">select</span> i1 %3, i32 <span class="m">1</span>, i32 <span class="m">3</span>
<span class="go">  store i32 %4, i32* %c, align 4</span>
<span class="gp">  %</span><span class="nv">5</span> <span class="o">=</span> load i32* %c, align <span class="m">4</span>
<span class="go">  ret i32 %5</span>
<span class="go">}</span>

<span class="go">; Function Attrs: nounwind uwtable</span>
<span class="go">define i32 @_Z11test_movx_2v() #0 {</span>
<span class="gp">  %</span><span class="nv">a</span> <span class="o">=</span> alloca i32, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">c</span> <span class="o">=</span> alloca i32, align <span class="m">4</span>
<span class="go">  store volatile i32 1, i32* %a, align 4</span>
<span class="go">  store i32 0, i32* %c, align 4</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> load volatile i32* %a, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">2</span> <span class="o">=</span> icmp ne i32 %1, <span class="m">0</span>
<span class="gp">  %</span><span class="nv">3</span> <span class="o">=</span> <span class="k">select</span> i1 %2, i32 <span class="m">1</span>, i32 <span class="m">3</span>
<span class="go">  store i32 %3, i32* %c, align 4</span>
<span class="gp">  %</span><span class="nv">4</span> <span class="o">=</span> load i32* %c, align <span class="m">4</span>
<span class="go">  ret i32 %4</span>
<span class="go">}</span>
<span class="go">...</span>

<span class="gp">114-37-150-209:input Jonathan$ </span>~/llvm/test/build/bin/llc
<span class="go">-march=cpu0 -mcpu=cpu032I -relocation-model=static -filetype=asm</span>
<span class="go">ch8_2_select.bc -o -</span>
<span class="go">...</span>
<span class="go">LLVM ERROR: Cannot select: 0x39f47c0: i32 = select_cc ...</span>
</pre></div>
</div>
<p>As above llvm IR, ch8_2_select.bc, clang generates <strong>select</strong> IR for
small basic control block (if statement only include one assign statement).
This <strong>select</strong> IR is the result of optimization for CPUs with conditional
instructions support.
And from above error message, obviously IR <strong>select</strong> is changed to
<strong>select_cc</strong> during DAG optimization stages.</p>
<p>Chapter8_2 supports <strong>select</strong> with the following code added and changed.</p>
<p class="rubric">lbdex/chapters/Chapter8_2/Cpu0InstrInfo.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ch8_2</span><span class="p">]</span> <span class="ow">in</span> <span class="p">{</span>
<span class="n">include</span> <span class="s2">&quot;Cpu0CondMov.td&quot;</span>
<span class="p">}</span> <span class="o">//</span> <span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ch8_2</span><span class="p">]</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter8_2/Cpu0CondMov.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>//===-- Cpu0CondMov.td - Describe Cpu0 Conditional Moves --*- tablegen -*--===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This is the Conditional Moves implementation.
//
//===----------------------------------------------------------------------===//

// Conditional moves:
// These instructions are expanded in
// Cpu0ISelLowering::EmitInstrWithCustomInserter if target does not have
// conditional move instructions.
// cond:int, data:int
class CondMovIntInt&lt;RegisterClass CRC, RegisterClass DRC, bits&lt;8&gt; op,
                    string instr_asm&gt; :
  FA&lt;op, (outs DRC:$ra), (ins DRC:$rb, CRC:$rc, DRC:$F),
     !strconcat(instr_asm, &quot;\t$ra, $rb, $rc&quot;), [], IIAlu&gt; {
  let shamt = 0;
  let Constraints = &quot;$F = $ra&quot;;
}

// select patterns
multiclass MovzPats0Slt&lt;RegisterClass CRC, RegisterClass DRC,
                     Instruction MOVZInst, Instruction SLTOp,
                     Instruction SLTuOp, Instruction SLTiOp,
                     Instruction SLTiuOp&gt; {
  def : Pat&lt;(select (i32 (setge CRC:$lhs, CRC:$rhs)), DRC:$T, DRC:$F),
            (MOVZInst DRC:$T, (SLTOp CRC:$lhs, CRC:$rhs), DRC:$F)&gt;;
  def : Pat&lt;(select (i32 (setuge CRC:$lhs, CRC:$rhs)), DRC:$T, DRC:$F),
            (MOVZInst DRC:$T, (SLTuOp CRC:$lhs, CRC:$rhs), DRC:$F)&gt;;
  def : Pat&lt;(select (i32 (setge CRC:$lhs, immSExt16:$rhs)), DRC:$T, DRC:$F),
            (MOVZInst DRC:$T, (SLTiOp CRC:$lhs, immSExt16:$rhs), DRC:$F)&gt;;
  def : Pat&lt;(select (i32 (setuge CRC:$lh, immSExt16:$rh)), DRC:$T, DRC:$F),
            (MOVZInst DRC:$T, (SLTiuOp CRC:$lh, immSExt16:$rh), DRC:$F)&gt;;
  def : Pat&lt;(select (i32 (setle CRC:$lhs, CRC:$rhs)), DRC:$T, DRC:$F),
            (MOVZInst DRC:$T, (SLTOp CRC:$rhs, CRC:$lhs), DRC:$F)&gt;;
  def : Pat&lt;(select (i32 (setule CRC:$lhs, CRC:$rhs)), DRC:$T, DRC:$F),
            (MOVZInst DRC:$T, (SLTuOp CRC:$rhs, CRC:$lhs), DRC:$F)&gt;;
}

multiclass MovzPats1&lt;RegisterClass CRC, RegisterClass DRC,
                     Instruction MOVZInst, Instruction XOROp&gt; {
  def : Pat&lt;(select (i32 (seteq CRC:$lhs, CRC:$rhs)), DRC:$T, DRC:$F),
            (MOVZInst DRC:$T, (XOROp CRC:$lhs, CRC:$rhs), DRC:$F)&gt;;
  def : Pat&lt;(select (i32 (seteq CRC:$lhs, 0)), DRC:$T, DRC:$F),
            (MOVZInst DRC:$T, CRC:$lhs, DRC:$F)&gt;;
}

multiclass MovnPats&lt;RegisterClass CRC, RegisterClass DRC, Instruction MOVNInst,
                    Instruction XOROp&gt; {
  def : Pat&lt;(select (i32 (setne CRC:$lhs, CRC:$rhs)), DRC:$T, DRC:$F),
            (MOVNInst DRC:$T, (XOROp CRC:$lhs, CRC:$rhs), DRC:$F)&gt;;
  def : Pat&lt;(select CRC:$cond, DRC:$T, DRC:$F),
            (MOVNInst DRC:$T, CRC:$cond, DRC:$F)&gt;;
  def : Pat&lt;(select (i32 (setne CRC:$lhs, 0)),DRC:$T, DRC:$F),
            (MOVNInst DRC:$T, CRC:$lhs, DRC:$F)&gt;;
}

// Instantiation of instructions.
def MOVZ_I_I     : CondMovIntInt&lt;CPURegs, CPURegs, 0x0a, &quot;movz&quot;&gt;;

def MOVN_I_I     : CondMovIntInt&lt;CPURegs, CPURegs, 0x0b, &quot;movn&quot;&gt;;

// Instantiation of conditional move patterns.
let Predicates = [HasSlt] in {
defm : MovzPats0Slt&lt;CPURegs, CPURegs, MOVZ_I_I, SLT, SLTu, SLTi, SLTiu&gt;;
}

defm : MovzPats1&lt;CPURegs, CPURegs, MOVZ_I_I, XOR&gt;;

defm : MovnPats&lt;CPURegs, CPURegs, MOVN_I_I, XOR&gt;;
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter8_2/Cpu0ISelLowering.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">SDValue</span> <span class="n">lowerSELECT</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter8_2/Cpu0ISelLowering.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="n">const</span> <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">,</span>
                                       <span class="n">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span>
    <span class="p">:</span> <span class="n">TargetLowering</span><span class="p">(</span><span class="n">TM</span><span class="p">),</span> <span class="n">Subtarget</span><span class="p">(</span><span class="n">STI</span><span class="p">),</span> <span class="n">ABI</span><span class="p">(</span><span class="n">TM</span><span class="o">.</span><span class="n">getABI</span><span class="p">())</span> <span class="p">{</span>

</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">SELECT</span><span class="p">,</span>             <span class="n">MVT</span><span class="p">::</span><span class="n">i32</span><span class="p">,</span>   <span class="n">Custom</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">SELECT_CC</span><span class="p">,</span>         <span class="n">MVT</span><span class="p">::</span><span class="n">i32</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">SELECT_CC</span><span class="p">,</span>         <span class="n">MVT</span><span class="p">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="p">::</span>
<span class="n">LowerOperation</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span>
<span class="p">{</span>
  <span class="n">switch</span> <span class="p">(</span><span class="n">Op</span><span class="o">.</span><span class="n">getOpcode</span><span class="p">())</span>
  <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">case</span> <span class="n">ISD</span><span class="p">::</span><span class="n">SELECT</span><span class="p">:</span>             <span class="k">return</span> <span class="n">lowerSELECT</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="p">::</span>
<span class="n">lowerSELECT</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">Op</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Set ISD::SELECT_CC to “Expand” will stop llvm optimization from merging “setcc”
and “select” into one IR “select_cc” <a class="footnote-reference brackets" href="#wb" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>.
Next the LowerOperation() return Op code directly for ISD::SELECT.
Finally the pattern defined in Cpu0CondMov.td will
translate the <strong>select</strong> IR into conditional instruction, <strong>movz</strong> or <strong>movn</strong>.
Let’s run Chapter8_2 with ch8_2_select.cpp to get the following result.
Again, the cpu032II uses <strong>slt</strong> instead of <strong>cmp</strong> has a little improved in
instructions number.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">114-37-150-209:input Jonathan$ </span>~/llvm/test/build/bin/llc
<span class="go">-march=cpu0 -mcpu=cpu032I -relocation-model=static -filetype=asm ch8_2_select.bc -o -</span>
<span class="go">...</span>
<span class="go">      .type   _Z11test_movx_1v,@function</span>
<span class="go">      ...</span>
<span class="go">      addiu   $2, $zero, 3</span>
<span class="go">      movz    $2, $3, $4</span>
<span class="go">      ...</span>
<span class="go">      .type   _Z11test_movx_2v,@function</span>
<span class="go">      ...</span>
<span class="go">      addiu   $2, $zero, 3</span>
<span class="go">      movn    $2, $3, $4</span>
<span class="go">      ...</span>
</pre></div>
</div>
<p>The clang uses <strong>select</strong> IR in small basic block
to reduce the branch cost in pipeline machine since the branch will make the
pipeline “stall”.
But it needs the conditional instruction support <a class="footnote-reference brackets" href="#quantitative" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>.
If your backend has no conditional instruction and needs clang compiler with
optimization option <strong>O1</strong> above level, you can change clang to force it
generating traditional branch basic block instead of generating IR <strong>select</strong>.
RISC CPU came from the advantage of pipeline and add more and more instruction
when time passed.
Compare Mips and ARM, the Mips has only <strong>movz</strong> and <strong>movn</strong> two
instructions while ARM has many. We create Cpu0 instructions as a simple
instructions RISC pipeline machine for compiler toolchain tutorial.
However the <strong>cmp</strong> instruction is hired because many programmer is used to
it in past and now (ARM use it).
This instruction matches the thinking in assembly programming,
but the <strong>slt</strong> instruction is more efficient in RISC pipleline.
If you designed a backend aimed for C/C++ highlevel language, you may consider
<strong>slt</strong> instead of <strong>cmp</strong> since assembly code are rare used in programming and
beside, the assembly programmer can accept <strong>slt</strong> not difficultly since usually
they are professional.</p>
<p>File ch8_2_select2.cpp will generate IR <strong>select</strong> if compile with <code class="docutils literal notranslate"><span class="pre">clang</span> <span class="pre">-O1</span></code>.</p>
<p class="rubric">lbdex/input/ch8_2_select2.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="o">//</span> <span class="n">The</span> <span class="n">following</span> <span class="n">files</span> <span class="n">will</span> <span class="n">generate</span> <span class="n">IR</span> <span class="n">select</span> <span class="n">when</span> <span class="nb">compile</span> <span class="k">with</span> <span class="n">clang</span> <span class="o">-</span><span class="n">O1</span> <span class="n">but</span> 
<span class="o">//</span> <span class="n">clang</span> <span class="o">-</span><span class="n">O0</span> <span class="n">won</span><span class="s1">&#39;t generate IR select.</span>
<span class="n">volatile</span> <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">volatile</span> <span class="nb">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="nb">int</span> <span class="n">test_movx_3</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">test_movx_4</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>

</pre></div>
</div>
<p>List the conditional statements of C, IR, DAG and Cpu0 instructions as the
following table.</p>
<table class="docutils align-default" id="id15">
<caption><span class="caption-number">Table 32 </span><span class="caption-text">Conditional statements of C, IR, DAG and Cpu0 instructions</span><a class="headerlink" href="#id15" title="Permalink to this table">¶</a></caption>
<tbody>
<tr class="row-odd"><td><p>C</p></td>
<td><p>if (a &lt; b) c = 1; else c = 3;</p></td>
</tr>
<tr class="row-even"><td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>c = a ? 1:3;</p></td>
</tr>
<tr class="row-odd"><td><p>IR</p></td>
<td><p>icmp + (eq, ne, sgt, sge, slt, sle) + br</p></td>
</tr>
<tr class="row-even"><td><p>DAG</p></td>
<td><p>((seteq, setne, setgt, setge, setlt, setle) + setcc) + select</p></td>
</tr>
<tr class="row-odd"><td><p>Cpu0</p></td>
<td><p>movz, movn</p></td>
</tr>
</tbody>
</table>
<p>File ch8_2_select_global_pic.cpp mentioned in Chapter Global variables can be
tested now as follows,</p>
<p class="rubric">lbdex/input/ch8_2_select_global_pic.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">volatile</span> <span class="nb">int</span> <span class="n">a1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">volatile</span> <span class="nb">int</span> <span class="n">b1</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="nb">int</span> <span class="n">gI1</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">gJ1</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>

<span class="nb">int</span> <span class="n">test_select_global_pic</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a1</span> <span class="o">&lt;</span> <span class="n">b1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">gI1</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="n">gJ1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>clang -O1 -target mips-unknown-linux-gnu
<span class="go">-c ch8_2_select_global_pic.cpp -emit-llvm -o ch8_2_select_global_pic.bc</span>
<span class="gp">JonathantekiiMac:input Jonathan$ </span>~/llvm/test/build/bin/
<span class="go">llvm-dis ch8_2_select_global_pic.bc -o -</span>
<span class="go">...</span>
<span class="go">@a1 = global i32 1, align 4</span>
<span class="go">@b1 = global i32 2, align 4</span>
<span class="go">@gI1 = global i32 100, align 4</span>
<span class="go">@gJ1 = global i32 50, align 4</span>

<span class="go">; Function Attrs: nounwind</span>
<span class="go">define i32 @_Z18test_select_globalv() #0 {</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> load volatile i32* @a1, align <span class="m">4</span>, !tbaa !1
<span class="gp">  %</span><span class="nv">2</span> <span class="o">=</span> load volatile i32* @b1, align <span class="m">4</span>, !tbaa !1
<span class="gp">  %</span><span class="nv">3</span> <span class="o">=</span> icmp slt i32 %1, %2
<span class="gp">  %</span>gI1.val <span class="o">=</span> load i32* @gI1, align <span class="m">4</span>
<span class="gp">  %</span>gJ1.val <span class="o">=</span> load i32* @gJ1, align <span class="m">4</span>
<span class="gp">  %</span>.0 <span class="o">=</span> <span class="k">select</span> i1 %3, i32 %gI1.val, i32 %gJ1.val
<span class="go">  ret i32 %.0</span>
<span class="go">}</span>
<span class="go">...</span>
<span class="gp">JonathantekiiMac:input Jonathan$ </span>~/llvm/test/build/bin/
<span class="go">llc -march=cpu0 -mcpu=cpu032I -relocation-model=pic -filetype=asm ch8_2_select_global_pic.bc -o -</span>
<span class="go">  .section .mdebug.abi32</span>
<span class="go">  .previous</span>
<span class="go">  .file &quot;ch8_2_select_global_pic.bc&quot;</span>
<span class="go">  .text</span>
<span class="go">  .globl  _Z18test_select_globalv</span>
<span class="go">  .align  2</span>
<span class="go">  .type _Z18test_select_globalv,@function</span>
<span class="go">  .ent  _Z18test_select_globalv # @_Z18test_select_globalv</span>
<span class="go">_Z18test_select_globalv:</span>
<span class="go">  .frame  $sp,0,$lr</span>
<span class="go">  .mask   0x00000000,0</span>
<span class="go">  .set  noreorder</span>
<span class="go">  .cpload $t9</span>
<span class="go">  .set  nomacro</span>
<span class="gp"># </span>BB#0:
<span class="go">  lui $2, %got_hi(a1)</span>
<span class="go">  addu  $2, $2, $gp</span>
<span class="go">  ld  $2, %got_lo(a1)($2)</span>
<span class="go">  ld  $2, 0($2)</span>
<span class="go">  lui $3, %got_hi(b1)</span>
<span class="go">  addu  $3, $3, $gp</span>
<span class="go">  ld  $3, %got_lo(b1)($3)</span>
<span class="go">  ld  $3, 0($3)</span>
<span class="go">  cmp $sw, $2, $3</span>
<span class="go">  andi  $2, $sw, 1</span>
<span class="go">  lui $3, %got_hi(gJ1)</span>
<span class="go">  addu  $3, $3, $gp</span>
<span class="go">  ori $3, $3, %got_lo(gJ1)</span>
<span class="go">  lui $4, %got_hi(gI1)</span>
<span class="go">  addu  $4, $4, $gp</span>
<span class="go">  ori $4, $4, %got_lo(gI1)</span>
<span class="go">  movn  $3, $4, $2</span>
<span class="go">  ld  $2, 0($3)</span>
<span class="go">  ld  $2, 0($2)</span>
<span class="go">  ret $lr</span>
<span class="go">  .set  macro</span>
<span class="go">  .set  reorder</span>
<span class="go">  .end  _Z18test_select_globalv</span>
<span class="gp">$</span>tmp0:
<span class="go">  .size _Z18test_select_globalv, ($tmp0)-_Z18test_select_globalv</span>

<span class="go">  .type a1,@object              # @a1</span>
<span class="go">  .data</span>
<span class="go">  .globl  a1</span>
<span class="go">  .align  2</span>
<span class="go">a1:</span>
<span class="go">  .4byte  1                       # 0x1</span>
<span class="go">  .size a1, 4</span>

<span class="go">  .type b1,@object              # @b1</span>
<span class="go">  .globl  b1</span>
<span class="go">  .align  2</span>
<span class="go">b1:</span>
<span class="go">  .4byte  2                       # 0x2</span>
<span class="go">  .size b1, 4</span>

<span class="go">  .type gI1,@object             # @gI1</span>
<span class="go">  .globl  gI1</span>
<span class="go">  .align  2</span>
<span class="go">gI1:</span>
<span class="go">  .4byte  100                     # 0x64</span>
<span class="go">  .size gI1, 4</span>

<span class="go">  .type gJ1,@object             # @gJ1</span>
<span class="go">  .globl  gJ1</span>
<span class="go">  .align  2</span>
<span class="go">gJ1:</span>
<span class="go">  .4byte  50                      # 0x32</span>
<span class="go">  .size gJ1, 4</span>
</pre></div>
</div>
</section>
<section id="phi-node">
<h2><a class="toc-backref" href="#id22" role="doc-backlink">Phi node</a><a class="headerlink" href="#phi-node" title="Permalink to this heading">¶</a></h2>
<p>Since phi node is popular used in SSA form <a class="footnote-reference brackets" href="#ssa-wiki" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a>, llvm applies
phi node in IR for optimization work either.
Phi node exists for “live variable analysis”. An example for C is here
<a class="footnote-reference brackets" href="#phi-ex" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a>.
As mentioned in wiki web site of reference above, through finding dominance
frontiers, compiler knows where to insert phi functions.
The following input let you know the benefits of phi node as follows,</p>
<p class="rubric">lbdex/input/ch8_2_phinode.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">test_phinode</span><span class="p">(</span><span class="nb">int</span> <span class="n">a</span> <span class="p">,</span> <span class="nb">int</span> <span class="n">b</span><span class="p">,</span> <span class="nb">int</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="o">//</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">+</span><span class="mi">2</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">d</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="n">d</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Compile it with debug build clang for O3 as follows,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">114-43-212-251:input Jonathan$ </span>~/llvm/debug/build/bin/clang
<span class="go">-O3 -target mips-unknown-linux-gnu -c ch8_2_phinode.cpp -emit-llvm -o</span>
<span class="go">ch8_2_phinode.bc</span>
<span class="gp">114-43-212-251:input Jonathan$ </span>~/llvm/test/build/bin/llvm-dis
<span class="go">ch8_2_phinode.bc -o -</span>
<span class="go">...</span>
<span class="go">define i32 @_Z12test_phinodeiii(i32 signext %a, i32 signext %b, i32 signext %c) local_unnamed_addr #0 {</span>
<span class="go">entry:</span>
<span class="gp">  %</span><span class="nv">cmp</span> <span class="o">=</span> icmp eq i32 %a, <span class="m">0</span>
<span class="go">  br i1 %cmp, label %if.end7, label %if.else</span>

<span class="go">if.else:                                          ; preds = %entry</span>
<span class="gp">  %</span><span class="nv">cmp1</span> <span class="o">=</span> icmp eq i32 %b, <span class="m">0</span>
<span class="go">  br i1 %cmp1, label %if.else3, label %if.then2</span>

<span class="go">if.then2:                                         ; preds = %if.else</span>
<span class="gp">  %</span><span class="nv">dec</span> <span class="o">=</span> add nsw i32 %a, -1
<span class="go">  br label %if.end7</span>

<span class="go">if.else3:                                         ; preds = %if.else</span>
<span class="gp">  %</span><span class="nv">cmp4</span> <span class="o">=</span> icmp eq i32 %c, <span class="m">0</span>
<span class="gp">  %</span><span class="nv">add</span> <span class="o">=</span> add nsw i32 %a, <span class="m">2</span>
<span class="gp">  %</span>add.a <span class="o">=</span> <span class="k">select</span> i1 %cmp4, i32 %add, i32 %a
<span class="go">  br label %if.end7</span>

<span class="go">if.end7:                                          ; preds = %entry, %if.else3, %if.then2</span>
<span class="gp">  %</span>a.addr.0 <span class="o">=</span> phi i32 <span class="o">[</span> %dec, %if.then2 <span class="o">]</span>, <span class="o">[</span> %add.a, %if.else3 <span class="o">]</span>, <span class="o">[</span> <span class="m">1</span>, %entry <span class="o">]</span>
<span class="gp">  %</span><span class="nv">add8</span> <span class="o">=</span> add nsw i32 %a.addr.0, %b
<span class="go">  ret i32 %add8</span>
<span class="go">}</span>
</pre></div>
</div>
<p>Because SSA form, the llvm ir for destination variable <cite>a</cite> in different basic
block (if then, else) must use different name. But how does the source variable
<cite>a</cite> in “d = a + b;” be named? The basic block “a = a-1;” and “a = a+2;” have different
names. The basic block “a = a-1;” uses %dec and the basic block “a = a+2;” uses “%add”
as destination variable name in SSA llvm ir.
In order to solve the source variable name from different basic blocks in SSA form,
the phi structure is created as above. The compiler option O0 as the following
doesn’t apply phi node. Instead, it uses store to solve the source variable name
from different basic block.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">114-43-212-251:input Jonathan$ </span>~/llvm/debug/build/bin/clang
<span class="go">-O0 -target mips-unknown-linux-gnu -c ch8_2_phinode.cpp -emit-llvm -o</span>
<span class="go">ch8_2_phinode.bc</span>
<span class="gp">114-43-212-251:input Jonathan$ </span>~/llvm/test/build/bin/llvm-dis
<span class="go">ch8_2_phinode.bc -o -</span>
<span class="go">...</span>
<span class="go">define i32 @_Z12test_phinodeiii(i32 signext %a, i32 signext %b, i32 signext %c) #0 {</span>
<span class="go">entry:</span>
<span class="gp">  %</span>a.addr <span class="o">=</span> alloca i32, align <span class="m">4</span>
<span class="gp">  %</span>b.addr <span class="o">=</span> alloca i32, align <span class="m">4</span>
<span class="gp">  %</span>c.addr <span class="o">=</span> alloca i32, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">d</span> <span class="o">=</span> alloca i32, align <span class="m">4</span>
<span class="go">  store i32 %a, i32* %a.addr, align 4</span>
<span class="go">  store i32 %b, i32* %b.addr, align 4</span>
<span class="go">  store i32 %c, i32* %c.addr, align 4</span>
<span class="go">  store i32 2, i32* %d, align 4</span>
<span class="gp">  %</span><span class="nv">0</span> <span class="o">=</span> load i32, i32* %a.addr, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">cmp</span> <span class="o">=</span> icmp eq i32 %0, <span class="m">0</span>
<span class="go">  br i1 %cmp, label %if.then, label %if.else</span>

<span class="go">if.then:                                          ; preds = %entry</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> load i32, i32* %a.addr, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">inc</span> <span class="o">=</span> add nsw i32 %1, <span class="m">1</span>
<span class="go">  store i32 %inc, i32* %a.addr, align 4</span>
<span class="go">  br label %if.end7</span>

<span class="go">if.else:                                          ; preds = %entry</span>
<span class="gp">  %</span><span class="nv">2</span> <span class="o">=</span> load i32, i32* %b.addr, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">cmp1</span> <span class="o">=</span> icmp ne i32 %2, <span class="m">0</span>
<span class="go">  br i1 %cmp1, label %if.then2, label %if.else3</span>

<span class="go">if.then2:                                         ; preds = %if.else</span>
<span class="gp">  %</span><span class="nv">3</span> <span class="o">=</span> load i32, i32* %a.addr, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">dec</span> <span class="o">=</span> add nsw i32 %3, -1
<span class="go">  store i32 %dec, i32* %a.addr, align 4</span>
<span class="go">  br label %if.end6</span>

<span class="go">if.else3:                                         ; preds = %if.else</span>
<span class="gp">  %</span><span class="nv">4</span> <span class="o">=</span> load i32, i32* %c.addr, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">cmp4</span> <span class="o">=</span> icmp eq i32 %4, <span class="m">0</span>
<span class="go">  br i1 %cmp4, label %if.then5, label %if.end</span>

<span class="go">if.then5:                                         ; preds = %if.else3</span>
<span class="gp">  %</span><span class="nv">5</span> <span class="o">=</span> load i32, i32* %a.addr, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">add</span> <span class="o">=</span> add nsw i32 %5, <span class="m">2</span>
<span class="go">  store i32 %add, i32* %a.addr, align 4</span>
<span class="go">  br label %if.end</span>

<span class="go">if.end:                                           ; preds = %if.then5, %if.else3</span>
<span class="go">  br label %if.end6</span>

<span class="go">if.end6:                                          ; preds = %if.end, %if.then2</span>
<span class="go">  br label %if.end7</span>

<span class="go">if.end7:                                          ; preds = %if.end6, %if.then</span>
<span class="gp">  %</span><span class="nv">6</span> <span class="o">=</span> load i32, i32* %a.addr, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">7</span> <span class="o">=</span> load i32, i32* %b.addr, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">add8</span> <span class="o">=</span> add nsw i32 %6, %7
<span class="go">  store i32 %add8, i32* %d, align 4</span>
<span class="gp">  %</span><span class="nv">8</span> <span class="o">=</span> load i32, i32* %d, align <span class="m">4</span>
<span class="go">  ret i32 %8</span>
<span class="go">}</span>
</pre></div>
</div>
<p>Compile with <code class="docutils literal notranslate"><span class="pre">clang</span> <span class="pre">-O3</span></code> generate phi function. The phi function can
assign virtual register value directly from multi basic blocks.
Compile with <code class="docutils literal notranslate"><span class="pre">clang</span> <span class="pre">-O0</span></code> doesn’t generate phi, it assigns virtual register
value by loading stack slot where the stack slot is saved in each of multi
basic blocks before.
In this example the pointer of %a.addr point to the stack slot, and
“store i32 %inc, i32* %a.addr, align 4”, “store i32 %dec, i32* %a.addr, align 4”,
“store i32 %add, i32* %a.addr, align 4” in label if.then:, if.then2: and
if.then5:, respectively. In other words, it needs 3 store instructions.
It’s possible that compiler finds that the a == 0 is always true after
optimization analysis through phi node.
If so, the phi node version will bring better
result because <code class="docutils literal notranslate"><span class="pre">clang</span> <span class="pre">-O0</span></code> version uses load and store with pointer %a.addr
which may cut the optimization opportunity.
Compiler books discuss the Control Flow Graph (CFG) analysis through dominance
frontiers calculation for setting phi node. Then compiler apply the global
optimization on CFG with phi node, and remove phi node by replacing with
“load store” at the end.</p>
<p>If you are interested in more details than the wiki web site, please refer book
here <a class="footnote-reference brackets" href="#phi-book" id="id8" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a> for phi node, or book here <a class="footnote-reference brackets" href="#dominator-dragonbooks" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></a> for the
dominator tree analysis if you have this book.</p>
</section>
<section id="risc-cpu-knowledge">
<h2><a class="toc-backref" href="#id23" role="doc-backlink">RISC CPU knowledge</a><a class="headerlink" href="#risc-cpu-knowledge" title="Permalink to this heading">¶</a></h2>
<p>As mentioned in the previous section, Cpu0 is a RISC
(Reduced Instruction Set
Computer) CPU with 5 stages of pipeline.
RISC CPU is full in the world, even the X86 of CISC (Complex Instruction Set
Computer) is RISC inside (It translates CISC instruction into
micro-instructions which do pipeline as RISC).
Knowledge with RISC concept may make you satisfied in compiler design.
List these two excellent books we have read for reference.
Sure, there are many books in Computer Architecture and some of them contain
real RISC CPU knowledge needed, but these two are excellent and popular.</p>
<p>Computer Organization and Design: The Hardware/Software Interface (The Morgan
Kaufmann Series in Computer Architecture and Design)</p>
<p>Computer Architecture: A Quantitative Approach (The Morgan Kaufmann Series in
Computer Architecture and Design)</p>
<p>The book of “Computer Organization and Design: The Hardware/Software Interface”
(there are 4 editions at the book is written) is for the introduction, while
“Computer Architecture: A Quantitative Approach” is more complicate and deep
in CPU architecture (there are 5 editions at the book is written).</p>
<p>Above two books use Mips CPU as an example since Mips is more RISC-like than
other market CPUs.
ARM serials of CPU dominate the embedded market especially in mobile phone and
other portable devices. The following book is good which I am reading now.</p>
<p>ARM System Developer’s Guide: Designing and Optimizing System Software
(The Morgan Kaufmann Series in Computer Architecture and Design).</p>
<aside class="footnote brackets" id="cache-speed" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>On a platform with cache and DRAM, the cache miss costs
serveral tens time of instruction cycle.
Usually, the compiler engineers who work in the vendor of platform
solution are spending much effort of trying to reduce the cache miss for
speed. Reduce code size will decrease the cache miss frequency too.</p>
</aside>
<aside class="footnote brackets" id="wb" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">2</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://llvm.org/docs/WritingAnLLVMBackend.html#expand">http://llvm.org/docs/WritingAnLLVMBackend.html#expand</a></p>
</aside>
<aside class="footnote brackets" id="quantitative" role="note">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id2">1</a>,<a role="doc-backlink" href="#id5">2</a>)</span>
<p>See book Computer Architecture: A Quantitative Approach (The
Morgan Kaufmann Series in Computer Architecture and Design)</p>
</aside>
<aside class="footnote brackets" id="wiki-pipeline" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">4</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://en.wikipedia.org/wiki/Classic_RISC_pipeline">http://en.wikipedia.org/wiki/Classic_RISC_pipeline</a></p>
</aside>
<aside class="footnote brackets" id="ssa-wiki" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">5</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Static_single_assignment_form">https://en.wikipedia.org/wiki/Static_single_assignment_form</a></p>
</aside>
<aside class="footnote brackets" id="phi-ex" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">6</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://stackoverflow.com/questions/11485531/what-exactly-phi-instruction-does-and-how-to-use-it-in-llvm">http://stackoverflow.com/questions/11485531/what-exactly-phi-instruction-does-and-how-to-use-it-in-llvm</a></p>
</aside>
<aside class="footnote brackets" id="phi-book" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id8">7</a><span class="fn-bracket">]</span></span>
<p>Section 8.11 of Muchnick, Steven S. (1997). Advanced Compiler Design and Implementation. Morgan Kaufmann. ISBN 1-55860-320-4.</p>
</aside>
<aside class="footnote brackets" id="dominator-dragonbooks" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id9">8</a><span class="fn-bracket">]</span></span>
<p>Refer chapter 9 of book Compilers: Principles,
Techniques, and Tools (2nd Edition)</p>
</aside>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="othertype.html">Other data type</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="funccall.html">Function call</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Chen Chung-Shu.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.0.2.
    </div>
  </body>
</html>