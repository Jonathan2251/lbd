
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Arithmetic and Logic Instructions &#8212; Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Generating object files" href="genobj.html" />
    <link rel="prev" title="Backend structure" href="backendstructure.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</span></a></h1>
        <h2 class="heading"><span>Arithmetic and Logic Instructions</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="backendstructure.html">Backend structure</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="genobj.html">Generating object files</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="arithmetic-and-logic-instructions">
<span id="sec-addingmoresupport"></span><h1>Arithmetic and Logic Instructions<a class="headerlink" href="#arithmetic-and-logic-instructions" title="Permalink to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#arithmetic" id="id21">Arithmetic</a></p>
<ul>
<li><p><a class="reference internal" href="#and" id="id22"><strong>+, -, *, &lt;&lt;,</strong> and <strong>&gt;&gt;</strong></a></p></li>
<li><p><a class="reference internal" href="#display-llvm-ir-nodes-with-graphviz" id="id23">Display LLVM IR Nodes with Graphviz</a></p></li>
<li><p><a class="reference internal" href="#operator-and" id="id24">Operator <code class="docutils literal notranslate"><span class="pre">%</span></code> and <code class="docutils literal notranslate"><span class="pre">/</span></code></a></p>
<ul>
<li><p><a class="reference internal" href="#dag-representation-of" id="id25">DAG Representation of <code class="docutils literal notranslate"><span class="pre">%</span></code></a></p></li>
<li><p><a class="reference internal" href="#arm-solution" id="id26">ARM Solution</a></p></li>
<li><p><a class="reference internal" href="#mips-solution" id="id27">MIPS Solution</a></p></li>
<li><p><a class="reference internal" href="#full-support-for-and" id="id28">Full Support for <cite>%</cite> and <cite>/</cite></a></p></li>
<li><p><a class="reference internal" href="#rotate-instructions" id="id29">Rotate Instructions</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#logical-instructions" id="id30">Logical Instructions</a></p></li>
<li><p><a class="reference internal" href="#summary" id="id31">Summary</a></p></li>
</ul>
</nav>
<p>This chapter first adds support for more Cpu0 arithmetic instructions.
The <a class="reference external" href="http://jonathan2251.github.io/lbd/otherinst.html#display-llvm-ir-nodes-with-graphviz">section Display llvm IR nodes with Graphviz</a> will show you the steps of
DAG optimization and their corresponding <code class="docutils literal notranslate"><span class="pre">llc</span></code> display options.
These DAG translations exist at various optimization steps and can be displayed
using the Graphviz tool, which provides useful graphical information.</p>
<p>Support for logic instructions will follow the arithmetic section.
Although the LLVM backend only handles IR, we derive the IR from corresponding
C operators using designed C example code.
Instead of focusing on class relationships in the backend structure, as in the
previous chapter, readers should now focus on mapping C operators to LLVM IR
and defining the mapping relationship between IR and instructions in <code class="docutils literal notranslate"><span class="pre">.td</span></code>
files.</p>
<p>The <strong>HILO</strong> and <strong>C0</strong> register classes are introduced in this chapter.
Readers will learn how to handle additional register classes beyond general-
purpose registers and understand why they are needed.</p>
<section id="arithmetic">
<h2><a class="toc-backref" href="#id21" role="doc-backlink">Arithmetic</a><a class="headerlink" href="#arithmetic" title="Permalink to this heading">¶</a></h2>
<p>The code added in <code class="docutils literal notranslate"><span class="pre">Chapter4_1/</span></code> to support arithmetic instructions is
summarized as follows:</p>
<p class="rubric">lbdex/chapters/Chapter4_1/Cpu0Subtarget.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">static</span> <span class="n">cl</span><span class="p">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="nb">bool</span><span class="o">&gt;</span> <span class="n">EnableOverflowOpt</span>
                <span class="p">(</span><span class="s2">&quot;cpu0-enable-overflow&quot;</span><span class="p">,</span> <span class="n">cl</span><span class="p">::</span><span class="n">Hidden</span><span class="p">,</span> <span class="n">cl</span><span class="p">::</span><span class="n">init</span><span class="p">(</span><span class="n">false</span><span class="p">),</span>
                 <span class="n">cl</span><span class="p">::</span><span class="n">desc</span><span class="p">(</span><span class="s2">&quot;Use trigger overflow instructions add and sub </span><span class="se">\</span>
<span class="s2">                 instead of non-overflow instructions addu and subu&quot;</span><span class="p">));</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Cpu0Subtarget</span><span class="p">::</span><span class="n">Cpu0Subtarget</span><span class="p">(</span><span class="n">const</span> <span class="n">Triple</span> <span class="o">&amp;</span><span class="n">TT</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">,</span>
                             <span class="n">StringRef</span> <span class="n">FS</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">little</span><span class="p">,</span> 
                             <span class="n">const</span> <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">_TM</span><span class="p">)</span> <span class="p">:</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">...</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">EnableOverflow</span> <span class="o">=</span> <span class="n">EnableOverflowOpt</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter4_1/Cpu0InstrInfo.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Only</span> <span class="n">op</span> <span class="n">DAG</span> <span class="n">can</span> <span class="n">be</span> <span class="n">disabled</span> <span class="n">by</span> <span class="n">ch4_1</span><span class="p">,</span> <span class="n">data</span> <span class="n">DAG</span> <span class="n">cannot</span><span class="o">.</span>
<span class="k">def</span> <span class="nf">SDT_Cpu0DivRem</span>       <span class="p">:</span> <span class="n">SDTypeProfile</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
                                         <span class="p">[</span><span class="n">SDTCisInt</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">,</span>
                                          <span class="n">SDTCisSameAs</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">DivRem</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="n">nodes</span>
<span class="k">def</span> <span class="nf">Cpu0DivRem</span>    <span class="p">:</span> <span class="n">SDNode</span><span class="o">&lt;</span><span class="s2">&quot;Cpu0ISD::DivRem&quot;</span><span class="p">,</span> <span class="n">SDT_Cpu0DivRem</span><span class="p">,</span>
                           <span class="p">[</span><span class="n">SDNPOutGlue</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">Cpu0DivRemU</span>   <span class="p">:</span> <span class="n">SDNode</span><span class="o">&lt;</span><span class="s2">&quot;Cpu0ISD::DivRemU&quot;</span><span class="p">,</span> <span class="n">SDT_Cpu0DivRem</span><span class="p">,</span>
                           <span class="p">[</span><span class="n">SDNPOutGlue</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>let Predicates = [Ch4_1] in {
class shift_rotate_reg&lt;bits&lt;8&gt; op, bits&lt;4&gt; isRotate, string instr_asm,
                       SDNode OpNode, RegisterClass RC&gt;:
  FA&lt;op, (outs GPROut:$ra), (ins RC:$rb, RC:$rc),
     !strconcat(instr_asm, &quot;\t$ra, $rb, $rc&quot;),
     [(set GPROut:$ra, (OpNode RC:$rb, RC:$rc))], IIAlu&gt; {
  let shamt = 0;
}
}
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>let Predicates = [Ch4_1] in {
// Mul, Div
class Mult&lt;bits&lt;8&gt; op, string instr_asm, InstrItinClass itin,
           RegisterClass RC, list&lt;Register&gt; DefRegs&gt;:
  FA&lt;op, (outs), (ins RC:$ra, RC:$rb),
     !strconcat(instr_asm, &quot;\t$ra, $rb&quot;), [], itin&gt; {
  let rc = 0;
  let shamt = 0;
  let isCommutable = 1;
  let Defs = DefRegs;
  let hasSideEffects = 0;
}

class Mult32&lt;bits&lt;8&gt; op, string instr_asm, InstrItinClass itin&gt;:
  Mult&lt;op, instr_asm, itin, CPURegs, [HI, LO]&gt;;

class Div&lt;SDNode opNode, bits&lt;8&gt; op, string instr_asm, InstrItinClass itin,
          RegisterClass RC, list&lt;Register&gt; DefRegs&gt;:
  FA&lt;op, (outs), (ins RC:$ra, RC:$rb),
     !strconcat(instr_asm, &quot;\t$ra, $rb&quot;),
     [(opNode RC:$ra, RC:$rb)], itin&gt; {
  let rc = 0;
  let shamt = 0;
  let Defs = DefRegs;
}

class Div32&lt;SDNode opNode, bits&lt;8&gt; op, string instr_asm, InstrItinClass itin&gt;:
  Div&lt;opNode, op, instr_asm, itin, CPURegs, [HI, LO]&gt;;

// Move from Lo/Hi
class MoveFromLOHI&lt;bits&lt;8&gt; op, string instr_asm, RegisterClass RC,
                   list&lt;Register&gt; UseRegs&gt;:
  FA&lt;op, (outs RC:$ra), (ins),
     !strconcat(instr_asm, &quot;\t$ra&quot;), [], IIHiLo&gt; {
  let rb = 0;
  let rc = 0;
  let shamt = 0;
  let Uses = UseRegs;
  let hasSideEffects = 0;
}

// Move to Lo/Hi
class MoveToLOHI&lt;bits&lt;8&gt; op, string instr_asm, RegisterClass RC,
                 list&lt;Register&gt; DefRegs&gt;:
  FA&lt;op, (outs), (ins RC:$ra),
     !strconcat(instr_asm, &quot;\t$ra&quot;), [], IIHiLo&gt; {
  let rb = 0;
  let rc = 0;
  let shamt = 0;
  let Defs = DefRegs;
  let hasSideEffects = 0;
}

// Move from C0 (co-processor 0) Register
class MoveFromC0&lt;bits&lt;8&gt; op, string instr_asm, RegisterClass RC&gt;:
  FA&lt;op, (outs), (ins RC:$ra, C0Regs:$rb),
     !strconcat(instr_asm, &quot;\t$ra, $rb&quot;), [], IIAlu&gt; {
  let rc = 0;
  let shamt = 0;
  let hasSideEffects = 0;
}

// Move to C0 Register
class MoveToC0&lt;bits&lt;8&gt; op, string instr_asm, RegisterClass RC&gt;:
  FA&lt;op, (outs C0Regs:$ra), (ins RC:$rb),
     !strconcat(instr_asm, &quot;\t$ra, $rb&quot;), [], IIAlu&gt; {
  let rc = 0;
  let shamt = 0;
  let hasSideEffects = 0;
}

// Move from C0 register to C0 register
class C0Move&lt;bits&lt;8&gt; op, string instr_asm&gt;:
  FA&lt;op, (outs C0Regs:$ra), (ins C0Regs:$rb),
     !strconcat(instr_asm, &quot;\t$ra, $rb&quot;), [], IIAlu&gt; {
  let rc = 0;
  let shamt = 0;
  let hasSideEffects = 0;
}
} // let Predicates = [Ch4_1]
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ch4_1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">{</span>
<span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">DisableOverflow</span><span class="p">]</span> <span class="ow">in</span> <span class="p">{</span>
<span class="k">def</span> <span class="nf">SUBu</span>    <span class="p">:</span> <span class="n">ArithLogicR</span><span class="o">&lt;</span><span class="mh">0x12</span><span class="p">,</span> <span class="s2">&quot;subu&quot;</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="n">IIAlu</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">EnableOverflow</span><span class="p">]</span> <span class="ow">in</span> <span class="p">{</span>
<span class="k">def</span> <span class="nf">ADD</span>     <span class="p">:</span> <span class="n">ArithLogicR</span><span class="o">&lt;</span><span class="mh">0x13</span><span class="p">,</span> <span class="s2">&quot;add&quot;</span><span class="p">,</span> <span class="n">add</span><span class="p">,</span> <span class="n">IIAlu</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">SUB</span>     <span class="p">:</span> <span class="n">ArithLogicR</span><span class="o">&lt;</span><span class="mh">0x14</span><span class="p">,</span> <span class="s2">&quot;sub&quot;</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="n">IIAlu</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">def</span> <span class="nf">MUL</span>     <span class="p">:</span> <span class="n">ArithLogicR</span><span class="o">&lt;</span><span class="mh">0x17</span><span class="p">,</span> <span class="s2">&quot;mul&quot;</span><span class="p">,</span> <span class="n">mul</span><span class="p">,</span> <span class="n">IIImul</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ch4_1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">{</span>
<span class="o">//</span> <span class="n">sra</span> <span class="ow">is</span> <span class="n">IR</span> <span class="n">node</span> <span class="k">for</span> <span class="n">ashr</span> <span class="n">llvm</span> <span class="n">IR</span> <span class="n">instruction</span> <span class="n">of</span> <span class="o">.</span><span class="n">bc</span>
<span class="k">def</span> <span class="nf">ROL</span>     <span class="p">:</span> <span class="n">shift_rotate_imm32</span><span class="o">&lt;</span><span class="mh">0x1c</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="s2">&quot;rol&quot;</span><span class="p">,</span> <span class="n">rotl</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">ROR</span>     <span class="p">:</span> <span class="n">shift_rotate_imm32</span><span class="o">&lt;</span><span class="mh">0x1d</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="s2">&quot;ror&quot;</span><span class="p">,</span> <span class="n">rotr</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ch4_1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">{</span>
<span class="o">//</span> <span class="n">srl</span> <span class="ow">is</span> <span class="n">IR</span> <span class="n">node</span> <span class="k">for</span> <span class="n">lshr</span> <span class="n">llvm</span> <span class="n">IR</span> <span class="n">instruction</span> <span class="n">of</span> <span class="o">.</span><span class="n">bc</span>
<span class="k">def</span> <span class="nf">SHR</span>     <span class="p">:</span> <span class="n">shift_rotate_imm32</span><span class="o">&lt;</span><span class="mh">0x1f</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="s2">&quot;shr&quot;</span><span class="p">,</span> <span class="n">srl</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">SRA</span>     <span class="p">:</span> <span class="n">shift_rotate_imm32</span><span class="o">&lt;</span><span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="s2">&quot;sra&quot;</span><span class="p">,</span> <span class="n">sra</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">SRAV</span>    <span class="p">:</span> <span class="n">shift_rotate_reg</span><span class="o">&lt;</span><span class="mh">0x21</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="s2">&quot;srav&quot;</span><span class="p">,</span> <span class="n">sra</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">SHLV</span>    <span class="p">:</span> <span class="n">shift_rotate_reg</span><span class="o">&lt;</span><span class="mh">0x22</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="s2">&quot;shlv&quot;</span><span class="p">,</span> <span class="n">shl</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">SHRV</span>    <span class="p">:</span> <span class="n">shift_rotate_reg</span><span class="o">&lt;</span><span class="mh">0x23</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="s2">&quot;shrv&quot;</span><span class="p">,</span> <span class="n">srl</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">ROLV</span>    <span class="p">:</span> <span class="n">shift_rotate_reg</span><span class="o">&lt;</span><span class="mh">0x24</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="s2">&quot;rolv&quot;</span><span class="p">,</span> <span class="n">rotl</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">RORV</span>    <span class="p">:</span> <span class="n">shift_rotate_reg</span><span class="o">&lt;</span><span class="mh">0x25</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="s2">&quot;rorv&quot;</span><span class="p">,</span> <span class="n">rotr</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ch4_1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">{</span>
<span class="o">///</span> <span class="n">Multiply</span> <span class="ow">and</span> <span class="n">Divide</span> <span class="n">Instructions</span><span class="o">.</span>
<span class="k">def</span> <span class="nf">MULT</span>    <span class="p">:</span> <span class="n">Mult32</span><span class="o">&lt;</span><span class="mh">0x41</span><span class="p">,</span> <span class="s2">&quot;mult&quot;</span><span class="p">,</span> <span class="n">IIImul</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">MULTu</span>   <span class="p">:</span> <span class="n">Mult32</span><span class="o">&lt;</span><span class="mh">0x42</span><span class="p">,</span> <span class="s2">&quot;multu&quot;</span><span class="p">,</span> <span class="n">IIImul</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">SDIV</span>    <span class="p">:</span> <span class="n">Div32</span><span class="o">&lt;</span><span class="n">Cpu0DivRem</span><span class="p">,</span> <span class="mh">0x43</span><span class="p">,</span> <span class="s2">&quot;div&quot;</span><span class="p">,</span> <span class="n">IIIdiv</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">UDIV</span>    <span class="p">:</span> <span class="n">Div32</span><span class="o">&lt;</span><span class="n">Cpu0DivRemU</span><span class="p">,</span> <span class="mh">0x44</span><span class="p">,</span> <span class="s2">&quot;divu&quot;</span><span class="p">,</span> <span class="n">IIIdiv</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">def</span> <span class="nf">MFHI</span>    <span class="p">:</span> <span class="n">MoveFromLOHI</span><span class="o">&lt;</span><span class="mh">0x46</span><span class="p">,</span> <span class="s2">&quot;mfhi&quot;</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="p">[</span><span class="n">HI</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">MFLO</span>    <span class="p">:</span> <span class="n">MoveFromLOHI</span><span class="o">&lt;</span><span class="mh">0x47</span><span class="p">,</span> <span class="s2">&quot;mflo&quot;</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="p">[</span><span class="n">LO</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">MTHI</span>    <span class="p">:</span> <span class="n">MoveToLOHI</span><span class="o">&lt;</span><span class="mh">0x48</span><span class="p">,</span> <span class="s2">&quot;mthi&quot;</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="p">[</span><span class="n">HI</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">MTLO</span>    <span class="p">:</span> <span class="n">MoveToLOHI</span><span class="o">&lt;</span><span class="mh">0x49</span><span class="p">,</span> <span class="s2">&quot;mtlo&quot;</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="p">[</span><span class="n">LO</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">def</span> <span class="nf">MFC0</span>    <span class="p">:</span> <span class="n">MoveFromC0</span><span class="o">&lt;</span><span class="mh">0x50</span><span class="p">,</span> <span class="s2">&quot;mfc0&quot;</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">MTC0</span>    <span class="p">:</span> <span class="n">MoveToC0</span><span class="o">&lt;</span><span class="mh">0x51</span><span class="p">,</span> <span class="s2">&quot;mtc0&quot;</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">def</span> <span class="nf">C0MOVE</span>  <span class="p">:</span> <span class="n">C0Move</span><span class="o">&lt;</span><span class="mh">0x52</span><span class="p">,</span> <span class="s2">&quot;c0mov&quot;</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter4_1/Cpu0ISelLowering.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">SDValue</span> <span class="n">PerformDAGCombine</span><span class="p">(</span><span class="n">SDNode</span> <span class="o">*</span><span class="n">N</span><span class="p">,</span> <span class="n">DAGCombinerInfo</span> <span class="o">&amp;</span><span class="n">DCI</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter4_1/Cpu0ISelLowering.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="n">const</span> <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">,</span>
                                       <span class="n">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span>
    <span class="p">:</span> <span class="n">TargetLowering</span><span class="p">(</span><span class="n">TM</span><span class="p">),</span> <span class="n">Subtarget</span><span class="p">(</span><span class="n">STI</span><span class="p">),</span> <span class="n">ABI</span><span class="p">(</span><span class="n">TM</span><span class="o">.</span><span class="n">getABI</span><span class="p">())</span> <span class="p">{</span>

</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">SDIV</span><span class="p">,</span> <span class="n">MVT</span><span class="p">::</span><span class="n">i32</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">SREM</span><span class="p">,</span> <span class="n">MVT</span><span class="p">::</span><span class="n">i32</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">UDIV</span><span class="p">,</span> <span class="n">MVT</span><span class="p">::</span><span class="n">i32</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">UREM</span><span class="p">,</span> <span class="n">MVT</span><span class="p">::</span><span class="n">i32</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">setTargetDAGCombine</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">SDIVREM</span><span class="p">);</span>
  <span class="n">setTargetDAGCombine</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">UDIVREM</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>static SDValue performDivRemCombine(SDNode *N, SelectionDAG&amp; DAG,
                                    TargetLowering::DAGCombinerInfo &amp;DCI,
                                    const Cpu0Subtarget &amp;Subtarget) {
  if (DCI.isBeforeLegalizeOps())
    return SDValue();

  EVT Ty = N-&gt;getValueType(0);
  unsigned LO = Cpu0::LO;
  unsigned HI = Cpu0::HI;
  unsigned Opc = N-&gt;getOpcode() == ISD::SDIVREM ? Cpu0ISD::DivRem :
                                                  Cpu0ISD::DivRemU;
  SDLoc DL(N);

  SDValue DivRem = DAG.getNode(Opc, DL, MVT::Glue,
                               N-&gt;getOperand(0), N-&gt;getOperand(1));
  SDValue InChain = DAG.getEntryNode();
  SDValue InGlue = DivRem;

  // insert MFLO
  if (N-&gt;hasAnyUseOfValue(0)) {
    SDValue CopyFromLo = DAG.getCopyFromReg(InChain, DL, LO, Ty,
                                            InGlue);
    DAG.ReplaceAllUsesOfValueWith(SDValue(N, 0), CopyFromLo);
    InChain = CopyFromLo.getValue(1);
    InGlue = CopyFromLo.getValue(2);
  }

  // insert MFHI
  if (N-&gt;hasAnyUseOfValue(1)) {
    SDValue CopyFromHi = DAG.getCopyFromReg(InChain, DL,
                                            HI, Ty, InGlue);
    DAG.ReplaceAllUsesOfValueWith(SDValue(N, 1), CopyFromHi);
  }

  return SDValue();
}

SDValue Cpu0TargetLowering::PerformDAGCombine(SDNode *N, DAGCombinerInfo &amp;DCI)
  const {
  SelectionDAG &amp;DAG = DCI.DAG;
  unsigned Opc = N-&gt;getOpcode();

  switch (Opc) {
  default: break;
  case ISD::SDIVREM:
  case ISD::UDIVREM:
    return performDivRemCombine(N, DAG, DCI, Subtarget);
  }

  return SDValue();
}
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter4_1/Cpu0RegisterInfo.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">Namespace</span> <span class="o">=</span> <span class="s2">&quot;Cpu0&quot;</span> <span class="ow">in</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="o">//</span> <span class="n">Hi</span><span class="o">/</span><span class="n">Lo</span> <span class="n">registers</span> <span class="n">number</span> <span class="ow">and</span> <span class="n">name</span>
  <span class="k">def</span> <span class="nf">HI</span>   <span class="p">:</span> <span class="n">Cpu0Reg</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;ac0&quot;</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">18</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">LO</span>   <span class="p">:</span> <span class="n">Cpu0Reg</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;ac0&quot;</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">}</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Hi</span><span class="o">/</span><span class="n">Lo</span> <span class="n">Registers</span> <span class="k">class</span>
<span class="nc">def</span> <span class="n">HILO</span>   <span class="p">:</span> <span class="n">RegisterClass</span><span class="o">&lt;</span><span class="s2">&quot;Cpu0&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">i32</span><span class="p">],</span> <span class="mi">32</span><span class="p">,</span> <span class="p">(</span><span class="n">add</span> <span class="n">HI</span><span class="p">,</span> <span class="n">LO</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter4_1/Cpu0Schedule.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">IIHiLo</span>             <span class="p">:</span> <span class="n">InstrItinClass</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">IIImul</span>             <span class="p">:</span> <span class="n">InstrItinClass</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">IIIdiv</span>             <span class="p">:</span> <span class="n">InstrItinClass</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">Cpu0GenericItineraries</span> <span class="p">:</span> <span class="n">ProcessorItineraries</span><span class="o">&lt;</span><span class="p">[</span><span class="n">ALU</span><span class="p">,</span> <span class="n">IMULDIV</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">InstrItinData</span><span class="o">&lt;</span><span class="n">IIHiLo</span>             <span class="p">,</span> <span class="p">[</span><span class="n">InstrStage</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span>  <span class="p">[</span><span class="n">IMULDIV</span><span class="p">]</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">InstrItinData</span><span class="o">&lt;</span><span class="n">IIImul</span>             <span class="p">,</span> <span class="p">[</span><span class="n">InstrStage</span><span class="o">&lt;</span><span class="mi">17</span><span class="p">,</span> <span class="p">[</span><span class="n">IMULDIV</span><span class="p">]</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">InstrItinData</span><span class="o">&lt;</span><span class="n">IIIdiv</span>             <span class="p">,</span> <span class="p">[</span><span class="n">InstrStage</span><span class="o">&lt;</span><span class="mi">38</span><span class="p">,</span> <span class="p">[</span><span class="n">IMULDIV</span><span class="p">]</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter4_1/Cpu0SEISelDAGToDAG.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">std</span><span class="p">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">SDNode</span> <span class="o">*</span><span class="p">,</span> <span class="n">SDNode</span> <span class="o">*&gt;</span> <span class="n">selectMULT</span><span class="p">(</span><span class="n">SDNode</span> <span class="o">*</span><span class="n">N</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">Opc</span><span class="p">,</span>
                                           <span class="n">const</span> <span class="n">SDLoc</span> <span class="o">&amp;</span><span class="n">DL</span><span class="p">,</span> <span class="n">EVT</span> <span class="n">Ty</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">HasLo</span><span class="p">,</span>
                                           <span class="nb">bool</span> <span class="n">HasHi</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter4_1/Cpu0SEISelDAGToDAG.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">///</span> <span class="n">Select</span> <span class="n">multiply</span> <span class="n">instructions</span><span class="o">.</span>
<span class="n">std</span><span class="p">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">SDNode</span> <span class="o">*</span><span class="p">,</span> <span class="n">SDNode</span> <span class="o">*&gt;</span>
<span class="n">Cpu0SEDAGToDAGISel</span><span class="p">::</span><span class="n">selectMULT</span><span class="p">(</span><span class="n">SDNode</span> <span class="o">*</span><span class="n">N</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">Opc</span><span class="p">,</span> <span class="n">const</span> <span class="n">SDLoc</span> <span class="o">&amp;</span><span class="n">DL</span><span class="p">,</span> <span class="n">EVT</span> <span class="n">Ty</span><span class="p">,</span>
                             <span class="nb">bool</span> <span class="n">HasLo</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">HasHi</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">SDNode</span> <span class="o">*</span><span class="n">Lo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">Hi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">SDNode</span> <span class="o">*</span><span class="n">Mul</span> <span class="o">=</span> <span class="n">CurDAG</span><span class="o">-&gt;</span><span class="n">getMachineNode</span><span class="p">(</span><span class="n">Opc</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">MVT</span><span class="p">::</span><span class="n">Glue</span><span class="p">,</span> <span class="n">N</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                                       <span class="n">N</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
  <span class="n">SDValue</span> <span class="n">InFlag</span> <span class="o">=</span> <span class="n">SDValue</span><span class="p">(</span><span class="n">Mul</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">HasLo</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Lo</span> <span class="o">=</span> <span class="n">CurDAG</span><span class="o">-&gt;</span><span class="n">getMachineNode</span><span class="p">(</span><span class="n">Cpu0</span><span class="p">::</span><span class="n">MFLO</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span>
                                <span class="n">Ty</span><span class="p">,</span> <span class="n">MVT</span><span class="p">::</span><span class="n">Glue</span><span class="p">,</span> <span class="n">InFlag</span><span class="p">);</span>
    <span class="n">InFlag</span> <span class="o">=</span> <span class="n">SDValue</span><span class="p">(</span><span class="n">Lo</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">HasHi</span><span class="p">)</span>
    <span class="n">Hi</span> <span class="o">=</span> <span class="n">CurDAG</span><span class="o">-&gt;</span><span class="n">getMachineNode</span><span class="p">(</span><span class="n">Cpu0</span><span class="p">::</span><span class="n">MFHI</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span>
                                <span class="n">Ty</span><span class="p">,</span> <span class="n">InFlag</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">std</span><span class="p">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">Lo</span><span class="p">,</span> <span class="n">Hi</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">bool</span> <span class="n">Cpu0SEDAGToDAGISel</span><span class="p">::</span><span class="n">trySelect</span><span class="p">(</span><span class="n">SDNode</span> <span class="o">*</span><span class="n">Node</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">unsigned</span> <span class="n">Opcode</span> <span class="o">=</span> <span class="n">Node</span><span class="o">-&gt;</span><span class="n">getOpcode</span><span class="p">();</span>
  <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">(</span><span class="n">Node</span><span class="p">);</span>

  <span class="o">///</span>
  <span class="o">//</span> <span class="n">Instruction</span> <span class="n">Selection</span> <span class="ow">not</span> <span class="n">handled</span> <span class="n">by</span> <span class="n">the</span> <span class="n">auto</span><span class="o">-</span><span class="n">generated</span>
  <span class="o">//</span> <span class="n">tablegen</span> <span class="n">selection</span> <span class="n">should</span> <span class="n">be</span> <span class="n">handled</span> <span class="n">here</span><span class="o">.</span>
  <span class="o">///</span>

  <span class="o">///</span>
  <span class="o">//</span> <span class="n">Instruction</span> <span class="n">Selection</span> <span class="ow">not</span> <span class="n">handled</span> <span class="n">by</span> <span class="n">the</span> <span class="n">auto</span><span class="o">-</span><span class="n">generated</span>
  <span class="o">//</span> <span class="n">tablegen</span> <span class="n">selection</span> <span class="n">should</span> <span class="n">be</span> <span class="n">handled</span> <span class="n">here</span><span class="o">.</span>
  <span class="o">///</span>
  <span class="n">EVT</span> <span class="n">NodeTy</span> <span class="o">=</span> <span class="n">Node</span><span class="o">-&gt;</span><span class="n">getValueType</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">unsigned</span> <span class="n">MultOpc</span><span class="p">;</span>

  <span class="n">switch</span><span class="p">(</span><span class="n">Opcode</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">default</span><span class="p">:</span> <span class="k">break</span><span class="p">;</span>

</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  case ISD::MULHS:
  case ISD::MULHU: {
    MultOpc = (Opcode == ISD::MULHU ? Cpu0::MULTu : Cpu0::MULT);
    auto LoHi = selectMULT(Node, MultOpc, DL, NodeTy, false, true);
    ReplaceNode(Node, LoHi.second);
    return true;
  }

  case ISD::Constant: {
    const ConstantSDNode *CN = dyn_cast&lt;ConstantSDNode&gt;(Node);
    unsigned Size = CN-&gt;getValueSizeInBits(0);

    if (Size == 32)
      break;

    return true;
  }
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter4_1/Cpu0SEInstrInfo.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">void</span> <span class="n">copyPhysReg</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MachineBasicBlock</span><span class="p">::</span><span class="n">iterator</span> <span class="n">MI</span><span class="p">,</span>
                   <span class="n">const</span> <span class="n">DebugLoc</span> <span class="o">&amp;</span><span class="n">DL</span><span class="p">,</span> <span class="n">MCRegister</span> <span class="n">DestReg</span><span class="p">,</span> <span class="n">MCRegister</span> <span class="n">SrcReg</span><span class="p">,</span>
                   <span class="nb">bool</span> <span class="n">KillSrc</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter4_1/Cpu0SEInstrInfo.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">Cpu0SEInstrInfo</span><span class="p">::</span><span class="n">copyPhysReg</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span>
                                  <span class="n">MachineBasicBlock</span><span class="p">::</span><span class="n">iterator</span> <span class="n">I</span><span class="p">,</span>
                                  <span class="n">const</span> <span class="n">DebugLoc</span> <span class="o">&amp;</span><span class="n">DL</span><span class="p">,</span> <span class="n">MCRegister</span> <span class="n">DestReg</span><span class="p">,</span>
                                  <span class="n">MCRegister</span> <span class="n">SrcReg</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">KillSrc</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="n">unsigned</span> <span class="n">Opc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ZeroReg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0</span><span class="p">::</span><span class="n">CPURegsRegClass</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">DestReg</span><span class="p">))</span> <span class="p">{</span> <span class="o">//</span> <span class="n">Copy</span> <span class="n">to</span> <span class="n">CPU</span> <span class="n">Reg</span><span class="o">.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0</span><span class="p">::</span><span class="n">CPURegsRegClass</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">SrcReg</span><span class="p">))</span>
      <span class="n">Opc</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">ADDu</span><span class="p">,</span> <span class="n">ZeroReg</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">ZERO</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">SrcReg</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">HI</span><span class="p">)</span>
      <span class="n">Opc</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">MFHI</span><span class="p">,</span> <span class="n">SrcReg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">SrcReg</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">LO</span><span class="p">)</span>
      <span class="n">Opc</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">MFLO</span><span class="p">,</span> <span class="n">SrcReg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0</span><span class="p">::</span><span class="n">CPURegsRegClass</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">SrcReg</span><span class="p">))</span> <span class="p">{</span> <span class="o">//</span> <span class="n">Copy</span> <span class="kn">from</span> <span class="nn">CPU</span> <span class="n">Reg</span><span class="o">.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">DestReg</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">HI</span><span class="p">)</span>
      <span class="n">Opc</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">MTHI</span><span class="p">,</span> <span class="n">DestReg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">DestReg</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">LO</span><span class="p">)</span>
      <span class="n">Opc</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">MTLO</span><span class="p">,</span> <span class="n">DestReg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">assert</span><span class="p">(</span><span class="n">Opc</span> <span class="o">&amp;&amp;</span> <span class="s2">&quot;Cannot copy registers&quot;</span><span class="p">);</span>

  <span class="n">MachineInstrBuilder</span> <span class="n">MIB</span> <span class="o">=</span> <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">get</span><span class="p">(</span><span class="n">Opc</span><span class="p">));</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">DestReg</span><span class="p">)</span>
    <span class="n">MIB</span><span class="o">.</span><span class="n">addReg</span><span class="p">(</span><span class="n">DestReg</span><span class="p">,</span> <span class="n">RegState</span><span class="p">::</span><span class="n">Define</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">ZeroReg</span><span class="p">)</span>
    <span class="n">MIB</span><span class="o">.</span><span class="n">addReg</span><span class="p">(</span><span class="n">ZeroReg</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">SrcReg</span><span class="p">)</span>
    <span class="n">MIB</span><span class="o">.</span><span class="n">addReg</span><span class="p">(</span><span class="n">SrcReg</span><span class="p">,</span> <span class="n">getKillRegState</span><span class="p">(</span><span class="n">KillSrc</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<section id="and">
<h3><a class="toc-backref" href="#id22" role="doc-backlink"><strong>+, -, *, &lt;&lt;,</strong> and <strong>&gt;&gt;</strong></a><a class="headerlink" href="#and" title="Permalink to this heading">¶</a></h3>
<p>The <strong>ADDu</strong>, <strong>ADD</strong>, <strong>SUBu</strong>, <strong>SUB</strong>, and <strong>MUL</strong> instructions defined in
<code class="docutils literal notranslate"><span class="pre">Chapter4_1/Cpu0InstrInfo.td</span></code> correspond to the <strong>+, -, *</strong> operators.
<strong>SHL</strong> (defined earlier) and <strong>SHLV</strong> are used for <strong>&lt;&lt;</strong>, while <strong>SRA</strong>,
<strong>SRAV</strong>, <strong>SHR</strong>, and <strong>SHRV</strong> handle <strong>&gt;&gt;</strong>.</p>
<p>In RISC CPUs like MIPS, the multiply/divide function unit and add/sub/logic
unit are implemented using separate hardware circuits with distinct data paths.
Cpu0 follows the same approach, allowing these function units to execute
simultaneously (instruction-level parallelism).
Refer to <a class="footnote-reference brackets" href="#instrstage" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> for details on instruction itineraries.</p>
<p><code class="docutils literal notranslate"><span class="pre">Chapter4_1/</span></code> supports the <strong>+, -, *, &lt;&lt;, and &gt;&gt;</strong> operators in C.
The corresponding LLVM IR instructions are <strong>add, sub, mul, shl, and ashr</strong>.</p>
<p>The <strong>ashr</strong> instruction (arithmetic shift right) shifts the first operand
right by a specified number of bits with sign extension.
In short, <strong>ashr</strong> performs “shift with sign extension fill.”</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>ashr</strong></p>
<dl>
<dt>Example:</dt><dd><p>&lt;result&gt; = ashr i32 4, 1   ; yields {i32}:result = 2</p>
<p>&lt;result&gt; = ashr i8 -2, 1   ; yields {i8}:result = -1</p>
<p>&lt;result&gt; = ashr i32 1, 32  ; undefined</p>
</dd>
</dl>
</div>
<p>The behavior of the C <strong>&gt;&gt;</strong> operator for negative operands is
implementation-dependent.
Most compilers translate it as a “shift with sign extension fill,”
which is equivalent to the MIPS <strong>sra</strong> instruction.
The Microsoft website provides the following explanation:</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>&gt;&gt;</strong>, Microsoft Specific</p>
<p>The result of a right shift of a signed negative quantity is implementation
dependent.
Although Microsoft C++ propagates the most-significant bit to fill vacated
bit positions, there is no guarantee that other implementations will do
likewise.</p>
</div>
<p>In addition to <strong>ashr</strong>, LLVM provides the <strong>lshr</strong> instruction (“logical shift
right with zero fill”), which MIPS implements with the <strong>srl</strong> instruction.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>lshr</strong></p>
<p>Example:
&lt;result&gt; = lshr i8 -2, 1   ; yields {i8}:result = 0x7FFFFFFF</p>
</div>
<p>LLVM defines <strong>sra</strong> as the IR node for <strong>ashr</strong> and <strong>srl</strong> for <strong>lshr</strong>.
(It’s unclear why LLVM does not directly use “ashr” and “lshr” as IR node names.)
The following table summarizes C <strong>&gt;&gt;</strong> operator implementations:</p>
<table class="docutils align-default" id="id10">
<caption><span class="caption-number">Table 21 </span><span class="caption-text">C operator &gt;&gt; implementation</span><a class="headerlink" href="#id10" title="Permalink to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Description</p></th>
<th class="head"><p>Shift with zero filled</p></th>
<th class="head"><p>Shift with signed extension filled</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>symbol in .bc</p></td>
<td><p>lshr</p></td>
<td><p>ashr</p></td>
</tr>
<tr class="row-odd"><td><p>symbol in IR node</p></td>
<td><p>srl</p></td>
<td><p>sra</p></td>
</tr>
<tr class="row-even"><td><p>Mips instruction</p></td>
<td><p>srl</p></td>
<td><p>sra</p></td>
</tr>
<tr class="row-odd"><td><p>Cpu0 instruction</p></td>
<td><p>shr</p></td>
<td><p>sra</p></td>
</tr>
<tr class="row-even"><td><p>signed example before x &gt;&gt; 1</p></td>
<td><p>0xfffffffe i.e. -2</p></td>
<td><p>0xfffffffe i.e. -2</p></td>
</tr>
<tr class="row-odd"><td><p>signed example after x &gt;&gt; 1</p></td>
<td><p>0x7fffffff i.e 2G-1</p></td>
<td><p>0xffffffff i.e. -1</p></td>
</tr>
<tr class="row-even"><td><p>unsigned example before x &gt;&gt; 1</p></td>
<td><p>0xfffffffe i.e. 4G-2</p></td>
<td><p>0xfffffffe i.e. 4G-2</p></td>
</tr>
<tr class="row-odd"><td><p>unsigned example after x &gt;&gt; 1</p></td>
<td><p>0x7fffffff i.e 2G-1</p></td>
<td><p>0xffffffff i.e. 4G-1</p></td>
</tr>
</tbody>
</table>
<p><strong>lshr:</strong> Logical SHift Right</p>
<p><strong>ashr:</strong> Arithmetic SHift right</p>
<p><strong>srl:</strong>  Shift Right Logically</p>
<p><strong>sra:</strong>  Shift Right Arithmetically</p>
<p><strong>shr:</strong>  SHift Right</p>
<p>If we define <strong>x &gt;&gt; 1</strong> as <strong>x = x / 2</strong>, then <strong>lshr</strong> fails for some signed
values (e.g., -2). Similarly, <strong>ashr</strong> fails for some unsigned values
(e.g., <strong>4G - 2</strong>).
Thus, to correctly handle both signed and unsigned integers, we need both
<strong>lshr</strong> and <strong>ashr</strong>.</p>
<table class="docutils align-default" id="id11">
<caption><span class="caption-number">Table 22 </span><span class="caption-text">C operator &lt;&lt; implementation</span><a class="headerlink" href="#id11" title="Permalink to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Description</p></th>
<th class="head"><p>Shift with zero filled</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>symbol in .bc</p></td>
<td><p>shl</p></td>
</tr>
<tr class="row-odd"><td><p>symbol in IR node</p></td>
<td><p>shl</p></td>
</tr>
<tr class="row-even"><td><p>Mips instruction</p></td>
<td><p>sll</p></td>
</tr>
<tr class="row-odd"><td><p>Cpu0 instruction</p></td>
<td><p>shl</p></td>
</tr>
<tr class="row-even"><td><p>signed example before x &lt;&lt; 1</p></td>
<td><p>0x40000000 i.e. 1G</p></td>
</tr>
<tr class="row-odd"><td><p>signed example after x &lt;&lt; 1</p></td>
<td><p>0x80000000 i.e -2G</p></td>
</tr>
<tr class="row-even"><td><p>unsigned example before x &lt;&lt; 1</p></td>
<td><p>0x40000000 i.e. 1G</p></td>
</tr>
<tr class="row-odd"><td><p>unsigned example after x &lt;&lt; 1</p></td>
<td><p>0x80000000 i.e 2G</p></td>
</tr>
</tbody>
</table>
<p>Again, consider the definition of <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;&lt;</span> <span class="pre">1</span></code> as <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">*</span> <span class="pre">2</span></code>.
From the table on C operator <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> implementation, we see that <strong>lshr</strong>
satisfies the case for “unsigned x = 1G” but fails for “signed x = 1G”.
This is acceptable since <code class="docutils literal notranslate"><span class="pre">2G</span></code> exceeds the 32-bit signed integer range
(<code class="docutils literal notranslate"><span class="pre">-2G</span></code> to <code class="docutils literal notranslate"><span class="pre">2G</span> <span class="pre">-</span> <span class="pre">1</span></code>).</p>
<p>In the case of overflow, there is no way to retain the correct result
within a register. Thus, any value stored in the register is acceptable.
You can verify that <strong>lshr</strong> satisfies <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">*</span> <span class="pre">2</span></code> for all <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;&lt;</span> <span class="pre">1</span></code>,
as long as the result remains within range, regardless of whether <code class="docutils literal notranslate"><span class="pre">x</span></code>
is signed or unsigned <a class="footnote-reference brackets" href="#arithmetic-shift" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>.</p>
<p>The reference for the <code class="docutils literal notranslate"><span class="pre">ashr</span></code> instruction is available here <a class="footnote-reference brackets" href="#ashr" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>,
and for <code class="docutils literal notranslate"><span class="pre">lshr</span></code> here <a class="footnote-reference brackets" href="#lshr" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a>.</p>
<p>The instructions <strong>srav</strong>, <strong>shlv</strong>, and <strong>shrv</strong> operate on two virtual
input registers, while <strong>sra</strong>, <strong>…</strong>, and others operate on one virtual
input register and one constant operand.</p>
<p>Now, let’s build <code class="docutils literal notranslate"><span class="pre">Chapter4_1/</span></code> and run it using the input file
<code class="docutils literal notranslate"><span class="pre">ch4_math.ll</span></code> as follows:</p>
<p class="rubric">lbdex/input/ch4_math.ll</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="p">;</span> <span class="n">Function</span> <span class="n">Attrs</span><span class="p">:</span> <span class="n">nounwind</span>
<span class="n">define</span> <span class="n">i32</span> <span class="nd">@_Z9test_mathv</span><span class="p">()</span> <span class="c1">#0 {</span>
  <span class="o">%</span><span class="n">a</span> <span class="o">=</span> <span class="n">alloca</span> <span class="n">i32</span><span class="p">,</span> <span class="n">align</span> <span class="mi">4</span>
  <span class="o">%</span><span class="n">b</span> <span class="o">=</span> <span class="n">alloca</span> <span class="n">i32</span><span class="p">,</span> <span class="n">align</span> <span class="mi">4</span>
  <span class="o">%</span><span class="mi">1</span> <span class="o">=</span> <span class="n">load</span> <span class="n">i32</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">align</span> <span class="mi">4</span>
  <span class="o">%</span><span class="mi">2</span> <span class="o">=</span> <span class="n">load</span> <span class="n">i32</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">align</span> <span class="mi">4</span>

  <span class="o">%</span><span class="mi">3</span> <span class="o">=</span> <span class="n">add</span> <span class="n">nsw</span> <span class="n">i32</span> <span class="o">%</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="mi">2</span>
  <span class="o">%</span><span class="mi">4</span> <span class="o">=</span> <span class="n">sub</span> <span class="n">nsw</span> <span class="n">i32</span> <span class="o">%</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="mi">2</span>
  <span class="o">%</span><span class="mi">5</span> <span class="o">=</span> <span class="n">mul</span> <span class="n">nsw</span> <span class="n">i32</span> <span class="o">%</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="mi">2</span>
  <span class="o">%</span><span class="mi">6</span> <span class="o">=</span> <span class="n">shl</span> <span class="n">i32</span> <span class="o">%</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
  <span class="o">%</span><span class="mi">7</span> <span class="o">=</span> <span class="n">ashr</span> <span class="n">i32</span> <span class="o">%</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
  <span class="o">%</span><span class="mi">8</span> <span class="o">=</span> <span class="n">lshr</span> <span class="n">i32</span> <span class="o">%</span><span class="mi">1</span><span class="p">,</span> <span class="mi">30</span>
  <span class="o">%</span><span class="mi">9</span> <span class="o">=</span> <span class="n">shl</span> <span class="n">i32</span> <span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="mi">2</span>
  <span class="o">%</span><span class="mi">10</span> <span class="o">=</span> <span class="n">ashr</span> <span class="n">i32</span> <span class="mi">128</span><span class="p">,</span> <span class="o">%</span><span class="mi">2</span>
  <span class="o">%</span><span class="mi">11</span> <span class="o">=</span> <span class="n">ashr</span> <span class="n">i32</span> <span class="o">%</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="mi">2</span>

  <span class="o">%</span><span class="mi">12</span> <span class="o">=</span> <span class="n">add</span> <span class="n">nsw</span> <span class="n">i32</span> <span class="o">%</span><span class="mi">3</span><span class="p">,</span> <span class="o">%</span><span class="mi">4</span>
  <span class="o">%</span><span class="mi">13</span> <span class="o">=</span> <span class="n">add</span> <span class="n">nsw</span> <span class="n">i32</span> <span class="o">%</span><span class="mi">12</span><span class="p">,</span> <span class="o">%</span><span class="mi">5</span>
  <span class="o">%</span><span class="mi">14</span> <span class="o">=</span> <span class="n">add</span> <span class="n">nsw</span> <span class="n">i32</span> <span class="o">%</span><span class="mi">13</span><span class="p">,</span> <span class="o">%</span><span class="mi">6</span>
  <span class="o">%</span><span class="mi">15</span> <span class="o">=</span> <span class="n">add</span> <span class="n">nsw</span> <span class="n">i32</span> <span class="o">%</span><span class="mi">14</span><span class="p">,</span> <span class="o">%</span><span class="mi">7</span>
  <span class="o">%</span><span class="mi">16</span> <span class="o">=</span> <span class="n">add</span> <span class="n">nsw</span> <span class="n">i32</span> <span class="o">%</span><span class="mi">15</span><span class="p">,</span> <span class="o">%</span><span class="mi">8</span>
  <span class="o">%</span><span class="mi">17</span> <span class="o">=</span> <span class="n">add</span> <span class="n">nsw</span> <span class="n">i32</span> <span class="o">%</span><span class="mi">16</span><span class="p">,</span> <span class="o">%</span><span class="mi">9</span>
  <span class="o">%</span><span class="mi">18</span> <span class="o">=</span> <span class="n">add</span> <span class="n">nsw</span> <span class="n">i32</span> <span class="o">%</span><span class="mi">17</span><span class="p">,</span> <span class="o">%</span><span class="mi">10</span>
  <span class="o">%</span><span class="mi">19</span> <span class="o">=</span> <span class="n">add</span> <span class="n">nsw</span> <span class="n">i32</span> <span class="o">%</span><span class="mi">18</span><span class="p">,</span> <span class="o">%</span><span class="mi">11</span>

  <span class="n">ret</span> <span class="n">i32</span> <span class="o">%</span><span class="mi">19</span>
<span class="p">}</span>

</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-78-12:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llc -march=cpu0 -relocation-model=pic -filetype=asm ch4_math.ll -o -</span>
<span class="go">  ...</span>
<span class="go">        ld    $2, 0($sp)</span>
<span class="go">        ld    $3, 4($sp)</span>
<span class="go">        subu  $4, $3, $2</span>
<span class="go">        addu  $5, $3, $2</span>
<span class="go">        addu  $4, $5, $4</span>
<span class="go">        mul   $5, $3, $2</span>
<span class="go">        addu  $4, $4, $5</span>
<span class="go">        shl   $5, $3, 2</span>
<span class="go">        addu  $4, $4, $5</span>
<span class="go">        sra   $5, $3, 2</span>
<span class="go">        addu  $4, $4, $5</span>
<span class="go">        addiu $5, $zero, 128</span>
<span class="go">        shrv  $5, $5, $2</span>
<span class="go">        addiu $t9, $zero, 1</span>
<span class="go">        shlv  $t9, $t9, $2</span>
<span class="go">        srav  $2, $3, $2</span>
<span class="go">        shr   $3, $3, 30</span>
<span class="go">        addu  $3, $4, $3</span>
<span class="go">        addu  $3, $3, $t9</span>
<span class="go">        addu  $3, $3, $5</span>
<span class="go">        addu  $2, $3, $2</span>
<span class="go">        addiu $sp, $sp, 8</span>
<span class="go">        ret   $lr</span>
</pre></div>
</div>
<p>The example input <code class="docutils literal notranslate"><span class="pre">ch4_1_math.cpp</span></code> shown below is a C file that includes
the operators <strong>`+`</strong>, <strong>`-`</strong>, <strong>`*`</strong>, <strong>`&lt;&lt;`</strong>, and <strong>`&gt;&gt;`</strong>.</p>
<p>Compiling this file with Clang will generate the corresponding LLVM IR
instructions: <strong>add</strong>, <strong>sub</strong>, <strong>mul</strong>, <strong>shl</strong>, and <strong>ashr</strong>, as indicated
in Chapter 3.</p>
<p class="rubric">lbdex/input/ch4_1_math.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">test_math</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">a1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">j</span><span class="p">;</span>
  <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">f1</span><span class="p">,</span> <span class="n">g1</span><span class="p">,</span> <span class="n">h1</span><span class="p">,</span> <span class="n">i1</span><span class="p">;</span>

  <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>      <span class="o">//</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">7</span>
  <span class="n">d</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span>      <span class="o">//</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">3</span>
  <span class="n">e</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>      <span class="o">//</span> <span class="n">e</span> <span class="o">=</span> <span class="mi">10</span>
  <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>   <span class="o">//</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">20</span>
  <span class="n">f1</span> <span class="o">=</span> <span class="p">(</span><span class="n">a1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span> <span class="o">//</span> <span class="n">f1</span> <span class="o">=</span> <span class="mh">0xfffffff6</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10</span>
  <span class="n">g</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>   <span class="o">//</span> <span class="n">g</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">g1</span> <span class="o">=</span> <span class="p">(</span><span class="n">a1</span> <span class="o">&gt;&gt;</span> <span class="mi">30</span><span class="p">);</span> <span class="o">//</span> <span class="n">g1</span> <span class="o">=</span> <span class="mh">0x03</span> <span class="o">=</span> <span class="mi">3</span>
  <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">);</span>   <span class="o">//</span> <span class="n">h</span> <span class="o">=</span> <span class="mh">0x20</span> <span class="o">=</span> <span class="mi">32</span>
  <span class="n">h1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">);</span>  <span class="o">//</span> <span class="n">h1</span> <span class="o">=</span> <span class="mh">0x04</span>
  <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x80</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">);</span> <span class="o">//</span> <span class="n">i</span> <span class="o">=</span> <span class="mh">0x04</span>
  <span class="n">i1</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">);</span>  <span class="o">//</span> <span class="n">i1</span> <span class="o">=</span> <span class="mh">0x0</span>
  <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">24</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>  <span class="o">//</span> <span class="n">j</span> <span class="o">=</span> <span class="o">-</span><span class="mi">6</span>

  <span class="k">return</span> <span class="p">(</span><span class="n">c</span><span class="o">+</span><span class="n">d</span><span class="o">+</span><span class="n">e</span><span class="o">+</span><span class="n">f</span><span class="o">+</span><span class="nb">int</span><span class="p">(</span><span class="n">f1</span><span class="p">)</span><span class="o">+</span><span class="n">g</span><span class="o">+</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="n">g1</span><span class="o">+</span><span class="n">h</span><span class="o">+</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="n">h1</span><span class="o">+</span><span class="n">i</span><span class="o">+</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="n">i1</span><span class="o">+</span><span class="n">j</span><span class="p">);</span>
<span class="o">//</span> <span class="mi">7</span><span class="o">+</span><span class="mi">3</span><span class="o">+</span><span class="mi">10</span><span class="o">+</span><span class="mi">20</span><span class="o">-</span><span class="mi">10</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">3</span><span class="o">+</span><span class="mi">32</span><span class="o">+</span><span class="mi">4</span><span class="o">+</span><span class="mi">4</span><span class="o">+</span><span class="mi">0</span><span class="o">-</span><span class="mi">6</span> <span class="o">=</span> <span class="mi">68</span>
<span class="p">}</span>

</pre></div>
</div>
<p>Cpu0 instructions <code class="docutils literal notranslate"><span class="pre">add</span></code> and <code class="docutils literal notranslate"><span class="pre">sub</span></code> will trigger an overflow exception,
whereas <code class="docutils literal notranslate"><span class="pre">addu</span></code> and <code class="docutils literal notranslate"><span class="pre">subu</span></code> truncate overflow values directly.</p>
<p>Compiling <code class="docutils literal notranslate"><span class="pre">ch4_1_addsuboverflow.cpp</span></code> with the following command:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">llc -cpu0-enable-overflow=true</span>
</pre></div>
</div>
<p>will generate <code class="docutils literal notranslate"><span class="pre">add</span></code> and <code class="docutils literal notranslate"><span class="pre">sub</span></code> instructions as shown below:</p>
<p class="rubric">lbdex/input/ch4_1_addsuboverflow.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &quot;debug.h&quot;</span>

<span class="nb">int</span> <span class="n">test_add_overflow</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mh">0x70000000</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mh">0x20000000</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">test_sub_overflow</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mh">0x70000000</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mh">0x20000000</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-78-12:input Jonathan$ </span>clang -target mips-unknown-linux-gnu -c
<span class="go">ch4_1_addsuboverflow.cpp -emit-llvm -o ch4_1_addsuboverflow.bc</span>
<span class="gp">118-165-78-12:input Jonathan$ </span>llvm-dis ch4_1_addsuboverflow.bc -o -
<span class="go">...</span>
<span class="go">; Function Attrs: nounwind</span>
<span class="go">define i32 @_Z13test_overflowv() #0 {</span>
<span class="go">  ...</span>
<span class="gp">  %</span><span class="nv">3</span> <span class="o">=</span> add nsw i32 %1, %2
<span class="go">  ...</span>
<span class="gp">  %</span><span class="nv">6</span> <span class="o">=</span> sub nsw i32 %4, %5
<span class="go">  ...</span>
<span class="go">}</span>

<span class="gp">118-165-78-12:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llc -march=cpu0 -relocation-model=pic -filetype=asm</span>
<span class="go">-cpu0-enable-overflow=true ch4_1_addsuboverflow.bc -o -</span>
<span class="go">      ...</span>
<span class="go">      add     $3, $4, $3</span>
<span class="go">      ...</span>
<span class="go">      sub     $3, $4, $3</span>
<span class="go">      ...</span>
</pre></div>
</div>
<p>In modern CPUs, programmers typically use truncate overflow instructions
for C operators <code class="docutils literal notranslate"><span class="pre">+</span></code> and <code class="docutils literal notranslate"><span class="pre">-</span></code>.</p>
<p>However, by using the <code class="docutils literal notranslate"><span class="pre">-cpu0-enable-overflow=true</span></code> option, programmers
can compile programs with overflow exception handling. This option is
mainly used for debugging purposes. Compiling with this option can help
identify bugs early and fix them efficiently.</p>
</section>
<section id="display-llvm-ir-nodes-with-graphviz">
<h3><a class="toc-backref" href="#id23" role="doc-backlink">Display LLVM IR Nodes with Graphviz</a><a class="headerlink" href="#display-llvm-ir-nodes-with-graphviz" title="Permalink to this heading">¶</a></h3>
<p>The previous section displayed the DAG translation process in text format
on the terminal using the <code class="docutils literal notranslate"><span class="pre">llc</span> <span class="pre">-debug</span></code> option.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">llc</span></code> tool also supports graphical visualization. The
<a class="reference external" href="http://jonathan2251.github.io/lbd/install.html#install-other-tools-on-imac">section Install other tools on iMac</a> explains how to download and
install Graphviz, a tool for rendering DAGs.</p>
<p>This section introduces how to use <code class="docutils literal notranslate"><span class="pre">llc</span></code> with Graphviz for graphical
display. Viewing DAGs graphically is often easier to interpret than
reading raw text in the terminal. While not mandatory, this visualization
can be very helpful, especially when debugging complex DAG transformations.</p>
<p>The following <code class="docutils literal notranslate"><span class="pre">llc</span></code> options allow graphical visualization of DAGs,
as mentioned in the “SelectionDAG Instruction Selection Process” section
of the LLVM Target-Independent Code Generator documentation <a class="footnote-reference brackets" href="#instructionsel" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a>:</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">llc</span></code> Graphviz DAG display options</p>
<p>-view-dag-combine1-dags displays the DAG after being built, before the
first optimization pass.</p>
<p>-view-legalize-dags displays the DAG before Legalization.</p>
<p>-view-dag-combine2-dags displays the DAG before the second optimization
pass.</p>
<p>-view-isel-dags displays the DAG before the Select phase.</p>
<p>-view-sched-dags displays the DAG before Scheduling.</p>
</div>
<p>By tracking <code class="docutils literal notranslate"><span class="pre">llc</span> <span class="pre">-debug</span></code>, you can see the steps of DAG translation as follows,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Initial selection DAG</span>
<span class="go">Optimized lowered selection DAG</span>
<span class="go">Type-legalized selection DAG</span>
<span class="go">Optimized type-legalized selection DAG</span>
<span class="go">Legalized selection DAG</span>
<span class="go">Optimized legalized selection DAG</span>
<span class="go">Instruction selection</span>
<span class="go">Selected selection DAG</span>
<span class="go">Scheduling</span>
<span class="go">...</span>
</pre></div>
</div>
<p>Let’s run <code class="docutils literal notranslate"><span class="pre">llc</span></code> with option -view-dag-combine1-dags, and open the output
result with Graphviz as follows,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-12-177:input Jonathan$ </span>/Users/Jonathan/llvm/test/
<span class="go">build/bin/llc -view-dag-combine1-dags -march=cpu0</span>
<span class="go">-relocation-model=pic -filetype=asm ch4_1_mult.bc -o ch4_1_mult.cpu0.s</span>
<span class="go">Writing &#39;/tmp/llvm_84ibpm/dag.main.dot&#39;...  done.</span>
<span class="gp">118-165-12-177:input Jonathan$ </span>Graphviz /tmp/llvm_84ibpm/dag.main.dot
</pre></div>
</div>
<p>It will show the /tmp/llvm_84ibpm/dag.main.dot as <a class="reference internal" href="#otherinst-f1"><span class="std std-numref">Fig. 27</span></a>.</p>
<figure class="align-center" id="id12">
<span id="otherinst-f1"></span><a class="reference internal image-reference" href="_images/15.png"><img alt="_images/15.png" src="_images/15.png" style="width: 687.0px; height: 851.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 27 </span><span class="caption-text">llc option -view-dag-combine1-dags graphic view</span><a class="headerlink" href="#id12" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p><a class="reference internal" href="#otherinst-f1"><span class="std std-numref">Fig. 27</span></a> is the stage of “Initial selection DAG”.
List the other view options and their corresponding stages of DAG translation as
follows,</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">llc</span></code> Graphviz options and the corresponding stages of DAG translation</p>
<p>-view-dag-combine1-dags: Initial selection DAG</p>
<p>-view-legalize-dags: Optimized type-legalized selection DAG</p>
<p>-view-dag-combine2-dags: Legalized selection DAG</p>
<p>-view-isel-dags: Optimized legalized selection DAG</p>
<p>-view-sched-dags: Selected selection DAG</p>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">-view-isel-dags</span></code> option is particularly important and frequently
used by LLVM backend developers. It displays the DAGs before instruction
selection, providing crucial insight into how LLVM represents operations
before they are mapped to target-specific instructions.</p>
<p>To write pattern-matching rules in the target description file (<code class="docutils literal notranslate"><span class="pre">.td</span></code>),
backend developers need to understand the DAG nodes corresponding to
specific C operators. This visualization helps in accurately defining
these patterns.</p>
</section>
<section id="operator-and">
<h3><a class="toc-backref" href="#id24" role="doc-backlink">Operator <code class="docutils literal notranslate"><span class="pre">%</span></code> and <code class="docutils literal notranslate"><span class="pre">/</span></code></a><a class="headerlink" href="#operator-and" title="Permalink to this heading">¶</a></h3>
<section id="dag-representation-of">
<h4><a class="toc-backref" href="#id25" role="doc-backlink">DAG Representation of <code class="docutils literal notranslate"><span class="pre">%</span></code></a><a class="headerlink" href="#dag-representation-of" title="Permalink to this heading">¶</a></h4>
<p>The following example, <code class="docutils literal notranslate"><span class="pre">ch4_1_mult.cpp</span></code>, contains the C operator <code class="docutils literal notranslate"><span class="pre">%</span></code>
(modulus). The corresponding LLVM IR is shown below:</p>
<p class="rubric">lbdex/input/ch4_1_mult.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">test_mult</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
<span class="o">//</span>  <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
  
  <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">12</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">...</span>
<span class="go">define i32 @_Z8test_multv() #0 {</span>
<span class="gp">  %</span><span class="nv">b</span> <span class="o">=</span> alloca i32, align <span class="m">4</span>
<span class="go">  store i32 11, i32* %b, align 4</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> load i32* %b, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">2</span> <span class="o">=</span> add nsw i32 %1, <span class="m">1</span>
<span class="gp">  %</span><span class="nv">3</span> <span class="o">=</span> srem i32 %2, <span class="m">12</span>
<span class="go">  store i32 %3, i32* %b, align 4</span>
<span class="gp">  %</span><span class="nv">4</span> <span class="o">=</span> load i32* %b, align <span class="m">4</span>
<span class="go">  ret i32 %4</span>
<span class="go">}</span>
</pre></div>
</div>
<p>LLVM <strong>srem</strong> corresponds to the C operator <strong>“%”</strong>. Reference: <a class="footnote-reference brackets" href="#srem" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a>.
The following note provides details on its syntax and behavior:</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>‘srem’</strong> Instruction</p>
<p><strong>Syntax:</strong>
<strong>&lt;result&gt; = srem &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;   ; yields {ty}:result</strong></p>
<p><strong>Overview:</strong>
The <strong>‘srem’</strong> instruction returns the remainder from the signed division
of its two operands. This instruction also supports vector types, where
the elements must be integers.</p>
<p><strong>Arguments:</strong>
The two arguments of the <strong>‘srem’</strong> instruction must be integers or vectors
of integer values. Both operands must have identical types.</p>
<p><strong>Semantics:</strong>
This instruction returns the remainder of a signed division, meaning the
result is either zero or has the same sign as the dividend (<strong>op1</strong>).
It is not the modulo operator, where the result would have the same sign
as the divisor (<strong>op2</strong>). For more details, see references such as
The Math Forum or Wikipedia’s article on the modulo operation.</p>
<p>Note that signed integer remainder (<strong>srem</strong>) and unsigned integer
remainder (<strong>urem</strong>) are distinct operations. For unsigned remainder,
use <strong>‘urem’</strong> instead.</p>
<p>Taking the remainder of a division by zero results in undefined behavior.
Overflow also causes undefined behavior, though it is a rare case. One such
scenario is taking the remainder of a 32-bit division of <strong>-2147483648</strong> by
<strong>-1</strong>, which cannot be directly represented. This rule allows <strong>srem</strong>
to be implemented using division instructions that return both the quotient
and the remainder.</p>
<p><strong>Example:</strong>
<code class="docutils literal notranslate"><span class="pre">&lt;result&gt;</span> <span class="pre">=</span> <span class="pre">srem</span> <span class="pre">i32</span> <span class="pre">4,</span> <span class="pre">%var</span></code>  ; yields <code class="docutils literal notranslate"><span class="pre">{i32}:</span> <span class="pre">result</span> <span class="pre">=</span> <span class="pre">4</span> <span class="pre">%</span> <span class="pre">%var</span></code></p>
</div>
<p>To observe LLVM’s DAG representation of <strong>srem</strong>, run <code class="docutils literal notranslate"><span class="pre">llc</span> <span class="pre">–view-isel-dags</span></code>
on the input file <code class="docutils literal notranslate"><span class="pre">ch4_1_mult.bc</span></code> in <code class="docutils literal notranslate"><span class="pre">Chapter3_5/</span></code>.
LLVM will display an error message along with the DAG output,
as illustrated in <a class="reference internal" href="#otherinst-f2"><span class="std std-numref">Fig. 28</span></a> below.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-79-37:input Jonathan$ </span>/Users/Jonathan/llvm/test/
<span class="go">build/bin/llc -march=cpu0 -view-isel-dags -relocation-model=</span>
<span class="go">pic -filetype=asm ch4_1_mult.bc -o -</span>
<span class="go">...</span>
<span class="go">LLVM ERROR: Cannot select: 0x7fa73a02ea10: i32 = mulhs 0x7fa73a02c610,</span>
<span class="go">0x7fa73a02e910 [ID=12]</span>
<span class="go">0x7fa73a02c610: i32 = Constant&lt;12&gt; [ORD=5] [ID=7]</span>
<span class="go">0x7fa73a02e910: i32 = Constant&lt;715827883&gt; [ID=9]</span>
</pre></div>
</div>
<figure class="align-center" id="id13">
<span id="otherinst-f2"></span><a class="reference internal image-reference" href="_images/23.png"><img alt="_images/23.png" src="_images/23.png" style="width: 580.0px; height: 629.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 28 </span><span class="caption-text">ch4_1_mult.bc DAG</span><a class="headerlink" href="#id13" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>LLVM optimizes the <strong>srem</strong> operation by replacing division with multiplication
in DAG optimization. This is because the <strong>DIV</strong> operation is more expensive
in terms of execution time compared to <strong>MUL</strong>.</p>
<p>For example, the following C code:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">11</span><span class="p">;</span><span class="w"></span>
<span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">12</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>is translated into DAGs, as shown in <a class="reference internal" href="#otherinst-f2"><span class="std std-numref">Fig. 28</span></a>.
The DAG representation is verified and explained by calculating the values
at each node.</p>
<p>The computation follows these steps:</p>
<ul class="simple">
<li><p><strong>0xC * 0x2AAAAAAB = 0x2,00000004</strong></p></li>
<li><p><strong>mulhs(0xC, 0x2AAAAAAAB)</strong> retrieves the signed multiplication’s high
word (upper 32 bits).</p></li>
<li><p>A multiplication of two 32-bit operands typically produces a 64-bit result
(e.g., <strong>0x2, 0xAAAAAAAB</strong>).</p></li>
<li><p>In this case, the high word of the result is <strong>0x2</strong>.</p></li>
<li><p>The final computation <strong>sub(12, 12)</strong> results in <strong>0</strong>,
which correctly matches <strong>(11 + 1) % 12</strong>.</p></li>
</ul>
</section>
<section id="arm-solution">
<h4><a class="toc-backref" href="#id26" role="doc-backlink">ARM Solution</a><a class="headerlink" href="#arm-solution" title="Permalink to this heading">¶</a></h4>
<p>To run this with an ARM-based solution, modify the following files in
<code class="docutils literal notranslate"><span class="pre">Chapter4_1/</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Cpu0InstrInfo.td</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Cpu0ISelDAGToDAG.cpp</span></code></p></li>
</ul>
<p>Make the necessary changes as follows:</p>
<p class="rubric">lbdex/chapters/Chapter4_1/Cpu0InstrInfo.td</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// Multiply and Divide Instructions.</span>
<span class="n">def</span><span class="w"> </span><span class="n">SMMUL</span><span class="w">   </span><span class="o">:</span><span class="w"> </span><span class="n">ArithLogicR</span><span class="o">&lt;</span><span class="mh">0x41</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;smmul&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">mulhs</span><span class="p">,</span><span class="w"> </span><span class="n">IIImul</span><span class="p">,</span><span class="w"> </span><span class="n">CPURegs</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="n">def</span><span class="w"> </span><span class="n">UMMUL</span><span class="w">   </span><span class="o">:</span><span class="w"> </span><span class="n">ArithLogicR</span><span class="o">&lt;</span><span class="mh">0x42</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ummul&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">mulhu</span><span class="p">,</span><span class="w"> </span><span class="n">IIImul</span><span class="p">,</span><span class="w"> </span><span class="n">CPURegs</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="c1">//def MULT    : Mult32&lt;0x41, &quot;mult&quot;, IIImul&gt;;</span>
<span class="c1">//def MULTu   : Mult32&lt;0x42, &quot;multu&quot;, IIImul&gt;;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter4_1/Cpu0ISelDAGToDAG.cpp</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#if 0</span><span class="c"></span>
<span class="c">/// Select multiply instructions.</span>
<span class="c">std::pair&lt;SDNode*, SDNode*&gt;</span>
<span class="c">Cpu0DAGToDAGISel::SelectMULT(SDNode *N, unsigned Opc, SDLoc DL, EVT Ty,</span>
<span class="c">                             bool HasLo, bool HasHi) {</span>
<span class="c">  SDNode *Lo = 0, *Hi = 0;</span>
<span class="c">  SDNode *Mul = CurDAG-&gt;getMachineNode(Opc, DL, MVT::Glue, N-&gt;getOperand(0),</span>
<span class="c">                                       N-&gt;getOperand(1));</span>
<span class="c">  SDValue InFlag = SDValue(Mul, 0);</span>

<span class="c">  if (HasLo) {</span>
<span class="c">    Lo = CurDAG-&gt;getMachineNode(Cpu0::MFLO, DL,</span>
<span class="c">                                Ty, MVT::Glue, InFlag);</span>
<span class="c">    InFlag = SDValue(Lo, 1);</span>
<span class="c">  }</span>
<span class="c">  if (HasHi)</span>
<span class="c">    Hi = CurDAG-&gt;getMachineNode(Cpu0::MFHI, DL,</span>
<span class="c">                                Ty, InFlag);</span>

<span class="c">  return std::make_pair(Lo, Hi);</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="c1">/// Select instructions not customized! Used for</span>
<span class="c1">/// expanded, promoted and normal instructions</span>
<span class="n">SDNode</span><span class="o">*</span><span class="w"> </span><span class="nf">Cpu0DAGToDAGISel::Select</span><span class="p">(</span><span class="n">SDNode</span><span class="w"> </span><span class="o">*</span><span class="n">Node</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="k">switch</span><span class="p">(</span><span class="n">Opcode</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">default</span><span class="o">:</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">  case ISD::MULHS:</span>
<span class="c">  case ISD::MULHU: {</span>
<span class="c">    MultOpc = (Opcode == ISD::MULHU ? Cpu0::MULTu : Cpu0::MULT);</span>
<span class="c">    return SelectMULT(Node, MultOpc, DL, NodeTy, false, true).second;</span>
<span class="c">  }</span>
<span class="cp">#endif</span>
<span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Let’s apply the above changes and run them with <code class="docutils literal notranslate"><span class="pre">ch4_1_mult.cpp</span></code> using
the <code class="docutils literal notranslate"><span class="pre">llc</span> <span class="pre">-view-sched-dags</span></code> option to generate <a class="reference internal" href="#otherinst-f3"><span class="std std-numref">Fig. 29</span></a>.</p>
<p>The <strong>SMMUL</strong> instruction is used to extract the high word of the
multiplication result.</p>
<figure class="align-center" id="id14">
<span id="otherinst-f3"></span><a class="reference internal image-reference" href="_images/31.png"><img alt="_images/31.png" src="_images/31.png" style="width: 684.0px; height: 743.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 29 </span><span class="caption-text">DAG for ch4_1_mult.bc with ARM style SMMUL</span><a class="headerlink" href="#id14" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>The following is the result of running the above changes with <code class="docutils literal notranslate"><span class="pre">ch4_1_mult.bc</span></code>.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-66-82:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/bin/llc
<span class="go">-march=cpu0 -relocation-model=pic -filetype=asm</span>
<span class="go">ch4_1_mult.bc -o -</span>
<span class="go">  ...</span>
<span class="gp"># </span>BB#0:                                 <span class="c1"># %entry</span>
<span class="go">  addiu $sp, $sp, -8</span>
<span class="gp">$</span>tmp1:
<span class="go">  .cfi_def_cfa_offset 8</span>
<span class="go">  addiu $2, $zero, 0</span>
<span class="go">  st  $2, 4($fp)</span>
<span class="go">  addiu $2, $zero, 11</span>
<span class="go">  st  $2, 0($fp)</span>
<span class="go">  lui $2, 10922</span>
<span class="go">  ori $3, $2, 43691</span>
<span class="go">  addiu $2, $zero, 12</span>
<span class="go">  smmul $3, $2, $3</span>
<span class="go">  shr $4, $3, 31</span>
<span class="go">  sra $3, $3, 1</span>
<span class="go">  addu  $3, $3, $4</span>
<span class="go">  mul $3, $3, $2</span>
<span class="go">  subu  $2, $2, $3</span>
<span class="go">  st  $2, 0($fp)</span>
<span class="go">  addiu $sp, $sp, 8</span>
<span class="go">  ret $lr</span>
</pre></div>
</div>
</section>
<section id="mips-solution">
<h4><a class="toc-backref" href="#id27" role="doc-backlink">MIPS Solution</a><a class="headerlink" href="#mips-solution" title="Permalink to this heading">¶</a></h4>
<p>MIPS uses the <strong>MULT</strong> instruction to perform multiplication, storing the high
and low parts of the result in the <strong>HI</strong> and <strong>LO</strong> registers, respectively.
After that, the <strong>mfhi</strong> and <strong>mflo</strong> instructions move the values from the
HI/LO registers to general-purpose registers.</p>
<p>ARM’s <strong>SMMUL</strong> instruction is optimized for cases where only the high part
of the result is needed, as it ignores the low part. ARM also provides <strong>SMULL</strong>
(signed multiply long) to obtain the full 64-bit result.</p>
<p>If only the low part of the result is needed, the <strong>Cpu0 MUL</strong> instruction can
be used. The implementation in <code class="docutils literal notranslate"><span class="pre">Chapter4_1/</span></code> follows the MIPS <strong>MULT</strong> style
to minimize the number of added instructions. This approach makes <strong>Cpu0</strong>
suitable as both a tutorial architecture for educational purposes and a
learning resource for compiler design.</p>
<p>The following instructions are added in <code class="docutils literal notranslate"><span class="pre">Chapter4_1/</span></code> for the MIPS-style
implementation:</p>
<ul class="simple">
<li><p><strong>MULT, MULTu, MFHI, MFLO, MTHI, MTLO</strong> in <code class="docutils literal notranslate"><span class="pre">Chapter4_1/Cpu0InstrInfo.td</span></code></p></li>
<li><p><strong>HI, LO registers</strong> in <code class="docutils literal notranslate"><span class="pre">Chapter4_1/Cpu0RegisterInfo.td</span></code> and
<code class="docutils literal notranslate"><span class="pre">Chapter4_1/MCTargetDesc/Cpu0BaseInfo.h</span></code></p></li>
<li><p><strong>IIHiLo, IIImul</strong> in <code class="docutils literal notranslate"><span class="pre">Chapter4_1/Cpu0Schedule.td</span></code></p></li>
<li><p><strong>SelectMULT()</strong> in <code class="docutils literal notranslate"><span class="pre">Chapter4_1/Cpu0ISelDAGToDAG.cpp</span></code></p></li>
</ul>
<p>Except for custom types, LLVM IR operations of type <strong>expand</strong> and <strong>promote</strong>
will call <strong>Cpu0DAGToDAGISel::Select()</strong> during instruction selection in the
DAG translation process.</p>
<p>The function <strong>selectMULT()</strong>, which is called by <strong>select()</strong>, returns the <strong>HI</strong>
part of the multiplication result to the <strong>HI</strong> register for IR operations
<strong>mulhs</strong> or <strong>mulhu</strong>. After that, the <strong>MFHI</strong> instruction moves the <strong>HI</strong>
register to the Cpu0 <strong>“a”</strong> register, <strong>$ra</strong>.</p>
<p>Since the <strong>MFHI</strong> instruction follows the <strong>FL</strong> format and only utilizes the
Cpu0 <strong>“a”</strong> register, we set <strong>$rb</strong> and <strong>imm16</strong> to 0.</p>
<p><a class="reference internal" href="#otherinst-f4"><span class="std std-numref">Fig. 30</span></a> and <code class="docutils literal notranslate"><span class="pre">ch4_1_mult.cpu0.s</span></code> show the compilation results
of <code class="docutils literal notranslate"><span class="pre">ch4_1_mult.bc</span></code>.</p>
<figure class="align-center" id="id15">
<span id="otherinst-f4"></span><a class="reference internal image-reference" href="_images/41.png"><img alt="_images/41.png" src="_images/41.png" style="width: 498.6px; height: 753.3000000000001px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 30 </span><span class="caption-text">DAG for ch4_1_mult.bc with Mips style MULT</span><a class="headerlink" href="#id15" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-66-82:input Jonathan$ </span>cat ch4_1_mult.cpu0.s
<span class="go">  ...</span>
<span class="gp"># </span>BB#0:
<span class="go">  addiu $sp, $sp, -8</span>
<span class="go">  addiu $2, $zero, 11</span>
<span class="go">  st  $2, 4($sp)</span>
<span class="go">  lui $2, 10922</span>
<span class="go">  ori $3, $2, 43691</span>
<span class="go">  addiu $2, $zero, 12</span>
<span class="go">  mult  $2, $3</span>
<span class="go">  mfhi  $3</span>
<span class="go">  shr $4, $3, 31</span>
<span class="go">  sra $3, $3, 1</span>
<span class="go">  addu  $3, $3, $4</span>
<span class="go">  mul $3, $3, $2</span>
<span class="go">  subu  $2, $2, $3</span>
<span class="go">  st  $2, 4($sp)</span>
<span class="go">  addiu $sp, $sp, 8</span>
<span class="go">  ret $lr</span>
</pre></div>
</div>
</section>
<section id="full-support-for-and">
<h4><a class="toc-backref" href="#id28" role="doc-backlink">Full Support for <cite>%</cite> and <cite>/</cite></a><a class="headerlink" href="#full-support-for-and" title="Permalink to this heading">¶</a></h4>
<p>Attentive readers may notice that LLVM replaces <strong>division (`/`)</strong> with
<strong>multiplication (`*`)</strong> when computing the <strong>remainder (`%`)</strong> in our
example. This optimization occurs because the divisor in our example,
<strong>“(b+1) % 12”</strong>, is a constant.</p>
<p>However, what happens if the divisor is a variable, such as in
<strong>“(b+1) % a”</strong>?
In this case, our current implementation would fail to handle it correctly.</p>
<p>Cpu0, like MIPS, uses the <strong>LO</strong> and <strong>HI</strong> registers to store the
<strong>quotient</strong> and <strong>remainder</strong>, respectively. The instructions <strong>“mflo”</strong>
and <strong>“mfhi”</strong> retrieve the results from the <strong>LO</strong> and <strong>HI</strong> registers.</p>
<p>Using this approach:
- The operation <strong>`c = a / b`</strong> is implemented as:</p>
<blockquote>
<div><div class="highlight-asm notranslate"><div class="highlight"><pre><span></span><span class="nf">div</span><span class="w"> </span><span class="no">a</span><span class="p">,</span><span class="w"> </span><span class="no">b</span><span class="w"></span>
<span class="nf">mflo</span><span class="w"> </span><span class="no">c</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
<ul>
<li><p>The operation <strong>`c = a % b`</strong> is implemented as:</p>
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span><span class="nf">div</span><span class="w"> </span><span class="no">a</span><span class="p">,</span><span class="w"> </span><span class="no">b</span><span class="w"></span>
<span class="nf">mfhi</span><span class="w"> </span><span class="no">c</span><span class="w"></span>
</pre></div>
</div>
</li>
</ul>
<p>To support the operators <strong>`%`</strong> and <strong>`/`</strong>, the following changes were
added in <strong>Chapter4_1/</strong>:</p>
<ol class="arabic simple">
<li><p><strong>SDIV</strong>, <strong>UDIV</strong>, and their reference classes, as well as DAG nodes in
<cite>Cpu0InstrInfo.td</cite>.</p></li>
<li><p><strong>copyPhysReg()</strong>, declared in <cite>Cpu0InstrInfo.h</cite> and implemented in
<cite>Cpu0InstrInfo.cpp</cite>.</p></li>
<li><p><strong>setOperationAction(ISD::SDIV, MVT::i32, Expand)</strong>,
<strong>setTargetDAGCombine(ISD::SDIVREM)</strong> in the constructor of
<cite>Cpu0ISelLowering.cpp</cite>, along with
<cite>PerformDivRemCombine()</cite> and <cite>PerformDAGCombine()</cite> in
<cite>Cpu0ISelLowering.cpp</cite>.</p></li>
</ol>
<p>The LLVM IR instruction <strong>sdiv</strong> represents <strong>signed division</strong>, while
<strong>udiv</strong> represents <strong>unsigned division</strong>.</p>
<p class="rubric">lbdex/input/ch4_1_mult2.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">test_mult</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>

  <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">a</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When running <cite>ch4_1_mult2.cpp</cite>, the <strong>`div`</strong> instruction is not generated
for the <strong>`%`</strong> operator. Instead, LLVM still replaces it with
<strong>multiplication (`*`)</strong>.</p>
<p>This happens because LLVM applies <strong>Constant Propagation Optimization</strong>,
which optimizes expressions involving constants at compile time.</p>
<p>To force LLVM to generate a <strong>`div`</strong> instruction for <strong>`%`</strong>,
we can use <cite>ch4_1_mod.cpp</cite>, which prevents LLVM from applying
<strong>Constant Propagation Optimization</strong>.</p>
<p class="rubric">lbdex/input/ch4_1_mod.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">test_mod</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
  <span class="n">volatile</span> <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
  
  <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">a</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-77-79:input Jonathan$ </span>clang -target mips-unknown-linux-gnu -c
<span class="go">ch4_1_mod.cpp -emit-llvm -o ch4_1_mod.bc</span>
<span class="gp">118-165-77-79:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/bin/llc
<span class="go">-march=cpu0 -relocation-model=pic -filetype=asm</span>
<span class="go">ch4_1_mod.bc -o -</span>
<span class="go">...</span>
<span class="go">div $zero, $3, $2</span>
<span class="go">mflo  $2</span>
<span class="go">...</span>
</pre></div>
</div>
<p>To explains how to work with <strong>“div”</strong>, let’s run ch4_1_mod.cpp with debug option
as follows,</p>
<p>To understand how LLVM generates the <strong>`div`</strong> instruction,
let’s run <cite>ch4_1_mod.cpp</cite> with the debug option as follows:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-83-58:input Jonathan$ </span>clang -target mips-unknown-linux-gnu -c
<span class="go">ch4_1_mod.cpp -I/Applications/Xcode.app/Contents/Developer/Platforms/</span>
<span class="go">MacOSX.platform/Developer/SDKs/MacOSX10.8.sdk/usr/include/ -emit-llvm -o</span>
<span class="go">ch4_1_mod.bc</span>
<span class="gp">118-165-83-58:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llc -march=cpu0 -relocation-model=pic -filetype=asm -debug</span>
<span class="go">ch4_1_mod.bc -o -</span>
<span class="go">...</span>
<span class="go">=== _Z8test_modi</span>
<span class="go">Initial selection DAG: BB#0 &#39;_Z8test_mod2i:&#39;</span>
<span class="go">SelectionDAG has 21 nodes:</span>
<span class="go">  ...</span>
<span class="go">    0x2447448: &lt;multiple use&gt;</span>
<span class="go">        0x24470d0: &lt;multiple use&gt;</span>
<span class="go">        0x24471f8: i32 = Constant&lt;1&gt;</span>

<span class="go">      0x2447320: i32 = add 0x24470d0, 0x24471f8 [ORD=7]</span>

<span class="go">      0x2447448: &lt;multiple use&gt;</span>
<span class="go">    0x2447570: i32 = srem 0x2447320, 0x2447448 [ORD=9]</span>

<span class="go">    0x24468b8: &lt;multiple use&gt;</span>
<span class="go">    0x2446b08: &lt;multiple use&gt;</span>
<span class="go">  0x2448fc0: ch = store 0x2447448:1, 0x2447570, 0x24468b8, ...</span>

<span class="go">  0x2449210: i32 = Register %V0</span>

<span class="go">    0x2448fc0: &lt;multiple use&gt;</span>
<span class="go">    0x2449210: &lt;multiple use&gt;</span>
<span class="go">      0x2448fc0: &lt;multiple use&gt;</span>
<span class="go">      0x24468b8: &lt;multiple use&gt;</span>
<span class="go">      0x2446b08: &lt;multiple use&gt;</span>
<span class="go">    0x24490e8: i32,ch = load 0x2448fc0, 0x24468b8, 0x2446b08&lt;LD4[%b]&gt; [ORD=11]</span>

<span class="go">  0x2449338: ch,glue = CopyToReg 0x2448fc0, 0x2449210, 0x24490e8 [ORD=12]</span>

<span class="go">    0x2449338: &lt;multiple use&gt;</span>
<span class="go">    0x2449210: &lt;multiple use&gt;</span>
<span class="go">    0x2449338: &lt;multiple use&gt;</span>
<span class="go">  0x2449460: ch = Cpu0ISD::Ret 0x2449338, 0x2449210, 0x2449338:1 [ORD=12]</span>

<span class="go">Replacing.1 0x24490e8: i32,ch = load 0x2448fc0, 0x24468b8, ...</span>

<span class="go">With: 0x2447570: i32 = srem 0x2447320, 0x2447448 [ORD=9]</span>
<span class="go"> and 1 other values</span>
<span class="go">...</span>

<span class="go">Optimized lowered selection DAG: BB#0 &#39;_Z8test_mod2i:&#39;</span>
<span class="go">...</span>
<span class="go">  0x2447570: i32 = srem 0x2447320, 0x2447448 [ORD=9]</span>
<span class="go">...</span>

<span class="go">Type-legalized selection DAG: BB#0 &#39;_Z8test_mod2i:&#39;</span>
<span class="go">SelectionDAG has 16 nodes:</span>
<span class="go">  ...</span>
<span class="go">  0x7fed6882d610: i32,ch = load 0x7fed6882d210, 0x7fed6882cd10,</span>
<span class="go">  0x7fed6882cb10&lt;LD4[%1]&gt; [ORD=5] [ID=-3]</span>

<span class="go">    0x7fed6882d810: i32 = Constant&lt;12&gt; [ID=-3]</span>

<span class="go">    0x7fed6882d610: &lt;multiple use&gt;</span>
<span class="go">  0x7fed6882d710: i32 = srem 0x7fed6882d810, 0x7fed6882d610 [ORD=6] [ID=-3]</span>
<span class="go">  ...</span>

<span class="go">Legalized selection DAG: BB#0 &#39;_Z8test_mod2i:&#39;</span>
<span class="go">  ...</span>
<span class="go">    ... i32 = srem 0x2447320, 0x2447448 [ORD=9] [ID=-3]</span>
<span class="go">  ...</span>
<span class="go"> ... replacing: ...: i32 = srem 0x2447320, 0x2447448 [ORD=9] [ID=13]</span>
<span class="go">     with:      ...: i32,i32 = sdivrem 0x2447320, 0x2447448 [ORD=9]</span>

<span class="go">Optimized legalized selection DAG: BB#0 &#39;_Z8test_mod2i:&#39;</span>
<span class="go">SelectionDAG has 18 nodes:</span>
<span class="go">  ...</span>
<span class="go">    0x2449588: i32 = Register %HI</span>

<span class="go">        0x24470d0: &lt;multiple use&gt;</span>
<span class="go">        0x24471f8: i32 = Constant&lt;1&gt; [ID=6]</span>

<span class="go">      0x2447320: i32 = add 0x24470d0, 0x24471f8 [ORD=7] [ID=12]</span>

<span class="go">      0x2447448: &lt;multiple use&gt;</span>
<span class="go">    0x24490e8: glue = Cpu0ISD::DivRem 0x2447320, 0x2447448 [ORD=9]</span>

<span class="go">  0x24496b0: i32,ch,glue = CopyFromReg 0x240d480, 0x2449588, 0x24490e8 [ORD=9]</span>

<span class="go">    0x2449338: &lt;multiple use&gt;</span>
<span class="go">    0x2449210: &lt;multiple use&gt;</span>
<span class="go">    0x2449338: &lt;multiple use&gt;</span>
<span class="go">  0x2449460: ch = Cpu0ISD::Ret 0x2449338, 0x2449210, ...</span>
<span class="go">  ...</span>

<span class="go">===== Instruction selection begins: BB#0 &#39;&#39;</span>
<span class="go">...</span>
<span class="go">Selecting: 0x24490e8: glue = Cpu0ISD::DivRem 0x2447320, 0x2447448 [ORD=9] [ID=14]</span>

<span class="go">ISEL: Starting pattern match on root node: 0x24490e8: glue = Cpu0ISD::DivRem</span>
<span class="go">0x2447320, 0x2447448 [ORD=9] [ID=14]</span>

<span class="go">  Initial Opcode index to 4044</span>
<span class="go">  Morphed node: 0x24490e8: i32,glue = SDIV 0x2447320, 0x2447448 [ORD=9]</span>

<span class="go">ISEL: Match complete!</span>
<span class="go">=&gt; 0x24490e8: i32,glue = SDIV 0x2447320, 0x2447448 [ORD=9]</span>
<span class="go">...</span>
</pre></div>
</div>
<p>Summary of DAG Translation Steps:</p>
<p>The translation of DAGs for the <strong>`%`</strong> operator follows these four steps:</p>
<ol class="arabic simple">
<li><p><strong>Reduce DAG Nodes</strong></p>
<ul class="simple">
<li><p>This occurs in the <strong>“Optimized Lowered Selection DAG”</strong> stage.</p></li>
<li><p>Redundant store and load nodes in SSA form are removed.</p></li>
</ul>
</li>
<li><p><strong>Convert `srem` to `sdivrem`</strong></p>
<ul class="simple">
<li><p>This transformation happens in the <strong>“Legalized Selection DAG”</strong> stage.</p></li>
</ul>
</li>
<li><p><strong>Convert `sdivrem` to `Cpu0ISD::DivRem`</strong></p>
<ul class="simple">
<li><p>This occurs in the <strong>“Optimized Legalized Selection DAG”</strong> stage.</p></li>
</ul>
</li>
<li><p><strong>Add Register Mapping for HI Register</strong></p>
<ul class="simple">
<li><p>In the <strong>“Optimized Legalized Selection DAG”</strong> stage, the following DAG nodes are added:
- <cite>“i32 = Register %HI”</cite>
- <cite>“CopyFromReg …”</cite></p></li>
</ul>
</li>
</ol>
<p>For a detailed breakdown, refer to:</p>
<ul class="simple">
<li><p><strong>Table: Stages for C Operator `%`</strong></p></li>
<li><p><strong>Table: Functions Handling DAG Translation and Pattern Matching for C Operator `%`</strong></p></li>
</ul>
<table class="docutils align-default" id="id16">
<caption><span class="caption-number">Table 23 </span><span class="caption-text">Stages for C operator %</span><a class="headerlink" href="#id16" title="Permalink to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Stage</p></th>
<th class="head"><p>IR/DAG/instruction</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>.bc</p></td>
<td><p>srem</p></td>
</tr>
<tr class="row-odd"><td><p>Legalized selection DAG</p></td>
<td><p>sdivrem</p></td>
</tr>
<tr class="row-even"><td><p>Optimized legalized selection DAG</p></td>
<td><p>Cpu0ISD::DivRem, CopyFromReg xx, Hi, Cpu0ISD::DivRem</p></td>
</tr>
<tr class="row-odd"><td><p>pattern match</p></td>
<td><p>div, mfhi</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="id17">
<caption><span class="caption-number">Table 24 </span><span class="caption-text">Functions handle the DAG translation and pattern match for C operator %</span><a class="headerlink" href="#id17" title="Permalink to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Translation</p></th>
<th class="head"><p>Do by</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>srem =&gt; sdivrem</p></td>
<td><p>setOperationAction(ISD::SREM, MVT::i32, Expand);</p></td>
</tr>
<tr class="row-odd"><td><p>sdivrem =&gt; Cpu0ISD::DivRem</p></td>
<td><p>setTargetDAGCombine(ISD::SDIVREM);</p></td>
</tr>
<tr class="row-even"><td><p>sdivrem =&gt; CopyFromReg xx, Hi, xx</p></td>
<td><p>PerformDivRemCombine();</p></td>
</tr>
<tr class="row-odd"><td><p>Cpu0ISD::DivRem =&gt; div</p></td>
<td><p>SDIV (Cpu0InstrInfo.td)</p></td>
</tr>
<tr class="row-even"><td><p>CopyFromReg xx, Hi, xx =&gt; mfhi</p></td>
<td><p>MFLO (Cpu0InstrInfo.td)</p></td>
</tr>
</tbody>
</table>
<p>The more detailed transformation of DAGs during <cite>llc</cite> execution follows these
steps:</p>
<ol class="arabic simple" start="2">
<li><p><strong>Convert `srem` to `sdivrem`</strong></p>
<ul class="simple">
<li><p>Triggered by the code:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">setOperationAction(ISD::SREM,</span> <span class="pre">MVT::i32,</span> <span class="pre">Expand);</span>
<span class="pre">`</span></code></p></li>
<li><p>Defined in <cite>Cpu0ISelLowering.cpp</cite>.</p></li>
<li><p>For details on <strong>Expand</strong>, refer to <a class="footnote-reference brackets" href="#expand" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a> and <a class="footnote-reference brackets" href="#legalizetypes" id="id8" role="doc-noteref"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></a>.</p></li>
</ul>
</li>
<li><p><strong>Convert `sdivrem` to `Cpu0ISD::DivRem`</strong></p>
<ul class="simple">
<li><p>Triggered by:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">setTargetDAGCombine(ISD::SDIVREM);</span>
<span class="pre">`</span></code></p></li>
<li><p>Also defined in <cite>Cpu0ISelLowering.cpp</cite>.</p></li>
</ul>
</li>
<li><p><strong>Handle `CopyFromReg` in DAG</strong></p>
<ul class="simple">
<li><p>Managed by <cite>PerformDivRemCombine()</cite>, which is called by
<cite>performDAGCombine()</cite>.</p></li>
<li><p>The <strong>`%`</strong> operator (corresponding to <cite>srem</cite>) makes
<cite>“N-&gt;hasAnyUseOfValue(1)”</cite> true in <cite>PerformDivRemCombine()</cite>, resulting in
<cite>“CopyFromReg”</cite> DAG creation.</p></li>
<li><p>The <strong>`/`</strong> operator makes <cite>“N-&gt;hasAnyUseOfValue(0)”</cite> true.</p></li>
<li><p>For <cite>sdivrem</cite>:</p>
<ul>
<li><p><cite>sdiv</cite> sets <cite>“N-&gt;hasAnyUseOfValue(0)”</cite> true.</p></li>
<li><p><cite>srem</cite> sets <cite>“N-&gt;hasAnyUseOfValue(1)”</cite> true.</p></li>
</ul>
</li>
</ul>
</li>
</ol>
<p>Once these steps modify the DAGs during <cite>llc</cite> execution, pattern matching in
<cite>Chapter4_1/Cpu0InstrInfo.td</cite> translates:</p>
<ul class="simple">
<li><p><strong>`Cpu0ISD::DivRem`</strong> → <strong>`div`</strong></p></li>
<li><p><strong>`CopyFromReg xxDAG, Register %H, Cpu0ISD::DivRem`</strong> → <strong>`mfhi`</strong></p></li>
</ul>
<p>The <cite>ch4_1_div.cpp</cite> file tests the <cite>/</cite> (division) operator.</p>
</section>
<section id="rotate-instructions">
<h4><a class="toc-backref" href="#id29" role="doc-backlink">Rotate Instructions</a><a class="headerlink" href="#rotate-instructions" title="Permalink to this heading">¶</a></h4>
<p><cite>Chapter4_1</cite> includes support for <strong>rotate operations</strong>.
The instructions <strong>`rol`</strong>, <strong>`ror`</strong>, <strong>`rolv`</strong>, and <strong>`rorv`</strong> are defined in <cite>Cpu0InstrInfo.td</cite> for translation.</p>
<p>Compiling <cite>ch4_1_rotate.cpp</cite> will generate the <cite>Cpu0 rol</cite> instruction.</p>
<p class="rubric">lbdex/input/ch4_1_rotate.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="o">//</span><span class="c1">#define TEST_ROXV</span>

<span class="nb">int</span> <span class="n">test_rotate_left</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">result</span> <span class="o">=</span> <span class="p">((</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">));</span>
  
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">#ifdef TEST_ROXV</span>

<span class="nb">int</span> <span class="n">test_rotate_left1</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">volatile</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
  <span class="n">volatile</span> <span class="nb">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">result</span> <span class="o">=</span> <span class="p">((</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">32</span> <span class="o">-</span> <span class="n">n</span><span class="p">)));</span>
  
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">test_rotate_right</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">volatile</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">volatile</span> <span class="nb">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">result</span> <span class="o">=</span> <span class="p">((</span><span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">32</span> <span class="o">-</span> <span class="n">n</span><span class="p">)));</span>
  
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">#endif</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">114-43-200-122:input Jonathan$ </span>clang -target mips-unknown-linux-gnu -c
<span class="go">ch4_1_rotate.cpp -emit-llvm -o ch4_1_rotate.bc</span>
<span class="gp">114-43-200-122:input Jonathan$ </span>llvm-dis ch4_1_rotate.bc -o -
</pre></div>
</div>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@_Z16test_rotate_leftv</span><span class="p">()</span><span class="w"> </span><span class="vg">#0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nv">%a</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">alloca</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span><span class="w"></span>
<span class="w">  </span><span class="nv">%result</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">alloca</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span><span class="w"></span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">8</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span><span class="w"></span>
<span class="w">  </span><span class="nv nv-Anonymous">%1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span><span class="w"></span>
<span class="w">  </span><span class="nv nv-Anonymous">%2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">shl</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv nv-Anonymous">%1</span><span class="p">,</span><span class="w"> </span><span class="m">30</span><span class="w"></span>
<span class="w">  </span><span class="nv nv-Anonymous">%3</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span><span class="w"></span>
<span class="w">  </span><span class="nv nv-Anonymous">%4</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">ashr</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv nv-Anonymous">%3</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="w"></span>
<span class="w">  </span><span class="nv nv-Anonymous">%5</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv nv-Anonymous">%2</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">%4</span><span class="w"></span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv nv-Anonymous">%5</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%result</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span><span class="w"></span>
<span class="w">  </span><span class="nv nv-Anonymous">%6</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%result</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span><span class="w"></span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv nv-Anonymous">%6</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">114-43-200-122:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llc -march=cpu0 -relocation-model=pic -filetype=asm ch4_1_rotate.bc -o -</span>
<span class="go">  ...</span>
<span class="go">  rol $2, $2, 30</span>
<span class="go">  ...</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="logical-instructions">
<h2><a class="toc-backref" href="#id30" role="doc-backlink">Logical Instructions</a><a class="headerlink" href="#logical-instructions" title="Permalink to this heading">¶</a></h2>
<p><cite>Chapter4_2</cite> introduces support for logical operators:</p>
<p><strong>`&amp;, |, ^, !, ==, !=, &lt;, &lt;=, &gt;, &gt;=`</strong></p>
<p>These operations are straightforward to implement.</p>
<p>Below, you’ll find:</p>
<ul class="simple">
<li><p>The added code with comments</p></li>
<li><p>A table mapping <strong>IR operations → DAG nodes → final instructions</strong></p></li>
<li><p>The execution results of <strong>bitcode (bc) and assembly (asm) for `ch4_2_logic.cpp`</strong></p></li>
</ul>
<p>Please check the run results to verify the implementation.</p>
<p class="rubric">lbdex/chapters/Chapter4_2/Cpu0InstrInfo.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>let Predicates = [Ch4_2] in {
class CmpInstr&lt;bits&lt;8&gt; op, string instr_asm, 
               InstrItinClass itin, RegisterClass RC, RegisterClass RD, 
               bit isComm = 0&gt;:
  FA&lt;op, (outs RD:$ra), (ins RC:$rb, RC:$rc),
     !strconcat(instr_asm, &quot;\t$ra, $rb, $rc&quot;), [], itin&gt; {
  let shamt = 0;
  let isCommutable = isComm;
  let Predicates = [HasCmp];
}
}
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>//  Logical
class LogicNOR&lt;bits&lt;8&gt; op, string instr_asm, RegisterClass RC&gt;:
  FA&lt;op, (outs RC:$ra), (ins RC:$rb, RC:$rc),
     !strconcat(instr_asm, &quot;\t$ra, $rb, $rc&quot;),
     [(set RC:$ra, (not (or RC:$rb, RC:$rc)))], IIAlu&gt; {
  let shamt = 0;
  let isCommutable = 1;
}
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// SetCC
let Predicates = [Ch4_2] in {
class SetCC_R&lt;bits&lt;8&gt; op, string instr_asm, PatFrag cond_op,
              RegisterClass RC&gt;:
  FA&lt;op, (outs GPROut:$ra), (ins RC:$rb, RC:$rc),
     !strconcat(instr_asm, &quot;\t$ra, $rb, $rc&quot;),
     [(set GPROut:$ra, (cond_op RC:$rb, RC:$rc))],
     IIAlu&gt;, Requires&lt;[HasSlt]&gt; {
  let shamt = 0;
}

class SetCC_I&lt;bits&lt;8&gt; op, string instr_asm, PatFrag cond_op, Operand Od,
              PatLeaf imm_type, RegisterClass RC&gt;:
  FL&lt;op, (outs GPROut:$ra), (ins RC:$rb, Od:$imm16),
     !strconcat(instr_asm, &quot;\t$ra, $rb, $imm16&quot;),
     [(set GPROut:$ra, (cond_op RC:$rb, imm_type:$imm16))],
     IIAlu&gt;, Requires&lt;[HasSlt]&gt; {
}
}
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ch4_2</span><span class="p">]</span> <span class="ow">in</span> <span class="p">{</span>
<span class="k">def</span> <span class="nf">ANDi</span>    <span class="p">:</span> <span class="n">ArithLogicI</span><span class="o">&lt;</span><span class="mh">0x0c</span><span class="p">,</span> <span class="s2">&quot;andi&quot;</span><span class="p">,</span> <span class="ow">and</span><span class="p">,</span> <span class="n">uimm16</span><span class="p">,</span> <span class="n">immZExt16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ch4_2</span><span class="p">]</span> <span class="ow">in</span> <span class="p">{</span>
<span class="k">def</span> <span class="nf">XORi</span>    <span class="p">:</span> <span class="n">ArithLogicI</span><span class="o">&lt;</span><span class="mh">0x0e</span><span class="p">,</span> <span class="s2">&quot;xori&quot;</span><span class="p">,</span> <span class="n">xor</span><span class="p">,</span> <span class="n">uimm16</span><span class="p">,</span> <span class="n">immZExt16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ch4_2</span><span class="p">]</span> <span class="ow">in</span> <span class="p">{</span>
<span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">HasCmp</span><span class="p">]</span> <span class="ow">in</span> <span class="p">{</span>
<span class="k">def</span> <span class="nf">CMP</span>     <span class="p">:</span> <span class="n">CmpInstr</span><span class="o">&lt;</span><span class="mh">0x2A</span><span class="p">,</span> <span class="s2">&quot;cmp&quot;</span><span class="p">,</span> <span class="n">IIAlu</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="n">SR</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">CMPu</span>    <span class="p">:</span> <span class="n">CmpInstr</span><span class="o">&lt;</span><span class="mh">0x2B</span><span class="p">,</span> <span class="s2">&quot;cmpu&quot;</span><span class="p">,</span> <span class="n">IIAlu</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="n">SR</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ch4_2</span><span class="p">]</span> <span class="ow">in</span> <span class="p">{</span>
<span class="k">def</span> <span class="nf">AND</span>     <span class="p">:</span> <span class="n">ArithLogicR</span><span class="o">&lt;</span><span class="mh">0x18</span><span class="p">,</span> <span class="s2">&quot;and&quot;</span><span class="p">,</span> <span class="ow">and</span><span class="p">,</span> <span class="n">IIAlu</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">OR</span>      <span class="p">:</span> <span class="n">ArithLogicR</span><span class="o">&lt;</span><span class="mh">0x19</span><span class="p">,</span> <span class="s2">&quot;or&quot;</span><span class="p">,</span> <span class="ow">or</span><span class="p">,</span> <span class="n">IIAlu</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">XOR</span>     <span class="p">:</span> <span class="n">ArithLogicR</span><span class="o">&lt;</span><span class="mh">0x1a</span><span class="p">,</span> <span class="s2">&quot;xor&quot;</span><span class="p">,</span> <span class="n">xor</span><span class="p">,</span> <span class="n">IIAlu</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">NOR</span>     <span class="p">:</span> <span class="n">LogicNOR</span><span class="o">&lt;</span><span class="mh">0x1b</span><span class="p">,</span> <span class="s2">&quot;nor&quot;</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ch4_2</span><span class="p">]</span> <span class="ow">in</span> <span class="p">{</span>
<span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">HasSlt</span><span class="p">]</span> <span class="ow">in</span> <span class="p">{</span>
<span class="k">def</span> <span class="nf">SLTi</span>    <span class="p">:</span> <span class="n">SetCC_I</span><span class="o">&lt;</span><span class="mh">0x26</span><span class="p">,</span> <span class="s2">&quot;slti&quot;</span><span class="p">,</span> <span class="n">setlt</span><span class="p">,</span> <span class="n">simm16</span><span class="p">,</span> <span class="n">immSExt16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">SLTiu</span>   <span class="p">:</span> <span class="n">SetCC_I</span><span class="o">&lt;</span><span class="mh">0x27</span><span class="p">,</span> <span class="s2">&quot;sltiu&quot;</span><span class="p">,</span> <span class="n">setult</span><span class="p">,</span> <span class="n">simm16</span><span class="p">,</span> <span class="n">immSExt16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">SLT</span>     <span class="p">:</span> <span class="n">SetCC_R</span><span class="o">&lt;</span><span class="mh">0x28</span><span class="p">,</span> <span class="s2">&quot;slt&quot;</span><span class="p">,</span> <span class="n">setlt</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">SLTu</span>    <span class="p">:</span> <span class="n">SetCC_R</span><span class="o">&lt;</span><span class="mh">0x29</span><span class="p">,</span> <span class="s2">&quot;sltu&quot;</span><span class="p">,</span> <span class="n">setult</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>let Predicates = [Ch4_2] in {
def : Pat&lt;(not CPURegs:$in),
// 1&#39;s complement of in, ex. not(0xf000000f) == 0x0ffffff0
          (NOR CPURegs:$in, ZERO)&gt;;
}
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// setcc patterns

let Predicates = [Ch4_2] in {
// setcc for cmp instruction
multiclass SeteqPatsCmp&lt;RegisterClass RC&gt; {
// a == b
  def : Pat&lt;(seteq RC:$lhs, RC:$rhs),
            (SHR (ANDi (CMP RC:$lhs, RC:$rhs), 2), 1)&gt;;
// a != b
  def : Pat&lt;(setne RC:$lhs, RC:$rhs),
            (XORi (SHR (ANDi (CMP RC:$lhs, RC:$rhs), 2), 1), 1)&gt;;
}

// a &lt; b
multiclass SetltPatsCmp&lt;RegisterClass RC&gt; {
  def : Pat&lt;(setlt RC:$lhs, RC:$rhs),
            (ANDi (CMP RC:$lhs, RC:$rhs), 1)&gt;;
// if cpu0  `define N    `SW[31]  instead of `SW[0] // Negative flag, then need
// 2 more instructions as follows,
//          (XORi (ANDi (SHR (CMP RC:$lhs, RC:$rhs), (LUi 0x8000), 31), 1), 1)&gt;;
  def : Pat&lt;(setult RC:$lhs, RC:$rhs),
            (ANDi (CMPu RC:$lhs, RC:$rhs), 1)&gt;;
}

// a &lt;= b
multiclass SetlePatsCmp&lt;RegisterClass RC&gt; {
  def : Pat&lt;(setle RC:$lhs, RC:$rhs),
// a &lt;= b is equal to (XORi (b &lt; a), 1)
            (XORi (ANDi (CMP RC:$rhs, RC:$lhs), 1), 1)&gt;;
  def : Pat&lt;(setule RC:$lhs, RC:$rhs),
            (XORi (ANDi (CMP RC:$rhs, RC:$lhs), 1), 1)&gt;;
}

// a &gt; b
multiclass SetgtPatsCmp&lt;RegisterClass RC&gt; {
  def : Pat&lt;(setgt RC:$lhs, RC:$rhs),
// a &gt; b is equal to b &lt; a is equal to setlt(b, a)
            (ANDi (CMP RC:$rhs, RC:$lhs), 1)&gt;;
  def : Pat&lt;(setugt RC:$lhs, RC:$rhs),
            (ANDi (CMPu RC:$rhs, RC:$lhs), 1)&gt;;
}

// a &gt;= b
multiclass SetgePatsCmp&lt;RegisterClass RC&gt; {
  def : Pat&lt;(setge RC:$lhs, RC:$rhs),
// a &gt;= b is equal to b &lt;= a
            (XORi (ANDi (CMP RC:$lhs, RC:$rhs), 1), 1)&gt;;
  def : Pat&lt;(setuge RC:$lhs, RC:$rhs),
            (XORi (ANDi (CMPu RC:$lhs, RC:$rhs), 1), 1)&gt;;
}

// setcc for slt instruction
multiclass SeteqPatsSlt&lt;RegisterClass RC, Instruction SLTiuOp, Instruction XOROp,
                     Instruction SLTuOp, Register ZEROReg&gt; {
// a == b
  def : Pat&lt;(seteq RC:$lhs, RC:$rhs),
                (SLTiuOp (XOROp RC:$lhs, RC:$rhs), 1)&gt;;
// a != b
  def : Pat&lt;(setne RC:$lhs, RC:$rhs),
                (SLTuOp ZEROReg, (XOROp RC:$lhs, RC:$rhs))&gt;;
}

// a &lt;= b
multiclass SetlePatsSlt&lt;RegisterClass RC, Instruction SLTOp, Instruction SLTuOp&gt; {
  def : Pat&lt;(setle RC:$lhs, RC:$rhs),
// a &lt;= b is equal to (XORi (b &lt; a), 1)
                (XORi (SLTOp RC:$rhs, RC:$lhs), 1)&gt;;
  def : Pat&lt;(setule RC:$lhs, RC:$rhs),
                (XORi (SLTuOp RC:$rhs, RC:$lhs), 1)&gt;;
}

// a &gt; b
multiclass SetgtPatsSlt&lt;RegisterClass RC, Instruction SLTOp, Instruction SLTuOp&gt; {
  def : Pat&lt;(setgt RC:$lhs, RC:$rhs),
// a &gt; b is equal to b &lt; a is equal to setlt(b, a)
                (SLTOp RC:$rhs, RC:$lhs)&gt;;
  def : Pat&lt;(setugt RC:$lhs, RC:$rhs),
                (SLTuOp RC:$rhs, RC:$lhs)&gt;;
}

// a &gt;= b
multiclass SetgePatsSlt&lt;RegisterClass RC, Instruction SLTOp, Instruction SLTuOp&gt; {
  def : Pat&lt;(setge RC:$lhs, RC:$rhs),
// a &gt;= b is equal to b &lt;= a
                (XORi (SLTOp RC:$lhs, RC:$rhs), 1)&gt;;
  def : Pat&lt;(setuge RC:$lhs, RC:$rhs),
                (XORi (SLTuOp RC:$lhs, RC:$rhs), 1)&gt;;
}

multiclass SetgeImmPatsSlt&lt;RegisterClass RC, Instruction SLTiOp,
                        Instruction SLTiuOp&gt; {
  def : Pat&lt;(setge RC:$lhs, immSExt16:$rhs),
                (XORi (SLTiOp RC:$lhs, immSExt16:$rhs), 1)&gt;;
  def : Pat&lt;(setuge RC:$lhs, immSExt16:$rhs),
                (XORi (SLTiuOp RC:$lhs, immSExt16:$rhs), 1)&gt;;
}

let Predicates = [HasSlt] in {
defm : SeteqPatsSlt&lt;CPURegs, SLTiu, XOR, SLTu, ZERO&gt;;
defm : SetlePatsSlt&lt;CPURegs, SLT, SLTu&gt;;
defm : SetgtPatsSlt&lt;CPURegs, SLT, SLTu&gt;;
defm : SetgePatsSlt&lt;CPURegs, SLT, SLTu&gt;;
defm : SetgeImmPatsSlt&lt;CPURegs, SLTi, SLTiu&gt;;
}

let Predicates = [HasCmp] in {
defm : SeteqPatsCmp&lt;CPURegs&gt;;
defm : SetltPatsCmp&lt;CPURegs&gt;;
defm : SetlePatsCmp&lt;CPURegs&gt;;
defm : SetgtPatsCmp&lt;CPURegs&gt;;
defm : SetgePatsCmp&lt;CPURegs&gt;;
}
} // let Predicates = [Ch4_2]
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter4_2/Cpu0ISelLowering.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="n">const</span> <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">,</span>
                                       <span class="n">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span>
    <span class="p">:</span> <span class="n">TargetLowering</span><span class="p">(</span><span class="n">TM</span><span class="p">),</span> <span class="n">Subtarget</span><span class="p">(</span><span class="n">STI</span><span class="p">),</span> <span class="n">ABI</span><span class="p">(</span><span class="n">TM</span><span class="o">.</span><span class="n">getABI</span><span class="p">())</span> <span class="p">{</span>

</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="o">//</span> <span class="n">Cpu0</span> <span class="n">doesn</span><span class="s1">&#39;t have sext_inreg, replace them with shl/sra.</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">SIGN_EXTEND_INREG</span><span class="p">,</span> <span class="n">MVT</span><span class="p">::</span><span class="n">i1</span> <span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">SIGN_EXTEND_INREG</span><span class="p">,</span> <span class="n">MVT</span><span class="p">::</span><span class="n">i8</span> <span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">SIGN_EXTEND_INREG</span><span class="p">,</span> <span class="n">MVT</span><span class="p">::</span><span class="n">i16</span> <span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">SIGN_EXTEND_INREG</span><span class="p">,</span> <span class="n">MVT</span><span class="p">::</span><span class="n">i32</span> <span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">SIGN_EXTEND_INREG</span><span class="p">,</span> <span class="n">MVT</span><span class="p">::</span><span class="n">Other</span> <span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/input/ch4_2_logic.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>int test_andorxornotcomplement()
{
  int a = 5;
  int b = 3;
  int c = 0, d = 0, e = 0, f = 0, g = 0;

  c = (a &amp; b);  // c = 1
  d = (a | b);  // d = 7
  e = (a ^ b);  // e = 6
  b = !a;       // b = 0
  g = ~f;       // 1&#39;s complement, ~0=(-1)=0xffffffff
  
  return (c+d+e+b+g); // 13
}

int test_setxx()
{
  int a = 5;
  int b = 3;
  int c, d, e, f, g, h;
  
  c = (a == b); // seq, c = 0
  d = (a != b); // sne, d = 1
  e = (a &lt; b);  // slt, e = 0
  f = (a &lt;= b); // sle, f = 0
  g = (a &gt; b);  // sgt, g = 1
  h = (a &gt;= b); // sge, g = 1
  
  return (c+d+e+f+g+h); // 3
}

</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">114-43-204-152:input Jonathan$ </span>clang -target mips-unknown-linux-gnu -c
<span class="go">ch4_2_logic.cpp -emit-llvm -o ch4_2_logic.bc</span>
<span class="gp">114-43-204-152:input Jonathan$ </span>llvm-dis ch4_2_logic.bc -o -
<span class="go">...</span>
<span class="go">; Function Attrs: nounwind uwtable</span>
<span class="go">define i32 @_Z16test_andorxornotv() #0 {</span>
<span class="go">entry:</span>
<span class="go">  ...</span>
<span class="gp">  %</span><span class="nv">and</span> <span class="o">=</span> and i32 %0, %1
<span class="go">  ...</span>
<span class="gp">  %</span><span class="nv">or</span> <span class="o">=</span> or i32 %2, %3
<span class="go">  ...</span>
<span class="gp">  %</span><span class="nv">xor</span> <span class="o">=</span> xor i32 %4, %5
<span class="go">  ...</span>
<span class="gp">  %</span><span class="nv">tobool</span> <span class="o">=</span> icmp ne i32 %6, <span class="m">0</span>
<span class="gp">  %</span><span class="nv">lnot</span> <span class="o">=</span> xor i1 %tobool, <span class="nb">true</span>
<span class="gp">  %</span><span class="nv">conv</span> <span class="o">=</span> zext i1 %lnot to i32
<span class="go">  ...</span>
<span class="go">}</span>

<span class="go">; Function Attrs: nounwind uwtable</span>
<span class="go">define i32 @_Z10test_setxxv() #0 {</span>
<span class="go">entry:</span>
<span class="go">  ...</span>
<span class="gp">  %</span><span class="nv">cmp</span> <span class="o">=</span> icmp eq i32 %0, %1
<span class="gp">  %</span><span class="nv">conv</span> <span class="o">=</span> zext i1 %cmp to i32
<span class="go">  store i32 %conv, i32* %c, align 4</span>
<span class="go">  ...</span>
<span class="gp">  %</span><span class="nv">cmp1</span> <span class="o">=</span> icmp ne i32 %2, %3
<span class="gp">  %</span><span class="nv">conv2</span> <span class="o">=</span> zext i1 %cmp1 to i32
<span class="go">  store i32 %conv2, i32* %d, align 4</span>
<span class="go">  ...</span>
<span class="gp">  %</span><span class="nv">cmp3</span> <span class="o">=</span> icmp slt i32 %4, %5
<span class="gp">  %</span><span class="nv">conv4</span> <span class="o">=</span> zext i1 %cmp3 to i32
<span class="go">  store i32 %conv4, i32* %e, align 4</span>
<span class="go">  ...</span>
<span class="gp">  %</span><span class="nv">cmp5</span> <span class="o">=</span> icmp sle i32 %6, %7
<span class="gp">  %</span><span class="nv">conv6</span> <span class="o">=</span> zext i1 %cmp5 to i32
<span class="go">  store i32 %conv6, i32* %f, align 4</span>
<span class="go">  ...</span>
<span class="gp">  %</span><span class="nv">cmp7</span> <span class="o">=</span> icmp sgt i32 %8, %9
<span class="gp">  %</span><span class="nv">conv8</span> <span class="o">=</span> zext i1 %cmp7 to i32
<span class="go">  store i32 %conv8, i32* %g, align 4</span>
<span class="go">  ...</span>
<span class="gp">  %</span><span class="nv">cmp9</span> <span class="o">=</span> icmp sge i32 %10, %11
<span class="gp">  %</span><span class="nv">conv10</span> <span class="o">=</span> zext i1 %cmp9 to i32
<span class="go">  store i32 %conv10, i32* %h, align 4</span>
<span class="go">  ...</span>
<span class="go">}</span>

<span class="gp">114-43-204-152:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llc -march=cpu0 -mcpu=cpu032I -relocation-model=pic -filetype=asm</span>
<span class="go">ch4_2_logic.bc -o -</span>

<span class="go">  .globl  _Z16test_andorxornotv</span>
<span class="go">  ...</span>
<span class="go">  and $3, $4, $3</span>
<span class="go">  ...</span>
<span class="go">  or  $3, $4, $3</span>
<span class="go">  ...</span>
<span class="go">  xor $3, $4, $3</span>
<span class="go">  ...</span>
<span class="go">  cmp $sw, $3, $2</span>
<span class="go">  andi  $2, $sw, 2</span>
<span class="go">  shr $2, $2, 1</span>
<span class="go">  ...</span>

<span class="go">  .globl  _Z10test_setxxv</span>
<span class="go">  ...</span>
<span class="go">  cmp $sw, $3, $2</span>
<span class="go">  andi  $2, $sw, 2</span>
<span class="go">  shr $2, $2, 1</span>
<span class="go">  ...</span>
<span class="go">  cmp $sw, $3, $2</span>
<span class="go">  andi  $2, $sw, 2</span>
<span class="go">  shr $2, $2, 1</span>
<span class="go">  xori  $2, $2, 1</span>
<span class="go">  ...</span>
<span class="go">  cmp $sw, $3, $2</span>
<span class="go">  andi  $2, $sw, 1</span>
<span class="go">  ...</span>
<span class="go">  cmp $sw, $3, $2</span>
<span class="go">  andi  $2, $sw, 1</span>
<span class="go">  xori  $2, $2, 1</span>
<span class="go">  ...</span>
<span class="go">  cmp $sw, $3, $2</span>
<span class="go">  andi  $2, $sw, 1</span>
<span class="go">  ...</span>
<span class="go">  cmp $sw, $3, $2</span>
<span class="go">  andi  $2, $sw, 1</span>
<span class="go">  xori  $2, $2, 1</span>
<span class="go">  ...</span>

<span class="gp">114-43-204-152:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llc -march=cpu0 -mcpu=cpu032II -relocation-model=pic -filetype=asm</span>
<span class="go">ch4_2_logic.bc -o -</span>
<span class="go">  ...</span>
<span class="go">      sltiu   $2, $2, 1</span>
<span class="go">      andi    $2, $2, 1</span>
<span class="go">      ...</span>
</pre></div>
</div>
<table class="docutils align-default" id="id18">
<caption><span class="caption-number">Table 25 </span><span class="caption-text">Logic operators for cpu032I</span><a class="headerlink" href="#id18" title="Permalink to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>C</p></th>
<th class="head"><p>.bc</p></th>
<th class="head"><p>Optimized legalized selection DAG</p></th>
<th class="head"><p>cpu032I</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>&amp;, &amp;&amp;</p></td>
<td><p>and</p></td>
<td><p>and</p></td>
<td><p>and</p></td>
</tr>
<tr class="row-odd"><td><p>|, ||</p></td>
<td><p>or</p></td>
<td><p>or</p></td>
<td><p>or</p></td>
</tr>
<tr class="row-even"><td><p>^</p></td>
<td><p>xor</p></td>
<td><p>xor</p></td>
<td><p>xor</p></td>
</tr>
<tr class="row-odd"><td><p>!</p></td>
<td><ul class="simple">
<li><p>%tobool = icmp ne i32 %6, 0</p></li>
<li><p>%lnot = xor i1 %tobool, true</p></li>
<li><p>%conv = zext i1 %lnot to i32</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>%lnot = (setcc %tobool, 0, seteq)</p></li>
<li><p>%conv = (and %lnot, 1)</p></li>
<li></li>
</ul>
</td>
<td><ul class="simple">
<li><p>xor $3, $4, $3</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>==</p></td>
<td><ul class="simple">
<li><p>%cmp = icmp eq i32 %0, %1</p></li>
<li><p>%conv = zext i1 %cmp to i32</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>%cmp = (setcc %0, %1, seteq)</p></li>
<li><p>and %cmp, 1</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>cmp $sw, $3, $2</p></li>
<li><p>andi  $2, $sw, 2</p></li>
<li><p>shr $2, $2, 1</p></li>
<li><p>andi $2, $2, 1</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>!=</p></td>
<td><ul class="simple">
<li><p>%cmp = icmp ne i32 %0, %1</p></li>
<li><p>%conv = zext i1 %cmp to i32</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>%cmp = (setcc %0, %1, setne)</p></li>
<li><p>and %cmp, 1</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>cmp $sw, $3, $2</p></li>
<li><p>andi  $2, $sw, 2</p></li>
<li><p>shr $2, $2, 1</p></li>
<li><p>andi $2, $2, 1</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>&lt;</p></td>
<td><ul class="simple">
<li><p>%cmp = icmp lt i32 %0, %1</p></li>
<li><p>%conv = zext i1 %cmp to i32</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>(setcc %0, %1, setlt)</p></li>
<li><p>and %cmp, 1</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>cmp $sw, $3, $2</p></li>
<li><p>andi  $2, $sw, 2</p></li>
<li><p>andi $2, $2, 1</p></li>
<li><p>andi $2, $2, 1</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>&lt;=</p></td>
<td><ul class="simple">
<li><p>%cmp = icmp le i32 %0, %1</p></li>
<li><p>%conv = zext i1 %cmp to i32</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>(setcc %0, %1, setle)</p></li>
<li><p>and %cmp, 1</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>cmp $sw, $2, $3</p></li>
<li><p>andi  $2, $sw, 1</p></li>
<li><p>xori  $2, $2, 1</p></li>
<li><p>andi $2, $2, 1</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>&gt;</p></td>
<td><ul class="simple">
<li><p>%cmp = icmp gt i32 %0, %1</p></li>
<li><p>%conv = zext i1 %cmp to i32</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>(setcc %0, %1, setgt)</p></li>
<li><p>and %cmp, 1</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>cmp $sw, $2, $3</p></li>
<li><p>andi  $2, $sw, 2</p></li>
<li><p>andi $2, $2, 1</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>&gt;=</p></td>
<td><ul class="simple">
<li><p>%cmp = icmp le i32 %0, %1</p></li>
<li><p>%conv = zext i1 %cmp to i32</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>(setcc %0, %1, setle)</p></li>
<li><p>and %cmp, 1</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>cmp $sw, $3, $2</p></li>
<li><p>andi  $2, $sw, 1</p></li>
<li><p>xori  $2, $2, 1</p></li>
<li><p>andi $2, $2, 1</p></li>
</ul>
</td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="id19">
<caption><span class="caption-number">Table 26 </span><span class="caption-text">Logic operators for cpu032II</span><a class="headerlink" href="#id19" title="Permalink to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>C</p></th>
<th class="head"><p>.bc</p></th>
<th class="head"><p>Optimized legalized selection DAG</p></th>
<th class="head"><p>cpu032II</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>&amp;, &amp;&amp;</p></td>
<td><p>and</p></td>
<td><p>and</p></td>
<td><p>and</p></td>
</tr>
<tr class="row-odd"><td><p>|, ||</p></td>
<td><p>or</p></td>
<td><p>or</p></td>
<td><p>or</p></td>
</tr>
<tr class="row-even"><td><p>^</p></td>
<td><p>xor</p></td>
<td><p>xor</p></td>
<td><p>xor</p></td>
</tr>
<tr class="row-odd"><td><p>!</p></td>
<td><ul class="simple">
<li><p>%tobool = icmp ne i32 %6, 0</p></li>
<li><p>%lnot = xor i1 %tobool, true</p></li>
<li><p>%conv = zext i1 %lnot to i32</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>%lnot = (setcc %tobool, 0, seteq)</p></li>
<li><p>%conv = (and %lnot, 1)</p></li>
<li></li>
</ul>
</td>
<td><ul class="simple">
<li><p>xor $3, $4, $3</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>==</p></td>
<td><ul class="simple">
<li><p>%cmp = icmp eq i32 %0, %1</p></li>
<li><p>%conv = zext i1 %cmp to i32</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>%cmp = (setcc %0, %1, seteq)</p></li>
<li><p>and %cmp, 1</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>xor $2, $3, $2</p></li>
<li><p>sltiu  $2, $2, 1</p></li>
<li><p>andi $2, $2, 1</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>!=</p></td>
<td><ul class="simple">
<li><p>%cmp = icmp ne i32 %0, %1</p></li>
<li><p>%conv = zext i1 %cmp to i32</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>%cmp = (setcc %0, %1, setne)</p></li>
<li><p>and %cmp, 1</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>xor $2, $3, $2</p></li>
<li><p>sltu  $2, $zero, 2</p></li>
<li><p>shr $2, $2, 1</p></li>
<li><p>andi $2, $2, 1</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>&lt;</p></td>
<td><ul class="simple">
<li><p>%cmp = icmp lt i32 %0, %1</p></li>
<li><p>%conv = zext i1 %cmp to i32</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>(setcc %0, %1, setlt)</p></li>
<li><p>and %cmp, 1</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>slt $2, $3, $2</p></li>
<li><p>andi  $2, $2, 1</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>&lt;=</p></td>
<td><ul class="simple">
<li><p>%cmp = icmp le i32 %0, %1</p></li>
<li><p>%conv = zext i1 %cmp to i32</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>(setcc %0, %1, setle)</p></li>
<li><p>and %cmp, 1</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>slt $2, $3, $2</p></li>
<li><p>xori  $2, $2, 1</p></li>
<li><p>andi $2, $2, 1</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>&gt;</p></td>
<td><ul class="simple">
<li><p>%cmp = icmp gt i32 %0, %1</p></li>
<li><p>%conv = zext i1 %cmp to i32</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>(setcc %0, %1, setgt)</p></li>
<li><p>and %cmp, 1</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>slt $2, $3, $2</p></li>
<li><p>andi  $2, $2, 1</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>&gt;=</p></td>
<td><ul class="simple">
<li><p>%cmp = icmp le i32 %0, %1</p></li>
<li><p>%conv = zext i1 %cmp to i32</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>(setcc %0, %1, setle)</p></li>
<li><p>and %cmp, 1</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>slt $2, $3, $2</p></li>
<li><p>xori  $2, $2, 1</p></li>
<li><p>andi $2, $2, 1</p></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>For <cite>ch4_2_logic.cpp</cite>, the relation operators such as <strong>`==, !=, &lt;, &lt;=, &gt;, &gt;=`</strong>
follow the convention where:</p>
<ul class="simple">
<li><p><cite>%0 = $3 = 5</cite></p></li>
<li><p><cite>%1 = $2 = 3</cite></p></li>
</ul>
<p>### Optimized Legalized Selection DAG</p>
<p>The <strong>“Optimized Legalized Selection DAG”</strong> is the final DAG stage before
<strong>instruction selection</strong>, as mentioned earlier in this chapter.
To view all DAG stages, use the command:</p>
<p><strong>`llc -debug`</strong></p>
<p>### <cite>slt</cite> vs. <cite>cmp</cite></p>
<p>From the results, <strong>`slt`</strong> (set-less-than) requires fewer instructions than
<strong>`cmp`</strong> for relation operator translation.</p>
<p>Additionally:</p>
<ul class="simple">
<li><p><strong>`slt`</strong> operates using general-purpose registers.</p></li>
<li><p><strong>`cmp`</strong> requires the dedicated <strong>`$sw`</strong> register.</p></li>
</ul>
<p>This difference makes <strong>`slt`</strong> a more efficient choice in certain scenarios.</p>
<p class="rubric">lbdex/input/ch4_2_slt_explain.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">test_OptSlt</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">f</span> <span class="o">=</span> <span class="n">d</span> <span class="o">+</span> <span class="n">e</span><span class="p">;</span>

  <span class="k">return</span> <span class="p">(</span><span class="n">f</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-78-10:input Jonathan$ </span>clang -target mips-unknown-linux-gnu -O2
<span class="go">-c ch4_2_slt_explain.cpp -emit-llvm -o ch4_2_slt_explain.bc</span>
<span class="gp">118-165-78-10:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llc -march=cpu0 -mcpu=cpu032I -relocation-model=static -filetype=asm</span>
<span class="go">ch4_2_slt_explain.bc -o -</span>
<span class="go">  ...</span>
<span class="go">  ld  $3, 20($sp)</span>
<span class="go">  cmp $sw, $3, $2</span>
<span class="go">  andi  $2, $sw, 1</span>
<span class="go">  andi  $2, $2, 1</span>
<span class="go">  st  $2, 12($sp)</span>
<span class="go">  addiu $2, $zero, 2</span>
<span class="go">  ld  $3, 16($sp)</span>
<span class="go">  cmp $sw, $3, $2</span>
<span class="go">  andi  $2, $sw, 1</span>
<span class="go">  andi  $2, $2, 1</span>
<span class="go">  ...</span>
<span class="gp">118-165-78-10:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llc -march=cpu0 -mcpu=cpu032II -relocation-model=static -filetype=asm</span>
<span class="go">ch4_2_slt_explain.bc -o -</span>
<span class="go">  ...</span>
<span class="go">  ld  $2, 20($sp)</span>
<span class="go">  slti  $2, $2, 1</span>
<span class="go">  andi  $2, $2, 1</span>
<span class="go">  st  $2, 12($sp)</span>
<span class="go">  ld  $2, 16($sp)</span>
<span class="go">  slti  $2, $2, 2</span>
<span class="go">  andi  $2, $2, 1</span>
<span class="go">  st  $2, 8($sp)</span>
<span class="go">  ...</span>
</pre></div>
</div>
<p>Run the following two <cite>llc -mcpu</cite> options with <cite>ch4_2_slt_explain.cpp</cite>
to obtain the results discussed above.</p>
<p>### Instruction Hazard in <cite>llc -mcpu=cpu032I</cite></p>
<p>Regardless of the move operation between <strong>`$sw`</strong> and general-purpose registers
in <cite>llc -mcpu=cpu032I</cite>, the two <strong>`cmp`</strong> instructions introduce a hazard
during instruction reordering.
This occurs because both instructions rely on the <strong>`$sw`</strong> register.</p>
<p>### Avoiding Hazards with <cite>llc -mcpu=cpu032II</cite></p>
<p>The <cite>llc -mcpu=cpu032II</cite> configuration avoids this issue by using <strong>`slti`</strong>
(set-less-than immediate) <a class="footnote-reference brackets" href="#quantitative" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a>.</p>
<p>#### Reordering Optimization with <cite>slti</cite></p>
<p>The <strong>`slti`</strong> version allows safer instruction reordering, as demonstrated below:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">...</span>
<span class="go">ld  $2, 16($sp)</span>
<span class="go">slti  $2, $2, 2</span>
<span class="go">andi  $2, $2, 1</span>
<span class="go">st  $2, 8($sp)</span>
<span class="go">ld  $2, 20($sp)</span>
<span class="go">slti  $2, $2, 1</span>
<span class="go">andi  $2, $2, 1</span>
<span class="go">st  $2, 12($sp)</span>
<span class="go">...</span>
</pre></div>
</div>
<p>Chapter 4.2 includes both <strong>`cmp`</strong> and <strong>`slt`</strong> instructions.
Although <strong>`cpu032II`</strong> supports both instructions, <strong>`slt`</strong> takes priority
because the directive:</p>
<p><strong>let Predicates = [HasSlt]</strong></p>
<p>appears <strong>before</strong>:</p>
<p><strong>let Predicates = [HasCmp]</strong></p>
<p>in <cite>Cpu0InstrInfo.td</cite>.</p>
</section>
<section id="summary">
<h2><a class="toc-backref" href="#id31" role="doc-backlink">Summary</a><a class="headerlink" href="#summary" title="Permalink to this heading">¶</a></h2>
<p>The following table summarizes the <strong>C operators</strong>, their corresponding
<strong>LLVM IR</strong> (<cite>.bc</cite>), <strong>Optimized Legalized Selection DAG</strong>,
and <strong>Cpu0 instructions</strong> implemented in this chapter.</p>
<p>This chapter covers over <strong>20 mathematical and logical operators</strong>,
spanning <strong>approximately 400 lines</strong> of source code.</p>
<table class="docutils align-default" id="id20">
<caption><span class="caption-number">Table 27 </span><span class="caption-text">Chapter 4 mathmetic operators</span><a class="headerlink" href="#id20" title="Permalink to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>C</p></th>
<th class="head"><p>.bc</p></th>
<th class="head"><p>Optimized legalized selection DAG</p></th>
<th class="head"><p>Cpu0</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>+</p></td>
<td><p>add</p></td>
<td><p>add</p></td>
<td><p>addu</p></td>
</tr>
<tr class="row-odd"><td><p>-</p></td>
<td><p>sub</p></td>
<td><p>sub</p></td>
<td><p>subu</p></td>
</tr>
<tr class="row-even"><td><p>*</p></td>
<td><p>mul</p></td>
<td><p>mul</p></td>
<td><p>mul</p></td>
</tr>
<tr class="row-odd"><td><p>/</p></td>
<td><p>sdiv</p></td>
<td><p>Cpu0ISD::DivRem</p></td>
<td><p>div</p></td>
</tr>
<tr class="row-even"><td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>udiv</p></td>
<td><p>Cpu0ISD::DivRemU</p></td>
<td><p>divu</p></td>
</tr>
<tr class="row-odd"><td><p>&lt;&lt;</p></td>
<td><p>shl</p></td>
<td><p>shl</p></td>
<td><p>shl</p></td>
</tr>
<tr class="row-even"><td><p>&gt;&gt;</p></td>
<td><ul class="simple">
<li><p>ashr</p></li>
<li><p>lshr</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>sra</p></li>
<li><p>srl</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>sra</p></li>
<li><p>shr</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>!</p></td>
<td><ul class="simple">
<li><p>%tobool = icmp ne i32 %0, 0</p></li>
<li><p>%lnot = xor i1 %tobool, true</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>%lnot = (setcc %tobool, 0, seteq)</p></li>
<li><p>%conv = (and %lnot, 1)</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>%1 = (xor %tobool, 0)</p></li>
<li><p>%true = (addiu $r0, 1)</p></li>
<li><p>%lnot = (xor %1, %true)</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><ul class="simple">
<li></li>
</ul>
</td>
<td><ul class="simple">
<li><p>%conv = zext i1 %lnot to i32</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>%conv = (and %lnot, 1)</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>%conv = (and %lnot, 1)</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>%</p></td>
<td><ul class="simple">
<li><p>srem</p></li>
<li><p>sremu</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Cpu0ISD::DivRem</p></li>
<li><p>Cpu0ISD::DivRemU</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>div</p></li>
<li><p>divu</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>(x&lt;&lt;n)|(x&gt;&gt;32-n)</p></td>
<td><p>shl + lshr</p></td>
<td><p>rotl, rotr</p></td>
<td><p>rol, rolv, ror, rorv</p></td>
</tr>
</tbody>
</table>
<aside class="footnote brackets" id="instrstage" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://llvm.org/docs/doxygen/html/structllvm_1_1InstrStage.html">http://llvm.org/docs/doxygen/html/structllvm_1_1InstrStage.html</a></p>
</aside>
<aside class="footnote brackets" id="arithmetic-shift" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://open4tech.com/logical-vs-arithmetic-shift">https://open4tech.com/logical-vs-arithmetic-shift</a></p>
</aside>
<aside class="footnote brackets" id="ashr" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">3</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://llvm.org/docs/LangRef.html#ashr-instruction">http://llvm.org/docs/LangRef.html#ashr-instruction</a></p>
</aside>
<aside class="footnote brackets" id="lshr" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">4</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://llvm.org/docs/LangRef.html#lshr-instruction">http://llvm.org/docs/LangRef.html#lshr-instruction</a></p>
</aside>
<aside class="footnote brackets" id="instructionsel" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">5</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://llvm.org/docs/CodeGenerator.html#selectiondag-instruction-selection-process">http://llvm.org/docs/CodeGenerator.html#selectiondag-instruction-selection-process</a></p>
</aside>
<aside class="footnote brackets" id="srem" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">6</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://llvm.org/docs/LangRef.html#srem-instruction">http://llvm.org/docs/LangRef.html#srem-instruction</a></p>
</aside>
<aside class="footnote brackets" id="expand" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">7</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://llvm.org/docs/WritingAnLLVMBackend.html#expand">http://llvm.org/docs/WritingAnLLVMBackend.html#expand</a></p>
</aside>
<aside class="footnote brackets" id="legalizetypes" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id8">8</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://llvm.org/docs/CodeGenerator.html#selectiondag-legalizetypes-phase">http://llvm.org/docs/CodeGenerator.html#selectiondag-legalizetypes-phase</a></p>
</aside>
<aside class="footnote brackets" id="quantitative" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id9">9</a><span class="fn-bracket">]</span></span>
<p>See book Computer Architecture: A Quantitative Approach (The Morgan
Kaufmann Series in Computer Architecture and Design)</p>
</aside>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="backendstructure.html">Backend structure</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="genobj.html">Generating object files</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Chen Chung-Shu.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.0.2.
    </div>
  </body>
</html>