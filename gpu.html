<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>The Concept of GPU Compiler &#8212; Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css?v=fce32b03" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css?v=4ae1632d" />
    <script src="_static/documentation_options.js?v=70bd5238"></script>
    <script src="_static/doctools.js?v=fd6eb6e6"></script>
    <script src="_static/sphinx_highlight.js?v=6ffebe34"></script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Appendix A: Getting Started: Installing LLVM and the Cpu0 Example Code" href="install.html" />
    <link rel="prev" title="Verify backend on Verilog simulator" href="verilog.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</span></a></h1>
        <h2 class="heading"><span>The Concept of GPU Compiler</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="Top">
      
        <p>
        «&#160;&#160;<a href="verilog.html">Verify backend on Verilog simulator</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="install.html">Appendix A: Getting Started: Installing LLVM and the Cpu0 Example Code</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="the-concept-of-gpu-compiler">
<span id="sec-gpu"></span><h1>The Concept of GPU Compiler<a class="headerlink" href="#the-concept-of-gpu-compiler" title="Link to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#concept-in-graphics-and-systems" id="id302">Concept in Graphics and Systems</a></p>
<ul>
<li><p><a class="reference internal" href="#d-modeling" id="id303">3D Modeling</a></p>
<ul>
<li><p><a class="reference internal" href="#animation" id="id304">Animation</a></p></li>
<li><p><a class="reference internal" href="#node-editor-shaders-generator" id="id305">Node-Editor (shaders generator)</a></p>
<ul>
<li><p><a class="reference internal" href="#id10" id="id306">Node-Editor</a></p></li>
<li><p><a class="reference internal" href="#code-generation-from-node-editor" id="id307">Code Generation from Node-Editor</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#d-modeling-tools" id="id308">3D Modeling Tools</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#graphics-hw-and-sw-stack" id="id309">Graphics HW and SW Stack</a></p>
<ul>
<li><p><a class="reference internal" href="#hw-block-diagram" id="id310">HW Block Diagram</a></p></li>
<li><p><a class="reference internal" href="#sw-stack-and-data-flow" id="id311">SW Stack and Data Flow</a></p></li>
<li><p><a class="reference internal" href="#pixels-displaying" id="id312">Pixels Displaying</a></p></li>
<li><p><a class="reference internal" href="#the-role-and-purpose-of-shaders" id="id313">The Role and Purpose of Shaders</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#basic-geometry-in-computer-graphics" id="id314">Basic geometry in computer graphics</a></p>
<ul>
<li><p><a class="reference internal" href="#color" id="id315">Color</a></p></li>
<li><p><a class="reference internal" href="#transformation" id="id316">Transformation</a></p></li>
<li><p><a class="reference internal" href="#projection" id="id317">Projection</a></p></li>
<li><p><a class="reference internal" href="#cross-product" id="id318">Cross Product</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#opengl" id="id319">OpenGL</a></p>
<ul>
<li><p><a class="reference internal" href="#example-of-opengl-program" id="id320">Example of OpenGL program</a></p></li>
<li><p><a class="reference internal" href="#d-rendering" id="id321">3D Rendering</a></p>
<ul>
<li><p><a class="reference internal" href="#animation-parameters" id="id322">Animation Parameters</a></p></li>
<li><p><a class="reference internal" href="#d-rendering-pipeline" id="id323">3D Rendering Pipeline</a></p></li>
<li><p><a class="reference internal" href="#tessellation-example" id="id324">Tessellation Example</a></p></li>
<li><p><a class="reference internal" href="#mobile-gpu-3d-rendering" id="id325">Mobile GPU 3D Rendering</a></p>
<ul>
<li><p><a class="reference internal" href="#tbdr-tilebased-deferred-rendering" id="id326">TBDR — Tile‑Based Deferred Rendering</a></p></li>
<li><p><a class="reference internal" href="#tbdr-rendering" id="id327">TBDR Rendering</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#mesh-shader-pipeline" id="id328">Mesh-Shader Pipeline</a></p></li>
<li><p><a class="reference internal" href="#animation-example" id="id329">Animation Example</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#glsl-gl-shader-language" id="id330">GLSL (GL Shader Language)</a></p>
<ul>
<li><p><a class="reference internal" href="#background" id="id331">Background</a></p></li>
<li><p><a class="reference internal" href="#examples" id="id332">Examples</a></p></li>
<li><p><a class="reference internal" href="#goals" id="id333">Goals</a></p></li>
<li><p><a class="reference internal" href="#glsl-vs-c-feature-overview" id="id334">GLSL vs. C: Feature Overview</a></p></li>
<li><p><a class="reference internal" href="#glsl-qualifiers-by-shader-stage" id="id335">GLSL Qualifiers by Shader Stage</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#opengl-shader-compiler" id="id336">OpenGL Shader Compiler</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#gpu-architecture" id="id337">GPU Architecture</a></p>
<ul>
<li><p><a class="reference internal" href="#gpu-hardware-units" id="id338">GPU Hardware Units</a></p></li>
<li><p><a class="reference internal" href="#sm-simt" id="id339">SM (SIMT)</a></p>
<ul>
<li><p><a class="reference internal" href="#sm-hardware" id="id340">SM Hardware</a></p></li>
<li><p><a class="reference internal" href="#sm-scheduling" id="id341">SM Scheduling</a></p></li>
<li><p><a class="reference internal" href="#simt-and-spmd-pipelines" id="id342">SIMT and SPMD Pipelines</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#processor-units-and-memory-hierarchy-in-nvidia-gpu" id="id343">Processor Units and Memory Hierarchy in NVIDIA GPU </a></p></li>
<li><p><a class="reference internal" href="#memory-subsystem" id="id344">Memory Subsystem</a></p>
<ul>
<li><p><a class="reference internal" href="#address-coalescing-and-gather-scatter" id="id345">Address Coalescing and Gather-scatter</a></p></li>
<li><p><a class="reference internal" href="#vram-dgpu" id="id346">VRAM dGPU</a></p></li>
<li><p><a class="reference internal" href="#regless-style-architectures" id="id347">RegLess-style architectures </a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#specialized-units" id="id348">Specialized Units</a></p>
<ul>
<li><p><a class="reference internal" href="#geometry-units" id="id349">Geometry Units</a></p></li>
<li><p><a class="reference internal" href="#rasterization-units" id="id350">Rasterization Units </a></p></li>
<li><p><a class="reference internal" href="#texture-mapping-units-tmus" id="id351">Texture Mapping Units (TMUs) </a></p></li>
<li><p><a class="reference internal" href="#render-output-units-rops" id="id352">Render Output Units (ROPs) </a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#system-features-buffers" id="id353">System Features – Buffers</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#software-structure" id="id354">Software Structure</a></p>
<ul>
<li><p><a class="reference internal" href="#general-purpose-gpu" id="id355">General purpose GPU</a></p>
<ul>
<li><p><a class="reference internal" href="#mapping-data-in-gpu" id="id356">Mapping data in GPU</a></p></li>
<li><p><a class="reference internal" href="#work-between-cpu-and-gpu-in-cuda" id="id357">Work between CPU and GPU in Cuda</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#opencl-vulkan-and-spir-v" id="id358">OpenCL, Vulkan and spir-v</a></p>
<ul>
<li><p><a class="reference internal" href="#summary" id="id359">Summary</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#unified-ir-conversion-flows" id="id360">Unified IR Conversion Flows</a></p>
<ul>
<li><p><a class="reference internal" href="#graphics-and-opencl-compilation" id="id361">Graphics and OpenCL Compilation</a></p></li>
<li><p><a class="reference internal" href="#graphics-compilation-flow-microsoft-directx-opengl" id="id362">Graphics Compilation Flow (Microsoft DirectX &amp; OpenGL)</a></p>
<ul>
<li><p><a class="reference internal" href="#references" id="id363">References</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#ml-and-gpu-compilation" id="id364">ML and GPU Compilation</a></p>
<ul>
<li><p><a class="reference internal" href="#nvidia-ir-conversion-flow" id="id365">NVIDIA IR Conversion Flow</a></p></li>
<li><p><a class="reference internal" href="#amd-ir-conversion-flow" id="id366">AMD IR Conversion Flow</a></p></li>
<li><p><a class="reference internal" href="#arm-ir-conversion-flow" id="id367">ARM IR Conversion Flow</a></p></li>
<li><p><a class="reference internal" href="#imagination-technologies-ir-conversion-flow" id="id368">Imagination Technologies IR Conversion Flow</a></p></li>
<li><p><a class="reference internal" href="#comparison-summary" id="id369">Comparison Summary</a></p></li>
<li><p><a class="reference internal" href="#id180" id="id370">References</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#accelerate-ml-dl-on-opencl-sycl" id="id371">Accelerate ML/DL on OpenCL/SYCL</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#open-sources" id="id372">Open Sources</a></p></li>
</ul>
</nav>
<p>Basically, a CPU is a SISD (Single Instruction Single Data) architecture in each
core. The multimedia instructions in CPUs are smaller-scale forms of SIMD (Single
Instruction Multiple Data), while GPUs are large-scale SIMD processors, capable of
coloring millions of image pixels in just a few milliseconds.</p>
<p>Since 2D and 3D graphic processing offers great potential for parallel data
processing, GPU hardware typically includes tens of thousands of functional units
per chip, as seen in products by NVIDIA and other manufacturers.</p>
<p>This chapter provides an overview of how 3D animation is created and executed on
a CPU+GPU system. Following that, it introduces GPU compilers and hardware
features relevant to graphics applications. Finally, it explains how GPUs have
taken on more computational tasks traditionally handled by CPUs, through the
GPGPU (General-Purpose computing on Graphics Processing Units) concept and the
emergence of related standards.</p>
<p>Website: Basic Theory of 3D Graphics with OpenGL <a class="footnote-reference brackets" href="#cg-basictheory" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>.</p>
<section id="concept-in-graphics-and-systems">
<h2><a class="toc-backref" href="#id302" role="doc-backlink">Concept in Graphics and Systems</a><a class="headerlink" href="#concept-in-graphics-and-systems" title="Link to this heading">¶</a></h2>
<section id="d-modeling">
<span id="three-d-model"></span><h3><a class="toc-backref" href="#id303" role="doc-backlink">3D Modeling</a><a class="headerlink" href="#d-modeling" title="Link to this heading">¶</a></h3>
<p>By creating 3D models with triangles or quads on a surface, the model is formed
using a polygon mesh <a class="footnote-reference brackets" href="#polygon" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>. This mesh consists of all the vertices shown in
the first image as <a class="reference internal" href="#modeling1"><span class="std std-numref">Fig. 60</span></a>.</p>
<figure class="align-center" id="id196">
<span id="modeling1"></span><a class="reference internal image-reference" href="_images/modeling1.png"><img alt="_images/modeling1.png" height="394" src="_images/modeling1.png" width="688" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 60 </span><span class="caption-text">Creating 3D model and texturing</span><a class="headerlink" href="#id196" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>After applying smooth shading <a class="footnote-reference brackets" href="#polygon" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>, the vertices and edge lines are
covered with color (or the edges are visually removed — <strong>edges never actually
have black outlines</strong>). As a result, the model appears much smoother
<a class="footnote-reference brackets" href="#shading" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>.</p>
<p>Furthermore, after texturing (texture mapping), the model looks even more
realistic <a class="footnote-reference brackets" href="#texturemapping" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a>.</p>
<section id="animation">
<span id="id6"></span><h4><a class="toc-backref" href="#id304" role="doc-backlink">Animation</a><a class="headerlink" href="#animation" title="Link to this heading">¶</a></h4>
<p>★ Animation Layers: High → Low</p>
<p>This breakdown organizes animation systems from the <strong>highest gameplay
logic</strong> down to the <strong>lowest GPU skinning</strong>, and clearly marks which
parts are controlled by the <strong>user</strong> and which parts are handled by the
<strong>3D engine</strong>.</p>
<ol class="arabic simple">
<li><p>Gameplay Animation Logic (High Level): set by user (game developer)</p></li>
</ol>
<p>See video here <a class="footnote-reference brackets" href="#animation-state-video" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a>.</p>
<p><strong>Examples</strong></p>
<ul class="simple">
<li><p>Play “walk” when speed &gt; 0.1</p></li>
<li><p>Trigger “jump” on button press</p></li>
<li><p>Switch to “attack” when enemy detected</p></li>
<li><p>Blend run when velocity increases</p></li>
</ul>
<p><strong>Where it lives</strong></p>
<p>Live in <strong>gameplay scripts</strong> (C#, Blueprints, GDScript, Python)</p>
<ul class="simple">
<li><p>Unity: C# scripts</p></li>
<li><p>Unreal: Blueprints or C++</p></li>
<li><p>Godot: GDScript</p></li>
<li><p>ThinMatrix: Java (no scripting layer)</p></li>
</ul>
<p>This layer decides <em>when</em> animations should play.</p>
<ol class="arabic simple" start="2">
<li><p>Animation State Machine / Animation Graph: set by user (game developer)</p></li>
</ol>
<p><strong>Examples</strong></p>
<ul class="simple">
<li><p>Idle → Walk → Run transitions</p></li>
<li><p>Blend trees</p></li>
<li><p>Animation layers (upper body, lower body)</p></li>
<li><p>Animation parameters (speed, grounded, direction)</p></li>
</ul>
<p><strong>Where it lives</strong></p>
<ul class="simple">
<li><p>Unity: Animator Controller</p></li>
<li><p>Unreal: Animation Blueprint</p></li>
<li><p>Godot: AnimationTree</p></li>
<li><p>ThinMatrix: <em>Does not have this layer</em></p></li>
</ul>
<p>This layer controls <em>which</em> animation clip is active and how transitions
occur.</p>
<ol class="arabic simple" start="3">
<li><p>Animation Clip Playback Layer: user chooses</p></li>
</ol>
<p>An <strong>animation clip</strong> is <strong>a sequence of keyframes</strong> over a period of time that
represents a <strong>motion or action</strong>.</p>
<p><strong>Examples</strong></p>
<ul class="simple">
<li><p>Play animation clip</p></li>
<li><p>Loop animation</p></li>
<li><p>Set animation speed</p></li>
<li><p>Crossfade between clips</p></li>
<li><p>Blend two clips together</p></li>
</ul>
<p><strong>Who sets it?</strong>
User chooses which clip to play.</p>
<p><strong>Who implements it?</strong>
Engine handles blending, timing, and playback.</p>
<p><strong>Where it lives</strong></p>
<ul class="simple">
<li><p>Unity: Mecanim runtime</p></li>
<li><p>Unreal: AnimInstance</p></li>
<li><p>Godot: AnimationPlayer</p></li>
<li><p>ThinMatrix: Java engine code (Animator.java)</p></li>
</ul>
<p>This layer executes the user’s choices.</p>
<ol class="arabic simple" start="4">
<li><p>Skeleton Animation System (Low Level): 3D engine implements it</p></li>
</ol>
<p><strong>Examples</strong></p>
<ul class="simple">
<li><p>Bone hierarchy</p></li>
<li><p>Keyframe interpolation</p></li>
<li><p>Joint transforms</p></li>
<li><p>Matrix palette generation</p></li>
<li><p>Pose calculation</p></li>
</ul>
<p><strong>Who sets it?</strong>
Engine</p>
<p><strong>Who uses it?</strong>
User indirectly, by playing animations.</p>
<p><strong>Where it lives</strong></p>
<ul class="simple">
<li><p>Unity: C++ engine core</p></li>
<li><p>Unreal: C++ engine core</p></li>
<li><p>Godot: C++ engine core</p></li>
<li><p>ThinMatrix: Java engine code (he writes this manually)</p></li>
</ul>
<p>This layer performs the mathematical work of animation.</p>
<ol class="arabic simple" start="5">
<li><p>GPU Skinning (Lowest Level): 3D engine implements it</p></li>
</ol>
<p><strong>Examples</strong></p>
<ul class="simple">
<li><p>Vertex shader skinning</p></li>
<li><p>Applying bone matrices</p></li>
<li><p>Weighted vertex deformation</p></li>
<li><p>Sending matrices to GPU</p></li>
</ul>
<p><strong>Who sets it?</strong>
Engine</p>
<p><strong>Who uses it?</strong>
User never touches this layer directly (except in custom engines).</p>
<p><strong>Where it lives</strong></p>
<ul class="simple">
<li><p>Unity: C++ + HLSL</p></li>
<li><p>Unreal: C++ + HLSL</p></li>
<li><p>Godot: C++ + GLSL</p></li>
<li><p>ThinMatrix: GLSL shader he writes manually</p></li>
</ul>
<p>This is the final stage where the GPU deforms the mesh.</p>
<p>Full Hierarchy (Summary)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>HIGH LEVEL (User)
──────────────────────────────────────────────
1. Gameplay Animation Logic
2. Animation State Machine / Animation Graph
3. Animation Clip Playback

LOW LEVEL (Engine)
──────────────────────────────────────────────
4. Skeleton Animation System
5. GPU Skinning
</pre></div>
</div>
<p>Developers only write the highest‑level animation logic and designed
transitions &amp; blends as shown in <a class="reference internal" href="#animation-levels"><span class="std std-numref">Fig. 61</span></a>.
The engine automatically handles all lower‑level animation work.
Like the video <a class="footnote-reference brackets" href="#animation-state-video" id="id8" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a>, Jason’s tutorials operate only in
Level 1 and Level 2:</p>
<p>✔ Level 1 — Scripts</p>
<p>He writes code like:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">animator</span><span class="p">.</span><span class="n">SetFloat</span><span class="p">(</span><span class="s">&quot;Speed&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">speed</span><span class="p">);</span>
</pre></div>
</div>
<p>✔ Level 2 — State Machine</p>
<p>He configures transitions and parameters.</p>
<figure class="align-default" id="id197">
<span id="animation-levels"></span><div class="graphviz"><img src="_images/graphviz-d5aaecd7d1d38ca7ea793a9abfc39f0c4b548ed0.png" alt="digraph AnimationLayers {
    rankdir=TB;
    node [shape=box, style=rounded, fontsize=12];

    High1 [label=&quot;1. Gameplay Animation Logic\n(User scripts / gameplay code)&quot;];
    High2 [label=&quot;2. Animation State Machine / Animation Graph\n(User-designed transitions &amp; blends)&quot;];
    Mid  [label=&quot;3. Animation Clip Playback\n(Engine-controlled timing &amp; blending)&quot;];
    Low1 [label=&quot;4. Skeleton Animation System\n(Bone transforms, keyframe interpolation)&quot;];
    Low2 [label=&quot;5. GPU Skinning\n(Vertex shader applies bone matrices)&quot;];

    High1 -&gt; High2 [label=&quot;animation intent\n(e.g., walk, run, jump)&quot;];
    High2 -&gt; Mid   [label=&quot;selected clip + blend parameters&quot;];
    Mid   -&gt; Low1  [label=&quot;sampled pose\n(bone transforms per frame)&quot;];
    Low1  -&gt; Low2  [label=&quot;matrix palette\n(bone matrices sent to GPU)&quot;];
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 61 </span><span class="caption-text">Animation levels</span><a class="headerlink" href="#id197" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>ThinMatrix’s engine collapses the top three layers into Java because it
has <strong>no scripting layer</strong> and <strong>no animation graph</strong>, so the user must
modify the engine code directly.</p>
<p>According to the video on ThinMatrix’s skeleton animation <a class="footnote-reference brackets" href="#animation1" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a>,
he is sampling the animation clip at different times.
The animation clip already contains: keyframes, bone transforms, timestamps,
interpolation curves.
All of this comes from Blender’s exported .dae file.
Joints are positioned at different poses at specific times (keyframes), as
illustrated in <a class="reference internal" href="#animationfigure"><span class="std std-numref">Fig. 62</span></a>.</p>
<figure class="align-center" id="id198">
<span id="animationfigure"></span><a class="reference internal image-reference" href="_images/animation.png"><img alt="_images/animation.png" height="497" src="_images/animation.png" width="962" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 62 </span><span class="caption-text">Get time points at keyframes</span><a class="headerlink" href="#id198" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Although most of 3D game engines are written C++, <strong>ThinMatrix’s engine</strong> is
100% Java.
In this series of videos, you will see that he writes new Java engine modules,
edits existing engine code, loads animation data from Blender, interpolates
keyframes, updates bone matrices and sends them to the GPU.
Because ThinMatrix’s engine is <strong>tiny and educational</strong> for engine programmer or
game developer, does not provide Scripting Layer (such as C#, Python, GDScript,
Blueprints) most commercial 3D engines.
Instead, he modifies ThinMatrix’s Java engine directly, which differs from most
other 3D engines operate.</p>
<p><strong>Animation flow</strong></p>
<p>Every modern 3D animation tool comes with its own <strong>built‑in render engine</strong>,
and often more than one. In 3D game design, <strong>game engines (Unity, Unreal,
Godot) use real‑time engines</strong> for real-time animation.</p>
<p><strong>Pipeline: Blender → Engine → OpenGL</strong></p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>+------------------+
|     Blender      |
|  (Modeling Tool) |
+------------------+
          |
          |  Exports assets:
          |  - Meshes (.obj, .fbx, .gltf)
          |  - Armatures / bones
          |  - Animations (keyframes)
          |  - Textures (PNG, EXR, TGA)
          v
+---------------------------+
|       Game Engine         |
| (Unity, Unreal, Godot,    |
|  LWJGL, JOGL, Custom)     |
+---------------------------+
          |
          |  Engine loads assets:
          |  - Parses mesh data
          |  - Loads skeletons
          |  - Loads animation curves
          |  - Loads materials/shaders
          |
          |  Engine code you write:
          |  - Java (JOGL/LWJGL)
          |  - C++ (custom engine)
          |  - C# (Unity)
          |  - GDScript/C++ (Godot)
          |
          |  Engine compiles shaders:
          |  - GLSL (OpenGL)
          |  - HLSL (DirectX)
          |  - SPIR-V (Vulkan)
          v
+---------------------------+
|         Renderer          |
|    (OpenGL / Vulkan /     |
|     DirectX / Metal)      |
+---------------------------+
          |
          |  GPU receives:
          |  - Vertex buffers
          |  - Index buffers
          |  - Textures
          |  - Uniforms (matrices, bones)
          |  - Compiled shaders
          v
+---------------------------+
|            GPU            |
| (Vertex Shader → Raster → |
|  Fragment Shader → Frame) |
+---------------------------+
          |
          v
+---------------------------+
|        Final Image        |
|     (On your screen)      |
+---------------------------+
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<dl class="simple">
<dt>3D modeling tools do store animation and movement data</dt><dd><p>— but they do NOT store any rendering or API‑specific code.</p>
</dd>
<dt>Game engines do store animation data</dt><dd><p>— but programmers still write the logic that plays, blends,
and controls those animations.</p>
</dd>
</dl>
</div>
<p id="movement"><strong>Animation Data vs. Movement Speed in Games</strong></p>
<p>List the animation types in a table for inclusion in this book.</p>
<table class="docutils align-default" id="id199">
<caption><span class="caption-number">Table 46 </span><span class="caption-text">Animation Types</span><a class="headerlink" href="#id199" title="Link to this table">¶</a></caption>
<colgroup>
<col style="width: 20.0%" />
<col style="width: 25.0%" />
<col style="width: 35.0%" />
<col style="width: 20.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong>Animation Type</strong></p></th>
<th class="head"><p>What Moves</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>GPU Requirement</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>Transform Animation</strong></p></td>
<td><p>Object transform</p></td>
<td><p>The entire mesh moves as a rigid body using
position, rotation, and scale. No vertex-level
deformation occurs.</p></td>
<td><p>Optional (fixed-function or shaders)</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Skinning</strong></p></td>
<td><p>Vertex positions</p></td>
<td><p>Vertices are blended by bone matrices to deform
the mesh (arms bending, legs walking). Requires
per-vertex matrix blending.</p></td>
<td><p>Requires shaders</p></td>
</tr>
<tr class="row-even"><td><p><strong>Morph Target Animation</strong></p></td>
<td><p>Vertex positions</p></td>
<td><p>Vertices blend between multiple stored shapes
(facial expressions, muscle bulges). Uses morph
weights to interpolate.</p></td>
<td><p>Requires shaders</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Procedural Deformation</strong></p></td>
<td><p>Vertex positions</p></td>
<td><p>Vertices are modified by mathematical functions
(wind, waves, noise, squash-and-stretch). Driven
by time or simulation parameters.</p></td>
<td><p>Requires shaders</p></td>
</tr>
</tbody>
</table>
<p><strong>Example: Walking Animation: Skinning + Transform Animation</strong></p>
<p>When a character walks in a game, the animation is produced by two
different systems working together:</p>
<ol class="arabic simple">
<li><p><strong>Skinning (Bone Animation)</strong>
Skinning is responsible for deforming the mesh. It drives the motion
of limbs such as legs, arms, spine, and feet. Without skinning, the
character would move as a rigid statue with no bending or articulation.</p></li>
<li><p><strong>Transform Animation (Rigid-Body Movement)</strong>
Transform animation moves the entire character through the world.
This includes translation, rotation, and root motion. Without transform
animation, the character would walk in place without actually moving
forward.</p>
<ul class="simple">
<li><p>Root bone: the bone that represents the entire object’s transform —
the top‑most parent of the hierarchy. An example of person:</p></li>
</ul>
</li>
</ol>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Root
 └─ Pelvis
     ├─ Spine
     │   ├─ Chest
     │   │   ├─ Neck
     │   │   │   └─ Head
     │   │   └─ Shoulders
     │   │       ├─ Arm_L
     │   │       └─ Arm_R
     ├─ Leg_L
     └─ Leg_R
</pre></div>
</div>
<p>Both systems are required to create a complete walking animation:</p>
<ul class="simple">
<li><p><strong>Skinning</strong> provides the internal limb motion.</p></li>
<li><p><strong>Transform animation</strong> provides the external world-space movement.</p></li>
</ul>
<p>Together, they produce the final effect of a character walking naturally
through the environment.</p>
<p>The following explains what animation data 3D modeling tools store, what
game engines store, and what programmers must implement manually. It also
clarifies the relationship between animation curves, movement speed, and
gameplay logic.</p>
<ol class="arabic simple">
<li><p>What 3D Modeling Tools Actually Store</p></li>
</ol>
<p>3D modeling and animation tools such as Blender, Maya, and 3ds Max store
<strong>animation data</strong>, not gameplay logic.</p>
<p>They <strong>do store</strong>:</p>
<ul class="simple">
<li><p>Keyframes (frame 0, frame 10, frame 24, etc.)</p></li>
<li><p>Bone transforms at each keyframe</p></li>
<li><p>Interpolation curves (Bezier, linear, quaternion)</p></li>
<li><p>Animation duration (e.g., 1.2 seconds)</p></li>
<li><p>Frame rate (e.g., 24 fps)</p></li>
<li><p>Skeleton hierarchy</p></li>
<li><p>Skin weights (vertex-to-bone influences)</p></li>
<li><p>Optional root bone motion (displacement over time)</p></li>
</ul>
<p>Modeling tools produce <strong>data</strong>, not rendering code and not gameplay rules in
OpenGL/DirectX code.</p>
<p>Example:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Bone &quot;Arm&quot; rotation at frame 0 = (0°, 0°, 0°)
Bone &quot;Arm&quot; rotation at frame 10 = (45°, 0°, 0°)
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p>What Game Engines Actually Store</p></li>
</ol>
<p>The <strong>engine’s built‑in C++ renderer handles all OpenGL/Vulkan/Metal calls
automatically</strong>.
Game engines such as Unity, Unreal Engine, Godot, or custom engines store
and manage animation data, but still do not define gameplay movement speed.</p>
<p>They <strong>do store</strong>:</p>
<ul class="simple">
<li><p>Animation clips</p></li>
<li><p>State machines (Idle → Walk → Run)</p></li>
<li><p>Blend trees</p></li>
<li><p>Transition rules</p></li>
<li><p>Animation events</p></li>
<li><p>Curves for rotation, scaling, and root motion</p></li>
</ul>
<p>Again: data, not OpenGL/DirectX code.</p>
<p>Example:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>If speed &lt; 0.1 → Idle
If speed &gt; 0.1 → Walk
If speed &gt; 4.0 → Run
</pre></div>
</div>
<p>This is engine logic, not GPU code.</p>
<p>Game engines interpret animation data but rely on programmer logic to
control how characters move in the world.</p>
<ol class="arabic simple" start="3">
<li><p>What Programmers Must Implement</p></li>
</ol>
<p>Programmers write the <strong>logic</strong> that uses animation data to move objects.</p>
<p>Examples:</p>
<p>In Unity (C#)</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">animator</span><span class="p">.</span><span class="n">SetFloat</span><span class="p">(</span><span class="s">&quot;speed&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">playerVelocity</span><span class="p">);</span>
<span class="p">...</span>
<span class="kt">float</span><span class="w"> </span><span class="n">speed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.5f</span><span class="p">;</span>
<span class="n">transform</span><span class="p">.</span><span class="n">position</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">speed</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Time</span><span class="p">.</span><span class="n">deltaTime</span><span class="p">;</span>
</pre></div>
</div>
<p>In a custom engine (C++/OpenGL)</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">shader</span><span class="p">.</span><span class="n">setMatrix</span><span class="p">(</span><span class="s">&quot;boneMatrices[0]&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">boneMatrix</span><span class="p">);</span>
<span class="p">...</span>
<span class="kt">float</span><span class="w"> </span><span class="n">velocity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.5f</span><span class="p">;</span>
<span class="n">position</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">velocity</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">deltaTime</span><span class="p">;</span>
</pre></div>
</div>
<p>In JOGL/LWJGL (Java)</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">boneLocation</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="n">boneMatrixBuffer</span><span class="p">);</span>
<span class="p">...</span>
<span class="kt">float</span><span class="w"> </span><span class="n">velocity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.5f</span><span class="p">;</span>
<span class="n">position</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">velocity</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">deltaTime</span><span class="p">;</span>
</pre></div>
</div>
<p>Programmers write:</p>
<p>Programmers implement:</p>
<ul class="simple">
<li><p>Movement speed</p>
<ul>
<li><p>E.g. <strong>Set the value for speed or velocity as the code above.</strong></p></li>
</ul>
</li>
<li><p>Acceleration and deceleration</p></li>
<li><p>Physics integration</p></li>
<li><p>AI movement</p></li>
<li><p>Player input</p></li>
<li><p>Animation blending logic</p></li>
<li><p>Uploading bone matrices to the GPU</p></li>
<li><p>GLSL shader code for skinning</p></li>
</ul>
<p>Animation data is <em>used</em> by code, not replaced by it.</p>
<ol class="arabic simple" start="4">
<li><p>Root Motion vs. Movement Speed</p></li>
</ol>
<p>Some animations include <strong>root motion</strong>, where the root bone moves forward
during a walk cycle. Modeling tools export this as bone displacement over
time, but they still do <strong>not</strong> define speed.</p>
<p>Example:</p>
<p>If the root bone moves 1 meter in 0.5 seconds, the engine can compute:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">speed</span> <span class="o">=</span> <span class="mi">1</span><span class="n">m</span> <span class="o">/</span> <span class="mf">0.5</span><span class="n">s</span> <span class="o">=</span> <span class="mi">2</span> <span class="n">m</span><span class="o">/</span><span class="n">s</span>
</pre></div>
</div>
<p>However:</p>
<ul class="simple">
<li><p>Blender does not store “2 m/s”</p></li>
<li><p>The engine derives speed from displacement</p></li>
<li><p>Programmers decide whether to use root motion or in-place animation</p></li>
</ul>
<ol class="arabic simple" start="5">
<li><p>Summary Table</p></li>
</ol>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Concept</p></th>
<th class="head"><p>Stored in Blender?</p></th>
<th class="head"><p>Stored in Engine?</p></th>
<th class="head"><p>Controlled by Programmer?</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Keyframes</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-odd"><td><p>Bone transforms</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-even"><td><p>Animation length</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-odd"><td><p>Movement speed</p></td>
<td><p>No</p></td>
<td><p>Yes (derived)</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-even"><td><p>Physics movement</p></td>
<td><p>No</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p>AI movement</p></td>
<td><p>No</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="6">
<li><p>Final Clarification</p></li>
</ol>
<ul class="simple">
<li><p><strong>3D modeling tools store animation timing, not gameplay speed.</strong></p></li>
<li><p><strong>Game engines store animation clips, not movement speed.</strong></p></li>
<li><p><strong>Programmers control movement speed, physics, and gameplay behavior.</strong></p></li>
<li><p><strong>No tool generates JOGL/OpenGL/Vulkan/DirectX code.</strong></p></li>
<li><p><strong>All rendering API calls are written by engine developers or by you in a
custom engine.</strong></p></li>
</ul>
<p><strong>Example for accelerating playing</strong></p>
<p>Animation Speed vs Engine Rendering (5× Speed)</p>
<p>The following table shows how animation playback, movement speed, and GPU
rendering interact when the gameplay speed is multiplied by five. The
animation remains 24 fps internally, but its playback time advances five
times faster. The GPU continues to render at 60 fps and samples the
animation at the current time.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Property</p></th>
<th class="head"><p>Original Value</p></th>
<th class="head"><p>After 5× Speed</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Animation FPS (baked)</p></td>
<td><p>24 fps</p></td>
<td><p>24 fps (unchanged)</p></td>
</tr>
<tr class="row-odd"><td><p>Animation Playback Speed</p></td>
<td><p>1×</p></td>
<td><p>5×</p></td>
</tr>
<tr class="row-even"><td><p>Steps per Second</p></td>
<td><p>6 steps/sec</p></td>
<td><p>30 steps/sec</p></td>
</tr>
<tr class="row-odd"><td><p>Movement Speed</p></td>
<td><p>6 m/sec</p></td>
<td><p>30 m/sec</p></td>
</tr>
<tr class="row-even"><td><p>GPU Rendering FPS</p></td>
<td><p>60 fps</p></td>
<td><p>60 fps</p></td>
</tr>
<tr class="row-odd"><td><p>Engine Playing Frames
(What GPU Displays)</p></td>
<td><p>Samples animation
at 60 fps</p></td>
<td><p>Samples animation at
60 fps (skips/interpolates
intermediate animation
frames)</p></td>
</tr>
</tbody>
</table>
<p>Summary:</p>
<ul class="simple">
<li><p>The animation does <strong>not</strong> become 120 fps; it is simply played 5× faster.</p></li>
<li><p>The runner appears to take <strong>30 steps per second</strong> and move <strong>30 meters per
second</strong>.</p></li>
<li><p>The GPU still renders <strong>60 frames per second</strong>.</p></li>
<li><p>The engine <strong>samples</strong> the animation at each rendered frame, so it
effectively displays every fifth animation sample, using interpolation
for smoothness. For this case, it may display <strong>1 out of 2 animation frames</strong>
from 3D modeling.</p></li>
</ul>
</section>
<section id="node-editor-shaders-generator">
<span id="node-editor"></span><h4><a class="toc-backref" href="#id305" role="doc-backlink">Node-Editor (shaders generator)</a><a class="headerlink" href="#node-editor-shaders-generator" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>3D animation tools (Blender, Maya, Houdini) use render engines and node
editors for materials, lighting, and effects.</p></li>
<li><p>Game engines (Unity, Unreal, Godot) use real‑time engines and node editors
for shaders, VFX, and sometimes logic.</p></li>
</ul>
<p>A node editor defines the <strong>entire material</strong> that is applied to the
surface of a 3D object. The shader generated from the node graph runs on
<strong>every pixel</strong> (fragment) of the object’s surface. In this sense, the
node editor controls the <strong>whole surface</strong>, not only a specific region.</p>
<p>However, the node graph can include <strong>masks</strong>, <strong>textures</strong>, <strong>vertex
colors</strong>, or <strong>procedural patterns</strong> that allow the artist to specify
which <em>parts</em> of the surface receive a particular effect. These masks do
not limit the shader to only part of the surface; instead, they instruct
the shader how to behave differently across different regions.</p>
<section id="id10">
<h5><a class="toc-backref" href="#id306" role="doc-backlink">Node-Editor</a><a class="headerlink" href="#id10" title="Link to this heading">¶</a></h5>
<p><strong>Example</strong></p>
<p>Let’s say you want:</p>
<ul class="simple">
<li><p>rust only on the edges</p></li>
<li><p>metal everywhere else</p></li>
</ul>
<p>In the node editor:</p>
<ol class="arabic simple">
<li><p>Load a rust texture</p></li>
<li><p>Load a metal texture</p></li>
<li><p>Use a mask (curvature or hand-painted)</p></li>
<li><p>Mix them using a Mix node</p></li>
</ol>
<p>The shader still runs on the whole surface, but the mask tells it:</p>
<ul class="simple">
<li><p>“Use rust here”</p></li>
<li><p>“Use metal here”</p></li>
</ul>
<p>In summary:</p>
<ul class="simple">
<li><p>The node editor defines the <strong>full material</strong> for the <strong>entire
surface</strong>.</p></li>
<li><p>Artists can use masks or textures to <strong>target specific areas</strong> within
that surface.</p></li>
<li><p>The shader still executes globally, but its <strong>output varies</strong> based on
the mask inputs.</p></li>
</ul>
<p>Thus, a node editor controls the whole surface, while masks determine how
different parts of that surface are shaded.</p>
<p>For 3D video game engines,
the only case where mask data is inside the model file is vertex colors.
Everything else lives in textures or material/shader assets.</p>
<p><strong>Procedural Rust on Edges Using Shader Nodes</strong></p>
<p>To demonstrate how to create a <strong>rust-on-edges</strong> material using Blender’s shader
node editor as shown in <a class="reference internal" href="#node-editor-ex1"><span class="std std-numref">Fig. 63</span></a>.
The goal is to reproduce the effect commonly used on metal containers: clean
metal on flat surfaces and rust accumulation along exposed edges.</p>
<figure class="align-center" id="id200">
<span id="node-editor-ex1"></span><a class="reference internal image-reference" href="_images/node-editor-ex1.png"><img alt="Full-width image" height="440" src="_images/node-editor-ex1.png" width="782" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 63 </span><span class="caption-text">An example to Rust on Edges Using Shader Nodes <a class="footnote-reference brackets" href="#node-editor-web1" id="id11" role="doc-noteref"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></a>.</span><a class="headerlink" href="#id200" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The technique relies on three core ideas:</p>
<ol class="arabic simple">
<li><p>Detecting edges using the <em>Bevel</em> or <em>Pointiness</em> attribute.</p></li>
<li><p>Creating a mask that isolates only the worn edges.</p></li>
<li><p>Blending a rust material with a metal material using that mask.</p></li>
</ol>
<p>This workflow is fully procedural and does not require painting or
external textures.</p>
<p>Procedural Edge Wear Node Graph (ASCII Diagram) to create
<a class="reference internal" href="#node-editor-ex1"><span class="std std-numref">Fig. 63</span></a> in video <a class="footnote-reference brackets" href="#node-editor-web1" id="id12" role="doc-noteref"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></a> includes
1. edge detection, 2. mask breakup, 3. material creation, and 4. final blending
as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>+================================================================+
|                    1.  EDGE DETECTION BLOCK                    |
|                     (Generating an Edge-Wear Mask)             |
+================================================================+

   Geometry Node
        |
        |----&gt; Pointiness (Cycles only)
        |
   Bevel Node (Eevee/Cycles)
        Radius = 0.01–0.03
        |
        v
   ColorRamp (Sharpen edge highlight)
        |
        v
   Edge Mask (base convex-edge detection)


+================================================================+
|              2. MASK BREAKUP / RANDOMIZATION BLOCK             |
|               (Refining the Mask With Noise Textures)          |
+================================================================+

   Noise Texture (Scale 5–15)
        |
        v
   ColorRamp (optional shaping)
        |
        v
   Multiply Node  &lt;---------------- Edge Mask
        |
        v
   ColorRamp (final threshold control)
        |
        v
   Final Edge Wear Mask

material creation
+================================================================+
|                      3. MATERIAL BLOCK                         |
|                       (Base Material Structure)                |
+================================================================+

   METAL MATERIAL:
        Principled BSDF
        Metallic = 1.0
        Roughness = 0.2–0.4

   RUST MATERIAL:
        Principled BSDF
        Base Color = orange/brown
        Roughness = 0.7–1.0
        Optional Noise → color variation
        Optional Bump → rust height


+================================================================+
|                      4. BLENDING BLOCK                         |
|                       (Blending Metal and Rust Materials)      |
+================================================================+

   Metal BSDF ----------------------+
                                    |
                                    v
                               Mix Shader ----&gt; Material Output
                                    ^
                                    |
   Rust BSDF -----------------------+
                                    |
                                    |
                         Final Edge Wear Mask (Fac)
</pre></div>
</div>
</section>
<section id="code-generation-from-node-editor">
<h5><a class="toc-backref" href="#id307" role="doc-backlink">Code Generation from Node-Editor</a><a class="headerlink" href="#code-generation-from-node-editor" title="Link to this heading">¶</a></h5>
<p>Node-based shader editors are visual tools used in modern game engines
and DCC (Digital Content Creation) software. They allow users to build
shaders by connecting nodes instead of writing GLSL, HLSL, or Metal code
manually. These editors <strong>do generate shader code automatically</strong>.</p>
<ol class="arabic simple">
<li><p>Node-Based Editors Do Generate Shader Code</p></li>
</ol>
<p>Node-based shader editors such as:</p>
<ul class="simple">
<li><p>Unity Shader Graph</p></li>
<li><p>Unreal Engine Material Editor</p></li>
<li><p>Godot Visual Shader Editor</p></li>
<li><p>Blender Shader Nodes (for Eevee/Cycles)</p></li>
</ul>
<p>all <strong>compile the visual node graph into real shader code</strong>.</p>
<p>Depending on the engine, the generated code may be:</p>
<ul class="simple">
<li><p>GLSL (OpenGL / Vulkan)</p></li>
<li><p>HLSL (DirectX)</p></li>
<li><p>MSL (Metal)</p></li>
<li><p>SPIR-V (Vulkan intermediate format)</p></li>
</ul>
<p>The generated code is usually not shown to the user, but it is compiled
and sent to the GPU at runtime.</p>
<ol class="arabic simple" start="2">
<li><p>How Users Generate Shader Code with Nodes</p></li>
</ol>
<p>The workflow for generating shader code through a node editor typically
looks like this:</p>
<ol class="arabic simple">
<li><p>The user opens the shader editor.</p></li>
<li><p>The user creates nodes representing:
- math operations (add, multiply, dot product)
- texture sampling
- lighting functions
- color adjustments
- UV transformations</p></li>
<li><p>The user connects nodes visually to define the shader logic.</p></li>
<li><p>The engine converts the node graph into an internal shader
representation.</p></li>
<li><p>The engine compiles this representation into platform-specific shader
code (GLSL, HLSL, MSL, or SPIR-V).</p></li>
<li><p>The compiled shader is sent to the GPU and used for rendering.</p></li>
</ol>
<p>The user never writes the shader code directly; the editor generates it
automatically.</p>
<ol class="arabic simple" start="3">
<li><p>Who Is the “User” of Node-Based Editors?</p></li>
</ol>
<p>The typical users of node-based shader editors are:</p>
<dl class="simple">
<dt><strong>Graphics Designers / Technical Artists</strong></dt><dd><ul class="simple">
<li><p>Primary users.</p></li>
<li><p>They create visual effects, materials, and surface shaders.</p></li>
<li><p>They usually do not write GLSL or HLSL manually.</p></li>
<li><p>Node editors allow them to work visually without programming.</p></li>
</ul>
</dd>
<dt><strong>Software Programmers / Graphics Programmers</strong></dt><dd><ul class="simple">
<li><p>Secondary users.</p></li>
<li><p>They may create custom nodes or extend the shader system.</p></li>
<li><p>They write low-level shader code when needed.</p></li>
<li><p>They integrate the generated shaders into the rendering pipeline.</p></li>
</ul>
</dd>
</dl>
<p>In most workflows:</p>
<ul class="simple">
<li><p><strong>Graphics designers</strong> build the shader visually.</p></li>
<li><p><strong>The engine</strong> generates the shader code.</p></li>
<li><p><strong>Programmers</strong> handle advanced logic, optimization, or custom nodes.</p></li>
</ul>
<ol class="arabic simple" start="4">
<li><p>Summary</p></li>
</ol>
<ul class="simple">
<li><p>Node-based shader editors <strong>do generate shader code</strong> automatically.</p></li>
<li><p>Users generate shaders by connecting visual nodes rather than writing
GLSL/HLSL manually.</p></li>
<li><p>The primary “user” is the <strong>graphics designer or technical artist</strong>.</p></li>
<li><p>Programmers support the system by writing custom nodes or low-level
shaders when needed.</p></li>
</ul>
<p>The shaders introduction is illustrated in the next section <a class="reference internal" href="#opengl"><span class="std std-ref">OpenGL</span></a>.</p>
</section>
</section>
<section id="d-modeling-tools">
<h4><a class="toc-backref" href="#id308" role="doc-backlink">3D Modeling Tools</a><a class="headerlink" href="#d-modeling-tools" title="Link to this heading">¶</a></h4>
<p>Every CAD software manufacturer, such as AutoDesk and Blender, has their own
proprietary format. To solve interoperability problems, neutral or open source
formats were created as intermediate formats to convert between proprietary
formats.</p>
<p>Naturally, these neutral formats have become very popular. Two famous examples
are STL (with a <cite>.STL</cite> extension) and COLLADA (with a <cite>.DAE</cite> extension). Below
is a list showing 3D file formats along with their types.</p>
<table class="docutils align-default" id="id201">
<caption><span class="caption-number">Table 47 </span><span class="caption-text">3D file formats <a class="footnote-reference brackets" href="#dfmt" id="id13" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a></span><a class="headerlink" href="#id201" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>3D file format</p></th>
<th class="head"><p>Type</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>STL</p></td>
<td><p>Neutral</p></td>
</tr>
<tr class="row-odd"><td><p>OBJ</p></td>
<td><p>ASCII variant is neutral, binary variant is proprietary</p></td>
</tr>
<tr class="row-even"><td><p>FBX</p></td>
<td><p>Proprietary</p></td>
</tr>
<tr class="row-odd"><td><p>COLLADA</p></td>
<td><p>Neutral</p></td>
</tr>
<tr class="row-even"><td><p>3DS</p></td>
<td><p>Proprietary</p></td>
</tr>
<tr class="row-odd"><td><p>IGES</p></td>
<td><p>Neutral</p></td>
</tr>
<tr class="row-even"><td><p>STEP</p></td>
<td><p>Neutral</p></td>
</tr>
<tr class="row-odd"><td><p>VRML/X3D</p></td>
<td><p>Neutral</p></td>
</tr>
</tbody>
</table>
<p>The four key features a 3D file can store include the model’s geometry, the
model’s surface texture, scene details, and animation of the model <a class="footnote-reference brackets" href="#dfmt" id="id14" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a>.</p>
<p>Specifically, they can store details about four key features of a 3D model,
though it’s worth bearing in mind that you may not always take advantage of
all four features in all projects, and not all file formats support all four
features!</p>
<p>3D printer applications do not to support animation. CAD and CAM such as
designing airplane does not need feature of scene details.</p>
<p>DAE (Collada) appeared in the video animation above.
Collada files  belong to a neutral format used heavily in the video game and
film industries. It’s managed by the non-profit technology consortium, the
Khronos Group.</p>
<p>The file extension for the Collada format is .dae.
The Collada format stores data using the XML mark-up language.</p>
<p>The original intention behind the Collada format was to become a standard among
3D file formats. Indeed, in 2013, it was adopted by ISO as a publicly available
specification, ISO/PAS 17506. As a result, many 3D modeling programs support
the Collada format.</p>
<p>That said, the consensus is that the Collada format hasn’t kept up with the
times. It was once used heavily as an interchange format for Autodesk Max/Maya
in film production, but the industry has now shifted more towards OBJ, FBX,
and Alembic <a class="footnote-reference brackets" href="#dfmt" id="id15" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a>.</p>
</section>
</section>
<section id="graphics-hw-and-sw-stack">
<span id="ghast"></span><h3><a class="toc-backref" href="#id309" role="doc-backlink">Graphics HW and SW Stack</a><a class="headerlink" href="#graphics-hw-and-sw-stack" title="Link to this heading">¶</a></h3>
<p>This section provides a more detailed illustration of animation accross the
software and hardware stacks on both CPU and GPU, and explains how data flows
between the CPU, the GPU, and each layer of the software stack.</p>
<p>In the previous section <a class="reference internal" href="#three-d-model"><span class="std std-ref">3D Modeling</span></a>, described what information 3D
models store and how this information is used to perform animation.</p>
<p>In the incoming section <a class="reference internal" href="#sw-stack"><span class="std std-ref">SW Stack and Data Flow</span></a> will describe <strong>how each frame is
generated</strong> to display the <strong>movement animation or skinning effects</strong> using the
small animation parameters stored in 3D model and sent from CPU.</p>
<p>The the incoming section <a class="reference internal" href="#role-shaders"><span class="std std-ref">Role and Purpose of Shaders</span></a> will
explain different visual effects can be achieved by <strong>switching shaders</strong> to
shapplying different materials across frames.</p>
<p>Reference:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Free_and_open-source_graphics_device_driver">https://en.wikipedia.org/wiki/Free_and_open-source_graphics_device_driver</a></p></li>
</ul>
<section id="hw-block-diagram">
<h4><a class="toc-backref" href="#id310" role="doc-backlink">HW Block Diagram</a><a class="headerlink" href="#hw-block-diagram" title="Link to this heading">¶</a></h4>
<p>The block diagram of the Graphic Processing Unit (GPU) is shown in
<a class="reference internal" href="#gpu-block-diagram"><span class="std std-numref">Fig. 64</span></a>.</p>
<figure class="align-center" id="id202">
<span id="gpu-block-diagram"></span><a class="reference internal image-reference" href="_images/gpu-block-diagram.png"><img alt="_images/gpu-block-diagram.png" height="376" src="_images/gpu-block-diagram.png" width="400" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 64 </span><span class="caption-text">Components of a GPU: GPU has accelerated video decoding and encoding
<a class="footnote-reference brackets" href="#wiki-gpu" id="id16" role="doc-noteref"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></a></span><a class="headerlink" href="#id202" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The roles of the CPU and GPU in graphic animation are illustrated in
<a class="reference internal" href="#graphic-cpu-gpu"><span class="std std-numref">Fig. 65</span></a>.</p>
<figure class="align-center" id="id203">
<span id="graphic-cpu-gpu"></span><a class="reference internal image-reference" href="_images/graphic-cpu-gpu.png"><img alt="_images/graphic-cpu-gpu.png" height="407" src="_images/graphic-cpu-gpu.png" width="711" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 65 </span><span class="caption-text">OpenGL and Vulkan are both rendering APIs. In both cases, the GPU executes
shaders, while the CPU executes everything else <a class="footnote-reference brackets" href="#ogl-cpu-gpu" id="id17" role="doc-noteref"><span class="fn-bracket">[</span>11<span class="fn-bracket">]</span></a>.</span><a class="headerlink" href="#id203" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<ul class="simple">
<li><p>GPU can’t directly read user input from, say, keyboard, mouse, gamepad, or
play audio, or load files from a hard drive, or anything like that. In this
situation, cannot let GPU handle the animation work <a class="footnote-reference brackets" href="#cpu-gpu-role" id="id18" role="doc-noteref"><span class="fn-bracket">[</span>12<span class="fn-bracket">]</span></a>.</p></li>
<li><p>A graphics driver consists of an implementation of the OpenGL state machine
and a compilation stack to compile the shaders into the GPU’s machine language.
This compilation, as well as pretty much anything else, is executed on the CPU,
then the compiled shaders are sent to the GPU and are executed by it.
(SDL = Simple DirectMedia Layer) <a class="footnote-reference brackets" href="#mesawiki" id="id19" role="doc-noteref"><span class="fn-bracket">[</span>13<span class="fn-bracket">]</span></a>.</p></li>
</ul>
<figure class="align-center" id="id204">
<span id="graphic-gpu-csf"></span><a class="reference internal image-reference" href="_images/graphic-gpu-csf.png"><img alt="_images/graphic-gpu-csf.png" height="610" src="_images/graphic-gpu-csf.png" width="643" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 66 </span><span class="caption-text">MCU and specific HW circuits to speedup the processing of CSF
(Command Stream Fronted) <a class="footnote-reference brackets" href="#csf" id="id20" role="doc-noteref"><span class="fn-bracket">[</span>14<span class="fn-bracket">]</span></a>.</span><a class="headerlink" href="#id204" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The GPU driver write command and data from CPU to GPU’s system memory through
PCIe. These commands are called Command Stream Fronted (CSF) in the memory of
GPU. A chipset of GPU includes tens of SIMD processors (cores). In order to
speedup the GPU driver’s processing, the CSF is designed to a simpler form.
As result, GPU chipset include MCU (Micro Chip Unit) and specfic HW to transfer
the CSF into individual data structure for each SIMD processor to execute as
<a class="reference internal" href="#graphic-gpu-csf"><span class="std std-numref">Fig. 66</span></a>. The firmware version of MCU is updated by MCU itself
usually.</p>
</section>
<section id="sw-stack-and-data-flow">
<span id="sw-stack"></span><h4><a class="toc-backref" href="#id311" role="doc-backlink">SW Stack and Data Flow</a><a class="headerlink" href="#sw-stack-and-data-flow" title="Link to this heading">¶</a></h4>
<p>The driver runs on the CPU side as shown in <a class="reference internal" href="#graphic-sw-stack"><span class="std std-numref">Fig. 67</span></a>.
The OpenGL API eventually calls the driver’s functions, and the driver
executes these functions by issuing commands to the GPU hardware and/or
sending data to the GPU.</p>
<p>Even so, the GPU’s rendering work, which uses data such as 3D vertices and
colors sent from the CPU and stored in GPU or shared memory, consumes
more computing power than the CPU.</p>
<figure class="align-default" id="id205">
<span id="graphic-sw-stack"></span><div class="graphviz"><img src="_images/graphviz-d57d5931f1f9ccf5318cd31cb81606a4851808e0.png" alt="digraph G {
  rankdir=LR;
  
  compound=true;
  node [shape=record];
  subgraph cluster_cpu {
    label = &quot;CPU (Client)&quot;;
    CPU_SW [label=&quot; 3D Model | Game Engine | { OpenGL API | Shaders \n (buitin-functions)} | &lt;f1&gt; Driver&quot;];
  }
  subgraph cluster_gpu {
    label = &quot;GPU HW (Server)&quot;;
    subgraph cluster_gpu_sw {
      label = &quot;3D Rendering pipeline \ndescribed in the later section&quot;;
      ModelData        [label=&quot;3D Model Information\n(VAO, VBO, textures,\nindex buffers, materials)&quot;];
    }
  }
  CPU_SW:f1 -&gt; ModelData [label=&quot;1. Creating Mesh:\nVAO, texture, ..., from 3D model, \n shader-exectuable-code.&quot;];
    
//  label = &quot;Graphic SW Stack&quot;;
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 67 </span><span class="caption-text">Graphic SW Stack and data flow in initializing graphic model</span><a class="headerlink" href="#id205" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>✅  As section <a class="reference internal" href="#animation"><span class="std std-ref">Animation</span></a> and <a class="reference internal" href="#graphic-sw-stack"><span class="std std-numref">Fig. 67</span></a>.
The <strong>game engine’s built‑in C++ renderer handles all OpenGL/Vulkan/Metal
calls automatically</strong>.
Users set the value for speed, velocity, …, etc, customize the animation
logic.</p>
<p>After the user creates a skeleton and textures
for each model and sets keyframe times using a 3D modeling tool, users can
write <strong>gameplay scripts</strong> (<strong>Java code</strong>, C#, Blueprints, GDScript, Python,
etc.) to tell the engine to play animations <a class="footnote-reference brackets" href="#joglwiki" id="id21" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a>.</p>
<p>As section <a class="reference internal" href="#node-editor"><span class="std std-ref">Node-Editor (shaders generator)</span></a>, the skin materials created by Graphics Designers
/ Technical Artists and secondly created by Software Programmers / Graphics
Programmers using the tool Node-Editor (shaders generator).
As result, shaders generated from tool Node-Editor (shaders generator).</p>
<p>Shaders may call built-in functions written in Compute Shaders, SPIR-V, or
LLVM-IR. LLVM <cite>libclc</cite> is a project for OpenCL built-in functions, which can
also be used in OpenGL <a class="footnote-reference brackets" href="#libclc" id="id22" role="doc-noteref"><span class="fn-bracket">[</span>15<span class="fn-bracket">]</span></a>. Like CPU built-ins, new GPU ISAs or
architectures must implement their own built-ins or port them from open source
projects like <cite>libclc</cite>.</p>
<p>The 3D model on the CPU performs these animations in movement and others by
computing each frame from the stored keyframes, as illustrated in animation
section <a class="reference internal" href="#animation"><span class="std std-ref">Animation</span></a>.</p>
<figure class="align-default" id="id206">
<span id="graphic-sw-stack-2"></span><div class="graphviz"><img src="_images/graphviz-0d075acb82ffbf7b5a9c6454129f2a2adea8b6e4.png" alt="digraph G {
  rankdir=LR;
  
  compound=true;
  node [shape=record];
  subgraph cluster_cpu {
    label = &quot;CPU (Client)&quot;;
    CPU_SW [label=&quot; 3D Model | Game Engine | { OpenGL API | Shaders \n (buitin-functions)} | &lt;f1&gt; Driver&quot;];
  }
  subgraph cluster_gpu {
    label = &quot;GPU HW (Server)&quot;;
    subgraph cluster_gpu_sw {
      label = &quot;3D Rendering pipeline \ndescribed in the later section&quot;;
      ModelData        [label=&quot;3D Model Information\n(VAO, VBO, textures,\nindex buffers, materials)&quot;];
      UniformUpdates   [label=&quot;Uniform Updates\n(bone matrices, morph weights,\nmaterial params, time, etc.\nsee Note below)&quot;, style=filled, fillcolor=lightgreen, color=&quot;black&quot;];
    }
  }
  CPU_SW:f1 -&gt; UniformUpdates [label=&quot;2. Animation: \nDraw command and Uniform Updates\nfor each frame rendering&quot;];
    
//  label = &quot;Graphic SW Stack&quot;;
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 68 </span><span class="caption-text">Graphic SW Stack and data flow in rendering</span><a class="headerlink" href="#id206" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The per-frame data is not the full set of vertices, but rather a small set of
animation parameters named <strong>Uniform Updates</strong> as appeared in
<a class="reference internal" href="#graphic-sw-stack-2"><span class="std std-numref">Fig. 68</span></a>, which are described later.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>Bone matrices</strong> determine the positions of triangles within a 3D model
during animation.
This bone transformation data is much <strong>smaller</strong> than the complete mesh of
the 3D model.
We will provide an example and explain this in more detail in the
<a class="reference internal" href="#animation-ex"><span class="std std-ref">Animation Example</span></a> section.
Because this transformation data is small and constant across all shader
pipeline stages, it is stored in the GPU’s global memory and can be cached in
the <strong>uniform/constant cache</strong> for performance, as illustrated in
<a class="reference internal" href="#mem-hierarchy"><span class="std std-numref">Fig. 112</span></a> of <a class="reference internal" href="#sec-mem-hierarchy"><span class="std std-ref">Processor Units and Memory Hierarchy in NVIDIA GPU 82</span></a> section.</p>
</div>
<p>The CPU updates only these small animation parameters and issues draw command to
the GPU server side.</p>
<figure class="align-default" id="id207">
<span id="in-out-rendering"></span><div class="graphviz"><img src="_images/graphviz-6d13404837e020997ab2c96aa6f23a40c76dc5e3.png" alt="digraph GPU_Pipeline {
    rankdir=LR;
    node [shape=box, style=rounded, fontsize=12];

    UniformUpdates   [label=&quot;Uniform Updates\n(bone matrices, morph weights,\nmaterial params, time, etc.)&quot;];
    ModelData        [label=&quot;3D Model Information\n(VAO, VBO, textures,\nindex buffers, materials)&quot;];
    GPURendering     [label=&quot;GPU Rendering\n(vertex shader, fragment shader,\nskinning, morphing, rasterization)&quot;];
    Framebuffer      [label=&quot;Framebuffer\n(Video Memory Output)&quot;];

    UniformUpdates -&gt; GPURendering;
    ModelData      -&gt; GPURendering;
    GPURendering   -&gt; Framebuffer [label=&quot;Rendered Image&quot;];
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 69 </span><span class="caption-text">The input and output for GPU rendering</span><a class="headerlink" href="#id207" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Next, the 3D Rendering-pipeline is illustrated in <a class="reference internal" href="#in-out-rendering"><span class="std std-numref">Fig. 69</span></a>.</p>
<p>The shape of object data are stored in the form of VAOs (Vertex Array Objects) in
OpenGL. This will be explained in a later <a class="reference internal" href="#opengl"><span class="std std-ref">section OpenGL</span></a>.
Additionally, OpenGL provides VBOs (Vertex Buffer Objects), which allow
vertex array data to be stored in high-performance graphics memory on the
server side GPU and enable efficient data transfer <a class="footnote-reference brackets" href="#vbo" id="id23" role="doc-noteref"><span class="fn-bracket">[</span>16<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#classorvbo" id="id24" role="doc-noteref"><span class="fn-bracket">[</span>17<span class="fn-bracket">]</span></a>.</p>
<p>After GPU receives the <strong>Uniform Updates</strong> from CPU, it performs the
computationally intensive per‑vertex work within the rendering pipeline to
generate the <strong>final pixel values</strong> for <strong>each frame</strong> displayed on screen.
These final pixel values are collectively referred to the
<strong>Rendered Image</strong>.</p>
<p>✅  “<strong>Rendered Image</strong>” = the final per‑frame output written into the
framebuffer.
The <strong>Uniform Updates</strong> will be described in detail later.</p>
<p>✅ CPU only updates small animation parameters named <strong>Uniform Updates</strong> as
appeared in <a class="reference internal" href="#graphic-sw-stack-2"><span class="std std-numref">Fig. 68</span></a>; GPU computes the heavy per‑vertex work.</p>
<p>As mentioned in the previous section on <a class="reference internal" href="#movement"><span class="std std-ref">animation movement</span></a>,
3D modeling tools store Keyframes, bone transforms at each keyframe and related
data, and perform animation based on this information.</p>
<p>The CPU updates only the <strong>bone</strong> transformation data …, rather than updating
the entire vertex or mesh data for each animation frame.
These updates are very small—on the order of kilobytes rather than megabytes.
For each rendered frame, the CPU sends these small updates to the GPU, and the
<strong>GPU takes over the animation work from the CPU</strong>.
This type of movement animation is called <strong>skinning</strong>, and is illustrated as
follows:</p>
<p><strong>Skinning</strong></p>
<p>Skinning is a vertex deformation technique used to animate a mesh by attaching
its vertices to a hierarchical skeleton (bones). Each vertex stores one or more
bone indices and corresponding weights that describe how strongly each bone
influences that vertex.</p>
<p>During animation, the application updates the bone transformation matrices.
The vertex shader then computes the final vertex position by blending the
transformed positions according to the stored weights. This allows the mesh to
bend, twist, and deform smoothly as the skeleton moves.</p>
<p>Skinning does not create new geometry or smooth the surface topology. It only
transforms the existing vertices of the mesh. Examples include bending an arm,
flapping a wing, or deforming a flexible tube as its bones rotate.</p>
<p>CPU only update high‑level animation state, such as:</p>
<ul class="simple">
<li><p>Current animation time</p></li>
<li><p><strong>Bone matrices (small)</strong></p></li>
<li><p><strong>Morph weights</strong></p></li>
<li><p>Material parameters</p></li>
<li><p>Particle emitter settings</p></li>
<li><p>Global uniforms (camera, lights, etc.)</p></li>
</ul>
<p>These are tiny updates — kilobytes, not megabytes.</p>
<div class="math notranslate nohighlight">
\[finalPosition =
\sum_{i=0}^{N-1}
\mathbf{weight}_i \left( \mathbf{boneMatrix}_i \cdot originalPosition \right)\]</div>
<p>In practice (real engines): the weights are normalized so the sum = 1.0
<span class="math notranslate nohighlight">\(\Rightarrow \sum_{i=0}^{N-1}\mathbf{weight}_i = 1.0\)</span></p>
<p>Example: Bending an Arm</p>
<p>Imagine a character’s arm mesh.
Each vertex in the elbow area has weights like:</p>
<ul class="simple">
<li><p>70% influenced by upper‑arm bone</p></li>
<li><p>30% influenced by lower‑arm bone</p></li>
</ul>
<p>When the elbow bends:</p>
<ul class="simple">
<li><p>Upper‑arm bone rotates</p></li>
<li><p>Lower‑arm bone rotates</p></li>
<li><p>GPU blends the influence</p></li>
<li><p>The elbow area deforms smoothly</p></li>
</ul>
<p>This is skinning.</p>
<p>✅  After the GPU animation, the color pixels are write to framebuffer
(video memory). The display device (monitor, LCD, OLED, etc.) fetches these
pixels and displays them on the screen. The interface between framebuffer and
display device is explained in the next section <a class="reference internal" href="#display"><span class="std std-ref">Pixels Displaying</span></a>.</p>
</section>
<section id="pixels-displaying">
<span id="display"></span><h4><a class="toc-backref" href="#id312" role="doc-backlink">Pixels Displaying</a><a class="headerlink" href="#pixels-displaying" title="Link to this heading">¶</a></h4>
<p>The interface between frame buffer and displaying device is shown as
<a class="reference internal" href="#pc-lcd"><span class="std std-numref">Fig. 70</span></a>.</p>
<figure class="align-center" id="id208">
<span id="pc-lcd"></span><a class="reference internal image-reference" href="_images/pc-lcd.png"><img alt="_images/pc-lcd.png" height="512" src="_images/pc-lcd.png" width="768" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 70 </span><span class="caption-text">PC with Frame Buffer to LCD Display</span><a class="headerlink" href="#id208" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>GPU and screen (monitor, LCD, OLED, etc.) use <strong>VSync, NVIDIA G-SYNC or AMD
FreeSync</strong> to prevent <strong>screen tearing</strong>, as described below:</p>
<figure class="align-center" id="id209">
<span id="db-vsync"></span><a class="reference internal image-reference" href="_images/db-vsync.png"><img alt="_images/db-vsync.png" height="324" src="_images/db-vsync.png" width="348" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 71 </span><span class="caption-text">VSync</span><a class="headerlink" href="#id209" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p class="rubric">VSync</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>No tearing occurs when the GPU and display operate at the same refresh rate,
since the GPU refreshes faster than the display as shown below.

              A    B

GPU      | ----| ----|

Display  |-----|-----|

            B      A

Tearing occurs when the GPU has exact refresh cycles but VSync takes
one more cycle than the display as shown below.

              A

GPU      | -----|

Display  |-----|-----|

            B      A

To avoid tearing, the GPU runs at half the refresh rate of the display,
as shown below.

              A          B

GPU      | -----|    | -----|

Display  |-----|-----|-----|-----|

            B      B    A     A
</pre></div>
</div>
<ul>
<li><p>Double Buffering</p>
<p>While the display is reading from the frame buffer to display the current
frame, we might be updating its contents for the next frame (not necessarily
in raster-scan manner). This would result in the so-called tearing, in which
the screen shows parts of the old frame and parts of the new frame.
This could be resolved by using so-called double buffering. Instead of using
a single frame buffer, modern GPU uses two of them: a front buffer and a back
buffer. The display reads from the front buffer, while we can write the next
frame to the back buffer. When we finish, we signal to GPU to swap the front
and back buffer (known as buffer swap or page flip).</p>
</li>
<li><p>VSync</p>
<p>Double buffering alone does not solve the entire problem, as the buffer swap
might occur at an inappropriate time, for example, while the display is in
the middle of displaying the old frame. This is resolved via the so-called
vertical synchronization (or VSync) at the end of the raster-scan.
When we signal to the GPU to do a buffer swap, the GPU will wait till the next
VSync to perform the actual swap, after the entire current frame is displayed.</p>
<p>As above text digram.
The most important point is: When the VSync buffer-swap is enabled, you cannot
refresh the display faster than the refresh rate of the display!!!
If GPU is capable of producing higher frame rates than the display’s
refresh rate, then GPU can use fast rate without tearing.
If GPU has same or less frame rates then display’s and you application
refreshes at a fixed rate, the resultant refresh rate is
likely to be an integral factor of the display’s refresh rate, i.e., 1/2, 1/3,
1/4, etc. Otherwise it will cause tearing <a class="footnote-reference brackets" href="#cg-basictheory" id="id25" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>.</p>
</li>
<li><p>NVIDIA G-SYNC and AMD FreeSync</p>
<p>If your monitor and graphics card both in your customer computer support
NVIDIA G-SYNC, you’re in luck. With this technology, a special chip in the
display communicates with the graphics card. This lets the monitor vary the
refresh rate to match the frame rate of the NVIDIA GTX graphics card, up to
the maximum refresh rate of the display. This means that the frames are
displayed as soon as they are rendered by the GPU, eliminating screen tearing
and reducing stutter for when the frame rate is both higher and lower than
the refresh rate of the display. This makes it perfect for situations where
the frame rate varies, which happens a lot when gaming.
Today, you can even find G-SYNC technology in gaming laptops!</p>
<p>AMD has a similar solution called FreeSync. However, this doesn’t require a
proprietary chip in the monitor.
In FreeSync, the AMD Radeon driver, and the display firmware handle the
communication.
Generally, FreeSync monitors are less expensive than their G-SYNC counterparts,
but gamers generally prefer G-SYNC over FreeSync as the latter may cause
ghosting, where old images leave behind artifacts <a class="footnote-reference brackets" href="#g-sync" id="id26" role="doc-noteref"><span class="fn-bracket">[</span>18<span class="fn-bracket">]</span></a>.</p>
</li>
</ul>
</section>
<section id="the-role-and-purpose-of-shaders">
<span id="role-shaders"></span><h4><a class="toc-backref" href="#id313" role="doc-backlink">The Role and Purpose of Shaders</a><a class="headerlink" href="#the-role-and-purpose-of-shaders" title="Link to this heading">¶</a></h4>
<p>The flow for 3D/2D graphic processing is shown in <a class="reference internal" href="#opengl-flow"><span class="std std-numref">Fig. 72</span></a>.</p>
<figure class="align-default" id="id210">
<span id="opengl-flow"></span><div class="graphviz"><img src="_images/graphviz-9a9d3960428cd44db25d58d9a03d5160f8bb70ca.png" alt="digraph G {
  rankdir=LR;

  compound=true;
  node [shape=record];
  subgraph cluster_3d {
    label = &quot;3D/2D modeling software&quot;;
    subgraph cluster_code {
      label = &quot;3D/2D's code: engine, shader, ...&quot;;
      Api [label=&quot;&lt;a&gt; OpenGL API | &lt;s&gt; Shaders (3D animation's shaders \n or programmer writing shaders&quot;];
    }
  }
  subgraph cluster_driver {
    label = &quot;Driver&quot;
    Compiler [label=&quot;On-line Compiler&quot;];
    Obj [label=&quot;obj&quot;];
    Linker [label=&quot;On-line binding (Linker)&quot;];
    Exe [label=&quot;exe&quot;];
  }
  Api:a -&gt; Obj [lhead =&quot;cluster_driver&quot;];
  Api:s -&gt; Compiler;
  Compiler -&gt; Obj -&gt; Linker -&gt; Exe;
  Exe -&gt; GPU;
  Exe -&gt; CPU [ltail =&quot;cluster_driver&quot;]; 

//  label = &quot;OpenGL Flow&quot;;
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 72 </span><span class="caption-text">OpenGL Flow</span><a class="headerlink" href="#id210" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The compiled shaders are sent to the GPU when you call glLinkProgram().
That is the moment the driver uploads the compiled shader binaries into
GPU‑executable form.</p>
<p>The glLinkProgram() is called when you finish preparing a shader program —
<strong>not when creating a mesh, and not when issuing a draw command</strong>.</p>
<p>When a game actually call <cite>glLinkProgram()</cite> to re-link the shader, the shader
need to be compiled and load to GPU.</p>
<p>Usually it is happend in game startup, level load, or creating a new shader
variant (e.g., enabling shadows, fog, skinning).</p>
<p>Games switch shaders constantly — sometimes hundreds of times per frame —
but they do not re‑link them.</p>
<p>When playing a video game, different materials, effects and rendering passes
will applying to difference shaders.</p>
<p>Examples of switching shaders:</p>
<ul class="simple">
<li><p>When the player enters a snowy biome, ice meshes use the ice shader.</p></li>
<li><p>The axe blade uses a metal PBR shader.
Sparks fly when the axe blade hits stone it switch to particle shader.</p></li>
</ul>
</section>
</section>
<section id="basic-geometry-in-computer-graphics">
<h3><a class="toc-backref" href="#id314" role="doc-backlink">Basic geometry in computer graphics</a><a class="headerlink" href="#basic-geometry-in-computer-graphics" title="Link to this heading">¶</a></h3>
<p>This section introduces the basic geometry math used in computer graphics.
The complete concept can be found in the book <em>Computer Graphics: Principles
and Practice, 3rd Edition</em>, authored by John F. et al. However, the book
contains over a thousand pages.</p>
<p>It is very comprehensive and may take considerable time to understand all the
details.</p>
<section id="color">
<h4><a class="toc-backref" href="#id315" role="doc-backlink">Color</a><a class="headerlink" href="#color" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Additive colors in light are shown in <a class="reference internal" href="#additive-colors"><span class="std std-numref">Fig. 73</span></a>
<a class="footnote-reference brackets" href="#additive-colors-wiki" id="id27" role="doc-noteref"><span class="fn-bracket">[</span>19<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#additive-colors-ytube" id="id28" role="doc-noteref"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></a>.</p></li>
<li><p>In the case of paints, additive colors produce shades and become light gray
due to the addition of darker pigments <a class="footnote-reference brackets" href="#additive-colors-shade" id="id29" role="doc-noteref"><span class="fn-bracket">[</span>21<span class="fn-bracket">]</span></a>.</p></li>
</ul>
<figure class="align-center" id="id211">
<span id="additive-colors"></span><a class="reference internal image-reference" href="_images/additive-colors.png"><img alt="_images/additive-colors.png" height="346" src="_images/additive-colors.png" width="954" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 73 </span><span class="caption-text">Additive colors in light</span><a class="headerlink" href="#id211" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>Additive colors</strong></p>
<p>I know it doesn’t match human intuition. However, additive RGB colors in
light combine to produce white light, while additive RGB in paints result in
light gray paint. This makes sense because light has no shade. This result
stems from the way human eyes perceive color. Without light, no color can be
sensed by the eyes.</p>
<p>Computer engineers should understand that exploring the underlying reasons
falls into the realms of physics or the biology of the human eye structure.</p>
</div>
</section>
<section id="transformation">
<h4><a class="toc-backref" href="#id316" role="doc-backlink">Transformation</a><a class="headerlink" href="#transformation" title="Link to this heading">¶</a></h4>
<p>Objects (Triangle/Quad) can be moved in 2D/3D using matrix representation, as
explained in this wiki page <a class="footnote-reference brackets" href="#wiki-transformation" id="id30" role="doc-noteref"><span class="fn-bracket">[</span>22<span class="fn-bracket">]</span></a>.</p>
<p>The rotation matrix used is derived from another wiki page
<a class="footnote-reference brackets" href="#wiki-rotation" id="id31" role="doc-noteref"><span class="fn-bracket">[</span>23<span class="fn-bracket">]</span></a>.</p>
<p>Every computer graphics book covers the topic of transformation of objects and
their positions in space. Chapter 4 of the <em>Blue Book: OpenGL SuperBible, 7th
Edition</em> provides a short but useful 40-page description of transformation
concepts. It is a good material for understanding the basics.</p>
<p>The following Quaternion Product (Hamilton product) is from the wiki
<a class="footnote-reference brackets" href="#wiki-quaternion" id="id32" role="doc-noteref"><span class="fn-bracket">[</span>24<span class="fn-bracket">]</span></a> since it is not covered in the book.</p>
<div class="math notranslate nohighlight">
\[\mathbf ij = -ji = k, jk = -kj = i, ki = -ik = j.\]</div>
<figure class="align-center" id="id212">
<span id="trans-steps"></span><a class="reference internal image-reference" href="_images/trans-steps.png"><img alt="_images/trans-steps.png" height="156" src="_images/trans-steps.png" width="877" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 74 </span><span class="caption-text">Cooridinates Transform Pipeline <a class="footnote-reference brackets" href="#cg-basictheory" id="id33" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></span><a class="headerlink" href="#id212" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Details for <a class="reference internal" href="#trans-steps"><span class="std std-numref">Fig. 74</span></a> can be found on the website
<a class="footnote-reference brackets" href="#cg-basictheory" id="id34" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>.</p>
</section>
<section id="projection">
<h4><a class="toc-backref" href="#id317" role="doc-backlink">Projection</a><a class="headerlink" href="#projection" title="Link to this heading">¶</a></h4>
<figure class="align-center" id="viewfrustum">
<a class="reference internal image-reference" href="_images/ViewFrustum.png"><img alt="_images/ViewFrustum.png" height="182" src="_images/ViewFrustum.png" width="223" />
</a>
</figure>
<p>Only objects within the cone between near and far planes are projected to 2D
in perspective projection.</p>
<p>Perspective and orthographic projections (used in CAD tools) from 3D to 2D
can be represented by transformation matrices as described in the previous
section <a class="footnote-reference brackets" href="#wiki-prospective-projection" id="id35" role="doc-noteref"><span class="fn-bracket">[</span>25<span class="fn-bracket">]</span></a>.</p>
</section>
<section id="cross-product">
<span id="id36"></span><h4><a class="toc-backref" href="#id318" role="doc-backlink">Cross Product</a><a class="headerlink" href="#cross-product" title="Link to this heading">¶</a></h4>
<p>Both triangles and quads are polygons. So, objects can be formed with
polygons in both 2D and 3D. The transformation in 2D or 3D is well covered in
almost every computer graphics book. This section introduces the most
important concept and method for determining inner and outer planes. Then,
a point or object can be checked for visibility during 2D or 3D rendering.</p>
<p>Any <strong>area</strong> of a polygon can be calculated by dividing it into triangles or
quads. The area of a triangle or quad can be calculated using the cross
product in 3D.</p>
<p>The cross product in <strong>3D</strong> is defined by the formula and can be represented
with matrix notation, as shown here <a class="footnote-reference brackets" href="#cross-product-wiki" id="id37" role="doc-noteref"><span class="fn-bracket">[</span>26<span class="fn-bracket">]</span></a>.</p>
<div class="math notranslate nohighlight">
\[\mathbf a \mathsf x \mathbf b = \Vert a \Vert \Vert b \Vert sin(\Theta) n\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf a \mathsf x \mathbf b =
\begin{vmatrix}
\mathbf i &amp; \mathbf j&amp; \mathbf k\\
a_1&amp; a_2&amp; a_3\\
b_1&amp; b_2&amp; b_3
\end{vmatrix}\end{split}\]</div>
<p>The cross product in <strong>2D</strong> is defined by a formula and can be represented
with matrix notation, as proven here
<a class="footnote-reference brackets" href="#cross-product-2d-proof" id="id38" role="doc-noteref"><span class="fn-bracket">[</span>27<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#cross-product-2d-proof2" id="id39" role="doc-noteref"><span class="fn-bracket">[</span>28<span class="fn-bracket">]</span></a>.</p>
<div class="math notranslate nohighlight">
\[\mathbf a \mathsf x \mathbf b = \Vert a \Vert \Vert b \Vert sin(\Theta)\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf a \mathsf x \mathbf b =
\begin{vmatrix}
\mathbf i &amp; \mathbf j&amp; \mathbf k\\
a_1&amp; a_2&amp; 0\\
b_1&amp; b_2&amp; 0
\end{vmatrix} =
\begin{bmatrix}
a_1&amp; a_2 \\
b_1&amp; b_2
\end{bmatrix}\end{split}\]</div>
<p>After the above matrix form is proven, the antisymmetry property
may be demonstrated as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}a \mathsf x b = \mathsf x&amp;
\begin{bmatrix}
a \\
b
\end{bmatrix} =
\begin{bmatrix}
a_1&amp; a_2 \\
b_1&amp; b_2
\end{bmatrix} =
a_1b_2 - a_2b_1 =\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}-b_1a_2 - (-b_2a_1) =
\begin{bmatrix}
- b_1&amp; - b_2 \\
a_1&amp; a_2
\end{bmatrix} =
\mathsf x&amp;
\begin{bmatrix}
-b \\
a
\end{bmatrix} =
-b \mathsf x a\end{split}\]</div>
<p>In 2D, any two points <span class="math notranslate nohighlight">\(\text{from } P_i \text{ to } P_{i+1}\)</span> can form a
vector and determine the inner or outer side.</p>
<p>For example, as shown in <a class="reference internal" href="#inward-edge-normals"><span class="std std-numref">Fig. 75</span></a>, <span class="math notranslate nohighlight">\(\Theta\)</span> is the
angle from <span class="math notranslate nohighlight">\(P_iP_{i+1}\)</span> to <span class="math notranslate nohighlight">\(P_iP'_{i+1} = 180^\circ\)</span>.</p>
<p>Using the right-hand rule and counter-clockwise order, any vector
<span class="math notranslate nohighlight">\(P_iQ\)</span> between <span class="math notranslate nohighlight">\(P_iP_{i+1}\)</span> and <span class="math notranslate nohighlight">\(P_iP'_{i+1}\)</span>, with angle
<span class="math notranslate nohighlight">\(\theta\)</span> such that <span class="math notranslate nohighlight">\(0^\circ &lt; \theta &lt; 180^\circ\)</span>, indicates the
inward direction.</p>
<figure class="align-center" id="id213">
<span id="inward-edge-normals"></span><a class="reference internal image-reference" href="_images/inward-edge-normals.png"><img alt="_images/inward-edge-normals.png" height="265" src="_images/inward-edge-normals.png" width="676" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 75 </span><span class="caption-text">Inward edge normals</span><a class="headerlink" href="#id213" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id214">
<span id="d-vector-inward"></span><a class="reference internal image-reference" href="_images/2d-vector-inward.png"><img alt="_images/2d-vector-inward.png" height="203" src="_images/2d-vector-inward.png" width="418" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 76 </span><span class="caption-text">Inward and outward in 2D for a vector.</span><a class="headerlink" href="#id214" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Based on this observation, the rule for inward and outward vectors is shown in
<a class="reference internal" href="#inward-edge-normals"><span class="std std-numref">Fig. 75</span></a>. Facing the same direction as a specific vector,
the left side is inward and the right side is outward, as shown in
<a class="reference internal" href="#d-vector-inward"><span class="std std-numref">Fig. 76</span></a>.</p>
<p>For each edge <span class="math notranslate nohighlight">\(P_i - P_{i+1}\)</span>, the inward edge normal is the vector
<span class="math notranslate nohighlight">\(\mathsf{x} \; v_i\)</span>; the outward edge normal is
<span class="math notranslate nohighlight">\(- \; \mathsf{x} \; v_i\)</span>, where <span class="math notranslate nohighlight">\(\mathsf{x} \; v_i\)</span> is the
cross-product of <span class="math notranslate nohighlight">\(v_i\)</span>, as shown in <a class="reference internal" href="#inward-edge-normals"><span class="std std-numref">Fig. 75</span></a>.</p>
<p>A polygon can be created from a set of vertices. Suppose
<span class="math notranslate nohighlight">\((P_0, P_1, ..., P_n)\)</span> defines a polygon. The line segments
<span class="math notranslate nohighlight">\(P_0P_1, P_1P_2\)</span>, etc., are the polygon’s edges. The vectors
<span class="math notranslate nohighlight">\(v_0 = P_1 - P_0, v_1 = P_2 - P_1, ..., v_n = P_0 - P_n\)</span> represent those
edges.</p>
<p>Using counter-clockwise ordering, the left side is inward. Thus, the inward
region of a polygon can be determined.</p>
<p>For a convex polygon with vertices listed in counter-clockwise order, the
inward edge normals point toward the interior of the polygon, and the outward
edge normals point toward the unbounded exterior. This matches our usual
intuition.</p>
<p>However, if the polygon vertices are listed in clockwise order, the interior
and exterior definitions are reversed.</p>
<p>This cross product has an important property: going from <span class="math notranslate nohighlight">\(v\)</span> to
<span class="math notranslate nohighlight">\(\times v\)</span> involves a 90° rotation in the same direction as the
rotation from the positive x-axis to the positive y-axis.</p>
<figure class="align-center" id="id215">
<span id="in-polygon"></span><a class="reference internal image-reference" href="_images/polygon.png"><img alt="_images/polygon.png" height="160" src="_images/polygon.png" width="237" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 77 </span><span class="caption-text">Draw a polygon with vectices counter clockwise</span><a class="headerlink" href="#id215" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>As shown in <a class="reference internal" href="#in-polygon"><span class="std std-numref">Fig. 77</span></a>, when drawing a polygon with vectors (lines)
in counter-clockwise order, the polygon will be formed, and the two sides of
each vector (line) can be identified <a class="footnote-reference brackets" href="#cgpap" id="id40" role="doc-noteref"><span class="fn-bracket">[</span>29<span class="fn-bracket">]</span></a>.</p>
<p>Furthermore, whether a point is inside or outside the polygon can be
determined.</p>
<p>One simple method to test whether a point lies inside or outside a simple
polygon is to cast a ray from the point in any fixed direction and count how
many times it intersects the edges of the polygon.</p>
<p>If the point is outside the polygon, the ray will intersect its edges an even
number of times. If the point is inside the polygon, it will intersect the
edges an odd number of times <a class="footnote-reference brackets" href="#wiki-point-in-polygon" id="id41" role="doc-noteref"><span class="fn-bracket">[</span>30<span class="fn-bracket">]</span></a>.</p>
<figure class="align-center" id="id216">
<span id="d-cross-product"></span><a class="reference internal image-reference" href="_images/3d-cross-product.png"><img alt="_images/3d-cross-product.png" height="355" src="_images/3d-cross-product.png" width="230" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 78 </span><span class="caption-text">Cross product definition in 3D</span><a class="headerlink" href="#id216" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>In the same way, by following the counter-clockwise direction to create a
2D polygon step by step, a 3D polygon can be constructed.</p>
<p>As shown in <a class="reference internal" href="#d-cross-product"><span class="std std-numref">Fig. 78</span></a> from the wiki
<a class="footnote-reference brackets" href="#cross-product-wiki" id="id42" role="doc-noteref"><span class="fn-bracket">[</span>26<span class="fn-bracket">]</span></a>, the inward direction is determined by
<span class="math notranslate nohighlight">\(a \times b &lt; 0\)</span>, and the outward direction is determined by
<span class="math notranslate nohighlight">\(a \times b &gt; 0\)</span> in OpenGL.</p>
<p>Replacing <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> with <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>, as shown in
<a class="reference internal" href="#ogl-pointing-outwards"><span class="std std-numref">Fig. 79</span></a>, the positive Z-axis (<span class="math notranslate nohighlight">\(z+\)</span>) represents
the outer surface, while the negative Z-axis (<span class="math notranslate nohighlight">\(z-\)</span>) represents the
inner surface <a class="footnote-reference brackets" href="#ogl-point-outwards" id="id43" role="doc-noteref"><span class="fn-bracket">[</span>31<span class="fn-bracket">]</span></a>.</p>
<figure class="align-center" id="id217">
<span id="ogl-pointing-outwards"></span><a class="reference internal image-reference" href="_images/ogl-pointing-outwards.png"><img alt="_images/ogl-pointing-outwards.png" height="320" src="_images/ogl-pointing-outwards.png" width="685" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 79 </span><span class="caption-text">OpenGL pointing outwards, indicating the outer surface (z axis is +)</span><a class="headerlink" href="#id217" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id218">
<span id="in-3d-polygon"></span><a class="reference internal image-reference" href="_images/3d-polygon.png"><img alt="_images/3d-polygon.png" height="243" src="_images/3d-polygon.png" width="285" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 80 </span><span class="caption-text">3D polygon with directions on each plane</span><a class="headerlink" href="#id218" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>When we build every triangle with CCW, then we can defined a consistent outer surface (front face).
The <a class="reference internal" href="#in-3d-polygon"><span class="std std-numref">Fig. 80</span></a> shows an example of a 3D polygon created from 2D
triangles. The direction of the plane (triangle) is given by the line
perpendicular to the plane.</p>
<p>This means:</p>
<p>✔️ The mesh has a fixed “outer” and “inner”</p>
<p>(based on CCW in object space)</p>
<p>Cast a ray from the 3D point along the X-axis and count how many intersections
with the outer object occur. Depending on the number of intersections along
each axis (even or odd), you can understan if <strong>the point (or the camara) is i
nside or outside</strong> <a class="footnote-reference brackets" href="#point-in-3d-object" id="id44" role="doc-noteref"><span class="fn-bracket">[</span>32<span class="fn-bracket">]</span></a>.</p>
<p>An odd number means inside, and an even number means outside. As shown in
<a class="reference internal" href="#in-3d-object"><span class="std std-numref">Fig. 81</span></a>, points on the line passing through the object satisfy
this rule.</p>
<figure class="align-center" id="id219">
<span id="in-3d-object"></span><a class="reference internal image-reference" href="_images/in-3d-object.png"><img alt="_images/in-3d-object.png" height="238" src="_images/in-3d-object.png" width="190" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 81 </span><span class="caption-text">Point is inside or outside of 3D object</span><a class="headerlink" href="#id219" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>How does OpenGL render (draw) the inner face of a triangle?</p>
<p>OpenGL does NOT determine front/back in world space.</p>
<p>When the camera moves to the inner space of a object:</p>
<ul class="simple">
<li><p>The projection changes</p></li>
<li><p>The triangle’s screen‑space orientation changes</p></li>
<li><p>CCW ↔ CW flips</p></li>
<li><p>So the GPU flips front/back classification</p></li>
</ul>
<p class="rubric">OpenGL uses counter clockwise and pointing outwards as default <a class="footnote-reference brackets" href="#vbo" id="id45" role="doc-noteref"><span class="fn-bracket">[</span>16<span class="fn-bracket">]</span></a>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// unit cube</span>
<span class="c1">// A cube has 6 sides and each side has 4 vertices, therefore, the total number</span>
<span class="c1">// of vertices is 24 (6 sides * 4 verts), and 72 floats in the vertex array</span>
<span class="c1">// since each vertex has 3 components (x,y,z) (= 24 * 3)</span>
<span class="c1">//    v6----- v5</span>
<span class="c1">//   /|      /|</span>
<span class="c1">//  v1------v0|</span>
<span class="c1">//  | |     | |</span>
<span class="c1">//  | v7----|-v4</span>
<span class="c1">//  |/      |/</span>
<span class="c1">//  v2------v3</span>

<span class="c1">// vertex position array</span>
<span class="n">GLfloat</span><span class="w"> </span><span class="n">vertices</span><span class="p">[]</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="mf">.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="w">  </span><span class="mf">-.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="w">  </span><span class="mf">-.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="w">  </span><span class="mf">.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="w"> </span><span class="c1">// v0,v1,v2,v3 (front)</span>
<span class="w">   </span><span class="mf">.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="w">   </span><span class="mf">.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="w">   </span><span class="mf">.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="w">  </span><span class="mf">.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="w"> </span><span class="c1">// v0,v3,v4,v5 (right)</span>
<span class="w">   </span><span class="mf">.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="w">   </span><span class="mf">.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="w">  </span><span class="mf">-.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">-.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="w"> </span><span class="c1">// v0,v5,v6,v1 (top)</span>
<span class="w">  </span><span class="mf">-.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="w">  </span><span class="mf">-.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="w">  </span><span class="mf">-.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">-.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="w"> </span><span class="c1">// v1,v6,v7,v2 (left)</span>
<span class="w">  </span><span class="mf">-.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="w">   </span><span class="mf">.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="w">   </span><span class="mf">.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">-.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="w"> </span><span class="c1">// v7,v4,v3,v2 (bottom)</span>
<span class="w">   </span><span class="mf">.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="w">  </span><span class="mf">-.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="w">  </span><span class="mf">-.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="w">  </span><span class="mf">.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="w">  </span><span class="c1">// v4,v7,v6,v5 (back)</span>
<span class="p">};</span>
</pre></div>
</div>
<p>From the code above, we can see that OpenGL uses counter-clockwise and
pointing outwards as the default. However, OpenGL provides
<code class="docutils literal notranslate"><span class="pre">glFrontFace(GL_CW)</span></code> for clockwise winding <a class="footnote-reference brackets" href="#ogl-frontface" id="id46" role="doc-noteref"><span class="fn-bracket">[</span>33<span class="fn-bracket">]</span></a>.</p>
<p>For a group of objects, a scene graph provides better animation support and
saves memory <a class="footnote-reference brackets" href="#scene-graph-wiki" id="id47" role="doc-noteref"><span class="fn-bracket">[</span>34<span class="fn-bracket">]</span></a>.</p>
</section>
</section>
</section>
<section id="opengl">
<span id="id48"></span><h2><a class="toc-backref" href="#id319" role="doc-backlink">OpenGL</a><a class="headerlink" href="#opengl" title="Link to this heading">¶</a></h2>
<section id="example-of-opengl-program">
<h3><a class="toc-backref" href="#id320" role="doc-backlink">Example of OpenGL program</a><a class="headerlink" href="#example-of-opengl-program" title="Link to this heading">¶</a></h3>
<p>The following example is from the OpenGL Red Book and its example code
<a class="footnote-reference brackets" href="#redbook" id="id49" role="doc-noteref"><span class="fn-bracket">[</span>37<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#redbook-examples" id="id50" role="doc-noteref"><span class="fn-bracket">[</span>43<span class="fn-bracket">]</span></a>.</p>
<p class="rubric">References/triangles.vert</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="c1">#version 400 core</span>

<span class="n">layout</span><span class="p">(</span> <span class="n">location</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">)</span> <span class="ow">in</span> <span class="n">vec4</span> <span class="n">vPosition</span><span class="p">;</span>

<span class="n">void</span>
<span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">vPosition</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">References/triangles.frag</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#version 450 core</span>

<span class="n">out</span> <span class="n">vec4</span> <span class="n">fColor</span><span class="p">;</span>

<span class="n">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">fColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">References/01-triangles.cpp</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">  1</span><span class="c1">//////////////////////////////////////////////////////////////////////////////</span>
<span class="linenos">  2</span><span class="c1">//</span>
<span class="linenos">  3</span><span class="c1">//  Triangles.cpp</span>
<span class="linenos">  4</span><span class="c1">//</span>
<span class="linenos">  5</span><span class="c1">//////////////////////////////////////////////////////////////////////////////</span>
<span class="linenos">  6</span>
<span class="linenos">  7</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;vgl.h&quot;</span>
<span class="linenos">  8</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;LoadShaders.h&quot;</span>
<span class="linenos">  9</span>
<span class="linenos"> 10</span><span class="k">enum</span><span class="w"> </span><span class="nc">VAO_IDs</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Triangles</span><span class="p">,</span><span class="w"> </span><span class="n">NumVAOs</span><span class="w"> </span><span class="p">};</span>
<span class="linenos"> 11</span><span class="k">enum</span><span class="w"> </span><span class="nc">Buffer_IDs</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ArrayBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">NumBuffers</span><span class="w"> </span><span class="p">};</span>
<span class="linenos"> 12</span><span class="k">enum</span><span class="w"> </span><span class="nc">Attrib_IDs</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">vPosition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">};</span>
<span class="linenos"> 13</span>
<span class="linenos"> 14</span><span class="n">GLuint</span><span class="w">  </span><span class="n">VAOs</span><span class="p">[</span><span class="n">NumVAOs</span><span class="p">];</span>
<span class="linenos"> 15</span><span class="n">GLuint</span><span class="w">  </span><span class="n">Buffers</span><span class="p">[</span><span class="n">NumBuffers</span><span class="p">];</span>
<span class="linenos"> 16</span>
<span class="linenos"> 17</span><span class="k">const</span><span class="w"> </span><span class="n">GLuint</span><span class="w">  </span><span class="n">NumVertices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span>
<span class="linenos"> 18</span>
<span class="linenos"> 19</span><span class="c1">//----------------------------------------------------------------------------</span>
<span class="linenos"> 20</span><span class="c1">//</span>
<span class="linenos"> 21</span><span class="c1">// init</span>
<span class="linenos"> 22</span><span class="c1">//</span>
<span class="linenos"> 23</span>
<span class="linenos"> 24</span><span class="kt">void</span>
<span class="linenos"> 25</span><span class="nf">init</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="linenos"> 26</span><span class="p">{</span>
<span class="linenos"> 27</span><span class="w">    </span><span class="n">glGenVertexArrays</span><span class="p">(</span><span class="w"> </span><span class="n">NumVAOs</span><span class="p">,</span><span class="w"> </span><span class="n">VAOs</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">// Same with glCreateVertexArray( NumVAOs, VAOs ); </span>
<span class="linenos"> 28</span><span class="w">      </span><span class="c1">// https://stackoverflow.com/questions/24441430/glgen-vs-glcreate-naming-convention</span>
<span class="linenos"> 29</span><span class="w">    </span><span class="c1">// Make the new VAO:VAOs[Triangles] active, creating it if necessary.</span>
<span class="linenos"> 30</span><span class="w">    </span><span class="n">glBindVertexArray</span><span class="p">(</span><span class="w"> </span><span class="n">VAOs</span><span class="p">[</span><span class="n">Triangles</span><span class="p">]</span><span class="w"> </span><span class="p">);</span>
<span class="linenos"> 31</span><span class="w">    </span><span class="c1">// opengl-&gt;current_array_buffer = VAOs[Triangles]</span>
<span class="linenos"> 32</span><span class="w">    </span>
<span class="linenos"> 33</span><span class="w">    </span><span class="n">GLfloat</span><span class="w">  </span><span class="n">vertices</span><span class="p">[</span><span class="n">NumVertices</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 34</span><span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="mf">-0.90f</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.90f</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="mf">0.85f</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.90f</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">-0.90f</span><span class="p">,</span><span class="w">  </span><span class="mf">0.85f</span><span class="w"> </span><span class="p">},</span><span class="w">  </span><span class="c1">// Triangle 1</span>
<span class="linenos"> 35</span><span class="w">        </span><span class="p">{</span><span class="w">  </span><span class="mf">0.90f</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.85f</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="mf">0.90f</span><span class="p">,</span><span class="w">  </span><span class="mf">0.90f</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">-0.85f</span><span class="p">,</span><span class="w">  </span><span class="mf">0.90f</span><span class="w"> </span><span class="p">}</span><span class="w">   </span><span class="c1">// Triangle 2</span>
<span class="linenos"> 36</span><span class="w">    </span><span class="p">};</span>
<span class="linenos"> 37</span>
<span class="linenos"> 38</span><span class="w">    </span><span class="n">glCreateBuffers</span><span class="p">(</span><span class="w"> </span><span class="n">NumBuffers</span><span class="p">,</span><span class="w"> </span><span class="n">Buffers</span><span class="w"> </span><span class="p">);</span>
<span class="linenos"> 39</span><span class="w">    </span>
<span class="linenos"> 40</span><span class="w">    </span><span class="c1">// Make the buffer the active array buffer.</span>
<span class="linenos"> 41</span><span class="w">    </span><span class="n">glBindBuffer</span><span class="p">(</span><span class="w"> </span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">Buffers</span><span class="p">[</span><span class="n">ArrayBuffer</span><span class="p">]</span><span class="w"> </span><span class="p">);</span>
<span class="linenos"> 42</span><span class="w">    </span><span class="c1">// Attach the active VBO:Buffers[ArrayBuffer] to VAOs[Triangles]</span>
<span class="linenos"> 43</span><span class="w">    </span><span class="c1">// as an array of vectors with 4 floats each.</span>
<span class="linenos"> 44</span><span class="w">    </span><span class="c1">// Kind of like:</span>
<span class="linenos"> 45</span><span class="w">    </span><span class="c1">// opengl-&gt;current_vertex_array-&gt;attributes[attr] = {</span>
<span class="linenos"> 46</span><span class="w">    </span><span class="c1">//     type = GL_FLOAT,</span>
<span class="linenos"> 47</span><span class="w">    </span><span class="c1">//     size = 4,</span>
<span class="linenos"> 48</span><span class="w">    </span><span class="c1">//     data = opengl-&gt;current_array_buffer</span>
<span class="linenos"> 49</span><span class="w">    </span><span class="c1">// }</span>
<span class="linenos"> 50</span><span class="w">    </span><span class="c1">// Can be replaced with glVertexArrayVertexBuffer(VAOs[Triangles], Triangles, </span>
<span class="linenos"> 51</span><span class="w">    </span><span class="c1">// buffer[ArrayBuffer], ArrayBuffer, sizeof(vmath::vec2));, glVertexArrayAttribFormat(), ...</span>
<span class="linenos"> 52</span><span class="w">    </span><span class="c1">// in OpenGL 4.5.</span>
<span class="linenos"> 53</span><span class="w">    </span>
<span class="linenos"> 54</span><span class="w">    </span><span class="n">glBufferStorage</span><span class="p">(</span><span class="w"> </span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span><span class="w"> </span><span class="n">vertices</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="linenos"> 55</span>
<span class="linenos"> 56</span><span class="w">    </span><span class="n">ShaderInfo</span><span class="w">  </span><span class="n">shaders</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span>
<span class="linenos"> 57</span><span class="w">    </span><span class="p">{</span>
<span class="linenos"> 58</span><span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="n">GL_VERTEX_SHADER</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;media/shaders/triangles/triangles.vert&quot;</span><span class="w"> </span><span class="p">},</span>
<span class="linenos"> 59</span><span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="n">GL_FRAGMENT_SHADER</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;media/shaders/triangles/triangles.frag&quot;</span><span class="w"> </span><span class="p">},</span>
<span class="linenos"> 60</span><span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="n">GL_NONE</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">}</span>
<span class="linenos"> 61</span><span class="w">    </span><span class="p">};</span>
<span class="linenos"> 62</span>
<span class="linenos"> 63</span><span class="w">    </span><span class="n">GLuint</span><span class="w"> </span><span class="n">program</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LoadShaders</span><span class="p">(</span><span class="w"> </span><span class="n">shaders</span><span class="w"> </span><span class="p">);</span>
<span class="linenos"> 64</span><span class="w">    </span><span class="n">glUseProgram</span><span class="p">(</span><span class="w"> </span><span class="n">program</span><span class="w"> </span><span class="p">);</span>
<span class="linenos"> 65</span>
<span class="linenos"> 66</span><span class="w">    </span><span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="w"> </span><span class="n">vPosition</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FLOAT</span><span class="p">,</span>
<span class="linenos"> 67</span><span class="w">                           </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">BUFFER_OFFSET</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="linenos"> 68</span><span class="w">    </span><span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="w"> </span><span class="n">vPosition</span><span class="w"> </span><span class="p">);</span>
<span class="linenos"> 69</span><span class="w">    </span><span class="c1">// Above two functions specify vPosition to vertex shader at layout (location = 0)</span>
<span class="linenos"> 70</span><span class="p">}</span>
<span class="linenos"> 71</span>
<span class="linenos"> 72</span><span class="c1">//----------------------------------------------------------------------------</span>
<span class="linenos"> 73</span><span class="c1">//</span>
<span class="linenos"> 74</span><span class="c1">// display</span>
<span class="linenos"> 75</span><span class="c1">//</span>
<span class="linenos"> 76</span>
<span class="linenos"> 77</span><span class="kt">void</span>
<span class="linenos"> 78</span><span class="nf">display</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="linenos"> 79</span><span class="p">{</span>
<span class="linenos"> 80</span><span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">black</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="w"> </span><span class="p">};</span>
<span class="linenos"> 81</span>
<span class="linenos"> 82</span><span class="w">    </span><span class="n">glClearBufferfv</span><span class="p">(</span><span class="n">GL_COLOR</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">black</span><span class="p">);</span>
<span class="linenos"> 83</span>
<span class="linenos"> 84</span><span class="w">    </span><span class="n">glBindVertexArray</span><span class="p">(</span><span class="w"> </span><span class="n">VAOs</span><span class="p">[</span><span class="n">Triangles</span><span class="p">]</span><span class="w"> </span><span class="p">);</span>
<span class="linenos"> 85</span><span class="w">    </span><span class="n">glDrawArrays</span><span class="p">(</span><span class="w"> </span><span class="n">GL_TRIANGLES</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">NumVertices</span><span class="w"> </span><span class="p">);</span>
<span class="linenos"> 86</span><span class="p">}</span>
<span class="linenos"> 87</span>
<span class="linenos"> 88</span><span class="c1">//----------------------------------------------------------------------------</span>
<span class="linenos"> 89</span><span class="c1">//</span>
<span class="linenos"> 90</span><span class="c1">// main</span>
<span class="linenos"> 91</span><span class="c1">//</span>
<span class="linenos"> 92</span>
<span class="linenos"> 93</span><span class="cp">#ifdef _WIN32</span>
<span class="linenos"> 94</span><span class="kt">int</span><span class="w"> </span><span class="n">CALLBACK</span><span class="w"> </span><span class="nf">WinMain</span><span class="p">(</span>
<span class="linenos"> 95</span><span class="w">  </span><span class="n">_In_</span><span class="w"> </span><span class="n">HINSTANCE</span><span class="w"> </span><span class="n">hInstance</span><span class="p">,</span>
<span class="linenos"> 96</span><span class="w">  </span><span class="n">_In_</span><span class="w"> </span><span class="n">HINSTANCE</span><span class="w"> </span><span class="n">hPrevInstance</span><span class="p">,</span>
<span class="linenos"> 97</span><span class="w">  </span><span class="n">_In_</span><span class="w"> </span><span class="n">LPSTR</span><span class="w">     </span><span class="n">lpCmdLine</span><span class="p">,</span>
<span class="linenos"> 98</span><span class="w">  </span><span class="n">_In_</span><span class="w"> </span><span class="kt">int</span><span class="w">       </span><span class="n">nCmdShow</span>
<span class="linenos"> 99</span><span class="p">)</span>
<span class="linenos">100</span><span class="cp">#else</span>
<span class="linenos">101</span><span class="kt">int</span>
<span class="linenos">102</span><span class="n">main</span><span class="p">(</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="w"> </span><span class="p">)</span>
<span class="linenos">103</span><span class="cp">#endif</span>
<span class="linenos">104</span><span class="p">{</span>
<span class="linenos">105</span><span class="w">    </span><span class="n">glfwInit</span><span class="p">();</span>
<span class="linenos">106</span>
<span class="linenos">107</span><span class="w">    </span><span class="n">GLFWwindow</span><span class="o">*</span><span class="w"> </span><span class="n">window</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glfwCreateWindow</span><span class="p">(</span><span class="mi">800</span><span class="p">,</span><span class="w"> </span><span class="mi">600</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Triangles&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="linenos">108</span>
<span class="linenos">109</span><span class="w">    </span><span class="n">glfwMakeContextCurrent</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
<span class="linenos">110</span><span class="w">    </span><span class="n">gl3wInit</span><span class="p">();</span>
<span class="linenos">111</span>
<span class="linenos">112</span><span class="w">    </span><span class="n">init</span><span class="p">();</span>
<span class="linenos">113</span>
<span class="linenos">114</span><span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">glfwWindowShouldClose</span><span class="p">(</span><span class="n">window</span><span class="p">))</span>
<span class="linenos">115</span><span class="w">    </span><span class="p">{</span>
<span class="linenos">116</span><span class="w">        </span><span class="n">display</span><span class="p">();</span>
<span class="linenos">117</span><span class="w">        </span><span class="n">glfwSwapBuffers</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
<span class="linenos">118</span><span class="w">        </span><span class="n">glfwPollEvents</span><span class="p">();</span>
<span class="linenos">119</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">120</span>
<span class="linenos">121</span><span class="w">    </span><span class="n">glfwDestroyWindow</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
<span class="linenos">122</span>
<span class="linenos">123</span><span class="w">    </span><span class="n">glfwTerminate</span><span class="p">();</span>
<span class="linenos">124</span><span class="p">}</span>
</pre></div>
</div>
<p>Init():</p>
<ul>
<li><p>Generate Vertex Array VAOs and bind VAOs[0].</p>
<p>(glGenVertexArrays(NumVAOs, VAOs);
glBindVertexArray(VAOs[Triangles]);
glCreateBuffers(NumBuffers, Buffers);)</p>
<p>A vertex-array object holds various data related to a collection of vertices.
Those data are stored in buffer objects and managed by the currently bound
vertex-array object.</p>
<ul>
<li><p>glBindBuffer(GL_ARRAY_BUFFER, Buffers[ArrayBuffer]);</p>
<p>Because there are many different places where buffer objects can be in
OpenGL, when we bind a buffer, we need to specify what we’d like to use it
for. In our example, because we’re storing vertex data into the buffer,
we use GL_ARRAY_BUFFER. The place where the buffer is bound is known as the
binding target.</p>
</li>
</ul>
</li>
<li><p>According to the counter-clockwise rule in the previous section, triangle
primitives are defined in variable <cite>vertices</cite>. After binding OpenGL
VBO Buffers[0] to <cite>vertices</cite>, vertex data will be sent to the memory of
the server (GPU).</p>
<p>Think of the “active” buffer as just a global variable, and there are a bunch
of functions that use the active buffer instead of taking using a parameter.
These global state variables are the ugly side of OpenGL <a class="footnote-reference brackets" href="#vao-vbo-binding" id="id51" role="doc-noteref"><span class="fn-bracket">[</span>44<span class="fn-bracket">]</span></a>
and can be replaced with <cite>glVertexArrayVertexBuffer()</cite>,
<cite>glVertexArrayAttribFormat()</cite>, etc. Then call <cite>glBindVertexArray(vao)</cite> before
drawing in OpenGL 4.5 <a class="footnote-reference brackets" href="#ogl-vavb" id="id52" role="doc-noteref"><span class="fn-bracket">[</span>45<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#ogl-bluebook-p152" id="id53" role="doc-noteref"><span class="fn-bracket">[</span>46<span class="fn-bracket">]</span></a>.</p>
</li>
<li><p>glVertexAttribPointer(vPosition, 2, GL_FLOAT, GL_FALSE, 0, BUFFER_OFFSET(0)):</p>
<p>During GPU rendering, each vertex position will be held in <cite>vPosition</cite> and
passed to the “triangles.vert” shader through the <cite>LoadShaders(shaders)</cite>
function.</p>
</li>
</ul>
<p>glfwSwapBuffers(window):</p>
<ul class="simple">
<li><p>You’ve already used double buffering for animation. Double buffering is done
by making the main color buffer have two parts: a front buffer that’s
displayed in your window; and a back buffer, which is where you render the
new image. When you swap the buffers (by calling <cite>glfwSwapBuffers()</cite>, for
example), the front and back buffers are exchanged
<a class="footnote-reference brackets" href="#redbook-colorbuffer" id="id54" role="doc-noteref"><span class="fn-bracket">[</span>86<span class="fn-bracket">]</span></a>.</p></li>
</ul>
<p>display():</p>
<ul class="simple">
<li><p>Bind VAOs[0], set render mode to GL_TRIANGLES and send vertex data to Buffer
(gpu memory, OpenGL pipeline). Next, GPU will do rendering pipeline descibed
in next section.</p></li>
</ul>
<p>The triangles.vert has input vPosition and no output variable, so using
gl_Position default varaible without declaration. The triangles.frag has not
defined input variable and has defined output variable fColor instead of using
gl_FragColor.</p>
<p>The “in” and “out” in shaders above are “type qualifier”.
A type qualifier is used in the OpenGL Shading Language (GLSL) to modify the
storage or behavior of global and locally defined variables. These qualifiers
change particular aspects of the variable, such as where they get their data
from and so forth <a class="footnote-reference brackets" href="#ogl-qualifier" id="id55" role="doc-noteref"><span class="fn-bracket">[</span>51<span class="fn-bracket">]</span></a>.</p>
<p>Though attribute and varying are removed from later version 1.4 of OpenGL,
many materials in website using them <a class="footnote-reference brackets" href="#ogl-qualifier-deprecate" id="id56" role="doc-noteref"><span class="fn-bracket">[</span>52<span class="fn-bracket">]</span></a>
<a class="footnote-reference brackets" href="#github-attr-varying-depr" id="id57" role="doc-noteref"><span class="fn-bracket">[</span>53<span class="fn-bracket">]</span></a>.
It’s better to use “in” and “out” to replace
them as the following code.
OpenGL has a few ways to binding API’s variable with shader’s variable.
glVertexAttrib* as the following code and glBindAttribLocation()
<a class="footnote-reference brackets" href="#ogl-layout-q" id="id58" role="doc-noteref"><span class="fn-bracket">[</span>54<span class="fn-bracket">]</span></a>, …</p>
<p class="rubric">replace attribute and varying with in and out</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">uniform</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">scale</span><span class="p">;</span>
<span class="n">layout</span><span class="w"> </span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">attribute</span><span class="w"> </span><span class="n">vec2</span><span class="w"> </span><span class="n">position</span><span class="p">;</span>
<span class="c1">// layout (location = 0) in vec2 position;</span>
<span class="n">layout</span><span class="w"> </span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">attribute</span><span class="w"> </span><span class="n">vec4</span><span class="w"> </span><span class="n">color</span><span class="p">;</span>
<span class="c1">// layout (location = 1) in vec4 color;</span>
<span class="n">varying</span><span class="w"> </span><span class="n">vec4</span><span class="w"> </span><span class="n">v_color</span><span class="p">;</span>
<span class="c1">// out v_color</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec4</span><span class="p">(</span><span class="n">position</span><span class="o">*</span><span class="n">scale</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
<span class="w">  </span><span class="n">v_color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">color</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// OpenGL API</span>
<span class="n">GLfloat</span><span class="w"> </span><span class="n">attrib</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.6f</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="o">*</span><span class="w"> </span><span class="mf">0.4f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="w"> </span><span class="p">};</span>
<span class="c1">// Update the value of input attribute 1 : layout (location = 1) in vec4 color</span>
<span class="n">glVertexAttrib4fv</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">attrib</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">varying</span><span class="w"> </span><span class="n">vec4</span><span class="w"> </span><span class="n">v_color</span><span class="p">;</span>
<span class="c1">// in vec4 v_color;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">gl_FragColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v_color</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>An OpenGL program is made of two shaders <a class="footnote-reference brackets" href="#monstar-lab-opengl" id="id59" role="doc-noteref"><span class="fn-bracket">[</span>49<span class="fn-bracket">]</span></a>
<a class="footnote-reference brackets" href="#glumpy-shaders" id="id60" role="doc-noteref"><span class="fn-bracket">[</span>50<span class="fn-bracket">]</span></a>:</p>
<ul class="simple">
<li><p>The vertex shader is (commonly) executed once for every vertex we want to
draw. It receives some attributes as input, computes the position of this
vertex in space and returns it in a variable called gl_Position. It also
defines some varyings.</p></li>
<li><p>The fragment shader is executed once for each pixel to be rendered. It
receives some varyings as input, computes the color of this pixel and
returns it in a variable called fColor.</p></li>
</ul>
<p>Since we have 6 vertices in our buffer, this shader will be executed 6 times by
the GPU (once per vertex)! We can also expect all 6 instances of the shader to
be executed in parallel, since a GPU have so many cores.</p>
</section>
<section id="d-rendering">
<span id="rendering3d"></span><h3><a class="toc-backref" href="#id321" role="doc-backlink">3D Rendering</a><a class="headerlink" href="#d-rendering" title="Link to this heading">¶</a></h3>
<p>3D animation is the process of creating moving images by manipulating digital
objects within a three‑dimensional space.
3D rendering is the process of converting 3D models into 2D images on a
computer <a class="footnote-reference brackets" href="#drendering-wiki" id="id61" role="doc-noteref"><span class="fn-bracket">[</span>35<span class="fn-bracket">]</span></a>.</p>
<p>Based on the previous section of 3D modeling, the 3D modeling tool will
generate a 3D vertex model and OpenGL code. Then, programmers may manually
modify the OpenGL code and add or update shaders.</p>
<p>In section <a class="reference internal" href="#sw-stack"><span class="std std-ref">SW Stack and Data Flow</span></a>, we mentioned the GPU will generate the rendering
image for each frame according the 3D Inforamtion and Uniform Updates sent from
CPU, and write each of the final frame of data in the form of color pixels to
framebuffer (video memory) as <a class="reference internal" href="#in-out-rendering"><span class="std std-numref">Fig. 69</span></a>.</p>
<section id="animation-parameters">
<span id="id62"></span><h4><a class="toc-backref" href="#id322" role="doc-backlink">Animation Parameters</a><a class="headerlink" href="#animation-parameters" title="Link to this heading">¶</a></h4>
<p>✅ CPU only updates small animation parameters named <strong>Uniform Updates</strong> as
appeared in <a class="reference internal" href="#graphic-sw-stack-2"><span class="std std-numref">Fig. 68</span></a>; GPU computes the heavy per‑vertex work.</p>
<p>The 3D animation will
trigger the 3D rendering process for each 2D image drawing accoriding the
<strong>Uniform Updates</strong>.</p>
<p>The “small animation parameters” updated by the CPU are formally called:</p>
<p>✔ Uniform updates</p>
<p>✔ Constant buffer updates</p>
<p>✔ Per‑frame / per‑draw constants</p>
<p>✔ Bone matrix palette updates (for skinning)</p>
<p>✔ Morph weight updates (for morphing)</p>
<p>These are the correct technical terms used in modern graphics pipelines.</p>
<p>⚓ The Proper Term: “Uniform Updates”</p>
<p>The most accurate and universal name is:</p>
<p>✅ Uniform updates</p>
<p>or</p>
<p>✅ Updating uniform buffers</p>
<p>Because the CPU is updating uniform data that the GPU reads during shading.</p>
<p>Examples of uniform data:</p>
<ul class="simple">
<li><p>bone matrices</p></li>
<li><p>morph weights</p></li>
<li><p>animation time</p></li>
<li><p>material parameters</p></li>
<li><p>camera matrices</p></li>
<li><p>light parameters</p></li>
</ul>
<p>These are small, constant‑for‑the‑draw values.</p>
<p>⚓ More Specific Terms Used in Game Engines</p>
<ol class="arabic simple">
<li><p>Animation Parameters</p></li>
</ol>
<p>Used in animation systems:</p>
<ul class="simple">
<li><p>“animation parameters”</p></li>
<li><p>“skinning parameters”</p></li>
<li><p>“bone palette”</p></li>
<li><p>“morph weights”</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p>Per‑Frame Constants</p></li>
</ol>
<p>Used in engine architecture:</p>
<ul class="simple">
<li><p>“frame constants”</p></li>
<li><p>“per‑frame constant buffer”</p></li>
<li><p>“global shader constants”</p></li>
</ul>
<ol class="arabic simple" start="3">
<li><p>Per‑Draw Constants</p></li>
</ol>
<p>Used in render pipelines:</p>
<ul class="simple">
<li><p>“per‑draw uniform block”</p></li>
<li><p>“per‑object constant buffer”</p></li>
<li><p>“material constant buffer”</p></li>
</ul>
<p>⚓ In Modern APIs (GL, Vulkan, DirectX)</p>
<p>OpenGL</p>
<ul class="simple">
<li><p>Uniforms</p></li>
<li><p>Uniform Buffer Objects (UBOs)</p></li>
<li><p>Shader Storage Buffer Objects (SSBOs)</p></li>
</ul>
<p>DirectX</p>
<ul class="simple">
<li><p>Constant Buffers (CBuffers)</p></li>
</ul>
<p>Vulkan</p>
<ul class="simple">
<li><p>Descriptor sets</p></li>
<li><p>Uniform buffers</p></li>
</ul>
<p>All refer to the same concept:
small CPU‑updated data that the GPU reads during shading.</p>
</section>
<section id="d-rendering-pipeline">
<span id="three-d-rendering-pipeline"></span><h4><a class="toc-backref" href="#id323" role="doc-backlink">3D Rendering Pipeline</a><a class="headerlink" href="#d-rendering-pipeline" title="Link to this heading">¶</a></h4>
<p>The steps are shown in <a class="reference internal" href="#short-rendering-pipeline"><span class="std std-numref">Fig. 82</span></a>.</p>
<figure class="align-center" id="id220">
<span id="short-rendering-pipeline"></span><a class="reference internal image-reference" href="_images/short-rendering-pipeline.png"><img alt="_images/short-rendering-pipeline.png" height="347" src="_images/short-rendering-pipeline.png" width="915" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 82 </span><span class="caption-text">3D Graphics Rendering Pipeline <a class="footnote-reference brackets" href="#cg-basictheory" id="id63" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></span><a class="headerlink" href="#id220" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<ul class="simple">
<li><p>A fragment can be treated as a pixel in 3D spaces, which is aligned with the
pixel grid, with attributes such as position, color, normal and texture.</p></li>
</ul>
<p>From the previous <a class="reference internal" href="#graphic-sw-stack-2"><span class="std std-numref">Fig. 68</span></a> and <a class="reference internal" href="#in-out-rendering"><span class="std std-numref">Fig. 69</span></a>
in section <a class="reference internal" href="#sw-stack"><span class="std std-ref">SW Stack and Data Flow</span></a>, we introduce the 3D anmiation data are classified
as follows:</p>
<ul class="simple">
<li><p><strong>Vertex Data = 3D model information</strong> (the mesh (geometry), such as VBO/VAO)</p></li>
<li><p><strong>Animation Parameters = per‑frame uniform updates</strong> (transforms, bone
matrices, camera, materials, …)</p></li>
</ul>
<p>The complete steps of 3D Rendering pipeline, <strong>excluding animation</strong> are shown
in the <a class="reference internal" href="#rendering-pipeline1"><span class="std std-numref">Fig. 83</span></a> from the OpenGL website <a class="footnote-reference brackets" href="#rendering" id="id64" role="doc-noteref"><span class="fn-bracket">[</span>36<span class="fn-bracket">]</span></a> and
in the <a class="reference internal" href="#opengl-pipeline"><span class="std std-numref">Fig. 84</span></a>.
The website also provides a description for each stage.</p>
<figure class="align-center" id="id221">
<span id="rendering-pipeline1"></span><a class="reference internal image-reference" href="_images/rendering_pipeline.png"><img alt="_images/rendering_pipeline.png" height="292" src="_images/rendering_pipeline.png" width="126" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 83 </span><span class="caption-text">Diagram of the Rendering Pipeline. The blue boxes are programmable shader
stages. Shaders with dashed outlines indicate optional shader stages.</span><a class="headerlink" href="#id221" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id222">
<span id="opengl-pipeline"></span><a class="reference internal image-reference" href="_images/OpenGL-pipeline.png"><img alt="_images/OpenGL-pipeline.png" height="543" src="_images/OpenGL-pipeline.png" width="854" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 84 </span><span class="caption-text">OpenGL pipeline</span><a class="headerlink" href="#id222" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The Red Book and Blue Book show only <strong>Vertex Specification</strong> and
<strong>Vertex Data</strong> in the rendering flow because
they <strong>never show Animation Parameters as part of the rendering flow</strong>.
The animation flow from CPU to GPU is shown in
<a class="reference internal" href="#short-rendering-pipeline-shaders-cpu-gpu"><span class="std std-numref">Fig. 85</span></a>, based on
<a class="reference internal" href="#short-rendering-pipeline"><span class="std std-numref">Fig. 82</span></a>.</p>
<figure class="align-default" id="id223">
<span id="short-rendering-pipeline-shaders-cpu-gpu"></span><div class="graphviz"><img src="_images/graphviz-bb6f73a70da9de0610bb1f0a2887d215e8cf21b1.png" alt="digraph CPU_GPU_Pipeline {
    rankdir=LR;
    node [shape=box, style=rounded, fontsize=12];

    subgraph cluster_cpu {
        label=&quot;CPU&quot;;
        style=rounded;
        CPU_Vertex [label=&quot;Load 3D Model\n(Vertex Data)\nVBOs, VAOs, Indices&quot;];
        CPU_Anim   [label=&quot;Update Animation Parameters\n(Bone Matrices, Morph Weights,\nTime, Material Params)&quot;];
    }

    subgraph cluster_gpu {
        label=&quot;GPU&quot;;
        style=rounded;
        VS      [label=&quot;Vertex Shader\n(Skinning, Morphing,\nModel/View/Proj Transform)&quot;];
        Raster  [label=&quot;Rasterizer\n(Primitive Assembly,\nClipping, Interpolation)&quot;];
        FS      [label=&quot;Fragment Shader\n(Lighting, Texturing,\nShading, Materials)&quot;];
        FB      [label=&quot;Final Rendered Image\n(Framebuffer Output)&quot;];
    }

    CPU_Vertex -&gt; VS;
    CPU_Anim   -&gt; VS;

    VS -&gt; Raster;
    Raster -&gt; FS;
    FS -&gt; FB;
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 85 </span><span class="caption-text">CPU and GPU Pipeline For Shaders</span><a class="headerlink" href="#id223" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Each draw call may correspond to:</p>
<ul class="simple">
<li><p>one mesh</p></li>
<li><p>one submesh</p></li>
<li><p>one meshlet (in mesh‑shader pipelines)</p></li>
<li><p>or many meshes batched together</p></li>
</ul>
<p>Although the Rendering Pipeline shown in <a class="reference internal" href="#rendering-pipeline1"><span class="std std-numref">Fig. 83</span></a> and
<a class="reference internal" href="#opengl-pipeline"><span class="std std-numref">Fig. 84</span></a> do not explicitly include per-frame animation flow—
because the inputs are labeled <strong>Vertex Specification</strong> and <strong>Vertex Data</strong> and
they do not show Animation Parameters as part of the rendering process—the
pipeline is still applicable.</p>
<p>However the following table from OpenGL rendering pipeline Figure 1.2 and its
stages from the book <em>OpenGL Programming Guide, 9th Edition</em> <a class="footnote-reference brackets" href="#redbook" id="id65" role="doc-noteref"><span class="fn-bracket">[</span>37<span class="fn-bracket">]</span></a> is
broad enough to cover animation.</p>
<table class="docutils align-default" id="id224">
<caption><span class="caption-number">Table 48 </span><span class="caption-text">OpenGL rendering pipeline from page 10 and page 36 of book
“OpenGL Programming Guide 9th Edition” <a class="footnote-reference brackets" href="#redbook" id="id66" role="doc-noteref"><span class="fn-bracket">[</span>37<span class="fn-bracket">]</span></a> and <a class="footnote-reference brackets" href="#rendering" id="id67" role="doc-noteref"><span class="fn-bracket">[</span>36<span class="fn-bracket">]</span></a>.</span><a class="headerlink" href="#id224" title="Link to this table">¶</a></caption>
<colgroup>
<col style="width: 25.0%" />
<col style="width: 75.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Stage.</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Vertex Shading</p></td>
<td><p><strong>Vertex → Vertex and other data such as color for later passes.</strong>
For each vertex issued by a drawing command, a vertex shader processes
the data associated with that vertex.
<strong>Vertex Shader:</strong> provides the Vertex → Vertex transformation effects
controlled by the users.</p></td>
</tr>
<tr class="row-odd"><td><p>Tessellation Shading</p></td>
<td><p><strong>Create more detail on demand when zoomed in.</strong>
After the vertex shader processes each vertex, the tessellation shader
stage (if active) continues processing.
The tessellation stage is actually divided into two shaders known as the
<strong>tessellation control shader</strong> and the <strong>tessellation evaluation
shader</strong>. A single patch from Tesslation Control Shader (TCS) and
Tesslation Evaluation Shader (TVS) can generate <strong>millions of
micro‑triangles</strong>. See reference below.</p></td>
</tr>
<tr class="row-even"><td><p>Geometry Shading</p></td>
<td><p><strong>Vertex → Primitives</strong>. Allows additional processing of geometric
primitives.
This stage may create new primitives before rasterization.
The Geometry shading stage is another optional stage that can modify
entire geometric primitives within the OpenGL pipeline. This stage
operates on individual geometric primitives allowing each to be modified.
In this stage, you might generate more geometry from the input primitive,
change the type of geometric primitive (e.g., converting triangles to
lines), or discard the geometry altogether. If activated, a geometry
shader receives its input either after vertex shading has completed
processing the vertices of a geometric primitive or from the primitives
generated from the tessellation shading stage, if it’s been enabled.
<strong>Geometry Shader:</strong> provides the Vertex → Geometric Primitives
transformation effects controlled by the users.
See Chapter 10 of the Red Book <a class="footnote-reference brackets" href="#redbook-p36" id="id68" role="doc-noteref"><span class="fn-bracket">[</span>40<span class="fn-bracket">]</span></a>.
<strong>Geometry Shader (GS)</strong> can generate both <strong>more vertices and more
primitives</strong> than it receives.</p></td>
</tr>
<tr class="row-odd"><td><p>Primitive Assembly</p></td>
<td><p>The previous shading stages all operate on vertices, with the information
about how those vertices are organized into geometric primitives being
carried along internal to OpenGL.
<strong>The primitive assembly stage organizes the vertices into their
associated geometric primitives in preparation for clipping and
rasterization.</strong></p></td>
</tr>
<tr class="row-even"><td><p>Clipping</p></td>
<td><p><strong>Clipping hidden parts.</strong> Occasionally, vertices will be outside of the
viewport—the region of the window where you’re permitted to draw—and
cause the primitive associated with that vertex to be modified so none
of its pixels are outside of the viewport.
This operation is called clipping and is handled automatically by OpenGL.</p></td>
</tr>
<tr class="row-odd"><td><p>Rasterization</p></td>
<td><p><strong>Vertex → Fragment.</strong> or <strong>Geometric Primitives → Fragment</strong>.
The job of the rasterizer is to determine which
screen locations are covered by a particular piece of geometry (point,
line, or triangle). Knowing those locations, along with the input vertex
data, the rasterizer linearly interpolates the data values for each
varying variable in the fragment shader and sends those values as inputs
into your fragment shader. A fragment can be treated as a pixel in 3D
spaces, which is aligned with the pixel grid, with attributes such as
position, color, normal and texture.</p></td>
</tr>
<tr class="row-even"><td><p>Fragment Shading</p></td>
<td><p><strong>Fragment → Fragment</strong>. <strong>Determine color for each pixel.</strong>
In this stage, a fragment’s <strong>color and depth</strong> values are computed and
then sent for further processing in the <strong>fragment-testing</strong> and
<strong>blending</strong> parts of the pipeline.
The final stage where you have programmable control over the color of
a screen location is fragment shading. In this shader stage, you use a
shader to determine the fragment’s final color (although the next stage,
per-fragment operations, can modify the color one last time) and
potentially its depth value. Fragment shaders are very powerful, as they
often employ texture mapping to augment the colors provided by the
vertex processing stages. A fragment shader may also terminate
processing a fragment if it determines the fragment shouldn’t be drawn;
this process is called fragment discard. A helpful way of thinking about
the difference between shaders that deal with vertices and fragment
shaders is this: vertex shading (including tessellation and geometry
shading) determines where on the screen a primitive is, while fragment
shading uses that information to determine what color that fragment will
be.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="id225">
<caption><span class="caption-number">Table 49 </span><span class="caption-text">Continue OpenGL rendering pipeline from page 10 and page 36 of
book “OpenGL Programming Guide 9th Edition” <a class="footnote-reference brackets" href="#redbook" id="id69" role="doc-noteref"><span class="fn-bracket">[</span>37<span class="fn-bracket">]</span></a> and <a class="footnote-reference brackets" href="#rendering" id="id70" role="doc-noteref"><span class="fn-bracket">[</span>36<span class="fn-bracket">]</span></a>.</span><a class="headerlink" href="#id225" title="Link to this table">¶</a></caption>
<colgroup>
<col style="width: 25.0%" />
<col style="width: 75.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Stage.</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Per-Fragment Operations</p></td>
<td><p>During this stage, a <strong>fragment’s visibility</strong> is determined using depth
testing (also commonly known as z-buffering) and stencil testing.
If a fragment successfully makes it through all of the enabled tests,
it may be written directly to the framebuffer, updating the color
(and possibly depth value) of its pixel, or
<strong>if blending is enabled, the fragment’s color will be combined with
the pixel’s current color to generate a new color that is written into
the framebuffer.</strong></p></td>
</tr>
<tr class="row-odd"><td><p>Compute shading stage</p></td>
<td><p><strong>Compute shader:</strong> may be applied in any stage.
This is not part of the graphical pipeline like the stages above, but
stands on its own as the only stage in a program. A compute shader
processes generic work items, driven by an application-chosen range,
rather than by graphical inputs like vertices and fragments.
Compute shaders can process buffers created and consumed by other shader
programs in your application.
This includes framebuffer post-processing effects or really anything you
want. Compute shaders are described in Chapter 12 of Red Book,
“Compute Shaders” <a class="footnote-reference brackets" href="#redbook-p36" id="id71" role="doc-noteref"><span class="fn-bracket">[</span>40<span class="fn-bracket">]</span></a>.</p></td>
</tr>
</tbody>
</table>
<p><strong>Tessllation</strong></p>
<ul class="simple">
<li><p>Tessellation Shading:
The core problem that Tessellation deals with is the static nature of 3D models
in terms of their detail and polygon count. The thing is that when we look at
a complex model such as a human face up close we prefer to use a highly
detailed model that will bring out the tiny details (e.g. skin bumps, etc).
A highly detailed model automatically translates to more triangles and more
compute power required for processing. …
One possible way to solve this problem using the existing features of OpenGL
is to generate the same model at multiple levels of detail (LOD). For example,
highly detailed, average and low. We can then select the version to use based
on the distance from the camera. This, however, will require more artist
resources and often will not be flexible enough. …
Let’s take a look at how Tessellation has been implemented in the graphics
pipeline. The core components that are responsible for Tessellation are two
new shader stages and in between them a <strong>fixed function</strong> stage that can be
configured to some degree but does not run a shader. The first shader stage
is called <strong>Tessellation Control Shader (TCS)</strong>, the <strong>fixed function</strong> stage
is called the <strong>Primitive Generator (PG)</strong>, and the second shader stage is
called <strong>Tessellation Evaluation Shader (TES)</strong>.
Some GPU havn’t this fixed function stage implemented in HW and even havn’t
provide these TCS, TES and Gemoetry Shader. User can write
<strong>Compute Shaders</strong> instead for this on-fly detail display.
This surface is usually defined by some <strong>polynomial formula</strong> and the idea
is that moving a <strong>CP</strong> has an effect on the entire surface. …
The group of CPs is usually called a <strong>Patch</strong> <a class="footnote-reference brackets" href="#ts-tu30" id="id72" role="doc-noteref"><span class="fn-bracket">[</span>38<span class="fn-bracket">]</span></a>.
The data flow in Tessllation Stage between TCS, Fixed-Function Tessellator
and TES is illustrated in <a class="reference internal" href="#imr-rendering-pipeline-1"><span class="std std-numref">Fig. 86</span></a>.
Chapter 9 of Red Book <a class="footnote-reference brackets" href="#redbook" id="id73" role="doc-noteref"><span class="fn-bracket">[</span>37<span class="fn-bracket">]</span></a> has details.
The next section <a class="reference internal" href="#tessellation-ex"><span class="std std-ref">Tessellation Example</span></a> describes the details for the
Tessallation with an example.</p></li>
<li><p>Tessellation <strong>cannot</strong> decrease the resolution of vertices from the VS.
The Geometry Shader can <strong>reduce geometry</strong> (by discarding primitives), but it
<strong>cannot</strong> reduce the number of input vertices coming from VS/TES.
The rasterizer can <strong>reduce fragments</strong>, but it cannot reduce vertices.</p></li>
</ul>
<p><strong>Data Flow</strong></p>
<p>Sumarize the OpenGL Rendering Pipeline as shown in the
<a class="reference internal" href="#imr-rendering-pipeline-1"><span class="std std-numref">Fig. 86</span></a> and
<a class="reference internal" href="#imr-rendering-pipeline-2"><span class="std std-numref">Fig. 87</span></a>.</p>
<figure class="align-default" id="id226">
<span id="imr-rendering-pipeline-1"></span><div class="graphviz"><img src="_images/graphviz-aefd3538cf9aa007162675c655a919e0841a0a6f.png" alt="digraph OpenGL_Pipeline_Part1 {
    rankdir=LR;
    node [shape=box, style=rounded, fontsize=12];

    App  [label=&quot;Application&quot;];
    VS   [label=&quot;Vertex Shader&quot;];

    subgraph cluster_optional {
        label=&quot;Optional Stages&quot;;
        style=&quot;rounded,dashed&quot;;
        color=&quot;gray&quot;;

        subgraph cluster_ts {
            label=&quot;Tessellation&quot;;
            style=rounded;

            TCS  [label=&quot;Tessellation Control Shader\n(TCS)&quot;];

            TS  [label=&quot;Fixed-Function Tessellator&quot;];

            TES  [label=&quot;Tessellation Evaluation Shader\n(TES)&quot;];

            TCS -&gt; TS      [label=&quot;CP + Tessellation level&quot;];
            TS  -&gt; TES     [label=&quot;Tessellated domain\ncoordinates&quot;];

            { rank = same;  TCS; TS; TES }
        }

        GS  [label=&quot;Geometry Shader&quot;];
    }

    PA   [label=&quot;Primitive Assembly&quot;];

    App -&gt; VS      [label=&quot;Vertex Arrays&quot;];
    VS  -&gt; TCS     [label=&quot;Transformed Vertices +\nControl Points(CP)&quot;];
    TES -&gt; GS      [label=&quot;Tessellated Vertices\n(more vertices)&quot;];
    GS  -&gt; PA      [label=&quot;Modified Primitives&quot;];

    //{ rank = same; TCS; TES }
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 86 </span><span class="caption-text">The part 1 of GPU Rendering Pipeline Stages in Red Book</span><a class="headerlink" href="#id226" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-default" id="id227">
<span id="imr-rendering-pipeline-2"></span><div class="graphviz"><img src="_images/graphviz-2eb6ba4912fd7c3dd289a22ea9f47043022e8c37.png" alt="digraph OpenGL_Pipeline_Part2 {
    rankdir=LR;
    node [shape=box, style=rounded, fontsize=12];

    PA      [label=&quot;Primitive Assembly&quot;];
    Raster  [label=&quot;Rasterization&quot;];
    FS      [label=&quot;Fragment Shader&quot;];
    PF      [label=&quot;Per-Fragment Ops&quot;];
    FB      [label=&quot;Framebuffer&quot;];

    PA     -&gt; Raster  [label=&quot;Assembled Primitives&quot;];
    Raster -&gt; FS      [label=&quot;Fragments&quot;];
    FS     -&gt; PF      [label=&quot;Colored Fragments&quot;];
    PF     -&gt; FB      [label=&quot;Final Fragments&quot;];
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 87 </span><span class="caption-text">The part 2 of GPU Rendering Pipeline Stages in Red Book</span><a class="headerlink" href="#id227" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The data flow through the OpenGL Shader and the details flow
in TCS, Fixed-Function Tessellator and TES are described in below.</p>
<table class="docutils align-default" id="id228">
<caption><span class="caption-number">Table 50 </span><span class="caption-text">Data Flow Through the OpenGL Shader Pipeline</span><a class="headerlink" href="#id228" title="Link to this table">¶</a></caption>
<colgroup>
<col style="width: 14.8%" />
<col style="width: 25.9%" />
<col style="width: 25.9%" />
<col style="width: 33.3%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Shader Stage</p></th>
<th class="head"><p>Input Data (from CPU or previous stage)</p></th>
<th class="head"><p>Output Data (to next stage)</p></th>
<th class="head"><p>How GPU Hardware Uses These Data (with Stage Name)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Vertex Shader</p></td>
<td><ul class="simple">
<li><p>Per-vertex attributes:</p>
<ul>
<li><p>Positions (vec3/vec4)</p></li>
<li><p>Normals, tangents</p></li>
<li><p>Texture coordinates</p></li>
<li><p>Vertex colors</p></li>
<li><p>Skinning weights/indices</p></li>
</ul>
</li>
<li><p>Uniforms and UBOs</p></li>
<li><p>Textures / samplers</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>gl_Position (clip-space)</p></li>
<li><p>Varyings</p></li>
<li><p>Optional point size</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><strong>Vertex Processing Stage</strong>:</p>
<ul>
<li><p>ALUs transform vertices</p></li>
<li><p>Writes positions into Primitive Assembly</p></li>
<li><p>Stores varyings in interpolation registers</p></li>
</ul>
</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>Tessellation Control Shader (TCS)</p></td>
<td><ul class="simple">
<li><p>Patch control points</p></li>
<li><p>Uniforms</p></li>
<li><p>Per-patch attributes</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><strong>Modified control points</strong>: gl_out</p></li>
<li><p><strong>Tessellation levels</strong>: gl_TessLevelInner, gl_TessLevelOuter</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><strong>Tessellation Control Stage</strong>:</p>
<ul>
<li><p>Writes tessellation levels to fixed-function tessellator</p></li>
<li><p>Stores control points in patch memory</p></li>
</ul>
</li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>Fixed‑Function Tessellator (TS)</p></td>
<td><ul class="simple">
<li><p>Modified control points: gl_out</p></li>
<li><p>Tessellation levels:  gl_TessLevelInner, gl_TessLevelOuter</p></li>
<li><p>Per-patch attribute (triangles, quads, isolines)</p></li>
<li><p>Partitioning mode (integer, fractional_even, fractional_odd)</p></li>
<li><p>Winding order</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><strong>Tessellated coordinates (u,v,w)</strong>: gl_TessCoord</p></li>
<li><p>Bypass modified Control Points</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><strong>Fixed‑Function Tessellator (TS)</strong>, also name as <strong>Primitive Generator (PG)</strong>:</p>
<ul>
<li><p>Generates tessellated domain coordinates (u,v,w) to TES</p></li>
</ul>
</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>Tessellation Evaluation Shader (TES)</p></td>
<td><ul class="simple">
<li><p>Tessellated coordinates (u,v,w): gl_TessCoord</p></li>
<li><p>modified Control Points</p></li>
<li><p>Uniforms</p></li>
<li><p>gl_PrimitiveID</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><strong>Tessellated Vertices</strong>: gl_Position</p></li>
<li><p>Any per‑vertex <strong>varyings</strong> for GS or rasterizer</p></li>
<li><p>Optional custom attributes</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><strong>Tessellation Evaluation Stage</strong>:</p>
<ul>
<li><p>ALUs compute final vertex positions</p></li>
<li><p>Outputs to Primitive Assembly</p></li>
<li><p>Sends varyings to interpolation hardware</p></li>
</ul>
</li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>Geometry Shader</p></td>
<td><ul class="simple">
<li><p>Assembled primitives</p></li>
<li><p>All varyings</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Zero or more primitives</p></li>
<li><p>New varyings</p></li>
<li><p>New gl_Position</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><strong>Geometry Processing Stage</strong>:</p>
<ul>
<li><p>Allocates per-primitive scratch memory</p></li>
<li><p>Emits new primitives</p></li>
<li><p>Expands or reduces geometry</p></li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="id229">
<caption><span class="caption-number">Table 51 </span><span class="caption-text">Data Flow Through the OpenGL Shader Pipeline Continue</span><a class="headerlink" href="#id229" title="Link to this table">¶</a></caption>
<colgroup>
<col style="width: 14.8%" />
<col style="width: 25.9%" />
<col style="width: 25.9%" />
<col style="width: 33.3%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Shader Stage</p></th>
<th class="head"><p>Input Data (from CPU or previous stage)</p></th>
<th class="head"><p>Output Data (to next stage)</p></th>
<th class="head"><p>How GPU Hardware Uses These Data (with Stage Name)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Rasterizer (Fixed Function)</p></td>
<td><ul class="simple">
<li><p>Primitives (triangles/lines/points)</p></li>
<li><p>Per-vertex varyings</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Fragments</p></li>
<li><p>Interpolated varyings</p></li>
<li><p>gl_FragCoord</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><strong>Rasterization Stage</strong>:</p>
<ul>
<li><p>Barycentric units interpolate varyings</p></li>
<li><p>Generates fragments</p></li>
<li><p>Sends fragments to fragment shader cores</p></li>
</ul>
</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>Fragment Shader</p></td>
<td><ul class="simple">
<li><p>Interpolated varyings</p></li>
<li><p>Textures / samplers</p></li>
<li><p>Uniforms</p></li>
<li><p>gl_FragCoord</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>gl_FragColor or user-defined outputs</p></li>
<li><p>Depth override (optional)</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><strong>Fragment Processing Stage</strong>:</p>
<ul>
<li><p>ALUs compute pixel color</p></li>
<li><p>Texture units fetch texels</p></li>
<li><p>Outputs color/depth to ROP</p></li>
</ul>
</li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>Output Merger / ROP (Fixed Function)</p></td>
<td><ul class="simple">
<li><p>Fragment shader outputs</p></li>
<li><p>Depth/stencil values</p></li>
<li><p>Blending state</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Final framebuffer color</p></li>
<li><p>Updated depth/stencil buffers</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><strong>Output Merger Stage</strong>:</p>
<ul>
<li><p>Performs depth/stencil tests</p></li>
<li><p>Applies blending</p></li>
<li><p>Writes final pixels to framebuffer memory</p></li>
<li><p>Handles MSAA resolve</p></li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><strong>Varying</strong></p>
<p>A varying is a piece of data that:</p>
<ul class="simple">
<li><p>Comes out of the vertex shader</p></li>
<li><p>Gets interpolated by the rasterizer</p></li>
<li><p>Arrives as input to the fragment shader</p></li>
</ul>
<p>It is called <strong>varying</strong> because its value <strong>varies across the surface of a
triangle</strong>.</p>
<table class="docutils align-default" id="id230">
<caption><span class="caption-number">Table 52 </span><span class="caption-text">Examples of Common Varyings</span><a class="headerlink" href="#id230" title="Link to this table">¶</a></caption>
<colgroup>
<col style="width: 22.2%" />
<col style="width: 33.3%" />
<col style="width: 44.4%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Varying Name</p></th>
<th class="head"><p>Meaning</p></th>
<th class="head"><p>Why It Varies Across the Primitive</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>vNormal</p></td>
<td><p>Surface normal at each vertex</p></td>
<td><p>Lighting requires a smoothly changing normal across the triangle
so per-pixel shading can compute correct diffuse and specular terms</p></td>
</tr>
<tr class="row-odd"><td><p>vUV</p></td>
<td><p>Texture coordinates</p></td>
<td><p>Each pixel needs its own UV to sample the correct texel from the texture</p></td>
</tr>
<tr class="row-even"><td><p>vColor</p></td>
<td><p>Vertex color (per-vertex material tint)</p></td>
<td><p>Enables smooth color gradients or per-vertex painting effects</p></td>
</tr>
<tr class="row-odd"><td><p>vWorldPos</p></td>
<td><p>World-space position of the vertex</p></td>
<td><p>Used for per-pixel lighting, reflections, shadows, and screen-space effects;
must be interpolated so each fragment knows its own world position</p></td>
</tr>
</tbody>
</table>
<p>For 2D animation, the model is created by 2D only (1 face only), so it only can be
viewed from the same face of model. If you want to display different faces of model,
multiple 2D models need to be created and switch these 2D models from face(flame) to
face(flame) from time to time <a class="footnote-reference brackets" href="#danimation" id="id74" role="doc-noteref"><span class="fn-bracket">[</span>39<span class="fn-bracket">]</span></a>.</p>
</section>
<section id="tessellation-example">
<span id="tessellation-ex"></span><h4><a class="toc-backref" href="#id324" role="doc-backlink">Tessellation Example</a><a class="headerlink" href="#tessellation-example" title="Link to this heading">¶</a></h4>
<p>In Chapter 9 (Tessellation), the Red Book <a class="footnote-reference brackets" href="#redbook" id="id75" role="doc-noteref"><span class="fn-bracket">[</span>37<span class="fn-bracket">]</span></a> focuses on:</p>
<ul class="simple">
<li><p>gl_TessLevelOuter[]</p></li>
<li><p>gl_TessLevelInner[]</p></li>
</ul>
<p>It never mentioned to gnerate modified CPs in TCS.
The following example give the output for  (TCS → TS → TES) in patching a
single rectangle.</p>
<p><strong>An example for Inflated 4×4 Bézier Patch (TCS → TS → TES)</strong></p>
<p>The following diagram illustrates the complete OpenGL tessellation
pipeline for a <strong>4×4</strong> bicubic Bézier patch on <strong>1 single rectangle</strong>.
Only the four interior control points (5, 6, 9, 10) are lifted off the plane,
producing a smooth inflated surface.</p>
<p><strong>Tessellation Control Shader (TCS)</strong>: output:</p>
<ul class="simple">
<li><p><strong>modified Control Points (CPs, Patch)</strong>: gl_out</p></li>
<li><p><strong>Tessellation level</strong>: gl_TessLevelInner, gl_TessLevelOuter</p></li>
</ul>
<p>Another name for <strong>CPs</strong> is <strong>Patch</strong>.</p>
<p>The TCS outputs 16 CPs arranged in a 4×4 grid.
Only CPs 5, 6, 9, and 10 are elevated to create curvature.</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="cp">#version 450 core</span>
<span class="k">layout</span><span class="p">(</span><span class="n">vertices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="k">out</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Copy all CPs</span>
<span class="w">    </span><span class="nb">gl_out</span><span class="p">[</span><span class="nb">gl_InvocationID</span><span class="p">].</span><span class="nb">gl_Position</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="nb">gl_in</span><span class="p">[</span><span class="nb">gl_InvocationID</span><span class="p">].</span><span class="nb">gl_Position</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Inflate interior CPs</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">gl_InvocationID</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">||</span>
<span class="w">        </span><span class="nb">gl_InvocationID</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="o">||</span>
<span class="w">        </span><span class="nb">gl_InvocationID</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="o">||</span>
<span class="w">        </span><span class="nb">gl_InvocationID</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="nb">gl_out</span><span class="p">[</span><span class="nb">gl_InvocationID</span><span class="p">].</span><span class="nb">gl_Position</span><span class="w"> </span><span class="o">+=</span>
<span class="w">            </span><span class="kt">vec4</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Tessellation levels</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">gl_InvocationID</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mo">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nb">gl_TessLevelOuter</span><span class="p">[</span><span class="mo">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.0</span><span class="p">;</span>
<span class="w">        </span><span class="nb">gl_TessLevelOuter</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.0</span><span class="p">;</span>
<span class="w">        </span><span class="nb">gl_TessLevelOuter</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.0</span><span class="p">;</span>
<span class="w">        </span><span class="nb">gl_TessLevelOuter</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.0</span><span class="p">;</span>

<span class="w">        </span><span class="nb">gl_TessLevelInner</span><span class="p">[</span><span class="mo">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.0</span><span class="p">;</span>
<span class="w">        </span><span class="nb">gl_TessLevelInner</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Fixed-Function Tessellator (TS)</strong>, also name as <strong>Primitive Generator
(PG)</strong>: output:</p>
<ul class="simple">
<li><p><strong>Tessellated coordinates (u,v,w)</strong>: gl_TessCoord</p></li>
</ul>
<p>The PG takes the TLs and based on their values generates a <strong>set of points</strong>
inside the triangle. Each point is defined by its own barycentric coordinate.
The set of points named <strong>Tessellated coordinates</strong>.</p>
<p>The grid size depends on tessellation levels:</p>
<ul class="simple">
<li><p>If gl_TessLevelOuter[0..3] = 4.0 and gl_TessLevelInner[0..1] = 4.0 → you
get a 5×5 grid, <strong>Tessellated coordinates (u,v,w)</strong></p></li>
<li><p>If you set 8.0 → you get a 9×9 grid</p></li>
<li><p>If you set 2.0 → you get a 3×3 grid</p></li>
</ul>
<p>The fixed‑function tessellator generates a 5×5 evaluation grid
for tessellation level 4.0.
No shading language code is written for this stage.</p>
<p><strong>Tessellation Evaluation Shader (TES)</strong>: output:</p>
<ul class="simple">
<li><p><strong>Tessellated Vertices</strong>: gl_Position</p></li>
</ul>
<p>For each <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v)</span></code>, the TES computes the surface point <code class="docutils literal notranslate"><span class="pre">P(u,</span> <span class="pre">v)</span></code> as:</p>
<div class="math notranslate nohighlight">
\[P(u, v)
\;=\;
\sum_{i=0}^{3} \sum_{j=0}^{3}
B_i(u)\, B_j(v)\, P_{ij}\]</div>
<p>where the Bernstein basis functions are:</p>
<div class="math notranslate nohighlight">
\[B_0(t) = (1 - t)^3,\qquad
B_1(t) = 3t(1 - t)^2,\qquad
B_2(t) = 3t^2(1 - t),\qquad
B_3(t) = t^3.\]</div>
<p>The TES evaluates the Bézier surface at each tessellated (u, v)
coordinate using the 16 CPs.</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="cp">#version 450 core</span>
<span class="k">layout</span><span class="p">(</span><span class="n">quads</span><span class="p">,</span><span class="w"> </span><span class="n">equal_spacing</span><span class="p">,</span><span class="w"> </span><span class="n">cw</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="p">;</span>

<span class="kt">float</span><span class="w"> </span><span class="n">B</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mo">0</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">gl_TessCoord</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">gl_TessCoord</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>

<span class="w">    </span><span class="kt">vec4</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">vec4</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">;</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">bu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">u</span><span class="p">);</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kt">float</span><span class="w"> </span><span class="n">bv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">);</span>
<span class="w">            </span><span class="n">p</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nb">gl_in</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="nb">gl_Position</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">bu</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">bv</span><span class="p">);</span>
<span class="w">            </span><span class="n">idx</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nb">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Result</strong></p>
<p>The output for (TCS → TS → TES) in patching a single rectangle as the
following table.</p>
<p>Inflated Bézier Patch: Control Points and Evaluated Surface (vec4)</p>
<p>All control points use homogeneous coordinates (x, y, z, w = 1.0).
Evaluated surface points P(u,v) are also vec4.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 11.1%" />
<col style="width: 22.2%" />
<col style="width: 33.3%" />
<col style="width: 33.3%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong>CP Index</strong></p></th>
<th class="head"><p><strong>Grid Position (i, j)</strong></p></th>
<th class="head"><p><strong>Control Point (x, y, z, w)</strong></p></th>
<th class="head"><p><strong>Evaluated P(u,v) = vec4</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>(0, 0)</p></td>
<td><p>(0, 0, 0, 1)</p></td>
<td><p>(0.0, 0.0, 0.0, 1)</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>(1, 0)</p></td>
<td><p>(1, 0, 0, 1)</p></td>
<td><p>(1.0, 0.0, 0.0, 1)</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>(2, 0)</p></td>
<td><p>(2, 0, 0, 1)</p></td>
<td><p>(2.0, 0.0, 0.0, 1)</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>(3, 0)</p></td>
<td><p>(3, 0, 0, 1)</p></td>
<td><p>(3.0, 0.0, 0.0, 1)</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>(0, 1)</p></td>
<td><p>(0, 1, 0, 1)</p></td>
<td><p>(0.0, 1.0, 0.0, 1)</p></td>
</tr>
<tr class="row-odd"><td><p>5</p></td>
<td><p>(1, 1)</p></td>
<td><p>(1, 1, 1, 1)</p></td>
<td><p>(1.0, 1.0, 0.5625, 1)</p></td>
</tr>
<tr class="row-even"><td><p>6</p></td>
<td><p>(2, 1)</p></td>
<td><p>(2, 1, 1, 1)</p></td>
<td><p>(2.0, 1.0, 0.5625, 1)</p></td>
</tr>
<tr class="row-odd"><td><p>7</p></td>
<td><p>(3, 1)</p></td>
<td><p>(3, 1, 0, 1)</p></td>
<td><p>(3.0, 1.0, 0.0, 1)</p></td>
</tr>
<tr class="row-even"><td><p>8</p></td>
<td><p>(0, 2)</p></td>
<td><p>(0, 2, 0, 1)</p></td>
<td><p>(0.0, 2.0, 0.0, 1)</p></td>
</tr>
<tr class="row-odd"><td><p>9</p></td>
<td><p>(1, 2)</p></td>
<td><p>(1, 2, 1, 1)</p></td>
<td><p>(1.0, 2.0, 0.5625, 1)</p></td>
</tr>
<tr class="row-even"><td><p>10</p></td>
<td><p>(2, 2)</p></td>
<td><p>(2, 2, 1, 1)</p></td>
<td><p>(2.0, 2.0, 0.5625, 1)</p></td>
</tr>
<tr class="row-odd"><td><p>11</p></td>
<td><p>(3, 2)</p></td>
<td><p>(3, 2, 0, 1)</p></td>
<td><p>(3.0, 2.0, 0.0, 1)</p></td>
</tr>
<tr class="row-even"><td><p>12</p></td>
<td><p>(0, 3)</p></td>
<td><p>(0, 3, 0, 1)</p></td>
<td><p>(0.0, 3.0, 0.0, 1)</p></td>
</tr>
<tr class="row-odd"><td><p>13</p></td>
<td><p>(1, 3)</p></td>
<td><p>(1, 3, 0, 1)</p></td>
<td><p>(1.0, 3.0, 0.0, 1)</p></td>
</tr>
<tr class="row-even"><td><p>14</p></td>
<td><p>(2, 3)</p></td>
<td><p>(2, 3, 0, 1)</p></td>
<td><p>(2.0, 3.0, 0.0, 1)</p></td>
</tr>
<tr class="row-odd"><td><p>15</p></td>
<td><p>(3, 3)</p></td>
<td><p>(3, 3, 0, 1)</p></td>
<td><p>(3.0, 3.0, 0.0, 1)</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-center">
<colgroup>
<col style="width: 50.0%" />
<col style="width: 50.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><figure class="align-default" id="id231">
<span id="ts-ex-left"></span><a class="reference internal image-reference" href="_images/ts-ex.png"><img alt="_images/ts-ex.png" height="512" src="_images/ts-ex.png" width="512" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 88 </span><span class="caption-text">The final rendering result for 5×5 tessellated mesh.</span><a class="headerlink" href="#id231" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</td>
<td><figure class="align-default" id="id232">
<span id="ts-ex-right"></span><a class="reference internal image-reference" href="_images/ts-gs-ex.png"><img alt="_images/ts-gs-ex.png" height="512" src="_images/ts-gs-ex.png" width="512" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 89 </span><span class="caption-text">Geometry Shader (GS) can expand a 5×5 tessellated grid into a 6×6 mesh</span><a class="headerlink" href="#id232" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</td>
</tr>
</tbody>
</table>
<p>The following TCS glsl from the Red Book can patch high or low resolution of
CPs at runtime according the distance of the squre vertices.</p>
<p>Specifying Tessellation Level Factors Using Perimeter Edge Centers.</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="cp">#version 450 core</span>

<span class="c1">// Each patch has four precomputed edge centers:</span>
<span class="c1">//   edgeCenter[0] = left edge center</span>
<span class="c1">//   edgeCenter[1] = bottom edge center</span>
<span class="c1">//   edgeCenter[2] = right edge center</span>
<span class="c1">//   edgeCenter[3] = top edge center</span>
<span class="k">struct</span><span class="w"> </span><span class="n">EdgeCenters</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">vec4</span><span class="w"> </span><span class="n">edgeCenter</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">};</span>

<span class="c1">// Array of edge-center data, one entry per patch</span>
<span class="k">uniform</span><span class="w"> </span><span class="n">EdgeCenters</span><span class="w"> </span><span class="k">patch</span><span class="p">[];</span>

<span class="c1">// Camera position in world space</span>
<span class="k">uniform</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">EyePosition</span><span class="p">;</span>

<span class="k">layout</span><span class="p">(</span><span class="n">vertices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="k">out</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Pass through control points unchanged</span>
<span class="w">    </span><span class="nb">gl_out</span><span class="p">[</span><span class="nb">gl_InvocationID</span><span class="p">].</span><span class="nb">gl_Position</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="nb">gl_in</span><span class="p">[</span><span class="nb">gl_InvocationID</span><span class="p">].</span><span class="nb">gl_Position</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Synchronize all invocations</span>
<span class="w">    </span><span class="n">barrier</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Only invocation 0 computes tessellation levels</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">gl_InvocationID</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mo">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Loop over the four perimeter edges</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// Distance from eye to this edge center</span>
<span class="w">            </span><span class="kt">float</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">distance</span><span class="p">(</span>
<span class="w">                </span><span class="k">patch</span><span class="p">[</span><span class="nb">gl_PrimitiveID</span><span class="p">].</span><span class="n">edgeCenter</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
<span class="w">                </span><span class="kt">vec4</span><span class="p">(</span><span class="n">EyePosition</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">)</span>
<span class="w">            </span><span class="p">);</span>

<span class="w">            </span><span class="c1">// Scale factor controlling how quickly tessellation increases</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">lodScale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.5</span><span class="p">;</span>

<span class="w">            </span><span class="c1">// Convert distance to tessellation level</span>
<span class="w">            </span><span class="kt">float</span><span class="w"> </span><span class="n">tessLOD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mix</span><span class="p">(</span>
<span class="w">                </span><span class="mf">0.0</span><span class="p">,</span>
<span class="w">                </span><span class="nb">gl_MaxTessGenLevel</span><span class="p">,</span>
<span class="w">                </span><span class="n">d</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">lodScale</span>
<span class="w">            </span><span class="p">);</span>

<span class="w">            </span><span class="nb">gl_TessLevelOuter</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tessLOD</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="cp">#if 1</span>
<span class="w">        </span><span class="c1">// Compute the inner tessellation as the average of opposing outer</span>
<span class="w">        </span><span class="c1">// edges: differently from Red Book.</span>
<span class="w">        </span><span class="c1">// It’s what most engines (Unreal, Unity HDRP, Vulkan samples) do.</span>
<span class="w">        </span><span class="c1">// Inner tessellation is the average of outer levels</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">inner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span>
<span class="w">            </span><span class="p">(</span><span class="nb">gl_TessLevelOuter</span><span class="p">[</span><span class="mo">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">gl_TessLevelOuter</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

<span class="w">        </span><span class="n">inner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clamp</span><span class="p">(</span><span class="n">inner</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="nb">gl_MaxTessGenLevel</span><span class="p">);</span>
<span class="w">        </span><span class="nb">gl_TessLevelInner</span><span class="p">[</span><span class="mo">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inner</span><span class="p">;</span>
<span class="w">        </span><span class="nb">gl_TessLevelInner</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inner</span><span class="p">;</span>
<span class="w">    </span><span class="cp">#else</span>
<span class="w">        </span><span class="c1">// The Red Book computes outer tessellation levels first, then</span>
<span class="w">        </span><span class="c1">// derives the inner levels from the last computed tessLOD.</span>
<span class="w">        </span><span class="n">tessLOD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clamp</span><span class="p">(</span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">tessLOD</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="nb">gl_MaxTessGenLevel</span><span class="p">);</span>
<span class="w">        </span><span class="nb">gl_TessLevelInner</span><span class="p">[</span><span class="mo">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tessLOD</span><span class="p">;</span>
<span class="w">        </span><span class="nb">gl_TessLevelInner</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tessLOD</span><span class="p">;</span>
<span class="w">    </span><span class="cp">#endif</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The texture function with the argument DisplacementMap in the Red Book, as
shown in the following code, does not return color data as in the Fragment
Shader.
It returns the vertex position data for displacement, such as a roughness map
or anything related to surface appearance.</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="n">p</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">texture</span><span class="p">(</span><span class="n">DisplacementMap</span><span class="p">,</span><span class="w"> </span><span class="nb">gl_TessCoord</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="mobile-gpu-3d-rendering">
<h4><a class="toc-backref" href="#id325" role="doc-backlink">Mobile GPU 3D Rendering</a><a class="headerlink" href="#mobile-gpu-3d-rendering" title="Link to this heading">¶</a></h4>
<p>The traditional desktop GPUs is <strong>IMR — Immediate‑Mode Rendering</strong>:
Cache misses dominate bandwidth.</p>
<p><strong>TBDR — Tile‑Based Deferred Rendering</strong>:
Cache misses are nearly eliminated.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>Idea:</strong></p>
<p>1. TBDR divides the whole frame into small tiles that fit entirely into
on‑chip <strong>SRAM</strong>.</p>
<p>2. Remove stages of Tessellation Control Shader (TCS), Tessellation
Evaluation Shader (TES) and Geometry Shader (GS) since they are optional stages
are shown in <a class="reference internal" href="#opengl-pipeline"><span class="std std-numref">Fig. 84</span></a>.
Instead, developers use <strong>compute shaders</strong> before the graphics pipeline to
generate meshlets, perform LOD selection, or add extra geometric detail for
close‑up <strong>room-in</strong> effects is shown as
<a class="reference internal" href="#mobile-mesh-to-meshlets-to-render"><span class="std std-numref">Fig. 92</span></a>.</p>
</div>
<p>★ TBDR reduces <strong>cache‑miss</strong> rate by roughly <strong>10×–50×</strong> compared to IMR,
because all intermediate color/depth/stencil traffic stays in on‑chip
tile memory instead of going to L2/DRAM.</p>
<p>★ Desktop GPUs adopt IMR partly because GS/Tess/Mesh Shaders cannot run
efficiently on TBDR.
In addition, desktop GPUs adopt IMR because they have the <strong>power</strong>,
<strong>bandwidth</strong>, and architectural freedom to <strong>support unpredictable
geometry pipelines</strong> and massive workloads that would break TBDR’s
tile‑based constraints.</p>
<section id="tbdr-tilebased-deferred-rendering">
<h5><a class="toc-backref" href="#id326" role="doc-backlink">TBDR — Tile‑Based Deferred Rendering</a><a class="headerlink" href="#tbdr-tilebased-deferred-rendering" title="Link to this heading">¶</a></h5>
<p>⚠️  For <strong>low power</strong> mobile device, mobile GPUs use <strong>tile-based</strong>
rendering to <strong>reduce the traffice to DRAM</strong> as
described below:</p>
<p>The traditional desktop GPUs is IMR — Immediate‑Mode Rendering:</p>
<ol class="arabic simple">
<li><p>IMR: “Draw call arrives → render immediately”</p></li>
</ol>
<p>CPU issues DrawCall #1</p>
<p>→ GPU transforms vertices</p>
<p>→ GPU rasterizes fragments</p>
<p>→ GPU writes to DRAM</p>
<p>It never waits to see the rest of the frame.</p>
<p>2. TBDR: “Draw call arrives → store geometry, don’t render yet”.
TBDR processes it into two phases as follows:</p>
<p><strong>Phase 1 — Binning</strong> (Full‑Frame Geometry Processing) is shown as
<a class="reference internal" href="#tbdr-pipeline"><span class="std std-numref">Fig. 90</span></a>.</p>
<figure class="align-default" id="id233">
<span id="tbdr-pipeline"></span><div class="graphviz"><img src="_images/graphviz-b8ac8ce572f69b89bf0e542dabd73deb1b9cf604.png" alt="digraph TBDR_Binning_Flow {
    rankdir=LR;
    node [shape=box, style=rounded];

    CPU_DrawCall   [label=&quot;CPU Issues Draw Call&quot;];
    VS              [label=&quot;Vertex Shader\n(Transform Vertices)&quot;];
    TriangleSetup   [label=&quot;Triangle Setup\n(Bounding Box, Coverage)&quot;];
    Binner          [label=&quot;Tile Binner\n(Determine Which Tiles Each Triangle Touches)&quot;];
    TileLists       [label=&quot;Per-Tile Triangle Lists\n(Store Geometry, No Rendering Yet)&quot;];

    CPU_DrawCall -&gt; VS -&gt; TriangleSetup -&gt; Binner -&gt; TileLists;
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 90 </span><span class="caption-text">TBDR Pipeline</span><a class="headerlink" href="#id233" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>When a draw call arrives on a TBDR GPU:</p>
<p>→ It runs the vertex shader</p>
<p>→ It transforms all triangles</p>
<p>→ It determines which tiles each triangle touches</p>
<p>→ It stores triangle references in <strong>per‑tile lists</strong> is shown as follows:</p>
<p class="rubric">Example of per‑tile lists</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Tile 0 → triangles: [T1, T7, T8, T20]
Tile 1 → triangles: [T2, T3, T7]
Tile 2 → triangles: [T4, T5, T6, T9, T10]
...
</pre></div>
</div>
<p><strong>Phase 2 — Tile Rendering</strong> (Deferred Shading)</p>
<p>For each tile:</p>
<p>→ Load tile’s triangle list</p>
<p>→ Rasterize only those triangles</p>
<p>→ Shade only visible fragments</p>
<p>→ Keep all intermediate buffers in on‑chip <strong>SRAM</strong></p>
<p>→ Write final tile to DRAM once</p>
<p>★ As you can see, tile is a small part of rendering frame.
In Phase 2 — Tile Rendering, GPU rendering each tile and
keep the rendering result of each <strong>tile in SRAM</strong>.</p>
</section>
<section id="tbdr-rendering">
<h5><a class="toc-backref" href="#id327" role="doc-backlink">TBDR Rendering</a><a class="headerlink" href="#tbdr-rendering" title="Link to this heading">¶</a></h5>
<p>✅ Rendering flow:</p>
<blockquote>
<div><ul class="simple">
<li><p>Vertax Shader → Primitive Setup → <strong>Tile-Based Culling and Clipping</strong> →
Rasterization → Fragment Shader</p></li>
</ul>
</div></blockquote>
<p>TBDR architectures depend on:</p>
<ul class="simple">
<li><p>predictable geometry counts,</p></li>
<li><p>small on-chip tile memory,</p></li>
<li><p>minimal external memory traffic.</p></li>
</ul>
<p>⚠️  As described in section <a class="reference internal" href="#three-d-rendering-pipeline"><span class="std std-ref">3D Rendering Pipeline</span></a>,
Geometry Shader (GS) can generate both more vertices and more
primitives than it receives.
A single patch from Tesslation Control Shader (TCS) and Tesslation Evaluation
Shader (TVS) can generate millions of micro‑triangles.
GS and Tessellation introduce <strong>unbounded geometry amplification</strong>, which
breaks these assumptions and forces expensive DRAM spills for TBDR as shown in
<a class="reference internal" href="#mobile-tile-base-pipeline"><span class="std std-numref">Fig. 91</span></a>,</p>
<figure class="align-default" id="id234">
<span id="mobile-tile-base-pipeline"></span><div class="graphviz"><img src="_images/graphviz-da0d8487fc2b2189966ed8ee986df42359e8059d.png" alt="digraph TBDR_GS_Comparison {
    rankdir=LR;
    node [shape=box, style=rounded, fontsize=11];

    // Clean TBDR pipeline
    subgraph cluster_clean {
        label=&quot;A. Clean TBDR Pipeline (Mobile GPUs: Mali / PowerVR / Apple)&quot;;
        style=rounded;

        C_VS   [label=&quot;Vertex Shader\n• Transform\n• Skinning\n• Varyings&quot;];
        C_PA   [label=&quot;Primitive Assembly\n• Triangle setup\n• Culling\n• Clipping&quot;];
        C_Tile [label=&quot;Tiling / Binning\n• Bin triangles\n• Build tile lists\n• Predictable geometry&quot;];
        C_Rast [label=&quot;Rasterization\n• Triangle traversal\n• Pixel coverage\n• Early-Z&quot;];
        C_FS   [label=&quot;Fragment Shader\n• Shading\n• Texturing\n• Lighting&quot;];
        C_WB   [label=&quot;Tile Writeback\n• Store tile once\n• Low bandwidth&quot;];

        C_VS -&gt; C_PA -&gt; C_Tile -&gt; C_Rast -&gt; C_FS -&gt; C_WB;
    }

    // GS/Tessellation amplified pipeline
    subgraph cluster_gs {
        label=&quot;B. TBDR with GS/Tessellation (Hypothetical — Why It Breaks)&quot;;
        style=rounded;

        G_VS   [label=&quot;Vertex Shader&quot;];
        G_Tess [label=&quot;Tessellation / Geometry Shader\n• 1→64→256 triangles\n• Unbounded amplification\n• View-dependent&quot;];
        G_PA   [label=&quot;Primitive Assembly\n(post-amplification)&quot;];
        G_Tile [label=&quot;Tiling / Binning\n• Tile list overflow\n• Unpredictable size\n• May spill to DRAM&quot;];
        G_Rast [label=&quot;Rasterization\n• Heavy load due to amplified geometry&quot;];
        G_FS   [label=&quot;Fragment Shader&quot;];
        G_WB   [label=&quot;Tile Writeback\n• Multiple passes\n• High bandwidth&quot;];

        G_VS -&gt; G_Tess -&gt; G_PA -&gt; G_Tile -&gt; G_Rast -&gt; G_FS -&gt; G_WB;
    }

    // Annotation arrows
    G_Tess -&gt; G_Tile [label=&quot;massive geometry\namplification&quot;, color=&quot;red&quot;];
    G_Tile -&gt; G_WB   [label=&quot;DRAM spills\n(high power)&quot;, color=&quot;red&quot;];
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 91 </span><span class="caption-text">CPU and GPU Pipeline For Shaders in Mobile Device</span><a class="headerlink" href="#id234" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>This is why Mali,
PowerVR, Apple, and Adreno mobile GPUs all omit these stages <a class="footnote-reference brackets" href="#arm-gs" id="id76" role="doc-noteref"><span class="fn-bracket">[</span>41<span class="fn-bracket">]</span></a>
<a class="footnote-reference brackets" href="#img-gs" id="id77" role="doc-noteref"><span class="fn-bracket">[</span>42<span class="fn-bracket">]</span></a>.</p>
<p>Developers manually invoke <strong>compute shaders</strong> to generate meshlets or
additional geometry, adding extra geometric detail for close-up <strong>zoom-in</strong>
effects.
Both Mali and PowerVR GPUs then run the standard vertex shader on the generated
results.</p>
<p>✔ Step 1 — Developer dispatches a compute shader</p>
<p>This compute shader can do things like:</p>
<ul class="simple">
<li><p>break a <strong>big mesh</strong> into <strong>meshlets</strong> as
<a class="reference internal" href="#mobile-mesh-to-meshlets-to-render"><span class="std std-numref">Fig. 92</span></a>.
The mesh and meshlets are described in the <a class="reference internal" href="#mesh-shader"><span class="std std-ref">Mesh-Shader Pipeline</span></a> next
section.</p></li>
<li><p>generate <strong>more vertices</strong> for detail (subdivision, displacement)</p></li>
<li><p>perform <strong>LOD</strong> selection</p></li>
<li><p>cull invisible meshlets</p></li>
<li><p>generate new index/vertex buffers</p></li>
</ul>
<p>This is developer‑controlled, not automatic.</p>
<figure class="align-default" id="id235">
<span id="mobile-mesh-to-meshlets-to-render"></span><div class="graphviz"><img src="_images/graphviz-dbad710c6206399b37ab311e8caaee4b64156a6a.png" alt="digraph Meshlet_Convert_To_Render_Mobile {
    rankdir=LR;
    node [shape=box, style=rounded, fontsize=12];

    subgraph cluster_input {
        label=&quot;Input Mesh Data&quot;;
        style=rounded;

        BigMesh [label=&quot;Big Mesh\n(Vertex + Index Buffers)&quot;];
    }

    subgraph cluster_runtime {
        label=&quot;Runtime / GPU Conversion&quot;;
        style=rounded;

        CS_Convert [label=&quot;Compute Shader\n(Convert Mesh → Meshlets,\nCluster Vertices &amp; Triangles,\nCulling, LOD,\nBuild Meshlet Tables)&quot;,
                    style=filled, fillcolor=orange];

        Meshlets [label=&quot;Generated Meshlets\n(Runtime GPU Data)&quot;];
    }

    subgraph cluster_render {
        label=&quot;Mobile Meshlet Rendering Flow\n(Compute + VS Pipeline)&quot;;
        style=rounded;

        VS [label=&quot;Mobile Rendering Pipeline\n(VS Pipeline&quot;];
    }

    BigMesh -&gt; CS_Convert;
    CS_Convert -&gt; Meshlets;
    Meshlets -&gt; VS;
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 92 </span><span class="caption-text">CPU and GPU Pipeline For Shader`s in Mobile Device</span><a class="headerlink" href="#id235" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The compute shader writes results into:</p>
<ul class="simple">
<li><p>SSBOs</p></li>
<li><p>vertex buffers</p></li>
<li><p>index buffers</p></li>
</ul>
<p>These buffers now contain the final geometry you want to render.</p>
<p>✔ Step 2 — Developer issues a normal draw call</p>
<p>The Mali and PowerVR’s rendering flow is illustrated as
<a class="reference internal" href="#mobile-rendering-pipeline-shaders-cpu-gpu"><span class="std std-numref">Fig. 93</span></a>.</p>
<figure class="align-default" id="id236">
<span id="mobile-rendering-pipeline-shaders-cpu-gpu"></span><div class="graphviz"><img src="_images/graphviz-ed7695039a41b16216b33ebda721f62661bb2f88.png" alt="digraph Mobile_GPU_Comparison {
    rankdir=TB;
    node [shape=box, style=rounded, fontsize=11];

    // ARM Mali cluster
    subgraph cluster_mali {
        label=&quot;ARM Mali TBDR Pipeline&quot;;
        style=rounded;

        Mali_VS [label=&quot;Vertex Shader (VS)\n• Vertex fetch\n• Skinning / morphing\n• Model→World→Clip transforms\n• Varying generation&quot;, style=&quot;filled,rounded,bold&quot;, fillcolor=&quot;orange&quot;];
        Mali_PA [label=&quot;Primitive Assembly\n• Triangle assembly\n• Back-face culling\n• Clipping\n• Viewport transform&quot;, style=&quot;filled,rounded,bold&quot;, fillcolor=&quot;lightyellow&quot;];
        Mali_Tiling [label=&quot;Tiling / Binning\n• Bin triangles into tiles\n• Per-tile visibility\n• Tile list construction&quot;];
        Mali_Raster [label=&quot;Rasterization\n• Triangle traversal\n• Pixel coverage\n• Early-Z&quot;];
        Mali_FS [label=&quot;Fragment Shader (FS)\n• Shading\n• Texturing\n• Lighting\n• Blending&quot;, style=&quot;filled,rounded,bold&quot;, fillcolor=&quot;orange&quot;];
        Mali_Writeback [label=&quot;Tile Writeback\n• Store tile to framebuffer\n• Resolve MSAA&quot;];

        Mali_VS -&gt; Mali_PA -&gt; Mali_Tiling -&gt; Mali_Raster -&gt; Mali_FS -&gt; Mali_Writeback;
    }

    // PowerVR cluster
    subgraph cluster_powervr {
        label=&quot;Imagination PowerVR TBDR Pipeline&quot;;
        style=rounded;

        PV_VS [label=&quot;Vertex Shader (VS)\n• Vertex fetch\n• Skinning / morphing\n• Transform to clip space\n• Varying generation&quot;, style=&quot;filled,rounded,bold&quot;, fillcolor=&quot;orange&quot;];
        PV_PB [label=&quot;Parameter Buffer (PB)\n• Store transformed vertices\n• Geometry parameter encoding\n• Prepare for tiling&quot;, style=&quot;filled,rounded,bold&quot;, fillcolor=&quot;lightyellow&quot;];
        PV_Tiling [label=&quot;Tiling / Binning\n• Tile list creation\n• Hidden surface removal (HSR)\n• Per-tile visibility&quot;];
        PV_Raster [label=&quot;Rasterization\n• Triangle traversal\n• Pixel coverage\n• Early-Z&quot;];
        PV_FS [label=&quot;Fragment Shader (FS)\n• Shading\n• Texturing\n• Lighting\n• Blending&quot;, style=&quot;filled,rounded,bold&quot;, fillcolor=&quot;orange&quot;];
        PV_Writeback [label=&quot;Tile Writeback\n• Store tile to framebuffer\n• Composition&quot;];

        PV_VS -&gt; PV_PB -&gt; PV_Tiling -&gt; PV_Raster -&gt; PV_FS -&gt; PV_Writeback;
    }

    // Compute shader (shared concept)
    Compute [shape=box, style=&quot;rounded,dashed&quot;,
             label=&quot;Compute Shader (Optional)\n• Culling\n• Skinning\n• Particle simulation\n• Buffer generation\n• Preprocessing&quot;];

    CPU [shape=box, style=rounded, label=&quot;CPU\n• glDispatchCompute\n• glDraw*&quot;];

    // Shared compute flow
    CPU -&gt; Compute [label=&quot;optional&quot;];
    Compute -&gt; Mali_VS [label=&lt;&lt;b&gt;&lt;font color=&quot;blue&quot;&gt;Small Meshlets&lt;br/&gt;in SSBO/buffers&lt;/font&gt;&lt;/b&gt;&gt;];
    Compute -&gt; PV_VS   [label=&lt;&lt;b&gt;&lt;font color=&quot;blue&quot;&gt;Small Meshlets&lt;br/&gt;in SSBO/buffers&lt;/font&gt;&lt;/b&gt;&gt;];
    CPU -&gt; Mali_VS     [label=&quot;draw call&quot;];
    CPU -&gt; PV_VS       [label=&quot;draw call&quot;];
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 93 </span><span class="caption-text">CPU and GPU Pipeline For Shaders in Mobile Device</span><a class="headerlink" href="#id236" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<ul class="simple">
<li><p>Modern mobile engines instead use <strong>compute shaders</strong> for culling, LOD,
meshlet prep, and procedural geometry.</p></li>
</ul>
<p>✅ Geometry Shaders are notoriously inefficient even on desktop GPUs.
GPU vendors (NVIDIA + AMD + Intel) designed the mesh‑shader pipeline described
in the section <a class="reference internal" href="#mesh-shader"><span class="std std-ref">Mesh-Shader Pipeline</span></a>.</p>
</section>
</section>
<section id="mesh-shader-pipeline">
<span id="mesh-shader"></span><h4><a class="toc-backref" href="#id328" role="doc-backlink">Mesh-Shader Pipeline</a><a class="headerlink" href="#mesh-shader-pipeline" title="Link to this heading">¶</a></h4>
<p>A single 3D object can contain 1 mesh, multiple meshes or hundreds of meshes
(complex characters, vehicles, weapons).</p>
<p><strong>Reasons</strong></p>
<p>The purpose of converting <strong>a mesh into small clusters (meshlets)</strong> is
to give the GPU <strong>small, coherent</strong>, cullable, cache‑friendly work units
that dramatically improve parallelism, memory locality, and LOD efficiency.</p>
<p>Raw meshes can have anywhere from thousands to millions of vertices/triangles,
while meshlets intentionally restrict clusters to ~32–128 vertices and
~32–256 triangles to maximize GPU efficiency.</p>
<p><strong>Motivation</strong></p>
<p>NVIDIA, AMD, and Intel all needed:</p>
<ul class="simple">
<li><p>a compute‑like geometry pipeline</p></li>
<li><p>meshlet‑based processing</p></li>
<li><p>better culling</p></li>
<li><p>GPU‑driven rendering</p></li>
<li><p>a <strong>replacement</strong> for VS → TCS → TES → GS</p></li>
<li><p>TCS → Fixed-Function Tessellator → TES: geometry amplification.</p>
<ul>
<li><p>Fixed‑Function Tessellator: subdivides the patch, generates new domain
coordinates and creates the tessellated grid.</p></li>
<li><p>Mesh-Shader replaces the fixed‑function tessellator with compute‑like
geometry pipeline.</p></li>
</ul>
</li>
</ul>
<p>So the vendors co‑designed the hardware pipeline.</p>
<p>✔ Microsoft and Khronos (Vulkan) each standardized it in their own APIs</p>
<p>✅ <strong>Solution</strong>: As shown in <a class="reference internal" href="#meshlet-offline-to-render"><span class="std std-numref">Fig. 94</span></a>.</p>
<figure class="align-default" id="id237">
<span id="meshlet-offline-to-render"></span><div class="graphviz"><img src="_images/graphviz-3f3d973069893eb8e11a9545e824a40362aa658c.png" alt="digraph Meshlet_Offline_To_Render {
    rankdir=LR;
    node [shape=box, style=rounded, fontsize=12];

    subgraph cluster_offline {
        label=&quot;Offline / Build Time&quot;;
        style=rounded;

        BigMesh [label=&quot;Big Mesh\n(High-Poly Model)&quot;];
        MeshletGen [label=&quot;CPU Meshlet Generator Tool\n(Cluster Vertices &amp; Triangles,\nBuild Meshlets, Culling Data)&quot;,
                    style=filled, fillcolor=orange];
        Meshlets [label=&quot;Small Clusters\n(Meshlets)\n(Precomputed)&quot;];
    }

    subgraph cluster_runtime {
        label=&quot;Runtime / Load Time&quot;;
        style=rounded;

        Loader [label=&quot;Meshlets Loader\n(Load Meshlet Buffers,\nBuild GPU-Ready Data)&quot;];
    }

    subgraph cluster_render {
        label=&quot;Mesh Rendering Flow&quot;;
        style=rounded;

        RenderFlow [label=&quot;Mesh Rendering Pipeline\n(Task/Mesh Shader or\nCompute + VS Pipeline)&quot;];
    }

    BigMesh -&gt; MeshletGen;
    MeshletGen -&gt; Meshlets;
    Meshlets -&gt; Loader;
    Loader -&gt; RenderFlow;
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 94 </span><span class="caption-text">Meshlet Offline To Render</span><a class="headerlink" href="#id237" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p><strong>Rendering Pipeline</strong></p>
<p>✔ GPU vendors (NVIDIA + AMD + Intel) designed the mesh‑shader pipeline:</p>
<p>3D Modeling Tool Output (big mesh)</p>
<p>→ CPU Meshlet Generator Tool (offline)</p>
<blockquote>
<div><ul class="simple">
<li><p>Converting <strong>big mesh</strong> into <strong>small clusters (meshlets)</strong> to maximize GPU
efficiency.</p></li>
</ul>
</div></blockquote>
<p>→ Precomputed meshlets (static clusters)</p>
<p>→ Task Shader (optional)</p>
<p>→ Mesh Shader</p>
<p>3D modeling tools do NOT generate meshlets.
Meshlets are always generated later, using specialized meshlet‑generation
→ tools, most commonly:</p>
<ul class="simple">
<li><p>NVIDIA meshlet generator (NV_mesh_shader ecosystem)</p></li>
<li><p>meshoptimizer (Khronos‑recommended, open source)</p></li>
<li><p>Engine‑specific meshlet builders (Unreal, Frostbite, etc.)</p></li>
</ul>
<p>So the meshlet conversion happens after the model is exported — not inside
Blender, Maya, 3ds Max, etc.</p>
<p>The animation flow from CPU to GPU for <strong>Traditional</strong>, <strong>Compute Shader</strong>
based and <strong>Mesh Shader</strong> are
shown in <a class="reference internal" href="#short-rendering-pipeline-shaders-cpu-gpu-2"><span class="std std-numref">Fig. 95</span></a>,
<a class="reference internal" href="#short-mobile-rendering-pipeline-shaders-cpu-gpu"><span class="std std-numref">Fig. 96</span></a> and
<a class="reference internal" href="#short-mesh-rendering-pipeline-shaders-cpu-gpu"><span class="std std-numref">Fig. 97</span></a>.</p>
<p>Mesh shading (Vulkan VK_EXT_mesh_shader, similarly in NV mesh shader) replaces
the fixed vertex-input + VS + optional tess/GS stages with a compute-like
geometry pipeline:</p>
<figure class="align-default" id="id238">
<span id="short-rendering-pipeline-shaders-cpu-gpu-2"></span><div class="graphviz"><img src="_images/graphviz-001e27daaf1ef8a9d5d084b0ca2b2dbc6f634918.png" alt="digraph CPU_GPU_Pipeline {
    rankdir=LR;
    node [shape=box, style=rounded, fontsize=12];

    subgraph cluster_cpu {
        label=&quot;CPU&quot;;
        style=rounded;
        CPU_Vertex [label=&quot;Load 3D Model\n(Vertex Data)\nVBOs, VAOs, Indices&quot;];
        CPU_Anim   [label=&quot;Update Animation Parameters\n(Bone Matrices, Morph Weights,\nTime, Material Params)&quot;];
    }

    subgraph cluster_gpu {
        label=&quot;GPU&quot;;
        style=rounded;

        VS   [label=&quot;Vertex Shader\n(Skinning, Morphing,\nModel/View/Proj Transform)&quot;,
              style=filled, fillcolor=orange];

        subgraph cluster_optional {
            label=&quot;Optional Stages&quot;;
            style=&quot;rounded,dashed&quot;;
            color=&quot;gray&quot;;

            subgraph cluster_ts {
                label=&quot;Tessellation&quot;;
                style=rounded;

                TCS  [label=&quot;Tessellation Control Shader\n(TCS)&quot;,
                      style=filled, fillcolor=orange];

                TS  [label=&quot;Fixed-Function Tessellator&quot;,
                      style=filled, fillcolor=orange];

                TES  [label=&quot;Tessellation Evaluation Shader\n(TES)&quot;,
                      style=filled, fillcolor=orange];

                TCS -&gt; TS [label=&quot;CP + Tessellation level&quot;];
                TS -&gt; TES  [label=&quot;Tessellated domain\ncoordinates&quot;];

                { rank = same;  TCS; TS; TES }
            }

            GS   [label=&quot;Geometry Shader\n(Primitive Expansion,\nCulling, Layering)&quot;,
                  style=filled, fillcolor=orange];
        }

        Raster [label=&quot;Rasterizer\n(Primitive Assembly,\nClipping, Interpolation)&quot;,
                style=filled, fillcolor=yellow];

        FS   [label=&quot;Fragment Shader\n(Lighting, Texturing,\nShading, Materials)&quot;];

        FB   [label=&quot;Final Rendered Image\n(Framebuffer Output)&quot;];
    }

    CPU_Vertex -&gt; VS [label=&lt;&lt;b&gt;&lt;font color=&quot;red&quot;&gt;Big Mesh&lt;/font&gt;&lt;/b&gt;&gt;];
    CPU_Anim   -&gt; VS;

    VS  -&gt; TCS [label=&quot;Transformed Vertices +\nControl Points(CP)&quot;];
    TES -&gt; GS [label=&quot;Tessellated Vertices\n(more vertices)&quot;];
    GS  -&gt; Raster;

    Raster -&gt; FS;
    FS -&gt; FB;
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 95 </span><span class="caption-text">CPU and GPU <strong>Traditional</strong> Pipeline For Shaders</span><a class="headerlink" href="#id238" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-default" id="id239">
<span id="short-mobile-rendering-pipeline-shaders-cpu-gpu"></span><div class="graphviz"><img src="_images/graphviz-ba7ee75e7abec13829d22c7a2bcc2f7b8fb9fb44.png" alt="digraph CPU_GPU_MobilePipeline {
    rankdir=LR;
    node [shape=box, style=rounded, fontsize=12];

    subgraph cluster_cpu {
        label=&quot;CPU&quot;;
        style=rounded;

        CPU_Vertex   [label=&quot;Load 3D Model\n(Vertex Data)\nVBOs, VAOs, Indices&quot;];
        CPU_Anim     [label=&quot;Update Animation Parameters\n(Bone Matrices, Morph Weights,\nTime, Material Params)&quot;];
    }

    subgraph cluster_gpu {
        label=&quot;GPU (Mobile / TBDR)&quot;;
        style=rounded;

        CS_Meshlet [label=&quot;Compute Shader\n(Generate Meshlets,\nCulling, LOD,\nBuild Indirect Draw Cmds)&quot;, 
                    style=filled, fillcolor=orange];

        VS         [label=&quot;Vertex Shader\n(Transform, Skinning,\nMorphing, MVP)&quot;];

        Raster     [label=&quot;Rasterizer\n(Primitive Assembly,\nClipping, Interpolation)&quot;,
                    style=filled, fillcolor=yellow];

        FS         [label=&quot;Fragment Shader\n(Lighting, Texturing,\nShading, Materials)&quot;];

        FB         [label=&quot;Final Rendered Image\n(Framebuffer Output)&quot;];
    }

    CPU_Vertex -&gt; CS_Meshlet;
    CPU_Anim   -&gt; CS_Meshlet;

    CS_Meshlet -&gt; VS [label=&lt;&lt;b&gt;&lt;font color=&quot;blue&quot;&gt;Small Meshlets&lt;/font&gt;&lt;/b&gt;&gt;];
    VS -&gt; Raster;
    Raster -&gt; FS;
    FS -&gt; FB;
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 96 </span><span class="caption-text">CPU and GPU <strong>Mobile</strong> Pipeline For Shaders</span><a class="headerlink" href="#id239" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-default" id="id240">
<span id="short-mesh-rendering-pipeline-shaders-cpu-gpu"></span><div class="graphviz"><img src="_images/graphviz-e51f607f338d5730208764bc92221d573274c56c.png" alt="digraph CPU_GPU_Pipeline {
    rankdir=LR;
    node [shape=box, style=rounded, fontsize=12];

    subgraph cluster_cpu {
        label=&quot;CPU&quot;;
        style=rounded;
        CPU_Vertex   [label=&quot;Load 3D Model\n(Vertex Data)\nVBOs, VAOs, Indices&quot;];
        MeshletGen   [label=&quot;Meshlet Generator Tool\n(Cluster Vertices &amp; Triangles,\nBuild Meshlets, Culling Data)&quot;, style=filled, fillcolor=orange];
        CPU_Anim     [label=&quot;Update Animation Parameters\n(Bone Matrices, Morph Weights,\nTime, Material Params)&quot;];
    }

    subgraph cluster_gpu {
        label=&quot;GPU&quot;;
        style=rounded;

        TaskS   [label=&quot;Task Shader (Optional)\n(Work Distribution,\nMeshlet Dispatch)&quot;, style=filled, fillcolor=orange];
        MeshS   [label=&quot;Mesh Shader\n(Expand Meshlets,\nCulling, LOD,\nEmit Triangles\nskinning)&quot;, style=filled, fillcolor=orange];

        Raster  [label=&quot;Rasterizer\n(Consumes Mesh Shader Output,\nClipping, Interpolation)&quot;, style=filled, fillcolor=yellow];

        FS      [label=&quot;Fragment Shader\n(Lighting, Texturing,\nShading, Materials)&quot;];
        FB      [label=&quot;Final Rendered Image\n(Framebuffer Output)&quot;];
    }

    CPU_Vertex -&gt; MeshletGen;
    MeshletGen -&gt; TaskS [label=&lt;&lt;b&gt;&lt;font color=&quot;blue&quot;&gt;Small Meshlets&lt;/font&gt;&lt;/b&gt;&gt;];
    CPU_Anim   -&gt; TaskS;

    TaskS -&gt; MeshS;
    MeshS -&gt; Raster;
    Raster -&gt; FS;
    FS -&gt; FB;
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 97 </span><span class="caption-text">CPU and GPU <strong>Mesh Shader</strong> Pipeline For Shaders</span><a class="headerlink" href="#id240" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>As in <a class="reference internal" href="#short-mesh-rendering-pipeline-shaders-cpu-gpu"><span class="std std-numref">Fig. 97</span></a>,
NVIDIA/AMD desktop provide mesh‑shader to do the following pipeline.</p>
<p><strong>Task Shader Responsibilities</strong></p>
<p>The <strong>Task Shader</strong> acts as a coarse-grained work distributor.</p>
<p>Key responsibilities:</p>
<ul class="simple">
<li><p>Perform coarse culling at the meshlet or instance level.</p></li>
<li><p>Select appropriate <strong>LODs</strong> for distant geometry.</p>
<ul>
<li><p>But it does not create new detail like the Tessellation Shaders.</p></li>
</ul>
</li>
<li><p>Build a compact list of meshlets to be processed.</p></li>
<li><p>Determine how many mesh shader workgroups to launch.</p></li>
<li><p>Pass a payload (task data) to mesh shader workgroups.</p></li>
</ul>
<p>The task shader does <em>not</em> emit vertices or primitives.</p>
<p><strong>Mesh Shader Responsibilities</strong></p>
<p>The <strong>mesh shader</strong> replaces the vertex shader, tessellation, and often
the geometry shader. It operates on meshlets inside workgroups.</p>
<p>Key responsibilities:</p>
<ul class="simple">
<li><p>Load meshlet vertices and indices from GPU memory.</p></li>
<li><p>Apply transforms, skinning, morphing, and procedural deformation.</p></li>
<li><p>Mesh Shader outputs exactly what the meshlet contains usually, unless you
code it manually.</p>
<ul>
<li><p>Custom procedural code inside a Mesh Shader can generate more vertices,
subdivide triangles, procedurally generate detail, amplify geometry.
Mesh Shaders replace Vertex Shader, Geometry Shader and Tessellation
(optional). But they do not perform automatic tessellation.
They simply take a meshlet, run a workgroup and output the triangles
inside that meshlet.</p></li>
</ul>
</li>
<li><p>Perform fine-grained culling:
- frustum culling
- backface culling
- small triangle culling
- cluster-level culling</p></li>
<li><p>Generate the final set of vertices and primitives.</p></li>
<li><p>Emit primitives directly to the rasterizer.</p></li>
</ul>
<p>Because mesh shaders run in workgroups, they can use shared memory and
synchronize threads, enabling efficient reuse of vertex data.</p>
<p><strong>Why Meshlets Fit GPU Architecture Well</strong></p>
<p>Meshlets align naturally with GPU hardware for several reasons:</p>
<ul class="simple">
<li><p><strong>Workgroup-Friendly:</strong>
Each meshlet maps cleanly to a single workgroup, keeping memory usage
predictable and minimizing divergence.</p></li>
<li><p><strong>Cache Efficiency:</strong>
Meshlets maximize vertex reuse and reduce memory bandwidth by grouping
spatially local geometry.</p></li>
<li><p><strong>Hierarchical Culling:</strong>
- Task shader: coarse culling of entire meshlets.
- Mesh shader: fine culling of individual primitives.</p></li>
<li><p><strong>Reduced CPU Overhead:</strong>
The GPU can perform culling, LOD selection, and primitive generation
without CPU intervention, enabling GPU-driven rendering.</p></li>
<li><p><strong>Scalable Parallelism:</strong>
Each meshlet is processed independently, allowing thousands of
workgroups to run in parallel across GPU SMs.</p></li>
</ul>
<p>Both Mobile GPU and Mesh-Shader GPU convert big mesh to small meshlets and
render them efficiently using GPU SIMT executation and memory hierarchy.
The comparsion is shown in the following table.</p>
<p><strong>Comparsion: Mobile GPU (Compute-Shader Based) vs Desktop Mesh-Shader GPU</strong></p>
<p>The <strong>Mesh Shader</strong> is similar to the previous section of <strong>Mobile
Compute Shader</strong> based Meshlets as the following table:</p>
<table class="docutils align-default" id="id241">
<caption><span class="caption-number">Table 53 </span><span class="caption-text">Mobile GPU vs Desktop Mesh-Shader GPU – <strong>Concept Comparison</strong></span><a class="headerlink" href="#id241" title="Link to this table">¶</a></caption>
<colgroup>
<col style="width: 26.3%" />
<col style="width: 36.8%" />
<col style="width: 36.8%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Concept</p></th>
<th class="head"><p>Mobile GPU (Compute-Shader Based)</p></th>
<th class="head"><p>Desktop Mesh-Shader GPU</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>Meshlet generation</strong></p></td>
<td><p><strong>Compute Shader</strong> generates meshlets at runtime</p></td>
<td><p><strong>CPU Meshlet Generator Tool</strong> (offline)</p></td>
</tr>
<tr class="row-odd"><td><p>Tile-based</p></td>
<td><p>Yes</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-even"><td><p>Work distribution</p></td>
<td><p>Compute Shader dispatch groups handle distribution</p></td>
<td><p>Task Shader distributes meshlet workloads</p></td>
</tr>
<tr class="row-odd"><td><p>Meshlet expansion</p></td>
<td><p>Vertex Shader processes vertices after compute pre-processing</p></td>
<td><p>Mesh Shader expands meshlets and emits triangles</p></td>
</tr>
<tr class="row-even"><td><p>Culling &amp; LOD</p></td>
<td><p>Compute Shader performs culling and LOD before raster</p></td>
<td><p>Task + Mesh Shader perform culling and LOD selection</p></td>
</tr>
<tr class="row-odd"><td><p>Draw submission</p></td>
<td><p>Compute Shader writes indirect draw commands</p></td>
<td><p>Mesh Shader emits primitives directly to rasterizer</p></td>
</tr>
<tr class="row-even"><td><p>Pipeline family</p></td>
<td><p>Traditional Pipeline (VS → Raster → FS)</p></td>
<td><p>Mesh-Shader Pipeline (Task → Mesh → Raster → FS)</p></td>
</tr>
</tbody>
</table>
<p><strong>Summary</strong></p>
<p>Meshlets and the mesh-shader pipeline transform geometry processing into
a compute-like workflow. By organizing geometry into small, cache-friendly
clusters and distributing work across task and mesh shaders, modern GPUs
achieve higher throughput, better culling efficiency, and reduced CPU
overhead compared to the traditional vertex-processing pipeline.</p>
</section>
<section id="animation-example">
<span id="animation-ex"></span><h4><a class="toc-backref" href="#id329" role="doc-backlink">Animation Example</a><a class="headerlink" href="#animation-example" title="Link to this heading">¶</a></h4>
<p>The skinning formula is described in <a class="reference internal" href="#sw-stack"><span class="std std-ref">SW Stack and Data Flow</span></a> section as follows:</p>
<div class="math notranslate nohighlight">
\[finalPosition =
\sum_{i=0}^{N-1}
\mathbf{weight}_i \left( \mathbf{boneMatrix}_i \cdot originalPosition \right)\]</div>
<p>The following code implements the formula shown above.</p>
<p class="rubric">GLSL Vertex Shader</p>
<div class="literal-block-wrapper docutils container" id="id242">
<div class="code-block-caption"><span class="caption-number">Listing 1 </span><span class="caption-text">Example GPU skinning</span><a class="headerlink" href="#id242" title="Link to this code">¶</a></div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">position</span><span class="p">;</span>
<span class="n">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">uvec4</span><span class="w"> </span><span class="n">boneIndex</span><span class="p">;</span>
<span class="n">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">vec4</span><span class="w"> </span><span class="n">boneWeights</span><span class="p">;</span>

<span class="c1">// Simple Uniforms (non-UBO)</span>
<span class="n">uniform</span><span class="w"> </span><span class="n">mat4</span><span class="w"> </span><span class="n">boneMatrices</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
<span class="n">uniform</span><span class="w"> </span><span class="n">mat4</span><span class="w"> </span><span class="n">model</span><span class="p">;</span>
<span class="n">uniform</span><span class="w"> </span><span class="n">mat4</span><span class="w"> </span><span class="n">view</span><span class="p">;</span>
<span class="n">uniform</span><span class="w"> </span><span class="n">mat4</span><span class="w"> </span><span class="n">projection</span><span class="p">;</span>

<span class="n">vec4</span><span class="w"> </span><span class="n">skinnedPos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec4</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">skinnedPos</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">boneMatrices</span><span class="p">[</span><span class="n">boneIndex</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">vec4</span><span class="p">(</span><span class="n">position</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">boneWeight</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
<span class="n">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">projection</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">view</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">skinnedPos</span><span class="p">;</span>
</pre></div>
</div>
</div>
<p>Here:</p>
<ul>
<li><p><strong>position, boneIndex, boneWeight = vertex attributes</strong></p></li>
<li><p><strong>boneMatrices, model, view, projection = uniforms</strong></p></li>
<li><p>The OpenGL code used to pass these varaibles to GLSL will be shown in
<a class="reference internal" href="#opengl-uniform"><span class="std std-ref">OpenGL API Commands That Trigger GPU Skinning</span></a> later.
The OpenGL API sets position, boneIndex and boneWeight to locations 0, 1 and
2, respectively, using <strong>glVertexAttribPointer</strong>.</p>
<ul>
<li><p>void glVertexAttribPointer(<strong>GLuint index, GLint size, GLenum type</strong>,
GLboolean normalized, GLsizei stride, const GLvoid * pointer);</p>
<p>Examples:</p>
<ul>
<li><p>glBindBuffer(GL_ARRAY_BUFFER, vboPositions);</p>
<p>glVertexAttribPointer(<strong>0, 3, GL_FLOAT, GL_FALSE</strong>, stride, offset); →
layout(<strong>location = 0</strong>) in <strong>vec3</strong> position;</p>
</li>
<li><p>glBindBuffer(GL_ARRAY_BUFFER, vboBoneIndex);</p>
<p>glVertexAttribIPointer(<strong>1, 4, GL_UNSIGNED_BYTE</strong>, stride, offset); →
layout(<strong>location = 1</strong>) in <strong>uvec4</strong> boneIndex;</p>
<ul class="simple">
<li><p>Bone indices are small integers (0–255), so storing them as
GL_UNSIGNED_BYTE: OpenGL will automatically zero‑extend 8‑bit
unsigned integers into 32‑bit unsigned integers inside the shader.</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>✔ Why boneIndex[] and boneWeight[] are 3D Model Information</p>
<p>These two arrays describe how the mesh is bound to the skeleton.</p>
<p>They are part of the static mesh data, created during rigging in Blender/Maya/etc.</p>
<p>boneIndex[] → tells which bone</p>
<ul class="simple">
<li><p>For each vertex: which bones influence it</p></li>
<li><p>Example: { 3, 7, 12, 0 }</p></li>
</ul>
<p>boneWeight[] → tells how much</p>
<ul class="simple">
<li><p>For each vertex: how much each bone influences it</p></li>
<li><p>Example: { 0.5, 0.3, 0.2, 0.0 }</p></li>
</ul>
<p>These values never change during animation.
They are baked into the mesh and stored in the VBO as vertex attributes.</p>
<p>✔ Why boneMatrices[] is Animation Parameters</p>
<p>boneMatrices[] → tells where the bone is this frame</p>
<ul class="simple">
<li><p>Example: boneMatrices[3] (upper arm bone this frame)</p></li>
</ul>
<p>[ 0.87  -0.49   0.00   0.12 ]
[ 0.49   0.87   0.00   0.03 ]
[ 0.00   0.00   1.00   0.00 ]
[ 0.00   0.00   0.00   1.00 ]</p>
<p>This matrix might represent:</p>
<ul class="simple">
<li><p>a 30° rotation of the upper arm</p></li>
<li><p>plus a small translation (0.12, 0.03, 0.0)</p></li>
</ul>
<p>Animation Parameters are dynamic per‑frame data, such as:</p>
<ul class="simple">
<li><p>bone matrices</p></li>
<li><p>animation time</p></li>
<li><p>morph weights</p></li>
<li><p>blend factors</p></li>
<li><p>procedural animation inputs</p></li>
</ul>
<p>These change every frame.</p>
<p id="opengl-uniform">✔ OpenGL API Commands That Trigger GPU Skinning</p>
<p>Overview</p>
<p>In OpenGL, animation is not built into the API. Instead, animation occurs
because the application updates <em>Animation Parameters</em> (such as bone
matrices) and the <em>vertex shader</em> interprets them. The GPU performs the
animation math during the draw call.</p>
<p>The following sections describe the exact OpenGL commands involved in
triggering GPU-based vertex animation.</p>
<ol class="arabic simple">
<li><p>Updating Animation Parameters (Uniforms or UBOs)</p></li>
</ol>
<p>Animation Parameters such as <code class="docutils literal notranslate"><span class="pre">boneMatrices[]</span></code> are updated every frame.
They are supplied to the vertex shader as uniforms or through a uniform
buffer object (UBO).</p>
<p><strong>Uniform array example:</strong></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Matrix Uniforms</span>
<span class="n">GLint</span><span class="w"> </span><span class="n">locModel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">program</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;model&quot;</span><span class="p">);</span>
<span class="n">GLint</span><span class="w"> </span><span class="n">locView</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">program</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;view&quot;</span><span class="p">);</span>
<span class="n">GLint</span><span class="w"> </span><span class="n">locProj</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">program</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;proj&quot;</span><span class="p">);</span>

<span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">locModel</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">value_ptr</span><span class="p">(</span><span class="n">modelMatrix</span><span class="p">));</span>
<span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">locView</span><span class="p">,</span><span class="w">  </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">value_ptr</span><span class="p">(</span><span class="n">viewMatrix</span><span class="p">));</span>
<span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">locProj</span><span class="p">,</span><span class="w">  </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">value_ptr</span><span class="p">(</span><span class="n">projMatrix</span><span class="p">));</span>

<span class="c1">// Bone Matrix Array</span>
<span class="n">GLint</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">program</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;boneMatrices&quot;</span><span class="p">);</span>
<span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span><span class="w"> </span><span class="n">boneCount</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="n">boneMatrixData</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>Uniform Buffer Object example:</strong></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_UNIFORM_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">boneUBO</span><span class="p">);</span>
<span class="n">glBufferSubData</span><span class="p">(</span><span class="n">GL_UNIFORM_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">boneMatrixData</span><span class="p">);</span>
<span class="n">glBindBufferBase</span><span class="p">(</span><span class="n">GL_UNIFORM_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">bindingPoint</span><span class="p">,</span><span class="w"> </span><span class="n">boneUBO</span><span class="p">);</span>
</pre></div>
</div>
<p>These commands send the per-frame animation data to the GPU.</p>
<ol class="arabic simple" start="2">
<li><p>Binding Vertex Data (Mesh Information)</p></li>
</ol>
<p>Static mesh data such as positions, normals, <code class="docutils literal notranslate"><span class="pre">boneIndex[]</span></code> and
<code class="docutils literal notranslate"><span class="pre">boneWeight[]</span></code> is stored in vertex buffer objects (VBOs) and attached
to a vertex array object (VAO).</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">vao</span><span class="p">);</span>

<span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">vboPositions</span><span class="p">);</span>
<span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FLOAT</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="n">stride</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">);</span>

<span class="c1">// Activate attribute location 1, then ehe shader’s layout(location = 1)</span>
<span class="c1">// input receives real data.</span>
<span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">vboBoneIndex</span><span class="p">);</span>
<span class="n">glVertexAttribIPointer</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span><span class="w"> </span><span class="n">stride</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">);</span>
<span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">vboBoneWeight</span><span class="p">);</span>
<span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FLOAT</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="n">stride</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">);</span>
<span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<p>These commands provide the static 3D model information to the vertex
shader.</p>
<ol class="arabic simple" start="3">
<li><p>Activating the Shader Program</p></li>
</ol>
<p>The vertex shader containing the skinning logic must be activated before
drawing.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">glUseProgram</span><span class="p">(</span><span class="n">program</span><span class="p">);</span>
</pre></div>
</div>
<p>This step ensures that the GPU will execute the correct vertex shader
when the draw call is issued.</p>
<ol class="arabic simple" start="4">
<li><p>Issuing the Draw Call (Animation Trigger)</p></li>
</ol>
<p>The draw call is the moment when the GPU executes the vertex shader for
each vertex. This is where animation actually happens.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">glDrawElements</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span><span class="w"> </span><span class="n">indexCount</span><span class="p">,</span><span class="w"> </span><span class="n">GL_UNSIGNED_INT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>or:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">vertexCount</span><span class="p">);</span>
</pre></div>
</div>
<p>The vertex shader runs once per vertex, combining:</p>
<ul class="simple">
<li><p>vertex attributes (<code class="docutils literal notranslate"><span class="pre">position</span></code>, <code class="docutils literal notranslate"><span class="pre">boneIndex[]</span></code>, <code class="docutils literal notranslate"><span class="pre">boneWeight[]</span></code>)</p></li>
<li><p>animation parameters (<code class="docutils literal notranslate"><span class="pre">boneMatrices[]</span></code>)</p></li>
</ul>
<p>to compute the animated vertex position.</p>
<p>Summary Table</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 22.0%" />
<col style="width: 25.0%" />
<col style="width: 28.0%" />
<col style="width: 25.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Purpose</p></th>
<th class="head"><p>Data Type</p></th>
<th class="head"><p>OpenGL API</p></th>
<th class="head"><p>Static or Dynamic</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Mesh data (positions, bone indices, bone weights)</p></td>
<td><p>Vertex Attributes</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">glVertexAttribPointer</span></code>
<code class="docutils literal notranslate"><span class="pre">glEnableVertexAttribArray</span></code></p></td>
<td><p>Static (stored in VBO)</p></td>
</tr>
<tr class="row-odd"><td><p>Animation Parameters (bone matrices)</p></td>
<td><p>Uniforms / UBO</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">glUniformMatrix4fv</span></code>
<code class="docutils literal notranslate"><span class="pre">glBufferSubData</span></code></p></td>
<td><p>Dynamic (updated every frame)</p></td>
</tr>
<tr class="row-even"><td><p>Activate shader program</p></td>
<td><p>Shader Program</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">glUseProgram</span></code></p></td>
<td><p>Per draw</p></td>
</tr>
<tr class="row-odd"><td><p>Trigger animation</p></td>
<td><p>Draw Call</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">glDrawElements</span></code> / <code class="docutils literal notranslate"><span class="pre">glDrawArrays</span></code></p></td>
<td><p>Per frame</p></td>
</tr>
</tbody>
</table>
<p>Conclusion</p>
<p>OpenGL does not provide a built-in animation system. Instead, animation
occurs because the application updates Animation Parameters each frame
and the vertex shader applies animation math during the draw call. The
GPU performs the animation only when the draw command is issued.</p>
</section>
</section>
<section id="glsl-gl-shader-language">
<h3><a class="toc-backref" href="#id330" role="doc-backlink">GLSL (GL Shader Language)</a><a class="headerlink" href="#glsl-gl-shader-language" title="Link to this heading">¶</a></h3>
<p>OpenGL is a standard specification for designing 2D and 3D graphics and animation
in computer graphics. To support advanced animation and rendering, OpenGL provides
a large set of APIs (functions) for graphics processing. Popular 3D modeling and
animation tools—such as Maya, Blender, and others—can utilize these APIs to handle
3D-to-2D projection and rendering directly on the computer.</p>
<p>The hardware-specific implementation of these APIs is provided by GPU manufacturers,
ensuring that rendering is optimized for the underlying hardware.</p>
<section id="background">
<h4><a class="toc-backref" href="#id331" role="doc-backlink">Background</a><a class="headerlink" href="#background" title="Link to this heading">¶</a></h4>
<p>In the previous section <a class="reference internal" href="#sw-stack"><span class="std std-ref">SW Stack and Data Flow</span></a> described <strong>how each frame is
generated</strong> to display the <strong>movement animation or skinning effects</strong> using the
small animation parameters stored in 3D model and sent from CPU.</p>
<p>Based on description of section <a class="reference internal" href="#sw-stack"><span class="std std-ref">SW Stack and Data Flow</span></a>, we know the animation can
be implemented using <strong>fixed‑function skinning</strong>.
The following are the animation examples for <strong>shader-less era</strong>.</p>
<p>✔ Some consoles and mobile GPUs did have fixed‑function skinning.</p>
<p>✔ In those systems, you could upload bone matrices and let hardware animate
vertices.</p>
<p>❌ <strong>But you could not change the formulas — only use the built‑in ones.</strong></p>
<p>The following console GPUs did have fixed‑function skinning:</p>
<p>PlayStation 2 (PS2) — VU0/VU1 Microcode</p>
<p>PS2 had fixed hardware instructions for:</p>
<ul class="simple">
<li><p>skinning</p></li>
<li><p>morphing</p></li>
<li><p>matrix blending</p></li>
</ul>
<p>Developers could upload bone matrices and let the hardware do the blending.
No shaders existed yet.</p>
<p>Nintendo GameCube / Wii — XF Unit</p>
<p>The GameCube GPU had a fixed‑function transform unit that supported:</p>
<ul class="simple">
<li><p>matrix palette skinning (up to 10 matrices)</p></li>
<li><p>per‑vertex weighted blending</p></li>
</ul>
<p>Again, no shaders — but hardware skinning existed.</p>
<p>The previous <a class="reference internal" href="#role-shaders"><span class="std std-ref">section Role and Purpose of Shaders</span></a> also
explained different visual effects can be achieved by <strong>switching shaders</strong> to
shapplying different materials across frames.</p>
<p>❌ However <strong>the fixed‑function pipeline (OpenGL 1.x / early 2.x without
shaders)</strong> has:</p>
<ul class="simple">
<li><p>no per‑vertex programmable math</p></li>
<li><p>no access to bone matrices</p></li>
<li><p>no ability to blend multiple positions</p></li>
<li><p>no ability to apply time‑based deformation</p></li>
<li><p>no ability to read custom vertex attributes</p></li>
<li><p>no ability to modify vertex positions except via the model‑view matrix</p></li>
</ul>
<p>❌ As result the shader-less (fixed-function) pipeline in early OpenGL did not
support GPU-based skinning.
Skinning had to be implemented on the CPU, which imposed limitations on both
<strong>animation capability and performance</strong>, as described below:</p>
<p><strong>Major Disadvantages of a Shader-less (Fixed-Function) Pipeline</strong></p>
<ul class="simple">
<li><p><strong>No GPU-side animation</strong></p>
<ul>
<li><p>Cannot perform skinning, morphing, or procedural deformation on the GPU.</p></li>
<li><p>All animation must be computed on the CPU, causing performance bottlenecks.</p></li>
</ul>
</li>
<li><p><strong>Limited lighting and materials</strong></p>
<ul>
<li><p>Only fixed-function lighting is available.</p></li>
<li><p>No custom BRDFs, PBR workflows, toon shading, or stylized effects.</p></li>
</ul>
</li>
<li><p><strong>No procedural or time-based effects</strong></p>
<ul>
<li><p>Cannot implement UV animation, distortion, dissolve, holograms, or particle effects.</p></li>
<li><p>No access to noise functions or time-driven logic in the pipeline.</p></li>
</ul>
</li>
<li><p><strong>No post-processing</strong></p>
<ul>
<li><p>Motion blur, bloom, depth of field, color grading, and screen-space effects are impossible.</p></li>
</ul>
</li>
<li><p><strong>Rigid data flow</strong></p>
<ul>
<li><p>Cannot define custom vertex attributes, varyings, or uniform buffers.</p></li>
<li><p>Material and animation systems cannot be data-driven.</p></li>
</ul>
</li>
<li><p><strong>Poor scalability and performance</strong></p>
<ul>
<li><p>CPU must update all animated geometry every frame.</p></li>
<li><p>GPU parallelism is unused, limiting scene complexity.</p></li>
</ul>
</li>
<li><p><strong>Deprecated and non-portable</strong></p>
<ul>
<li><p>Fixed-function pipeline is removed in modern OpenGL core profiles.</p></li>
<li><p>Not compatible with contemporary engines or hardware.</p></li>
</ul>
</li>
</ul>
<p>✔ <strong>All modern consoles</strong> (PS5, PS5 Pro, PS6‑class hardware of Sony, Switch 2 of
Nintendo) use <strong>programmable shader architectures</strong> rather than fixed‑function
animation hardware. Fixed-function animation is now <strong>obsolete</strong>.</p>
<blockquote>
<div><ul class="simple">
<li><p>Sony’s current and upcoming GPUs are based on AMD RDNA architectures, which
are fully programmable shader GPUs.</p></li>
<li><p>Nintendo’s upcoming Switch 2 uses a custom Nvidia Ampere GPU.</p></li>
</ul>
</div></blockquote>
</section>
<section id="examples">
<h4><a class="toc-backref" href="#id332" role="doc-backlink">Examples</a><a class="headerlink" href="#examples" title="Link to this heading">¶</a></h4>
<p>An OpenGL program typically follows a structure like the example below:</p>
<p class="rubric">Vertex shader</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#version 330 core</span>
<span class="n">layout</span><span class="w"> </span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">aPos</span><span class="p">;</span><span class="w"> </span><span class="c1">// the position variable has attribute position 0</span>

<span class="n">out</span><span class="w"> </span><span class="n">vec4</span><span class="w"> </span><span class="n">vertexColor</span><span class="p">;</span><span class="w"> </span><span class="c1">// specify a color output to the fragment shader</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span><span class="w"> </span><span class="c1">// see how we directly give a vec3 to vec4&#39;s constructor</span>
<span class="w">    </span><span class="n">vertexColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec4</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span><span class="w"> </span><span class="c1">// set the output variable to a dark-red color</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">Fragment shader</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#version 330 core</span>
<span class="n">out</span><span class="w"> </span><span class="n">vec4</span><span class="w"> </span><span class="n">FragColor</span><span class="p">;</span>

<span class="n">in</span><span class="w"> </span><span class="n">vec4</span><span class="w"> </span><span class="n">vertexColor</span><span class="p">;</span><span class="w"> </span><span class="c1">// the input variable from the vertex shader (same name and same type)</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">FragColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">computeColorOfThisPixel</span><span class="p">(...);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">OpenGL user program</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// init window, detect user input and do corresponding animation by calling opengl api</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The last <cite>main()</cite> function in an OpenGL application is written by the user, as expected.
Now, let’s explain the purpose of the first two main components of the OpenGL pipeline.</p>
<p>As discussed in the <em>Concepts of Computer Graphics</em> textbook, OpenGL provides a
rich set of APIs that allow programmers to render 3D objects onto a 2D computer screen.
The general rendering process follows these steps:</p>
<ol class="arabic simple">
<li><p>The user sets up lighting, textures, and object materials.</p></li>
<li><p>The system calculates the position of each vertex in 3D space.</p></li>
<li><p>The GPU and rendering pipeline automatically determine the color of each pixel
based on lighting, textures, and interpolation.</p></li>
<li><p>The final image is displayed on the screen by writing pixel colors to the framebuffer.</p></li>
</ol>
<p>To give programmers the flexibility to add custom effects or visual enhancements—such
as modifying vertex positions for animation or applying unique coloring—OpenGL provides
two programmable stages in the graphics pipeline:</p>
<ul class="simple">
<li><p><strong>Vertex Shader:</strong> Allows the user to customize how vertex coordinates are
transformed and processed.</p></li>
<li><p><strong>Fragment Shader:</strong> Allows the user to define how each pixel (fragment) is shaded
and colored, enabling effects like lighting, textures, and transparency.</p></li>
</ul>
<p>These shaders are written by the user and compiled at runtime, providing powerful
control over the rendering process.</p>
<p>OpenGL uses fragment shader instead of pixel is : “Fragment shaders are a more
accurate name for the same functionality as Pixel shaders. They aren’t pixels
yet, since the output still has to past several tests (depth, alpha, stencil)
as well as the fact that one may be using antialiasing, which renders
one-fragment-to-one-pixel non-true <a class="footnote-reference brackets" href="#fragmentshader-reason" id="id78" role="doc-noteref"><span class="fn-bracket">[</span>55<span class="fn-bracket">]</span></a>.
Programmer is allowed to add their converting functions that compiler translate them
into GPU instructions running on GPU processor. With these two shaders, new
features have been added to allow for increased flexibility in the rendering
pipeline at the vertex and fragment level <a class="footnote-reference brackets" href="#shaderswiki" id="id79" role="doc-noteref"><span class="fn-bracket">[</span>56<span class="fn-bracket">]</span></a>.
Unlike the shaders example here <a class="footnote-reference brackets" href="#shadersex" id="id80" role="doc-noteref"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></a>, some converting functions
for coordinate in vertex shader or for color in fragment shade are more
complicated according the scenes of
animation. Here is an example <a class="footnote-reference brackets" href="#glsleffect" id="id81" role="doc-noteref"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></a>.
In wiki shading page <a class="footnote-reference brackets" href="#shading" id="id82" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>, Gourand and Phong shading methods make the
surface of object more smooth by glsl. Example glsl code of Gourand
and Phong shading on OpenGL api are here <a class="footnote-reference brackets" href="#smoothshadingex" id="id83" role="doc-noteref"><span class="fn-bracket">[</span>59<span class="fn-bracket">]</span></a>.
Since the hardware of graphic card and software graphic driver can be replaced,
the compiler is run on-line meaning driver will compile the shaders program when
it is run at first time and kept in cache after compilation <a class="footnote-reference brackets" href="#on-line" id="id84" role="doc-noteref"><span class="fn-bracket">[</span>60<span class="fn-bracket">]</span></a>.</p>
<p>The shaders program is C-like syntax and can be compiled in few mini-seconds,
add up this few mini-seconds of on-line compilation time in running OpenGL
program is a good choice for dealing the cases of driver software or gpu
hardware replacement <a class="footnote-reference brackets" href="#onlinecompile" id="id85" role="doc-noteref"><span class="fn-bracket">[</span>61<span class="fn-bracket">]</span></a>.</p>
</section>
<section id="goals">
<h4><a class="toc-backref" href="#id333" role="doc-backlink">Goals</a><a class="headerlink" href="#goals" title="Link to this heading">¶</a></h4>
<p>Goals of GLSL Shader Language:</p>
<p>GLSL was designed for real-time graphics using programmable GPUs.</p>
<ol class="arabic simple">
<li><p>Programmable Pipeline:</p></li>
</ol>
<ul class="simple">
<li><p>Custom control over vertex, fragment, and other pipeline stages</p></li>
<li><p>Enables dynamic effects, lighting, animation, and transformations</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p>GPU Acceleration</p></li>
</ol>
<ul class="simple">
<li><p>Executes on GPU cores for massive parallel performance</p></li>
<li><p>Optimized for matrix and vector operations common in graphics</p></li>
</ul>
<ol class="arabic simple" start="3">
<li><p>Cross-Platform Compatibility:</p></li>
</ol>
<ul class="simple">
<li><p>Runs consistently across OSes and hardware via OpenGL</p></li>
<li><p>Avoids vendor lock-in for portable shader code</p></li>
</ul>
<ol class="arabic simple" start="4">
<li><p>C-Like Syntax</p></li>
</ol>
<ul class="simple">
<li><p>Familiar syntax for developers used to C-style languages</p></li>
<li><p>Supports functions, loops, conditionals, and custom types</p></li>
</ul>
<ol class="arabic simple" start="5">
<li><p>Fine-Grained Rendering Control</p></li>
</ol>
<ul class="simple">
<li><p>Direct access to geometry, color, texture, lighting parameters</p></li>
<li><p>Enables advanced effects like shadows, fog, reflections</p></li>
</ul>
<ol class="arabic simple" start="6">
<li><p>Real-Time Interactivity</p></li>
</ol>
<ul class="simple">
<li><p>Responds to user input, time, and animations at runtime</p></li>
<li><p>Suitable for games, simulations, and creative tools</p></li>
</ul>
<ol class="arabic simple" start="7">
<li><p>Minimal Host Dependency</p></li>
</ol>
<ul class="simple">
<li><p>Executes within the graphics driver context</p></li>
<li><p>No need for external libraries, file I/O, or system calls</p></li>
</ul>
</section>
<section id="glsl-vs-c-feature-overview">
<h4><a class="toc-backref" href="#id334" role="doc-backlink">GLSL vs. C: Feature Overview</a><a class="headerlink" href="#glsl-vs-c-feature-overview" title="Link to this heading">¶</a></h4>
<p>GLSL expands upon C for GPU-based graphics programming.</p>
<p><strong>Additions to C:</strong></p>
<ol class="arabic simple">
<li><p>Specialized Data Types</p></li>
</ol>
<ul class="simple">
<li><p>vec2, vec3, vec4: float vectors</p></li>
<li><p>mat2, mat3, mat4: float matrices</p></li>
<li><p>bvec, ivec, uvec, dvec: boolean and integer vectors</p></li>
<li><p>sampler2D, samplerCube: texture samplers</p></li>
</ul>
<ol class="arabic simple" id="pipeline-qualifier" start="2">
<li><p>Pipeline Qualifiers</p></li>
</ol>
<ul class="simple">
<li><p>attribute, varying (legacy)</p></li>
<li><p>in, out, inout: stage and parameter I/O</p></li>
<li><p><strong>uniform:</strong> uniform variables are set externally by the host application
(e.g., OpenGL) and remain constant across all shader invocations for
a draw call.</p></li>
<li><p><strong>layout(location = x)</strong>: set GPU variable locations. See <a class="reference internal" href="#animation-ex"><span class="std std-ref">Animation Example</span></a>
section.</p></li>
<li><p>precision qualifiers: lowp, mediump, highp</p></li>
</ul>
<ol class="arabic simple" start="3">
<li><p>Built-in Functions</p></li>
</ol>
<ul class="simple">
<li><p>texture(), reflect(), refract(), normalize()</p></li>
<li><p>mix(), smoothstep(): interpolation and blending</p></li>
<li><p>dot(), cross(), transpose(), inverse(): math ops</p></li>
<li><p>dFdx(), dFdy(), fwidth(): pixel derivatives</p></li>
</ul>
<ol class="arabic simple" start="4">
<li><p>Swizzling</p></li>
</ol>
<ul class="simple">
<li><p>.xyzw, .rgba, .stpq access vector components</p></li>
<li><p>e.g., vec4 pos = vec3(1, 2, 3).xyzx</p></li>
</ul>
<ol class="arabic simple" start="5">
<li><p>Shader-Specific Keywords</p></li>
</ol>
<ul class="simple">
<li><p>discard: drop fragments early</p></li>
<li><p>gl_Position, gl_FragColor, gl_VertexID: built-ins</p></li>
<li><p>subroutine, patch, sample: advanced pipeline control</p></li>
</ul>
<p><strong>Removals and Restrictions:</strong></p>
<ol class="arabic simple">
<li><p>No Pointers or Memory Access</p></li>
</ol>
<ul class="simple">
<li><p>No * or &amp; operators</p></li>
<li><p>No malloc, free</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p>No File I/O or Standard C Libs</p></li>
</ol>
<ul class="simple">
<li><p>No stdio.h, printf(), fopen()</p></li>
</ul>
<ol class="arabic simple" start="3">
<li><p>No Recursion</p></li>
</ol>
<ul class="simple">
<li><p>Recursive functions not allowed</p></li>
</ul>
<ol class="arabic simple" start="4">
<li><p>No #include Support</p></li>
</ol>
<ul class="simple">
<li><p>Files can’t be included via preprocessor</p></li>
</ul>
<ol class="arabic simple" start="5">
<li><p>Limited Control Flow</p></li>
</ol>
<ul class="simple">
<li><p>goto not allowed</p></li>
<li><p>Loops must be statically determinable in many cases for compiler optimization as follows:</p></li>
</ul>
<p class="rubric">Example for loops must be statically determinable in many cases</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">MAX_LIGHTS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_LIGHTS</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Safe: MAX_LIGHTS is a compile-time constant</span>
<span class="p">}</span>
</pre></div>
</div>
<ol class="arabic simple" start="6">
<li><p>Restricted C Keywords</p></li>
</ol>
<ul class="simple">
<li><p>typedef, union, enum, class, namespace, inline, etc.</p></li>
<li><p>Reserved or disallowed</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>Changes help GPU execute safely in parallel</p></li>
<li><p>Designed for real-time, interactive graphics</p></li>
</ul>
</section>
<section id="glsl-qualifiers-by-shader-stage">
<h4><a class="toc-backref" href="#id335" role="doc-backlink">GLSL Qualifiers by Shader Stage</a><a class="headerlink" href="#glsl-qualifiers-by-shader-stage" title="Link to this heading">¶</a></h4>
<p>The CPU and GPU Pipeline For Shaders is introduced in section
<a class="reference internal" href="#three-d-rendering-pipeline"><span class="std std-ref">3D Rendering Pipeline</span></a>.
The <a class="reference internal" href="#shaders-pipeline-in-out"><span class="std std-numref">Fig. 98</span></a> is the summary of GLSL Qualifiers below.</p>
<figure class="align-default" id="id243">
<span id="shaders-pipeline-in-out"></span><div class="graphviz"><img src="_images/graphviz-e2594ff1194a5682c90bb59fc5a1d7670c5b8b27.png" alt="digraph CPU_GPU_Pipeline {
    rankdir=LR;
    node [shape=box, style=rounded, fontsize=12];

    subgraph cluster_cpu {
        label=&quot;CPU&quot;;
        style=rounded;

        CPU_Vertex [label=&quot;Load 3D Model\n(Per-Vertex Attributes)\nVBOs, VAOs, Indices&quot;];
        CPU_Anim   [label=&quot;Uniform Updates\n(Animation Parameters,\nMatrices, Lighting,\nMaterial Params)&quot;];
    }

    subgraph cluster_gpu {
        label=&quot;GPU&quot;;
        style=rounded;

        VS      [label=&quot;Vertex Shader\nInputs:\n - Vertex Attributes (in)\n - Uniforms (matrices, animation)\nOutputs:\n - Varyings → Rasterizer&quot;];
        
        Raster  [label=&quot;Rasterizer\n(Primitive Assembly,\nClipping, Interpolation)\nOutputs:\n - Interpolated Varyings&quot;];

        FS      [label=&quot;Fragment Shader\nInputs:\n - Interpolated Data (in)\n - Uniforms (textures, lighting)\nOutputs:\n - Final Fragment Color&quot;];

        FB      [label=&quot;Framebuffer\n(Final Rendered Image)&quot;];

        CS      [label=&quot;Compute Shader\n(Workgroups, SSBOs,\nImages, Shared Memory)\nIndependent of VS→FS Pipeline&quot;];
    }

    # Main graphics pipeline
    CPU_Vertex -&gt; VS;
    CPU_Anim   -&gt; VS;

    VS -&gt; Raster;
    Raster -&gt; FS;
    FS -&gt; FB;

    # Compute shader is dispatched separately
    CPU_Anim -&gt; CS [style=dashed, label=&quot;Dispatch Compute&quot;];
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 98 </span><span class="caption-text">Shaders input and output</span><a class="headerlink" href="#id243" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p><strong>Vertex Shader:</strong></p>
<ul class="simple">
<li><p>in: Receives per-vertex attributes from buffer objects, it is
<strong>3D Model Information</strong> described in <a class="reference internal" href="#shaders-pipeline-in-out"><span class="std std-numref">Fig. 98</span></a>.</p></li>
<li><p>out: Passes data to next stage (e.g., fragment shader)</p></li>
<li><p><strong>uniform</strong>: Global parameters like matrices or lighting, it is
<strong>Animation Parameters</strong>, also referred to as <strong>Uniform Updates</strong> described
in <a class="reference internal" href="#shaders-pipeline-in-out"><span class="std std-numref">Fig. 98</span></a>.
The <a class="reference internal" href="#animation-ex"><span class="std std-ref">Animation Example</span></a> section provides an example in Vertex Shader (VS) that
demostrates animation using both the 3D model information and Uniform Updates.</p></li>
<li><p><strong>layout(location = x)</strong>: Binds input/output to attribute index. See
<a class="reference internal" href="#animation-ex"><span class="std std-ref">Animation Example</span></a> section.</p></li>
<li><p>const: Compile-time constants</p></li>
<li><p>Cannot use interpolation qualifiers on inputs</p></li>
</ul>
<p><strong>Fragment Shader:</strong></p>
<ul class="simple">
<li><p>in: Receives <strong>interpolated data</strong> from previous stage as shown in
<a class="reference internal" href="#shaders-pipeline-in-out"><span class="std std-numref">Fig. 98</span></a>.</p></li>
<li><p>out: Writes <strong>Final Fragement Color</strong> to FrameBuffer</p></li>
<li><p>uniform: Global parameters like <strong>textures</strong> or <strong>lighting</strong> as shown in
<a class="reference internal" href="#shaders-pipeline-in-out"><span class="std std-numref">Fig. 98</span></a>.
<strong>Uniform data remains unchanged</strong> across all pipeline stages and is shared by
all shaders in the pipeline.
This means that uniform data represents global parameters for 3D GPU rendering.</p></li>
<li><p>flat: Disables interpolation; uses provoking vertex</p></li>
<li><p>smooth: Enables perspective-correct interpolation (default)</p></li>
<li><p>noperspective: Linear interpolation in screen space</p></li>
<li><p>centroid: Samples within primitive area (for multisampling)</p></li>
<li><p>sample: Per-sample interpolation (GLSL 4.0+)</p></li>
<li><p>discard: Terminates fragment processing early</p></li>
</ul>
<p><strong>Compute Shader:</strong></p>
<ul class="simple">
<li><p>layout(local_size_x = x): Defines workgroup size</p></li>
<li><p>uniform: Input parameters from host</p></li>
<li><p>buffer: Shader storage buffer access</p></li>
<li><p>shared: Shared memory among invocations in a workgroup</p></li>
<li><p>image2D, image3D: Direct image access</p></li>
<li><p>coherent, volatile, restrict: Memory access control</p></li>
<li><p>readonly, writeonly: Access mode for image/buffer</p></li>
<li><p>Compute shader: <strong>may be applied in any stage</strong> as described in section
<a class="reference internal" href="#three-d-rendering-pipeline"><span class="std std-ref">3D Rendering Pipeline</span></a>.</p></li>
</ul>
<p><strong>Common Across Stages:</strong></p>
<ul class="simple">
<li><p>const: Immutable values</p></li>
<li><p>uniform: Host-set global parameters</p></li>
<li><p>layout(binding = x): Bind uniform/buffer/image to index</p></li>
<li><p>precise: Ensures consistent computation</p></li>
<li><p>invariant: Prevents variation across shader executions</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>attribute and varying are deprecated (use in/out instead)</p></li>
<li><p>Interpolation qualifiers only affect fragment shader inputs</p></li>
<li><p>Uniforms are shared across all stages and remain constant</p></li>
</ul>
<p class="rubric">Examples of GLSL Qualifiers by Shader Stage</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// ==============================================</span>
<span class="c1">// Vertex Shader: Qualifier Summary (GLSL)</span>
<span class="c1">// ==============================================</span>

<span class="c1">// Vertex inputs</span>
<span class="n">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">aPosition</span><span class="p">;</span><span class="w">   </span><span class="c1">// in: per-vertex attribute</span>
<span class="n">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">aNormal</span><span class="p">;</span>

<span class="c1">// Outputs to fragment shader</span>
<span class="n">out</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">vNormal</span><span class="p">;</span><span class="w">                         </span><span class="c1">// out: passes to next stage</span>

<span class="c1">// Uniforms</span>
<span class="n">uniform</span><span class="w"> </span><span class="n">mat4</span><span class="w"> </span><span class="n">uModelMatrix</span><span class="p">;</span><span class="w">               </span><span class="c1">// uniform: global parameter</span>
<span class="n">uniform</span><span class="w"> </span><span class="n">mat4</span><span class="w"> </span><span class="n">uViewProjectionMatrix</span><span class="p">;</span>

<span class="c1">// Constants</span>
<span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">PI</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.14159265</span><span class="p">;</span><span class="w">             </span><span class="c1">// const: compile-time constant</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">vNormal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">aNormal</span><span class="p">;</span>
<span class="w">  </span><span class="n">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uViewProjectionMatrix</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">uModelMatrix</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">vec4</span><span class="p">(</span><span class="n">aPosition</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ==============================================</span>
<span class="c1">// Fragment Shader: Qualifier Summary (GLSL)</span>
<span class="c1">// ==============================================</span>

<span class="c1">// Inputs from vertex shader</span>
<span class="n">in</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">vNormal</span><span class="p">;</span><span class="w">                          </span><span class="c1">// in: interpolated input</span>

<span class="c1">// Output to framebuffer</span>
<span class="n">out</span><span class="w"> </span><span class="n">vec4</span><span class="w"> </span><span class="n">fragColor</span><span class="p">;</span><span class="w">                       </span><span class="c1">// out: final pixel color</span>

<span class="c1">// Uniforms</span>
<span class="n">uniform</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">uLightDirection</span><span class="p">;</span><span class="w">            </span><span class="c1">// uniform: shared global input</span>
<span class="n">uniform</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">uBaseColor</span><span class="p">;</span>

<span class="c1">// Interpolation control</span>
<span class="c1">// flat in vec3 vFlatColor;              // flat: no interpolation</span>
<span class="c1">// smooth in vec3 vSmoothColor;         // smooth: default interpolation</span>
<span class="c1">// noperspective in vec3 vLinearColor;  // noperspective: screen-space linear</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">brightness</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">normalize</span><span class="p">(</span><span class="n">vNormal</span><span class="p">),</span><span class="w"> </span><span class="n">uLightDirection</span><span class="p">),</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span>
<span class="w">  </span><span class="n">fragColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec4</span><span class="p">(</span><span class="n">uBaseColor</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">brightness</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ==============================================</span>
<span class="c1">// Compute Shader: Qualifier Summary (GLSL)</span>
<span class="c1">// ==============================================</span>

<span class="cp">#version 430</span>

<span class="c1">// Workgroup size</span>
<span class="n">layout</span><span class="p">(</span><span class="n">local_size_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="n">local_size_y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="n">in</span><span class="p">;</span>

<span class="c1">// Shared memory</span>
<span class="n">shared</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">tileData</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span><span class="w">              </span><span class="c1">// shared: intra-group memory</span>

<span class="c1">// Uniforms</span>
<span class="n">uniform</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">uTime</span><span class="p">;</span><span class="w">                     </span><span class="c1">// uniform: global input</span>

<span class="c1">// Buffer access</span>
<span class="n">layout</span><span class="p">(</span><span class="n">std430</span><span class="p">,</span><span class="w"> </span><span class="n">binding</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="n">DataBuffer</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">values</span><span class="p">[];</span>
<span class="p">};</span>

<span class="c1">// Image access</span>
<span class="n">layout</span><span class="p">(</span><span class="n">binding</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">rgba32f</span><span class="p">)</span><span class="w"> </span><span class="n">uniform</span><span class="w"> </span><span class="n">image2D</span><span class="w"> </span><span class="n">uImage</span><span class="p">;</span>

<span class="c1">// Memory qualifiers</span>
<span class="c1">// coherent, volatile, restrict, readonly, writeonly</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">uint</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gl_GlobalInvocationID</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="w">  </span><span class="n">values</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="n">uTime</span><span class="p">);</span><span class="w">           </span><span class="c1">// buffer write</span>
<span class="w">  </span><span class="n">imageStore</span><span class="p">(</span><span class="n">uImage</span><span class="p">,</span><span class="w"> </span><span class="n">ivec2</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">vec4</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">idx</span><span class="p">]));</span><span class="w"> </span><span class="c1">// image write</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="opengl-shader-compiler">
<span id="id86"></span><h3><a class="toc-backref" href="#id336" role="doc-backlink">OpenGL Shader Compiler</a><a class="headerlink" href="#opengl-shader-compiler" title="Link to this heading">¶</a></h3>
<p>The OpenGL standard is defined in <a class="footnote-reference brackets" href="#openglspec" id="id87" role="doc-noteref"><span class="fn-bracket">[</span>62<span class="fn-bracket">]</span></a>. OpenGL is primarily designed for
desktop computers and servers, whereas OpenGL ES is a subset tailored for embedded systems
<a class="footnote-reference brackets" href="#opengleswiki" id="id88" role="doc-noteref"><span class="fn-bracket">[</span>63<span class="fn-bracket">]</span></a>.</p>
<p>Although shaders represent only a small part of the entire OpenGL software/hardware
stack, implementing a compiler for them is still a significant undertaking. This is
because a large number of APIs need to be supported. For instance, there are over 80
texture-related APIs alone <a class="footnote-reference brackets" href="#textureapi" id="id89" role="doc-noteref"><span class="fn-bracket">[</span>64<span class="fn-bracket">]</span></a>.</p>
<p>A practical approach to implementing such a compiler involves generating LLVM extended
intrinsic functions from the shader frontend (parser and AST generator). These intrinsics
can then be lowered into GPU-specific instructions in the LLVM backend. The overall
workflow is illustrated as follows:</p>
<p class="rubric">Fragment shader</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#version 320 es</span>
<span class="n">uniform</span><span class="w"> </span><span class="n">sampler2D</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="n">out</span><span class="w"> </span><span class="n">vec4</span><span class="w"> </span><span class="n">FragColor</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">FragColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">texture</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">uv_2d</span><span class="p">,</span><span class="w"> </span><span class="n">bias</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">llvm-ir</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>...
!1 = !{!&quot;sampler_2d&quot;}
!2 = !{i32 SAMPLER_2D} ; SAMPLER_2D is integer value for sampler2D, for example: 0x0f02
; A named metadata.
!x_meta = !{!1, !2}

define void @main() #0 {
    ...
    %1 = @llvm.gpu0.texture(metadata !x_meta, %1, %2, %3); ; %1: %sampler_2d, %2: %uv_2d, %3: %bias
    ...
}
</pre></div>
</div>
<p class="rubric">asm of gpu</p>
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span><span class="na">...</span>
<span class="c1">// gpu machine code</span>
<span class="nf">load</span><span class="w"> </span><span class="no">$1</span><span class="p">,</span><span class="w"> </span><span class="no">tex_a</span><span class="c1">;</span>
<span class="nf">sample2d_inst</span><span class="w"> </span><span class="no">$1</span><span class="p">,</span><span class="w"> </span><span class="no">$2</span><span class="p">,</span><span class="w"> </span><span class="no">$3</span><span class="w"> </span><span class="c1">// $1: tex_a, $2: %uv_2d, $3: %bias</span>

<span class="na">.tex_a</span><span class="w"> </span><span class="c1">// Driver set the index of gpu descriptor regsters here</span>
</pre></div>
</div>
<p>As shown at the end of the code above, the <cite>.tex_a</cite> memory address contains the Texture
Object, which is bound by the driver during online compilation and linking. By binding
a Texture Object (software representation) to a Texture Unit (hardware resource) via
OpenGL API calls, the GPU can access and utilize Texture Unit hardware efficiently.
This binding mechanism ensures that texture sampling and mapping are executed with
minimal overhead during rendering.</p>
<p>For more information about LLVM extended intrinsic functions, please refer to
<a class="footnote-reference brackets" href="#intrinsiccpu0" id="id90" role="doc-noteref"><span class="fn-bracket">[</span>65<span class="fn-bracket">]</span></a>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">gvec4</span><span class="w"> </span><span class="nf">texture</span><span class="p">(</span><span class="n">gsampler2D</span><span class="w"> </span><span class="n">sampler</span><span class="p">,</span><span class="w"> </span><span class="n">vec2</span><span class="w"> </span><span class="n">P</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="kt">float</span><span class="w"> </span><span class="n">bias</span><span class="p">]);</span>
</pre></div>
</div>
<p>GPUs provide <em>Texture Units</em> to accelerate texture access in fragment shaders.
However, <em>Texture Units</em> are expensive hardware resources, and only a limited number
are available on a GPU. To manage this limitation, the OpenGL driver can associate
a <em>Texture Unit</em> with a <cite>sampler</cite> variable using OpenGL API calls. This association
can be updated or switched between shaders as needed. The following statements
demonstrate how to bind and switch <em>Texture Units</em> across shaders:</p>
<figure class="align-center" id="id244">
<span id="sampling"></span><a class="reference internal image-reference" href="_images/sampling_diagram.png"><img alt="_images/sampling_diagram.png" height="330" src="_images/sampling_diagram.png" width="490" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 99 </span><span class="caption-text">Relationships between the texturing concept <a class="footnote-reference brackets" href="#textureobject" id="id91" role="doc-noteref"><span class="fn-bracket">[</span>66<span class="fn-bracket">]</span></a>.</span><a class="headerlink" href="#id244" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>As shown in <a class="reference internal" href="#sampling"><span class="std std-numref">Fig. 99</span></a>, the texture object is not bound directly to a shader
(where sampling operations occur). Instead, it is bound to a <em>texture unit</em>, and the
index of this texture unit is passed to the shader. This means the shader accesses
the texture object through the assigned texture unit. Most GPUs support multiple
texture units, though the exact number depends on the hardware capabilities
<a class="footnote-reference brackets" href="#textureobject" id="id92" role="doc-noteref"><span class="fn-bracket">[</span>66<span class="fn-bracket">]</span></a>.</p>
<p>A <em>texture unit</em>—also known as a <em>Texture Mapping Unit (TMU)</em> or <em>Texture Processing Unit (TPU)</em>—
is a dedicated hardware component in the GPU that performs texture sampling operations.</p>
<p>The <cite>sampler</cite> argument in the texture sampling function refers to a <cite>sampler2D</cite> (or similar)
uniform variable. This variable represents the texture unit index used to access the
associated texture object <a class="footnote-reference brackets" href="#textureobject" id="id93" role="doc-noteref"><span class="fn-bracket">[</span>66<span class="fn-bracket">]</span></a>.</p>
<p><strong>Sampler Uniform Variables</strong>:</p>
<p>OpenGL provides a set of special uniform variables for texture sampling, named according to
the texture target: <cite>sampler1D</cite>, <cite>sampler2D</cite>, <cite>sampler3D</cite>, <cite>samplerCube</cite>, etc.</p>
<p>You can create as many <em>sampler uniform variables</em> as needed and assign each one to a
specific texture unit index using OpenGL API calls. Whenever a sampling function is
invoked with a sampler uniform, the GPU uses the texture unit (and its bound texture object)
associated with that sampler <a class="footnote-reference brackets" href="#textureobject" id="id94" role="doc-noteref"><span class="fn-bracket">[</span>66<span class="fn-bracket">]</span></a>.</p>
<figure class="align-center" id="id245">
<span id="sampling-binding"></span><img alt="_images/sampling_diagram_binding.png" src="_images/sampling_diagram_binding.png" />
<figcaption>
<p><span class="caption-number">Fig. 100 </span><span class="caption-text">Binding sampler variables <a class="footnote-reference brackets" href="#tpu" id="id95" role="doc-noteref"><span class="fn-bracket">[</span>67<span class="fn-bracket">]</span></a>.</span><a class="headerlink" href="#id245" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>For Java programmers, JOGL provides same level of API in Java for wrapping to
OpenGL C API.
As shown in <a class="reference internal" href="#sampling-binding"><span class="std std-numref">Fig. 100</span></a>, the JOGL <cite>gl.bindTexture()</cite>
binds a <em>Texture Object</em> to a specific <em>Texture Unit</em>. Then, using
<strong>gl.getUniformLocation() and gl.uniform1i()</strong>, you <strong>associate</strong> the
<strong>Texture Unit</strong> with a <em>sampler uniform variable</em> in the shader.</p>
<p>For example, <strong>gl.uniform1i(xLoc, 1)</strong> assigns <strong>Texture Unit 1</strong> to the
sampler variable at location <strong>xLoc</strong>.
Similarly, passing <cite>2</cite> would refer to <em>Texture Unit 2</em>, and so on
<a class="footnote-reference brackets" href="#tpu" id="id96" role="doc-noteref"><span class="fn-bracket">[</span>67<span class="fn-bracket">]</span></a>.</p>
<p>The following <a class="reference internal" href="#driver-sampler-table"><span class="std std-numref">Fig. 101</span></a> illustrates how the OpenGL driver
reads metadata from a compiled GLSL object, how the OpenGL API <strong>links</strong>
<strong>sampler uniform variables</strong> to <strong>Texture Units</strong>,
and how the GPU <strong>executes</strong> the corresponding <strong>texture instructions</strong>.</p>
<figure class="align-default" id="id246">
<span id="driver-sampler-table"></span><div class="graphviz"><img src="_images/graphviz-dd79cb438e50fc29ce80618c03fc64495df8cd50.png" alt="digraph G {
    graph [rankdir=TB];

    // ---------------------
    // Node n1, n2, n3, n4
    // ---------------------
    n1 [shape=box, label=&quot;1. GPU Compiler&quot;];
    n2 [shape=box, label=&quot;2. Driver alloc memory xLoc for x&quot;];
    n3 [shape=box, label=&quot;3. xLoc = gl.getUniformLocation(prog, \&quot;x\&quot;)&quot;];
    n4 [shape=box, label=&quot;4. gl.uniform1i(xLoc, 1)&quot;];

    // -------------------------
    // Table 1 (tbl1)
    // -------------------------
    tbl1 [
        shape=none
        label=&lt;
        &lt;TABLE BORDER=&quot;1&quot; CELLBORDER=&quot;1&quot; CELLSPACING=&quot;0&quot;&gt;
            &lt;TR&gt;&lt;TD COLSPAN=&quot;3&quot;&gt;&lt;B&gt;driver Sampler Variables table&lt;/B&gt;&lt;/TD&gt;&lt;/TR&gt;
            &lt;TR&gt;
                &lt;TD PORT=&quot;r0c0&quot;&gt;name&lt;/TD&gt;
                &lt;TD PORT=&quot;r0c1&quot;&gt;type&lt;/TD&gt;
                &lt;TD PORT=&quot;r0c2&quot;&gt;location&lt;/TD&gt;
            &lt;/TR&gt;
            &lt;TR&gt;
                &lt;TD PORT=&quot;r1c0&quot;&gt;...&lt;/TD&gt;
                &lt;TD PORT=&quot;r1c1&quot;&gt;&lt;/TD&gt;
                &lt;TD PORT=&quot;r1c2&quot;&gt;&lt;/TD&gt;
            &lt;/TR&gt;
            &lt;TR&gt;
                &lt;TD PORT=&quot;r2c0&quot;&gt;&quot;x&quot;&lt;/TD&gt;
                &lt;TD PORT=&quot;r2c1&quot;&gt;SAMPLE_2D&lt;/TD&gt;
                &lt;TD PORT=&quot;r2c2&quot;&gt;xLoc&lt;/TD&gt;
            &lt;/TR&gt;
            &lt;TR&gt;
                &lt;TD PORT=&quot;r3c0&quot;&gt;...&lt;/TD&gt;
                &lt;TD PORT=&quot;r3c1&quot;&gt;&lt;/TD&gt;
                &lt;TD PORT=&quot;r3c2&quot;&gt;&lt;/TD&gt;
            &lt;/TR&gt;
        &lt;/TABLE&gt;
        &gt;
    ];

    // -------------------------
    // Table 2 (tbl2)
    // -------------------------
    tbl2 [
        shape=none
        label=&lt;
        &lt;TABLE BORDER=&quot;1&quot; CELLBORDER=&quot;1&quot; CELLSPACING=&quot;0&quot;&gt;
            &lt;TR&gt;&lt;TD COLSPAN=&quot;4&quot;&gt;&lt;B&gt;texture descriptor&lt;/B&gt;&lt;/TD&gt;&lt;/TR&gt;
            &lt;TR&gt;
                &lt;TD PORT=&quot;t0c0&quot;&gt;offset&lt;/TD&gt;
                &lt;TD PORT=&quot;t0c1&quot;&gt;location&lt;/TD&gt;
                &lt;TD PORT=&quot;t0c2&quot;&gt;Texture Unit&lt;/TD&gt;
            &lt;/TR&gt;
            &lt;TR&gt;
                &lt;TD PORT=&quot;t1c0&quot;&gt;...&lt;/TD&gt;
                &lt;TD PORT=&quot;t1c1&quot;&gt;&lt;/TD&gt;
                &lt;TD PORT=&quot;t1c2&quot;&gt;&lt;/TD&gt;
            &lt;/TR&gt;
            &lt;TR&gt;
                &lt;TD PORT=&quot;t2c0&quot;&gt;k&lt;/TD&gt;
                &lt;TD PORT=&quot;t2c1&quot;&gt;xLoc&lt;/TD&gt;
                &lt;TD PORT=&quot;t2c2&quot;&gt;1&lt;/TD&gt;
            &lt;/TR&gt;
            &lt;TR&gt;
                &lt;TD PORT=&quot;t3c0&quot;&gt;...&lt;/TD&gt;
                &lt;TD PORT=&quot;t3c1&quot;&gt;&lt;/TD&gt;
                &lt;TD PORT=&quot;t3c2&quot;&gt;&lt;/TD&gt;
            &lt;/TR&gt;
        &lt;/TABLE&gt;
        &gt;
    ];

    // -------------------------
    // Table 3 (tbl3)
    // -------------------------
    tbl3 [
        shape=none
        label=&lt;
        &lt;TABLE BORDER=&quot;1&quot; CELLBORDER=&quot;1&quot; CELLSPACING=&quot;0&quot;&gt;
            &lt;TR&gt;&lt;TD COLSPAN=&quot;3&quot;&gt;&lt;B&gt;GPU executable binary&lt;/B&gt;&lt;/TD&gt;&lt;/TR&gt;
            &lt;TR&gt;
                &lt;TD PORT=&quot;u0c0&quot; ALIGN=&quot;LEFT&quot;&gt;4. load $1, tex_a&lt;/TD&gt;
            &lt;/TR&gt;
            &lt;TR&gt;
                &lt;TD PORT=&quot;u1c0&quot; ALIGN=&quot;LEFT&quot;&gt;   sample_inst $1, $2, $3 // $2: %uv_2d, $3: %bias&lt;/TD&gt;
            &lt;/TR&gt;
            &lt;TR&gt;
                &lt;TD PORT=&quot;u2c0&quot; ALIGN=&quot;LEFT&quot;&gt;   .tex_a // Driver set value to k when calling gl.uniformli(xLoc, 1)&lt;/TD&gt;
            &lt;/TR&gt;
        &lt;/TABLE&gt;
        &gt;
    ];

    // -------------------------
    // Edges
    // -------------------------

    // n1 -&gt; n2 -&gt; tbl1(2,2)
    n1 -&gt; n2 [label=&quot;During the link stage for uniform sampler2D x;&quot;];
    n2 -&gt; tbl1:r2c2;

    // tbl1(2,2) -&gt; n3
    tbl1:r2c2 -&gt; n3;

    n3 -&gt; tbl2:t2c1 [label=&quot;Driver fill xLoc \n(the location of x sampler variable)\n to the offset k in the table&quot;];

    // n4 -&gt; right side of tbl2 (choose last column: row 2 col 2)
    n4 -&gt; tbl2:t2c2 [label=&quot;Driver write 1 to the table\nfor using Texture Unit 1&quot;];

    // tbl2(2,0) -&gt; tb3(2,0)
    tbl2:t2c0 -&gt; tbl3:u2c0 [label=&quot;Driver lookup the table and \nset the value of the symbol '.tex_a' to k \nin the executable binary file&quot;];
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 101 </span><span class="caption-text">Binding Sampler Variables to Texture Instructions</span><a class="headerlink" href="#id246" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Explaining the detailed steps for the figure above:</p>
<ol class="arabic simple">
<li><p>To enable the GPU driver to bind the <em>texture unit</em>, the frontend compiler
must pass metadata for each <em>sampler uniform variable</em>
(e.g., <cite>sampler_2d_var</cite> in this example) <a class="footnote-reference brackets" href="#samplervar" id="id97" role="doc-noteref"><span class="fn-bracket">[</span>70<span class="fn-bracket">]</span></a> to the backend.
The backend then allocates and embeds this metadata in the compiled binary
file <a class="footnote-reference brackets" href="#metadata" id="id98" role="doc-noteref"><span class="fn-bracket">[</span>68<span class="fn-bracket">]</span></a>.</p></li>
<li><p>During the link stage of on-line compilation of the GLSL shader, the GPU
driver reads this metadata from the compiled binary file.
It constructs an internal
table mapping each <em>sampler uniform variable</em> to its attributes, such as
<cite>{name, type, location}</cite>. This mapping allows the driver to properly
populate the <em>Texture Descriptor</em> in the GPU’s memory, linking the variable
to a specific <em>texture unit</em>.</p></li>
<li><p>API:</p></li>
</ol>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">xLoc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gl</span><span class="p">.</span><span class="n">getUniformLocation</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;x&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// prog: GLSL program, xLoc: location of sampler variable &quot;x&quot;</span>
</pre></div>
</div>
<p>This API call queries the location of the <cite>sampler uniform variable</cite> named <cite>“x”</cite>
from the internal table that the driver created after parsing the shader metadata.</p>
<p>The returned <cite>xLoc</cite> value corresponds to the location field associated with <cite>“x”</cite>,
which will later be used to bind a specific <em>texture unit</em> to this sampler variable
via <cite>gl.uniform1i(xLoc, unit_index)</cite>.</p>
<p><cite>SAMPLER_2D</cite> is the internal representation (usually an integer) that identifies
a <cite>sampler2D</cite> type in the shader.</p>
<ol class="arabic simple" start="4">
<li><p>API:</p></li>
</ol>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">gl</span><span class="p">.</span><span class="n">uniform1i</span><span class="p">(</span><span class="n">xLoc</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>This API call binds the sampler uniform variable <cite>x</cite> (located at <cite>xLoc</cite>) to
<strong>Texture Unit 1</strong>. It works by writing the integer value <cite>1</cite> to the internal
GLSL program memory at the location of the sampler variable <cite>x</cite>, as indicated
by <cite>xLoc</cite>.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">{xLoc, 1} : 1 is &#39;Texture Unit 1&#39;, xLoc is the memory address of &#39;sampler uniform variable&#39; x</span>
</pre></div>
</div>
<p>After this call, the OpenGL driver updates the <strong>Texture Descriptor</strong> table in GPU
memory with this <cite>{xLoc, 1}</cite> information.</p>
<p>Next, the driver associates the memory address or index of the GPU’s texture descriptor
with a hardware register or pointer used during fragment shader execution. For example,
as shown in the diagram, the driver may write a pointer <cite>k</cite> to the <cite>.tex_a</cite> field in memory.</p>
<p>This <cite>.tex_a</cite> address is used by the GPU to locate the correct <strong>Texture Unit</strong>
and access the texture object during shader execution.</p>
<ol class="arabic simple" start="5">
<li></li>
</ol>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">// gpu machine code</span>
<span class="go">load $1, tex_a;</span>
<span class="go">sample2d_inst $1, $2, $3 // $1: tex_a, $2: %uv_2d, $3: %bias</span>

<span class="go">.tex_a // Driver set the index of gpu descriptor regsters here at step 4</span>
</pre></div>
</div>
<p>When executing the texture instructions from glsl binary file on gpu, the
corresponding ‘Texture Unit 1’ on gpu will being executed through texture
descriptor in gpu’s memory because .tex_a: {xLoc, 1}. Driver may set
texture descriptor in gpu’s texture desciptors if gpu provides specific
texture descriptors in architecture <a class="footnote-reference brackets" href="#descriptorreg" id="id99" role="doc-noteref"><span class="fn-bracket">[</span>71<span class="fn-bracket">]</span></a>.</p>
<p>For instance, Nvidia texture instruction as follow,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">// the content of tex_a bound to texture unit as step 5 above</span>
<span class="go">tex.3d.v4.s32.s32  {r1,r2,r3,r4}, [tex_a, {f1,f2,f3,f4}];</span>

<span class="go">.tex_a</span>
</pre></div>
</div>
<p>The content of tex_a bound to texture unit set by driver as the end of step 4.
The pixel of coordinates (x,y,z) is given by (f1,f2,f3) user input.
The f4 is skipped for 3D texture.</p>
<p>Above tex.3d texture instruction load the calculated color of pixel (x,y,z) from
texture image into GPRs (r1,r2,r3,r4)=(R,G,B,A).
And fragment shader can re-calculate the color of this pixel with the color of
this pixel at texture image <a class="footnote-reference brackets" href="#ptxtex" id="id100" role="doc-noteref"><span class="fn-bracket">[</span>69<span class="fn-bracket">]</span></a>.</p>
<p>If it is 1d texture instruction, the tex.1d as follows,</p>
<ol class="arabic simple" start="5">
<li><p>GPU Execution of Texture Instruction</p></li>
</ol>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">// GPU machine code</span>
<span class="go">load $1, tex_a;</span>
<span class="go">sample2d_inst $1, $2, $3  // $1: tex_a, $2: %uv_2d, $3: %bias</span>

<span class="go">.tex_a // Set by driver to index of GPU descriptor at step 4</span>
</pre></div>
</div>
<p>When the GPU executes the texture sampling instruction (e.g., <cite>sample2d_inst</cite>), it uses
the <cite>.tex_a</cite> address, which was assigned by the driver in step 4, to access the appropriate
<strong>Texture Descriptor</strong> from GPU memory. This descriptor corresponds to <strong>Texture Unit 1</strong>
because of the earlier API call:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">gl</span><span class="p">.</span><span class="n">uniform1i</span><span class="p">(</span><span class="n">xLoc</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>If the GPU hardware provides dedicated <strong>texture descriptor registers</strong> or memory structures,
the driver maps <cite>.tex_a</cite> to those structures <a class="footnote-reference brackets" href="#descriptorreg" id="id101" role="doc-noteref"><span class="fn-bracket">[</span>71<span class="fn-bracket">]</span></a>.</p>
<p><strong>Example (NVIDIA PTX texture instruction):</strong></p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">// The content of tex_a is bound to a texture unit, as in step 4</span>
<span class="go">tex.3d.v4.s32.s32 {r1,r2,r3,r4}, [tex_a, {f1,f2,f3,f4}];</span>

<span class="go">.tex_a</span>
</pre></div>
</div>
<p>Here, the <cite>.tex_a</cite> register holds the texture binding information set by the driver.
The vector <cite>{f1, f2, f3}</cite> represents the 3D coordinates (x, y, z) provided by the shader
or program logic. The <cite>f4</cite> value is ignored for 3D textures.</p>
<p>This <cite>tex.3d</cite> instruction performs a texture fetch from the bound 3D texture and loads
the resulting color values into general-purpose registers:</p>
<ul class="simple">
<li><p><cite>r1</cite>: Red</p></li>
<li><p><cite>r2</cite>: Green</p></li>
<li><p><cite>r3</cite>: Blue</p></li>
<li><p><cite>r4</cite>: Alpha</p></li>
</ul>
<p>The <strong>fragment shader</strong> can then use or modify this color value based on further calculations
or blending logic <a class="footnote-reference brackets" href="#ptxtex" id="id102" role="doc-noteref"><span class="fn-bracket">[</span>69<span class="fn-bracket">]</span></a>.</p>
<p>If a 1D texture is used instead, the texture instruction would look like:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">// For compatibility with prior versions of PTX, the square brackets are not</span>
<span class="go">// required and .v4 coordinate vectors are allowed for any geometry, with</span>
<span class="go">// the extra elements being ignored.</span>
<span class="go">tex.1d.v4.s32.f32  {r1,r2,r3,r4}, [tex_a, {f1}];</span>
</pre></div>
</div>
<p>Since the ‘Texture Unit’ is a limited hardware accelerator on the GPU, OpenGL
provides APIs that allow user programs to bind ‘Texture Units’ to ‘Sampler
Variables’. As a result, user programs can balance the use of ‘Texture Units’
efficiently through OpenGL APIs without recompiling GLSL. Fast texture sampling
is one of the key requirements for good GPU performance <a class="footnote-reference brackets" href="#tpu" id="id103" role="doc-noteref"><span class="fn-bracket">[</span>67<span class="fn-bracket">]</span></a>.</p>
<p>In addition to the API for binding textures, OpenGL provides the
<code class="docutils literal notranslate"><span class="pre">glTexParameteri</span></code> API for texture wrapping <a class="footnote-reference brackets" href="#texturewrapper" id="id104" role="doc-noteref"><span class="fn-bracket">[</span>72<span class="fn-bracket">]</span></a>. Furthermore, the
texture instruction for some GPUs may include S# and T# values in the operands.
Similar to associating ‘Sampler Variables’ to ‘Texture Units’, S# and T# are
memory locations associated with texture wrapping descriptor registers. This
allows user programs to change wrapping options without recompiling GLSL.</p>
<p>Even though the GLSL frontend compiler always expands function calls into inline
functions, and LLVM intrinsic extensions provide an easy way to generate code
through LLVM’s target description (TD) files, the GPU backend compiler is still
somewhat more complex than the CPU backend.</p>
<p>(However, considering the effort required for the CPU frontend compiler such as
Clang, or toolchains like the linker and GDB/LLDB, the overall difficulty of
building a CPU compiler is not necessarily less than that of a GPU compiler.)</p>
<p>Here is the software stack of the 3D graphics system for OpenGL on Linux
<a class="footnote-reference brackets" href="#mesawiki" id="id105" role="doc-noteref"><span class="fn-bracket">[</span>13<span class="fn-bracket">]</span></a>. The Mesa open source project website is here <a class="footnote-reference brackets" href="#mesa" id="id106" role="doc-noteref"><span class="fn-bracket">[</span>73<span class="fn-bracket">]</span></a>.</p>
</section>
</section>
<section id="gpu-architecture">
<h2><a class="toc-backref" href="#id337" role="doc-backlink">GPU Architecture</a><a class="headerlink" href="#gpu-architecture" title="Link to this heading">¶</a></h2>
<figure class="align-center" id="id247">
<span id="cg-hw"></span><a class="reference internal image-reference" href="_images/cg-hw.png"><img alt="_images/cg-hw.png" height="327" src="_images/cg-hw.png" width="693" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 102 </span><span class="caption-text">Computer Graphics Hardware (figure from book <a class="footnote-reference brackets" href="#cg-basictheory" id="id107" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>)</span><a class="headerlink" href="#id247" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<section id="gpu-hardware-units">
<h3><a class="toc-backref" href="#id338" role="doc-backlink">GPU Hardware Units</a><a class="headerlink" href="#gpu-hardware-units" title="Link to this heading">¶</a></h3>
<p>A GPU (graphics processing unit) is built as a massively generic parallel
processor of SIMD/SIMT architecture with several specialized processing units
inside shown as <a class="reference internal" href="#gpu-block-diagram-2"><span class="std std-numref">Fig. 103</span></a> from the
<a class="reference internal" href="#ghast"><span class="std std-ref">section Graphics HW and SW Stack</span></a>.</p>
<figure class="align-center" id="id248">
<span id="gpu-block-diagram-2"></span><a class="reference internal image-reference" href="_images/gpu-block-diagram.png"><img alt="_images/gpu-block-diagram.png" height="376" src="_images/gpu-block-diagram.png" width="400" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 103 </span><span class="caption-text">Components of a GPU: GPU has accelerated video decoding and encoding
<a class="footnote-reference brackets" href="#wiki-gpu" id="id108" role="doc-noteref"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></a></span><a class="headerlink" href="#id248" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>From compiler’s view, GPU is shown as <a class="reference internal" href="#gpu-hw"><span class="std std-numref">Fig. 104</span></a>.</p>
<figure class="align-default" id="id249">
<span id="gpu-hw"></span><div class="graphviz"><img src="_images/graphviz-db622d4ddb603b47e8f52d1a558c2e044f9876ea.png" alt="digraph GPU {
  rankdir=LR;
  bgcolor=&quot;white&quot;;
  node [shape=box, fontname=&quot;Helvetica&quot;, fontsize=10];

  /* Top-level GPU container */
  subgraph cluster_gpu {
    label = &quot;Massively Parallel Processor (GPU)&quot;;
    style = rounded;
    color = black;
    fontsize=12;

    /* Compute cluster: many SMs/CUs */
    subgraph cluster_compute {
      label = &quot;Compute Cluster (many SMs / CUs)&quot;;
      style = filled;
      fillcolor = &quot;#f7fbff&quot;;
      color = &quot;#c6dbef&quot;;

      SMs [label=&lt;
        &lt;TABLE BORDER=&quot;0&quot; CELLBORDER=&quot;0&quot; CELLSPACING=&quot;6&quot;&gt;
          &lt;TR&gt;&lt;TD&gt;&lt;B&gt;SM 0..N-1&lt;/B&gt;&lt;/TD&gt;&lt;/TR&gt;
          &lt;TR&gt;&lt;TD&gt;
            &lt;TABLE BORDER=&quot;0&quot; CELLBORDER=&quot;1&quot; CELLSPACING=&quot;0&quot;&gt;
              &lt;TR&gt;&lt;TD&gt;&lt;FONT POINT-SIZE=&quot;10&quot;&gt;&lt;B&gt;Warp Scheduler&lt;/B&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;
              &lt;TR&gt;&lt;TD&gt;&lt;FONT POINT-SIZE=&quot;10&quot;&gt;Registers&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;
              &lt;TR&gt;&lt;TD&gt;&lt;FONT POINT-SIZE=&quot;10&quot;&gt;Shared Memory / L1&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;
              &lt;TR&gt;&lt;TD&gt;&lt;FONT POINT-SIZE=&quot;10&quot;&gt;ALUs (FP/INT)&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;
              &lt;TR&gt;&lt;TD&gt;&lt;FONT POINT-SIZE=&quot;10&quot;&gt;SFUs (transcendental)&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;
              &lt;TR&gt;&lt;TD&gt;&lt;FONT POINT-SIZE=&quot;10&quot;&gt;Load/Store Units&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;
              &lt;TR&gt;&lt;TD&gt;&lt;FONT POINT-SIZE=&quot;10&quot;&gt;RegLess Staging Operands (RSO)&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;
            &lt;/TABLE&gt;
          &lt;/TD&gt;&lt;/TR&gt;
        &lt;/TABLE&gt;
      &gt;, shape=plaintext];
    }

    /* Specialized units */
    subgraph cluster_special {
      label = &quot;Specialized Units&quot;;
      style = filled;
      fillcolor = &quot;#fff7f3&quot;;
      color = &quot;#fcbba1&quot;;

      Geo [label=&quot;Geometry Units\n(primitive assembly,\ntessellation, clipping)&quot;];
      Raster [label=&quot;Rasterization Units\n(triangle -&gt; fragments,\nattribute interpolation)&quot;];
      TMU  [label=&quot;Texture Mapping Units (TMUs)\n(sampling &amp; filtering)&quot;];
      ROP  [label=&quot;Render Output Units (ROPs)\n(blend, depth, stencil,\nframebuffer write)&quot;];
      Tensor [label=&quot;Tensor / Matrix Cores\n(AI accel)&quot;];
      RT     [label=&quot;Ray-Tracing Cores\n(BVH traversal, intersections)&quot;];
      Video  [label=&quot;Video Encode / Decode Engines\n(NVENC / VCN / VPU)&quot;];
      Display [label=&quot;Display Controller\n(HDMI / DP)&quot;];
    }

    /* Memory subsystem */
    subgraph cluster_mem {
      label = &quot;Memory Subsystem&quot;;
      style = filled;
      fillcolor = &quot;#f7fff7&quot;;
      color = &quot;#c7e9c0&quot;;

      L1  [label=&quot;L1 / Shared Memory (per SM)&quot;];
      L2  [label=&quot;L2 Cache (shared)&quot;];
      VRAM[label=&quot;VRAM (GDDR / HBM)\n(high bandwidth)&quot;];
      Interconnect [label=&quot;Memory Controller / Interconnect&quot;];

      Coalescing [label=&quot;Memory Coalescing\n(merge warp memory requests)&quot;];
      GatherScatter [label=&quot;Gather–Scatter\n(irregular memory access)&quot;];
    }

    /* Connections between major blocks */
    SMs -&gt; Geo [label=&quot; vertices&quot;];
    Geo -&gt; Raster [label=&quot; primitives&quot;];
    Raster -&gt; SMs [label=&quot; fragments (shaded in SMs)&quot;];

    SMs -&gt; TMU [label=&quot; texture fetch&quot;];
    SMs -&gt; Tensor [label=&quot; matrix ops&quot;];
    SMs -&gt; RT [label=&quot; ray queries&quot;, style=dashed];

    Raster -&gt; ROP [label=&quot; fragments -&gt; tests + blend&quot;];
    SMs -&gt; ROP [label=&quot; shaded fragments&quot;];
    ROP  -&gt; VRAM [label=&quot; final framebuffer write&quot;];

    /* Memory subsystem connections */
    SMs -&gt; L1 [label=&quot; fast access&quot;];
    TMU  -&gt; L2 [label=&quot; texture reads&quot;];
    SMs -&gt; L2 [label=&quot; global loads/stores&quot;];
    L2   -&gt; VRAM [label=&quot; miss -&gt; VRAM&quot;];
    Interconnect -&gt; VRAM [label=&quot; memory transactions&quot;];

    /* Memory behavior connections */
    SMs -&gt; Coalescing [label=&quot; warp memory requests&quot;];
    Coalescing -&gt; L2 [label=&quot; optimized transaction&quot;];
    SMs -&gt; GatherScatter [label=&quot; irregular access&quot;, style=dashed];
    GatherScatter -&gt; L2 [label=&quot; multiple transactions&quot;, style=dashed];

    /* Video/Display */
    Video -&gt; VRAM [label=&quot; read/write video frames&quot;];
    Display -&gt; VRAM [label=&quot; scanout&quot;];
  }
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 104 </span><span class="caption-text">Components of a GPU: SIMD/SIMT + several specialized processing units</span><a class="headerlink" href="#id249" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>A GPU is not just “many cores” — it’s a mix of general-purpose ompute clusters,
specialized units, and the memory subsystem. It corresponds to the block
diagram graph shown in <a class="reference internal" href="#gpu-hw"><span class="std std-numref">Fig. 104</span></a>.</p>
<p>The stages of the OpenGL rendering pipeline and the GPU hardware units
that accelerate them as shown in <a class="reference internal" href="#ogl-pipeline-hw"><span class="std std-numref">Fig. 105</span></a>:</p>
<figure class="align-default" id="id250">
<span id="ogl-pipeline-hw"></span><div class="graphviz"><img src="_images/graphviz-3ca0467b8878209cbbb4397d03ca6bde891369f0.png" alt="digraph OpenGL_GPU_Mapping {
    rankdir=TB;

    // Use HTML-like label for the whole graph
    label=&lt;
        &lt;TABLE BORDER=&quot;0&quot; CELLBORDER=&quot;0&quot; CELLSPACING=&quot;0&quot; ALIGN=&quot;LEFT&quot;&gt;
            &lt;TR&gt;&lt;TD&gt;&lt;/TD&gt;&lt;/TR&gt;
            &lt;TR&gt;&lt;TD&gt;&lt;/TD&gt;&lt;/TR&gt;
            &lt;TR&gt;&lt;TD&gt;&lt;FONT POINT-SIZE=&quot;16&quot; COLOR=&quot;darkblue&quot;&gt;&lt;B&gt;• OpenGL pipeline stages = Yellow&lt;/B&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;
            &lt;TR&gt;&lt;TD&gt;&lt;FONT POINT-SIZE=&quot;16&quot; COLOR=&quot;darkblue&quot;&gt;&lt;B&gt;• GPU hardware units = Blue&lt;/B&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;
            &lt;TR&gt;&lt;TD&gt;&lt;FONT POINT-SIZE=&quot;16&quot; COLOR=&quot;darkblue&quot;&gt;&lt;B&gt;• GPU-only internals = Gray&lt;/B&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;
            &lt;TR&gt;&lt;TD&gt;&lt;FONT POINT-SIZE=&quot;16&quot; COLOR=&quot;darkblue&quot;&gt;&lt;B&gt;• Dashed arrows indicate mapping from OpenGL stages to hardware&lt;/B&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;
        &lt;/TABLE&gt;
    &gt;;

    node [shape=box style=&quot;rounded,filled&quot; fontsize=16];

    // === OpenGL Pipeline (multi-rows) ===
    Application   [label=&quot;Application\n(CPU Side)&quot;, fillcolor=lightyellow];
    VertexSpec    [label=&quot;Vertex Specification\n(glDraw, VBOs)&quot;, fillcolor=lightyellow];

    OGL_Vertex    [label=&quot;Vertex Shader&quot;, fillcolor=lightyellow];
    TessCtrl      [label=&quot;Tessellation \nControl Shader&quot;, fillcolor=lightyellow];
    TessGen       [label=&quot;Tessellation \nPrimitive Generator&quot;, fillcolor=lightyellow];
    TessEval      [label=&quot;Tessellation \nEvaluation Shader&quot;, fillcolor=lightyellow];
    OGL_Geometry  [label=&quot;Geometry Shader / Clipping&quot;, fillcolor=lightyellow];

    OGL_Raster    [label=&quot;Rasterization&quot;, fillcolor=lightyellow];
    OGL_Fragment  [label=&quot;Fragment Shader&quot;, fillcolor=lightyellow];
    OGL_PerFrag   [label=&quot;Per-Fragment Ops\n(Depth, Stencil, Blend)&quot;, fillcolor=lightyellow];
    OGL_Framebuf  [label=&quot;Framebuffer&quot;, fillcolor=lightyellow];

    // OpenGL flow
    Application -&gt; VertexSpec -&gt; OGL_Vertex -&gt; TessCtrl -&gt; TessGen -&gt; TessEval -&gt; OGL_Geometry -&gt; OGL_Raster -&gt; OGL_Fragment -&gt; OGL_PerFrag -&gt; OGL_Framebuf;

    // === GPU Hardware Units (multi-rows) ===
    HW_Vertex    [label=&quot;SMs (Vertex Shader)\n(ALUs, SFUs, Load/Store)&quot;, fillcolor=lightblue];
    HW_Fragment  [label=&quot;SMs (Fragment Shader)\n(ALUs, SFUs, TMUs)&quot;, fillcolor=lightblue];
    HW_Geometry  [label=&quot;Geometry Units\n(Primitive Assembly, Clipping)&quot;, fillcolor=lightblue];
    HW_Raster    [label=&quot;Rasterization Units\n(Triangle → Fragments)&quot;, fillcolor=lightblue];
    ROP          [label=&quot;Render Output Units (ROPs)\n(Depth, Stencil, Blend)&quot;, fillcolor=lightblue];
    HW_Framebuf  [label=&quot;Framebuffer in VRAM&quot;, fillcolor=lightblue];
    TMU          [label=&quot;Texture Mapping Units (TMUs)\n(Texture Fetch/Filter)&quot;, fillcolor=lightgray];
    Display      [label=&quot;Display Controller\n(Output to Screen)&quot;, fillcolor=lightgray];

    // Memory hierarchy
    L1           [label=&quot;L1 / Shared Memory&quot;, fillcolor=lightgray];
    L2           [label=&quot;L2 Cache&quot;, fillcolor=lightgray];
    VRAM         [label=&quot;VRAM (GDDR/HBM)&quot;, fillcolor=lightgray];
    Coalescing   [label=&quot;Coalescing Unit&quot;, fillcolor=lightgray];
    GatherScatter[label=&quot;Gather–Scatter Unit&quot;, fillcolor=lightgray];

    // GPU flow
    HW_Vertex -&gt; HW_Geometry -&gt; HW_Raster -&gt; HW_Fragment;
    HW_Fragment -&gt; TMU;
    HW_Fragment -&gt; ROP -&gt; HW_Framebuf -&gt; Display;

    // Memory path
    HW_Vertex -&gt; L1;
    HW_Fragment -&gt; L1;
    L2 -&gt; Coalescing;
    L1 -&gt; L2 -&gt; VRAM;
    L2 -&gt; GatherScatter;
    TMU -&gt; L1 [label=&quot;Texture Fetch&quot;];
    VRAM -&gt; Display;

    // === Mapping edges (OpenGL → Hardware) ===
    OGL_Vertex   -&gt; HW_Vertex   [style=dashed color=blue];
    TessCtrl     -&gt; HW_Vertex   [style=dashed color=blue];
    TessEval     -&gt; HW_Vertex   [style=dashed color=blue];
    OGL_Geometry -&gt; HW_Geometry [style=dashed color=blue];
    OGL_Raster   -&gt; HW_Raster   [style=dashed color=blue];
    OGL_Fragment -&gt; HW_Fragment [style=dashed color=blue];
    OGL_PerFrag  -&gt; ROP         [style=dashed color=blue];
    OGL_Framebuf -&gt; HW_Framebuf [style=dashed color=blue];

    // === Layering for better spacing ===
    { rank = same; Application; VertexSpec }
    { rank = same; OGL_Vertex; TessCtrl; TessGen }
    { rank = same; TessEval; OGL_Geometry }
    { rank = same; OGL_Raster; OGL_Fragment; OGL_PerFrag; OGL_Framebuf }

    { rank = same; HW_Vertex; HW_Fragment }
    { rank = same; HW_Geometry; HW_Raster; ROP; HW_Framebuf; TMU }
    { rank = same; L1; L2; VRAM; Display }
    { rank = same; Coalescing; GatherScatter }
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 105 </span><span class="caption-text">The stages of OpenGL pipeline and GPU’s acceleration components</span><a class="headerlink" href="#id250" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p><strong>Compute Cluster</strong></p>
<ul class="simple">
<li><p><strong>Role:</strong>
Provide large-scale data-parallel execution. Each GPU contains many
Streaming Multiprocessors (SMs) or Compute Units (CUs), each capable
of executing thousands of threads in parallel.</p></li>
<li><p><strong>Components:</strong></p>
<ul>
<li><p><strong>Warp Scheduler</strong> – Schedules groups of threads (Warps/Wavefronts),
issues instructions in SIMT (Single Instruction, Multiple Threads) fashion.</p></li>
<li><p><strong>Registers</strong> – Per-thread private storage, the fastest memory level.</p></li>
<li><p><strong>Shared Memory / L1 Cache</strong> – On-chip memory close to the SM.
Shared Memory is explicitly managed by the programmer for cooperation
across threads, while L1 acts as a transparent cache.</p></li>
<li><p><strong>ALUs (FP/INT)</strong> – Execute floating-point and integer arithmetic.
They form the bulk of compute resources inside an SM.</p></li>
<li><p><strong>SFUs (Special Function Units)</strong> – Execute transcendental functions
such as sin, cos, exp, and reciprocal approximations.</p></li>
<li><p><strong>Load/Store Units</strong> – Handle global, local, and shared memory access,
interact with coalescing and caching logic.</p></li>
<li><p><strong>RegLess Staging Operands (RSO)</strong> – Temporary operand buffers used
to hide instruction and memory latencies.</p></li>
</ul>
</li>
<li><p><strong>Usage:</strong></p>
<ul>
<li><p>Run programmable shaders (vertex, fragment, geometry, compute).</p></li>
<li><p>Perform general-purpose compute workloads (GPGPU).</p></li>
<li><p>Issue texture fetch requests to TMUs.</p></li>
<li><p>Interact with memory hierarchy via load/store units.</p></li>
<li><p>Offload certain operations to Tensor or Ray-Tracing units.</p></li>
</ul>
</li>
</ul>
<p><strong>Specialized Units</strong></p>
<ul>
<li><p><strong>Role:</strong>
Accelerate fixed-function or specialized stages of the graphics and
compute pipeline that are inefficient to run purely in SMs.</p></li>
<li><p><strong>Components and Usage:</strong></p>
<ul>
<li><p><strong>Geometry Units</strong> –
Assemble input vertices into primitives (points, lines, triangles).
Perform tessellation (subdivide patches into smaller primitives),
clipping (discard geometry outside view), and geometry shading.</p>
<p><em>Usage:</em> Corresponds to the geometry/tessellation stage in the graphics pipeline.</p>
</li>
<li><p><strong>Rasterization Units</strong> –
Convert vector-based primitives into fragments (potential pixels).
Interpolate per-vertex attributes (texture coordinates, normals, colors)
across the surface of each primitive.</p>
<p><em>Usage:</em> Bridge between geometry and fragment stages; produces fragments
for SM fragment shading.</p>
</li>
<li><p><strong>Texture Mapping Units (TMUs)</strong> –
Fetch texture data from memory, apply filtering (bilinear, trilinear,
anisotropic), and compute texel addresses (wrap, clamp).</p>
<p><em>Usage:</em> Invoked during fragment shading inside SMs to provide sampled
texture values.</p>
</li>
<li><p><strong>Render Output Units (ROPs)</strong> –
Handle late-stage pixel processing. Perform blending operations
(alpha, additive), depth and stencil tests, and write final pixel values
to the framebuffer in VRAM.</p>
<p><em>Usage:</em> Final step of the graphics pipeline before display scanout.</p>
</li>
<li><p><strong>Tensor / Matrix Cores</strong> –
Perform fused-multiply-add (FMA) on large matrix tiles.
Designed for machine learning, AI inference, and linear algebra.</p>
<p><em>Usage:</em> Accelerate deep learning workloads or matrix-heavy compute kernels.</p>
</li>
<li><p><strong>Ray-Tracing Units (RT Cores)</strong> –
Traverse bounding volume hierarchies (BVH) and perform ray–primitive
intersection tests in hardware.</p>
<p><em>Usage:</em> Enable real-time ray tracing <a class="footnote-reference brackets" href="#wiki-ray-tracing" id="id109" role="doc-noteref"><span class="fn-bracket">[</span>96<span class="fn-bracket">]</span></a> by offloading
intersection work from SMs.</p>
</li>
<li><p><strong>Video Engines</strong> –
Dedicated ASICs for video codec operations such as H.264/H.265/AV1 encode
and decode.</p>
<p><em>Usage:</em> Media playback, streaming, and video encoding without occupying SMs.</p>
</li>
<li><p><strong>Display Controller</strong> –
Reads final framebuffer images from VRAM and drives display interfaces
like HDMI and DisplayPort.</p>
<p><em>Usage:</em> Outputs rendered frames to monitors or VR headsets.</p>
</li>
</ul>
</li>
</ul>
<p><strong>Memory Subsystem</strong></p>
<ul>
<li><p><strong>Role:</strong>
Deliver high-bandwidth data access to thousands of threads while
minimizing latency through caching and access optimization.</p></li>
<li><p><strong>Components:</strong></p>
<ul>
<li><p><strong>L1 / Shared Memory</strong> –
Closest to SMs. Shared Memory is explicitly used by programs for
intra-block communication, while L1 acts as an automatic cache.</p>
<p><em>Usage:</em> Boosts performance by keeping frequently accessed data
close to execution units.</p>
</li>
<li><p><strong>L2 Cache</strong> –
Shared across all SMs. Reduces redundant traffic to VRAM and
improves latency for reused data.</p>
<p><em>Usage:</em> Provides intermediate caching layer for both compute and graphics.</p>
</li>
<li><p><strong>VRAM (GDDR / HBM)</strong> –
External high-bandwidth DRAM. Stores textures, framebuffers,
vertex/index buffers, and large compute datasets.</p>
<p><em>Usage:</em> The main memory backing for all GPU workloads.</p>
</li>
<li><p><strong>Interconnect / Memory Controller</strong> –
Orchestrates memory requests, manages access to VRAM,
and ensures fairness between SMs.</p>
<p><em>Usage:</em> Handles scheduling and distribution of memory transactions.</p>
</li>
<li><p><strong>Memory Coalescing Unit</strong> –
Combines multiple per-thread memory requests from a Warp into fewer,
wider transactions. Most effective for contiguous access patterns.</p>
<p><em>Usage:</em> Improves memory bandwidth efficiency and reduces wasted cycles.</p>
</li>
<li><p><strong>Gather–Scatter Unit</strong> –
Handles irregular or sparse memory accesses where coalescing is not possible.
May break requests into multiple smaller transactions.</p>
<p><em>Usage:</em> Supports workloads such as sparse matrix operations, graph traversal,
or irregular data structures.</p>
</li>
</ul>
</li>
</ul>
<p><strong>Data Flow Highlights</strong></p>
<ul class="simple">
<li><p><strong>Graphics pipeline path:</strong>
Vertex data → Geometry Units → Rasterization Units → Fragment Shading (SMs)
→ TMUs (texture fetch) → ROPs (blend/depth/stencil) → VRAM (framebuffer).</p></li>
<li><p><strong>Compute path:</strong>
SMs execute general-purpose kernels → optional offload to Tensor or RT cores
→ interact with caches → VRAM.</p></li>
<li><p><strong>Memory behavior:</strong>
SMs issue memory requests → Coalescing Unit optimizes if possible → L2 cache →
VRAM. For irregular access (e.g., sparse data), Gather–Scatter generates
multiple VRAM transactions.</p></li>
<li><p><strong>Display path:</strong>
Final framebuffer stored in VRAM → Display Controller → HDMI / DP scanout.</p></li>
</ul>
<p><strong>All Together</strong></p>
<p><strong>GPU provides the following hardware to accelerate graphics rendering pipeline as follows:</strong></p>
<dl class="simple">
<dt>✅ Simplified Flow (OpenGL → Hardware)</dt><dd><ol class="arabic simple">
<li><p>Vertex Fetch → VRAM &amp; Memory Controllers.</p></li>
<li><p>Vertex Shader → SM cores + Geometry Units.</p></li>
<li><p>Geometry/Tessellation → SM core + Geometry Units.</p></li>
<li><p>Rasterization → Rasterization units.</p></li>
<li><p>Fragment Shader → SM cores + TMUs (texture sampling).</p></li>
<li><p>Depth/Stencil/Blending → ROPs.</p></li>
<li><p>Framebuffer Write → L2 cache &amp; VRAM → Display Controller.</p></li>
</ol>
</dd>
</dl>
<p><strong>Variable Rate Shading (VRS) Support</strong></p>
<p>By utilizing certain GPU units as outlined below, Variable Rate Shading (VRS) can be
supported <a class="footnote-reference brackets" href="#vrs" id="id110" role="doc-noteref"><span class="fn-bracket">[</span>97<span class="fn-bracket">]</span></a>.</p>
<ul class="simple">
<li><p>Rasterizer (Rasterization Units):</p>
<ul>
<li><p>Decides how many fragments per pixel (or group of pixels) will actually be shaded.</p></li>
<li><p>Instead of generating 1 fragment per pixel, it may shade 1 fragment for a 2×2 or 4×4 block and reuse that result.</p></li>
</ul>
</li>
<li><p>Fragment Shader Cores (SMs/CUs):</p>
<ul>
<li><p>Still run the shading code, but at a reduced frequency (fewer fragment invocations).</p></li>
</ul>
</li>
<li><p>ROPs (and pipeline integration):</p>
<ul>
<li><p>Apply results to the framebuffer, handling blending/depth as usual.</p></li>
</ul>
</li>
</ul>
</section>
<section id="sm-simt">
<h3><a class="toc-backref" href="#id339" role="doc-backlink">SM (SIMT)</a><a class="headerlink" href="#sm-simt" title="Link to this heading">¶</a></h3>
<p>Single instruction, multiple threads (SIMT) is an execution model used in
parallel computing where a single central “Control Unit” broadcasts an
instruction to multiple “Processing Units” for them to all optionally perform
simultaneous synchronous and fully-independent parallel execution of that one
instruction. <strong>Each PU has its own independent data and address registers, its
own independent Memory, but no PU in the array has a Program counter</strong>
<a class="footnote-reference brackets" href="#simt-wiki" id="id111" role="doc-noteref"><span class="fn-bracket">[</span>74<span class="fn-bracket">]</span></a>.</p>
<p>Summary:</p>
<ul class="simple">
<li><p>Each Control Unit has a Program Counter (PC) and  has tens of Processor Unit
(PU).</p></li>
<li><p>Each Processor Unit (PU) has it’s General Purpose Register Set (GPR) and stack
memory.</p></li>
<li><p>The PU is a pipleline execution unit compared to CPU architecture.</p></li>
</ul>
<section id="sm-hardware">
<h4><a class="toc-backref" href="#id340" role="doc-backlink">SM Hardware</a><a class="headerlink" href="#sm-hardware" title="Link to this heading">¶</a></h4>
<p>The leading NVIDIA GPU architecture is illustrated in <a class="reference internal" href="#gpu-sched"><span class="std std-numref">Fig. 106</span></a>,
<strong>where the scoreboard is shown without the mask field</strong>.
This represents a SIMT pipeline with a scoreboard.</p>
<figure class="align-center" id="id251">
<span id="gpu-sched"></span><a class="reference internal image-reference" href="_images/gpu-sched.png"><img alt="_images/gpu-sched.png" height="556" src="_images/gpu-sched.png" width="606" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 106 </span><span class="caption-text">Simplified block diagram of a Multithreaded SIMD Processor. (figure from book
<a class="footnote-reference brackets" href="#quantitative-threads-lanes" id="id112" role="doc-noteref"><span class="fn-bracket">[</span>80<span class="fn-bracket">]</span></a>)</span><a class="headerlink" href="#id251" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A SIMD Thread executed by SIMD Processor, a.k.a. SM, has 16 Lanes.</p>
</div>
<table class="docutils align-center">
<colgroup>
<col style="width: 60.0%" />
<col style="width: 40.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><figure class="align-default" id="id252">
<span id="sm-left"></span><a class="reference internal image-reference" href="_images/sm.png"><img alt="_images/sm.png" height="603" src="_images/sm.png" width="468" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 107 </span><span class="caption-text">Streaming Multiprocessor SM figure from book <a class="footnote-reference brackets" href="#quantitative-gpu-sm" id="id113" role="doc-noteref"><span class="fn-bracket">[</span>81<span class="fn-bracket">]</span></a>.</span><a class="headerlink" href="#id252" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</td>
<td><figure class="align-default" id="id253">
<span id="sm-right"></span><a class="reference internal image-reference" href="_images/sm2.png"><img alt="_images/sm2.png" height="552" src="_images/sm2.png" width="349" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 108 </span><span class="caption-text">SM figure from websites <a class="footnote-reference brackets" href="#cuda-sm" id="id114" role="doc-noteref"><span class="fn-bracket">[</span>77<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#fermi" id="id115" role="doc-noteref"><span class="fn-bracket">[</span>78<span class="fn-bracket">]</span></a>.</span><a class="headerlink" href="#id253" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><p>Streaming Multiprocessor SM has two 16-way SIMD units and four special
function units.
Fermi has 32 SIMD Lanes and Cuda cores.
SM has L1 and Read Only Cache (Uniform Cache)
GTX480 has 48 SMs.</p></li>
<li><p>In Fermi,
ALUs run at twice the clock rate of rest of chip. So each
decoded instruction runs on 32 pieces of data on the 16 ALUs over two ALU
clocks <a class="footnote-reference brackets" href="#chime" id="id116" role="doc-noteref"><span class="fn-bracket">[</span>79<span class="fn-bracket">]</span></a>. However after Fermi, the ALUs run at the same clock rate
of rest of chip.</p></li>
<li><p>As <a class="reference internal" href="#sm-left"><span class="std std-numref">Fig. 107</span></a> in Fermi and Volta, it can dual-issue “float + integer” or
“integer + load/store” but cannot dual-issue “float + float” or “int + int”.</p></li>
<li><p>Uniform cache: used for storing constant variables in OpenGL (see
<a class="reference internal" href="#pipeline-qualifier"><span class="std std-ref">uniform of Pipeline Qualifiers</span></a>) and in OpenCL/CUDA.</p></li>
</ul>
<p id="cfg-warps"><strong>Configurable maximum resident warps and allocated registers per thread</strong> as
follows:</p>
<ul class="simple">
<li><p>Example: Fermi SM (SM 2.x)</p>
<ul>
<li><p>Hawdware limit:</p>
<ul>
<li><p>Total registers per SM = 32,768 × 32-bit</p></li>
<li><p>Max Warps per SM = 48</p></li>
<li><p>Max threads per SM = 1536</p></li>
<li><p>Max registers/thread = 63</p></li>
</ul>
</li>
<li><p>Configuration: If each thread uses R registers:</p>
<ul>
<li><p>Max resident threads = floor(32768 / R)</p></li>
<li><p>Max resident Warps   = floor(Max resident threads / 32)</p></li>
<li><p>E.g. <strong>R=32: Max resident threads = 32768/32 = 1024, Max resident Warps =
1024/32 = 32.</strong></p></li>
</ul>
</li>
</ul>
</li>
<li><p>After Fermi, the hardware limit for Maxwell, Pascal, Volta and Ampere are:</p>
<ul>
<li><p>Hawdware limit:</p>
<ul>
<li><p>Each SM includes 32 Cuda cores and Lanes → 32 active threads.</p></li>
<li><p>Total registers per SM = 64K x 32-bit</p></li>
<li><p>Max Warps per SM = 64</p></li>
<li><p>Max threads per SM = 2048 (64 Warps x 32 threads)</p></li>
<li><p>Max registers/thread = 255</p></li>
</ul>
</li>
<li><p>Notes:</p>
<ul>
<li><p>Registers per thread: max number of registers <strong>compiler can allocate to
a thread</strong>.</p></li>
<li><p>The “registers per thread” limit (255) is a hardware/compiler limit, but
the actual number used depends on the kernel.
If a kernel uses too many registers per thread, occupancy drops (fewer
threads can be resident).</p></li>
<li><p>The “max threads per SM = 2048” is a theoretical upper limit; actual
resident threads will also depend on shared memory usage, number of
thread-blocks per SM, and register usage.</p></li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A SIMD thread executed by a Multithreaded SIMD processor, also known as an SM,
processes 32 elements.</p>
<p>As configuation above, the 32,768 registers per SM can be configured to  each
thread alllocated 32 registers, Max resident Warps = 32.</p>
<p>Fermi has a mode bit that offers the choice of using 64 KB of SRAM as
a 16 KB L1 cache with 48 KB of Local Memory or as a 48 KB L1 cache
with 16 KB of Local Memory <a class="footnote-reference brackets" href="#quantitative-gpu-l1" id="id117" role="doc-noteref"><span class="fn-bracket">[</span>93<span class="fn-bracket">]</span></a>.</p>
</div>
<table class="docutils align-center">
<colgroup>
<col style="width: 60.0%" />
<col style="width: 40.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><figure class="align-default" id="id254">
<span id="threadblock"></span><a class="reference internal image-reference" href="_images/threadblock.jpg"><img alt="_images/threadblock.jpg" height="295" src="_images/threadblock.jpg" width="596" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 109 </span><span class="caption-text">SM select Thread Blocks to run <a class="footnote-reference brackets" href="#wiki-tbcp" id="id118" role="doc-noteref"><span class="fn-bracket">[</span>100<span class="fn-bracket">]</span></a>.</span><a class="headerlink" href="#id254" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</td>
<td><figure class="align-default" id="id255">
<span id="threadblocks-map"></span><a class="reference internal image-reference" href="_images/threadblocks-map.png"><img alt="_images/threadblocks-map.png" height="400" src="_images/threadblocks-map.png" width="389" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 110 </span><span class="caption-text">Mapping Thread Block to SMs <a class="footnote-reference brackets" href="#mapping-blocks-to-sm" id="id119" role="doc-noteref"><span class="fn-bracket">[</span>76<span class="fn-bracket">]</span></a>.</span><a class="headerlink" href="#id255" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</td>
</tr>
</tbody>
</table>
</section>
<section id="sm-scheduling">
<h4><a class="toc-backref" href="#id341" role="doc-backlink">SM Scheduling</a><a class="headerlink" href="#sm-scheduling" title="Link to this heading">¶</a></h4>
<ul>
<li><p>A GPU is built around an array of Streaming Multiprocessors (SMs).
A multithreaded program is partitioned into blocks of threads that execute
independently from each other, so that a GPU with more multiprocessors will
automatically execute the program in less time than a GPU with fewer
multiprocessors <a class="footnote-reference brackets" href="#mapping-blocks-to-sm" id="id120" role="doc-noteref"><span class="fn-bracket">[</span>76<span class="fn-bracket">]</span></a>.</p></li>
<li><p>Nvidia’s GPUs:</p>
<p>Fermi (2010), Kepler (2012), Maxwell (2014), Pascal (2016), Volta (2017),
Turing (2018), Ampere (2020), Ada Lovelace (2022), and Hopper (2022, for data
centers).</p>
</li>
<li><p>Two levels of scheduling:</p>
<ul>
<li><p>Level 1: Thread Block Scheduler</p>
<p>For Fermi/Kepler/Maxwell/Pascal (pre-Volta): Warp-synchronous SIMT
(lock-step in Warp):</p>
<p>A Warp includes 32 threads in Fermi GPU.
Each Streaming Multiprocessor SM includes 32 Lanes in Fermi GPU, as shown
in <a class="reference internal" href="#threadblock"><span class="std std-numref">Fig. 109</span></a>, the Thread Block includes a Warp (32 threads).
According <a class="reference internal" href="#threadblocks-map"><span class="std std-numref">Fig. 110</span></a>, more than one block can be assigned
and run on a same SM.</p>
<p id="l1-warp-sched">When an SM executes a Thread Block, all the threads within the block are
are executed at the same time. If any thread in a Warp is not ready due to
operand data dependencies, the scheduler switches context between Warps.
During a context switch, all the data of the current Warp remains in the
register file so it can resume quickly once its operands are ready
<a class="footnote-reference brackets" href="#wiki-tbcp" id="id121" role="doc-noteref"><span class="fn-bracket">[</span>100<span class="fn-bracket">]</span></a>.</p>
<p>Once a Thread Block is launched on a multiprocessor (SM), all
of its Warps are <strong>resident</strong> until their execution finishes.
Thus a new block is not launched on an SM until there is sufficient
number of free registers for all Warps of the new block, and until there
is enough free shared memory for the new block <a class="footnote-reference brackets" href="#wiki-tbcp" id="id122" role="doc-noteref"><span class="fn-bracket">[</span>100<span class="fn-bracket">]</span></a>.</p>
</li>
<li><p>Level 2: Warp Scheduler</p>
<p>Manages CUDA threads (resident threads) within the same Warp.</p>
<p>A <strong>resident thread</strong> is a thread whose execution context has been
allocated on an SM (registers, Warp slot, shared memory).  Once resident,
the thread is always in exactly one of the following execution states.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Resident Thread
├── Ready
│     Thread is eligible to execute; no pending dependencies.
│
├── Running
│     Warp containing the thread is currently issued by the scheduler.
│
│     ├── Active (mask = 1)
│     │     Thread participates in the current instruction.
│     │
│     └── Inactive (mask = 0)
│           Thread is masked off due to branch divergence and
│           will re-activate at a reconvergence point.
│
├── Stalled
│     Warp cannot issue due to memory latency, synchronization,
│     or scoreboard dependency.
│
└── Exited
      Thread has completed execution but its Warp has not yet been
      released from the SM.
</pre></div>
</div>
<p>Threads retain their registers and per-thread local memory during the
stalled state.
Therefore, <strong>the context switch incurs almost no overhead compared to CPU
threads</strong>.</p>
<ul class="simple">
<li><p>No pipeline flush: illustrate below.</p></li>
<li><p>No register save/restore</p></li>
<li><p>No stack frame swapping</p></li>
<li><p><strong>No OS involvement</strong></p></li>
<li><p>Takes roughly <strong>1 cycle</strong></p></li>
</ul>
<p>No pipeline flush because:</p>
<p>For Fermi/Kepler/Maxwell/Pascal (pre-Volta): Warp-synchronous SIMT
(lock-step in Warp):</p>
<ul>
<li><p>No data is saved/restored when switching to another Warp</p></li>
<li><p>Switching Warps = selecting a different Warp in the Warp scheduler</p></li>
<li><p>No pipeline flush</p>
<p>On an NVIDIA GPU, no pipeline flush occurs when a Warp stalls because
the Warp’s next instruction is <strong>never issued until its operands are
ready</strong> as illustrated in
<a class="reference internal" href="#l1-warp-sched"><span class="std std-ref">Warp scheduling in Level 1</span></a>.
The stalled Warp simply stops issuing instructions, and its
pipeline slot is taken by another ready Warp.
When the stall condition clears, the Warp re-enters the pipeline by
issuing the stalled instruction anew. No state is saved or restored.</p>
</li>
</ul>
<p>For Volta, Turing, Ampere, Hopper: Independent Thread Scheduling:</p>
<ul class="simple">
<li><p>No pipeline flush</p>
<ul>
<li><p>Stalled threads simply do not issue instructions.</p></li>
<li><p>Other threads in the same warp continue issuing independently.</p></li>
<li><p>No pipeline flush needed and No data is saved/restored because
instructions are tracked per thread, not per warp.</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</section>
<section id="simt-and-spmd-pipelines">
<h4><a class="toc-backref" href="#id342" role="doc-backlink">SIMT and SPMD Pipelines</a><a class="headerlink" href="#simt-and-spmd-pipelines" title="Link to this heading">¶</a></h4>
<p>This section illustrates the difference between SIMT and SPMD
pipelines using the same pipeline stages: Fetch (F), Decode (D),
Execute (E), Memory (M), and Writeback (W).</p>
<p>A GPU contains many SMs.
The execution model between SMs is MIMD (Multiple Instructions, Multiple Data)
when running different programs, or SPMD (Single Program, Multiple Data).
However, within a single SM, the execution model is SIMD/SIMT.”</p>
<p>Low-end GPUs implement SIMD in their pipelines, where all instructions are
executed in lockstep. High-end GPUs, however, approximate SPMD in their
pipelines, meaning that instructions are interleaved within the pipeline, as
shown below.</p>
<p><strong>SPMD Programming Model vs SIMD/SIMT Execution</strong></p>
<p>In the SISD of CPU, a thread is a single pipeline execution unit which can be
issued at any specific address.</p>
<p><strong>In a multi-core CPU running SPMD, each core can schedule and execute
instructions at any program counter (PC)</strong>. For example, core-1 may execute
I(1–10), while core-2 executes I(31–35).
<strong>For GPU, however, within an SM, it is not possible to schedule thread-1 to
execute I(1–10) while thread-2 executes I(31–35)</strong>.</p>
<p>As result,
<strong>there is no mainstream GPU that is truly hardware-SPMD</strong> (where each thread
has its own independent pipeline).
All modern GPUs (NVIDIA, AMD, Intel) implement SPMD as a programming model, but
under the hood they execute in SIMD lock-step groups (Warps or Wavefronts).
GPUs expose an <strong>SPMD programming model</strong> (each thread runs the same kernel on
different data). However, the hardware actually executes instructions in
<strong>SIMD/SIMT lock-step groups</strong>.</p>
<p class="rubric">An example to illustrate the difference between Pascal SIMT, Volta
SIMT and SPMD.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Divergent Kernel Example:
-------------------------
if (tid % 2 == 0) {         // even threads: long loop
  for (...) { loop_body } // many iterations
} else {                    // odd threads: short path
  C[tid] = A[tid] + B[tid];
}

Legend: F=Fetch, D=Decode, E=Execute, M=Memory, W=Writeback
        S=Stall/masked-off, &quot;...&quot; = loop continues


===================================================================
Pascal (lock-step SIMT with SIMT stack)
-------------------------------------------------------------------
Cycle →   0   1   2   3   4   5   6   7   8   9  10  11  12 ...
T0 even:  F   D   E   M   W   F   D   E   M   W   F   D  ...
T1 odd :  S   S   S   S   S   S   S   S   S   S   S   S  ...
          (Odd threads wait until even path completes, then:)
          ... F D E M W → done


===================================================================
Volta (SIMT with independent thread scheduling)
-------------------------------------------------------------------
Cycle →   0   1   2   3   4   5   6   7   8   9  10  11 ...
T0 even:  F   D   E   M   W   F   D   E   M   W   F   D  ...
T1 odd :      F   D   E   M   W   done
          (Odd thread issues its short path early,
           interleaved with even loop instructions)


===================================================================
True SPMD (CPU-like, fully independent threads)
-------------------------------------------------------------------
Cycle →   0   1   2   3   4   5   6   7   8   9 ...
T0 even:  F   D   E   M   W   F   D   E   M   W  ...
T1 odd :  F   D   E   M   W   done
          (Threads fetch/execute independently —
           odd thread finishes immediately)
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>SPMD and MIMD</strong></p>
<p>When run a single program across all cores, SPMD and MIMD pipelines look the
same.</p>
</div>
<p><a class="reference internal" href="#mapping-data-in-gpu"><span class="std std-ref">The subection Mapping data in GPU</span></a> includes more
details in Lanes masked.</p>
<p><strong>Scoreboard purpose:</strong></p>
<ul class="simple">
<li><p>GPU scoreboard = in-order issue, out-of-order completion</p></li>
<li><p>CPU reorder buffer (ROB) = out-of-order issue + completion, but retire in-order
- CPUs use a ROB to support out-of-order issue and retirement.</p></li>
</ul>
<p><strong>Comparsion of Volta and Pascal</strong></p>
<p>In a lock-step GPU without divergence support, the scoreboard entries include
only {Warp-ID, PC (Instruction Address), …}. With divergence support (as in
real-world GPUs), the scoreboard entries expand to {Warp-ID, PC, mask, …}.</p>
<p><strong>Volta (Cuda thread/SIMD Lane with PC, Program Couner and Call Stack)</strong></p>
<p><strong>GPU scoreboard = in-order issue, out-of-order completion</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>SIMT GPU before Volta = scoreboard contains: { Warp ID + PC + Active Mask }</p></li>
<li><p>Volta = scoreboard contains: { Warp ID + PC per thread (+ readiness per thread) }</p></li>
</ul>
</div></blockquote>
<p><strong>Example for mutex</strong> <a class="footnote-reference brackets" href="#volta" id="id123" role="doc-noteref"><span class="fn-bracket">[</span>103<span class="fn-bracket">]</span></a></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//</span>
<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">insert_after</span><span class="p">(</span><span class="n">Node</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">Node</span><span class="w"> </span><span class="o">*</span><span class="n">c</span><span class="p">;</span>
<span class="w">  </span><span class="n">lock</span><span class="p">(</span><span class="n">a</span><span class="p">);</span><span class="w"> </span><span class="n">lock</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="n">unlock</span><span class="p">(</span><span class="n">c</span><span class="p">);</span><span class="w"> </span><span class="n">unlock</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Assume that the mutex is contended across SMs but not within the same SM. On
average, each thread spends 10 cycles executing the insert_after operation
without resource contention, and 20 cycles when accounting for contention.
Therefore, the average total execution time for 32 threads in an SM is:</p>
<ul class="simple">
<li><p>Volta: 20 cycles</p></li>
<li><p>Pascal: 640 cycles (20 cycles × 32 threads, due to lack of independent
progress inside a Warp)</p></li>
</ul>
</section>
</section>
<section id="processor-units-and-memory-hierarchy-in-nvidia-gpu">
<span id="sec-mem-hierarchy"></span><h3><a class="toc-backref" href="#id343" role="doc-backlink">Processor Units and Memory Hierarchy in NVIDIA GPU <a class="footnote-reference brackets" href="#chatgpt-pumh" id="id124" role="doc-noteref"><span class="fn-bracket">[</span>82<span class="fn-bracket">]</span></a></a><a class="headerlink" href="#processor-units-and-memory-hierarchy-in-nvidia-gpu" title="Link to this heading">¶</a></h3>
<figure class="align-center" id="id256">
<span id="gpu-mem"></span><a class="reference internal image-reference" href="_images/memory.png"><img alt="_images/memory.png" height="380" src="_images/memory.png" width="407" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 111 </span><span class="caption-text">GPU memory (figure from book <a class="footnote-reference brackets" href="#quantitative-gpu-mem" id="id125" role="doc-noteref"><span class="fn-bracket">[</span>83<span class="fn-bracket">]</span></a>).</span><a class="headerlink" href="#id256" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-default" id="id257">
<span id="mem-hierarchy"></span><div class="graphviz"><img src="_images/graphviz-5ce62e2d24d290889b7c0e7f71d9f21cfb84e1f3.png" alt="digraph GPU_Memory_Hierarchy {
    rankdir=TB;
    node [shape=box, style=rounded, fontname=&quot;Helvetica&quot;];

    // Processing hierarchy
    GigaThread [label=&quot;GigaThread Engine\n(Chip-wide Scheduler)&quot;];
    GPC [label=&quot;GPC\n(Graphics Processing Cluster)&quot;];
    TPC [label=&quot;TPC\n(Texture Processing Cluster)&quot;];
    SM [label=&quot;SM\n(Streaming Multiprocessor)&quot;];
    Core [label=&quot;CUDA Cores&quot;];

    // Memory hierarchy
    Global [label=&quot;Global Memory (HBM/GDDR)\nGPU-wide, slowest&quot;];
    L2 [label=&quot;L2 Cache\nGPU-wide&quot;];
    L1 [label=&quot;L1 Cache\nPer-SM, unified with Shared&quot;];
    Uniform [label=&quot;Uniform / Constant Cache\nPer-SM, Read-only,\nFor Uniform Parameters&quot;];
    Shared [label=&quot;Shared Memory\nPer-SM, Block-visible&quot;];
    Local [label=&quot;Local Memory\nPer-thread, in DRAM&quot;];
    Reg [label=&quot;Registers\nPer-thread, fastest&quot;];

    // Hierarchy connections
    GigaThread -&gt; GPC -&gt; TPC -&gt; SM -&gt; Core;

    // Memory hierarchy connections
    Global -&gt; L2;
    L2 -&gt; L1;
    L2 -&gt; Uniform;

    L1 -&gt; Core;
    Uniform -&gt; Core;

    Shared -&gt; SM;
    Reg -&gt; Core;
    Local -&gt; Core;

    // Styling groups
    subgraph cluster_gpu {
        label=&quot;GPU Processing Units&quot;;
        style=dashed;
        GigaThread; GPC; TPC; SM; Core;
    }

    subgraph cluster_mem {
        label=&quot;Memory Hierarchy&quot;;
        style=dashed;
        Global; L2; L1; Uniform, Shared; Local; Reg;
    }
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 112 </span><span class="caption-text">Processor Units and Memory Hierarchy in NVIDIA GPU
<strong>Local Memory is shared by all threads and Cached in L1 and L2.</strong>
In addition, the <strong>Shared Memory is provided to use per-SM, not
cacheable</strong>.</span><a class="headerlink" href="#id257" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Illustrate L1, L2 and Global Memory used by SM and whole chip of GPU as
<a class="reference internal" href="#l1-l2"><span class="std std-numref">Fig. 113</span></a>.</p>
<figure class="align-center" id="id258">
<span id="l1-l2"></span><a class="reference internal image-reference" href="_images/l1-l2.png"><img alt="_images/l1-l2.png" height="362" src="_images/l1-l2.png" width="632" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 113 </span><span class="caption-text"><strong>L1 Cache: Per-SM, Coherent across all 16 Lanes in the same SM.</strong>
L2 Cache: Coherent across all SMs and GPCs.
Global Memory (DRAM: HBM/GDDR). Both HBM and GDDR are DRAM.
GDDR (Graphics DDR) – optimized for GPUs (GDDR5, GDDR6, GDDR6X).
HBM (High Bandwidth Memory) – 3D-stacked DRAM connected via TSVs
(Through-Silicon Vias) for extremely high bandwidth and wide buses
<a class="footnote-reference brackets" href="#mapping-blocks-to-sm" id="id126" role="doc-noteref"><span class="fn-bracket">[</span>76<span class="fn-bracket">]</span></a>.</span><a class="headerlink" href="#id258" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The <a class="reference internal" href="#mem-hierarchy"><span class="std std-numref">Fig. 112</span></a> <strong>illustrates the memory hierarchy in NVIDIA GPU</strong>.
The Cache flow for 3D Model Information, Animation Parameters, and GLSL Variables
is as follows:</p>
<dl class="simple">
<dt>3D Model Information:</dt><dd><ul class="simple">
<li><p>VBO/IBO → Global → L2 → L1 → Registers</p></li>
<li><p>Material constants → Uniform Cache → Registers</p></li>
</ul>
</dd>
<dt>Animation Parameters:</dt><dd><ul class="simple">
<li><p>Bone matrices → Uniform Cache → Registers</p></li>
<li><p>Morph targets → Global → L2 → L1 → Registers</p></li>
<li><p>Shared bone data (compute) → Shared Memory</p></li>
</ul>
</dd>
<dt>GLSL Variables:</dt><dd><ul class="simple">
<li><p>uniform → Uniform Cache</p></li>
<li><p>in (vertex attributes) → Global → L2 → L1</p></li>
<li><p>out (varyings) → Registers → Interpolators</p></li>
<li><p>buffer (SSBO) → Global → L2 → L1</p></li>
<li><p>shared → Shared Memory</p></li>
<li><p>local arrays → Registers or Local Memory</p></li>
</ul>
</dd>
</dl>
<p>More details of the NVIDIA GPU memory hierarchy are described as follows:</p>
<ul class="simple">
<li><p><strong>Registers</strong></p>
<ul>
<li><p>Per-thread, fastest memory, located in CUDA cores, as illustrated also in
<a class="reference internal" href="#sm-left"><span class="std std-numref">Fig. 107</span></a>.</p></li>
<li><p><a class="reference internal" href="#cfg-warps"><span class="std std-ref">Configurable maximum resident warps and
allocated registers per thread</span></a> following
<a class="reference internal" href="#sm-left"><span class="std std-numref">Fig. 107</span></a>.</p></li>
<li><p>Latency: ~1 cycle.</p></li>
</ul>
</li>
<li><p><strong>Uniform / Constant cache</strong></p>
<ul>
<li><p>Stored constant variables in OpenGL and OpenCL/CUDA, as illustrated in
<a class="reference internal" href="#sm-left"><span class="std std-numref">Fig. 107</span></a>.</p></li>
</ul>
</li>
<li><p><strong>Local Memory</strong></p>
<ul>
<li><p>Per-thread, stored in global DRAM.</p></li>
<li><p>Cached in L1 and L2.</p></li>
<li><p>Latency: high, depends on cache hit/miss.</p></li>
</ul>
</li>
<li><p><strong>Shared Memory</strong></p>
<ul>
<li><p><strong>Per-SM, shared across threads in a Thread Block as shown in</strong>
<a class="reference internal" href="#sm-left"><span class="std std-numref">Fig. 107</span></a>.</p></li>
<li><p><strong>On-chip, programmer-controlled.</strong></p></li>
<li><p>Latency: ~20 cycles.</p></li>
</ul>
</li>
<li><p><strong>L1 Cache</strong></p>
<ul>
<li><p>Per-SM, unified with shared memory.</p></li>
<li><p>Hardware-managed.</p></li>
<li><p>Latency: ~20 cycles.</p></li>
</ul>
</li>
<li><p><strong>L2 Cache</strong></p>
<ul>
<li><p>Shared across the entire GPU chip.</p></li>
<li><p><strong>Coherent across all SMs and GPCs as shown in</strong> <a class="reference internal" href="#l1-l2"><span class="std std-numref">Fig. 113</span></a>.</p></li>
</ul>
</li>
<li><p><strong>Global Memory (DRAM: HBM/GDDR)</strong></p>
<ul>
<li><p>Visible to all SMs across all GPCs.</p></li>
<li><p>Highest latency (~400–800 cycles).</p></li>
</ul>
</li>
</ul>
<p><strong>GPU Hierarchy Context</strong></p>
<ul class="simple">
<li><p><strong>GigaThread Engine (chip-wide scheduler)</strong></p>
<ul>
<li><p>Contains multiple GPCs.</p>
<ul>
<li><p>Fermi (2010): up to 4 GPCs per chip.</p></li>
<li><p>Pascal GP100 (Tesla P100): 6 GPCs.</p></li>
<li><p>Volta GV100 (Tesla V100): 6 GPCs.</p></li>
</ul>
</li>
<li><p>Distributes Thread Blocks to all GPCs.</p></li>
</ul>
</li>
<li><p><strong>GPC (Graphics Processing Cluster)</strong></p>
<ul>
<li><p>Contains multiple TPCs.</p></li>
</ul>
</li>
<li><p><strong>TPC (Texture Processing Cluster)</strong></p>
<ul>
<li><p>Groups 1–2 SMs.</p></li>
</ul>
</li>
<li><p><strong>SM (Streaming Multiprocessor)</strong></p>
<ul>
<li><p>Contains CUDA cores, registers, shared memory, L1 cache.</p></li>
</ul>
</li>
<li><p><strong>CUDA Cores</strong></p>
<ul>
<li><p>Execute threads with registers and access the memory hierarchy.</p></li>
</ul>
</li>
</ul>
<figure class="align-center" id="id259">
<span id="gpu-terms"></span><a class="reference internal image-reference" href="_images/gpu-terms.png"><img alt="_images/gpu-terms.png" height="721" src="_images/gpu-terms.png" width="621" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 114 </span><span class="caption-text">Terms in Nvidia’s gpu (figure from book <a class="footnote-reference brackets" href="#quantitative-gpu-terms" id="id127" role="doc-noteref"><span class="fn-bracket">[</span>92<span class="fn-bracket">]</span></a>)</span><a class="headerlink" href="#id259" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-default" id="id260">
<span id="warp-sched-pipeline"></span><div class="graphviz"><img src="_images/graphviz-cc2f17258f647668997d9703e4ad9c88e4df68ce.png" alt="digraph WarpSchedulerPipeline {
    rankdir=TB;
    node [shape=box, style=filled, fillcolor=lightgray];

    WarpScheduler -&gt; InstructionIssue;
    InstructionIssue -&gt; Lane0;
    InstructionIssue -&gt; Lane1;
    InstructionIssue -&gt; Lane2;
    InstructionIssue -&gt; Lane3;
    InstructionIssue -&gt; Lane4;
    InstructionIssue -&gt; Lane5;
    InstructionIssue -&gt; Placeholder;
    InstructionIssue -&gt; Lane30;
    InstructionIssue -&gt; Lane31;

    Lane0 [label=&quot;Lane 0\n(Chime A / Chime B)&quot;, fillcolor=lightyellow];
    Lane1 [label=&quot;Lane 1\n(Chime A / Chime B)&quot;, fillcolor=lightyellow];
    Lane2 [label=&quot;Lane 2\n(Chime A / Chime B)&quot;, fillcolor=lightyellow];
    Lane3 [label=&quot;Lane 3\n(Chime A / Chime B)&quot;, fillcolor=lightyellow];
    Lane4 [label=&quot;Lane 4\n(Chime A / Chime B)&quot;, fillcolor=lightyellow];
    Lane5 [label=&quot;Lane 5\n(Chime A / Chime B)&quot;, fillcolor=lightyellow];
    Placeholder [label=&quot;………………&quot;, shape=plaintext, fillcolor=white];
    Lane30 [label=&quot;Lane 30\n(Chime A / Chime B)&quot;, fillcolor=lightyellow];
    Lane31 [label=&quot;Lane 31\n(Chime A / Chime B)&quot;, fillcolor=lightyellow];
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 115 </span><span class="caption-text">In <strong>dual-issue mode</strong>, Chime A carries floating-point data while Chime
B carries integer data—both issued by the same CUDA thread.
In contrast, under <strong>time-sliced execution</strong>, Chime A and Chime B carry
either floating-point or integer data independently, and are
assigned to separate CUDA threads.</span><a class="headerlink" href="#id260" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<ul class="simple">
<li><p>A Warp of 32 threads is mapped across 16 Lanes. If each Lane has 2 Chimes,
it may support dual-issue or time-sliced execution as
<a class="reference internal" href="#warp-sched-pipeline"><span class="std std-numref">Fig. 115</span></a>.</p></li>
</ul>
<p>In the following matrix multiplication code, the 8096 elements of matrix
A = B × C are mapped to Thread Blocks, SIMD Threads, Lanes, and Chimes as
illustrated in the <a class="reference internal" href="#grid"><span class="std std-numref">Fig. 116</span></a>. In this example, it run on
<strong>time-sliced execution</strong>.</p>
<div class="literal-block-wrapper docutils container" id="id261">
<span id="matmul-cuda"></span><div class="code-block-caption"><span class="caption-number">Listing 2 </span><span class="caption-text">MATMUL CUDA Example</span><a class="headerlink" href="#id261" title="Link to this code">¶</a></div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Invoke MATMUL with 256 threads per Thread Block</span>
<span class="n">__host__</span>
<span class="kt">int</span><span class="w"> </span><span class="n">nblocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">255</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">512</span><span class="p">;</span>
<span class="n">matmul</span><span class="o">&lt;&lt;&lt;</span><span class="n">nblocks</span><span class="p">,</span><span class="w"> </span><span class="mi">255</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">);</span>
<span class="c1">// MATMUL in CUDA</span>
<span class="n">__device__</span>
<span class="kt">void</span><span class="w"> </span><span class="n">matmul</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">C</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="o">*</span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<figure class="align-center" id="id262">
<span id="grid"></span><a class="reference internal image-reference" href="_images/grid.png"><img alt="_images/grid.png" height="694" src="_images/grid.png" width="558" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 116 </span><span class="caption-text">Mapping 8192 elements of matrix multiplication for Nvidia’s GPU
(figure from <a class="footnote-reference brackets" href="#quantitative-grid" id="id128" role="doc-noteref"><span class="fn-bracket">[</span>75<span class="fn-bracket">]</span></a>).
SIMT: 16 SIMD threads in one Thread Block.</span><a class="headerlink" href="#id262" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Explain the mapping and execution in <a class="reference internal" href="#grid"><span class="std std-numref">Fig. 116</span></a> for <a class="reference internal" href="#matmul-cuda"><span class="std std-ref">MATMUL CUDA Example</span></a> using the terminology from
<a class="reference internal" href="#gpu-terms"><span class="std std-numref">Fig. 114</span></a> and the previous sections of this book, presented in the
table below.</p>
<table class="docutils align-default" id="id263">
<caption><span class="caption-number">Table 54 </span><span class="caption-text">Summary terms for GPU.</span><a class="headerlink" href="#id263" title="Link to this table">¶</a></caption>
<colgroup>
<col style="width: 13.3%" />
<col style="width: 20.0%" />
<col style="width: 66.7%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Terms</p></th>
<th class="head"><p>Structure</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Grid, Giga Thread Engine</p></td>
<td><p>Each loop (Grid) consists of multiple Thread Blocks.</p></td>
<td><p>Grid is Vectorizable Loop as <a class="reference internal" href="#gpu-terms"><span class="std std-numref">Fig. 114</span></a>.
The hardware scheduler Guda Thread Engine schedules the Thread Blocks to
SMs.</p></td>
</tr>
<tr class="row-odd"><td><p>Thread Block</p></td>
<td><p>In this example, each Grid has 16 Giga Thread <a class="footnote-reference brackets" href="#quantitative-gpu-threadblock" id="id129" role="doc-noteref"><span class="fn-bracket">[</span>95<span class="fn-bracket">]</span></a>.</p></td>
<td><p>Each Thread Block is assigned 512 elements of the vectors to
work on.
As <a class="reference internal" href="#grid"><span class="std std-numref">Fig. 116</span></a>, it assigns 16 Thread Block to 16 SMs.
Giga Thread is the name of the scheduler that distributes Thread Blocks
to Multiprocessors, each of which has its own SIMD Thread Scheduler
<a class="footnote-reference brackets" href="#quantitative-gpu-threadblock" id="id130" role="doc-noteref"><span class="fn-bracket">[</span>95<span class="fn-bracket">]</span></a>.
More than one Block can be mapped to a same SM as the explanation in
“Level 1: Thread Block Scheduler” for <a class="reference internal" href="#threadblocks-map"><span class="std std-numref">Fig. 110</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p>Streaming Multiprocessor, <strong>SM</strong>, GPU Core (Warp) <a class="footnote-reference brackets" href="#gpu-core" id="id131" role="doc-noteref"><span class="fn-bracket">[</span>101<span class="fn-bracket">]</span></a></p></td>
<td><p>Each SIMD Processor has 16 SIMD Threads.</p></td>
<td><p>Each SIMD processor includes local memory, as in <a class="reference internal" href="#gpu-mem"><span class="std std-numref">Fig. 111</span></a>. Local
memory is shared among SIMD Lanes within a SIMD processor but not across
different SIMD processors. A Warp has its own PC and may correspond to a
whole function or part of a function. Compiler and runtime may assign
functions to the same or different Warps <a class="footnote-reference brackets" href="#quantitative-gpu-warp" id="id132" role="doc-noteref"><span class="fn-bracket">[</span>102<span class="fn-bracket">]</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p>Cuda core</p></td>
<td><p>Fermi has 32 Cuda cores in a SM as <a class="reference internal" href="#sm-right"><span class="std std-numref">Fig. 108</span></a>.</p></td>
<td><p>A CUDA core is the scalar execution unit inside an SM.
It is capable of executing one integer or floating-point instruction from
one Lane of a Warp.
The CUDA core is analogous to an ALU pipeline stage in a CPU.</p></td>
</tr>
<tr class="row-even"><td><p>Cuda Thread</p></td>
<td><p>Each SM can configure to have different number of resident threads.</p></td>
<td><p>Fermi can configure Max resident threads = 32768/32 = 1024 for 32
registers/per thread in a SM as memtioned eariler.
A CUDA thread is the basic unit of execution defined in CUDA’s programming
model.
Each thread executes the kernel code independently with its own registers,
program counter (PC), and per-thread local memory.
Each Thread has its TLR
(Thread Level Registers) allocated from Register file (32768 x
32-bit) by SIMD Processor (SM) as <a class="reference internal" href="#sm-left"><span class="std std-numref">Fig. 107</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p>SIMD Lane</p></td>
<td><p>Each SIMD Thread has 32 Lanes.</p></td>
<td><p>A vertical cut of a thread of SIMD instructions corresponding to
one element executed by one SIMD Lane. It is a vector instruction with
processing 32-elements.
A Warp of 32 threads is mapped across 32 Lanes.
Lane = per-thread execution slot inside a Warp.
If each Lane has 2 Chimes, it may support dual-issue or time-sliced
execution as <a class="reference internal" href="#warp-sched-pipeline"><span class="std std-numref">Fig. 115</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p>Chime</p></td>
<td><p>Each Lane has 2 Chimes.</p></td>
<td><p>A Chime represents one “attempt” or opportunity for issuing instructions
from Warps.
In Fermi (SM2.x): Each SM has 2 Warp schedulers. Each Warp scheduler has 2
dispatch units (dual-issue, but with constraints, it can issue “float +
load/store” for “fadd and load C[i]” in this example).</p></td>
</tr>
</tbody>
</table>
<p>References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://developer.nvidia.com/blog/nvidia-ampere-architecture-in-depth/">NVIDIA GPU Architecture Overview</a></p></li>
<li><p><a class="reference external" href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#Warps">Understanding Warps and Threads</a></p></li>
</ul>
</section>
<section id="memory-subsystem">
<h3><a class="toc-backref" href="#id344" role="doc-backlink">Memory Subsystem</a><a class="headerlink" href="#memory-subsystem" title="Link to this heading">¶</a></h3>
<section id="address-coalescing-and-gather-scatter">
<h4><a class="toc-backref" href="#id345" role="doc-backlink">Address Coalescing and Gather-scatter</a><a class="headerlink" href="#address-coalescing-and-gather-scatter" title="Link to this heading">¶</a></h4>
<p>Brief description is shown in <a class="reference internal" href="#coalescing-gather"><span class="std std-numref">Fig. 117</span></a>.</p>
<figure class="align-default" id="id264">
<span id="coalescing-gather"></span><div class="graphviz"><img src="_images/graphviz-a9d0800a94d34796e0dcd9d6ad5e1d283861694c.png" alt="digraph GPU_Memory {
    rankdir=LR;
    node [shape=box, style=rounded, fontsize=12];

    subgraph cluster_gather {
        label=&quot;Gather-Scatter (Sparse Matrix Access): \nIndirect index of LD/ST&quot;;
        color=green;

        Idx [label=&quot;Index Array A[]:\nA[0]=200\nA[1]=400\nA[2]=1200\nA[3]=320&quot;, shape=note, style=filled, fillcolor=lightyellow];

        G1 [label=&quot;Thread 1\nMem[A[0]]&quot;];
        G2 [label=&quot;Thread 2\nMem[A[1]]&quot;];
        G3 [label=&quot;Thread 3\nMem[A[2]]&quot;];
        G4 [label=&quot;Thread 4\nMem[A[3]]&quot;];

        Idx -&gt; G1;
        Idx -&gt; G2;
        Idx -&gt; G3;
        Idx -&gt; G4;
    }

    subgraph cluster_coalescing {
        label=&quot;Address Coalescing: \nMerge memory transcations into a contiguous memory access&quot;;
        color=blue;

        T1 [label=&quot;Thread 1\nAddr 100&quot;];
        T2 [label=&quot;Thread 2\nAddr 104&quot;];
        T3 [label=&quot;Thread 3\nAddr 108&quot;];
        T4 [label=&quot;Thread 4\nAddr 112&quot;];

        MT [label=&quot;Merged Transaction&quot;, shape=ellipse, style=filled, fillcolor=lightblue];

        T1 -&gt; MT;
        T2 -&gt; MT;
        T3 -&gt; MT;
        T4 -&gt; MT;

        T5 [label=&quot;Addr[100..112]&quot;, shape=ellipse, style=filled, fillcolor=lightblue];

        MT -&gt; T5;
    }
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 117 </span><span class="caption-text">Coalescing and Gather-scatter</span><a class="headerlink" href="#id264" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The Load/Store Units (LD/ST) is important because memory latency is huge
compared to ALU ops.
Some GPUs provide Address Coalescing and gather-scatter to accelerate memory
access.</p>
<ul class="simple">
<li><p>Address Coalescing: <strong>Memory coalescing is the process of merging memory
requests from threads in a Warp (NVIDIA: 32 threads, AMD: 64 threads) into as
few memory transactions as possible.</strong></p>
<ul>
<li><p>Cache miss (global memory/DRAM): Coalescing = big performance improvement.</p></li>
<li><p>Cache hit (L1/L2): Coalescing = smaller benefit, since cache line fetch
already amortizes cost.</p></li>
<li><p>Note that unlike vector architectures, GPUs don’t have separate instructions
for sequential data transfers, strided data transfers, and gather-scatter
data transfers. All data transfers are gather-scatter! To regain the
efficiency of sequential (unit-stride) data transfers, GPUs include special
Address Coalescing hardware to recognize when the SIMD Lanes within a thread
of SIMD instructions are collectively issuing sequential addresses. That
runtime hardware then notifies the Memory Interface Unit to request a block
transfer of 32 sequential words. To get this important performance
improvement, the GPU programmer must ensure that adjacent CUDA Threads access
nearby addresses at the same time that can be coalesced into one or a
few memory or cache blocks, which our example does <a class="footnote-reference brackets" href="#quantitative-gpu-ac" id="id133" role="doc-noteref"><span class="fn-bracket">[</span>99<span class="fn-bracket">]</span></a>.</p></li>
</ul>
</li>
<li><p>Gather-scatter data transfer: <strong>HW support sparse vector access is called
gather-scatter.</strong> The VMIPS instructions are LVI (load vector indexed or gather)
and SVI (store vector indexed or scatter) <a class="footnote-reference brackets" href="#quantitative-gpu-gs" id="id134" role="doc-noteref"><span class="fn-bracket">[</span>98<span class="fn-bracket">]</span></a>.</p></li>
</ul>
<p><strong>1. Address Coalescing in GPU Memory Transactions</strong></p>
<p><strong>Definition:</strong>
Memory coalescing is the process of merging memory requests from threads
in a Warp (NVIDIA: 32 threads, AMD: 64 threads) into as few memory
transactions as possible.</p>
<p><strong>How It Works:</strong></p>
<ul class="simple">
<li><p>If threads access <strong>contiguous and aligned addresses</strong>, the hardware
combines them into a single memory transaction.</p></li>
<li><p>If threads access <strong>strided or random addresses</strong>, the GPU must issue
multiple transactions, wasting bandwidth.</p></li>
</ul>
<p><strong>Examples:</strong></p>
<ul>
<li><p><em>Coalesced (efficient):</em></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Each thread accesses consecutive elements</span>
<span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">threadId</span><span class="p">];</span>
</pre></div>
</div>
<p>→ One transaction for 32 threads.</p>
</li>
<li><p><em>Non-coalesced (inefficient):</em></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Each thread accesses strided elements</span>
<span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">threadId</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">100</span><span class="p">];</span>
</pre></div>
</div>
<p>→ Many transactions required due to striding.</p>
</li>
</ul>
<p><strong>2. Gather–Scatter in Sparse Matrix Access</strong></p>
<p><strong>Definition:</strong>
Gather–scatter refers to memory operations where each GPU thread in a Warp
loads from or stores to irregular memory addresses. This is common in sparse
matrix operations, where non-zero elements are stored in compressed formats.</p>
<p><strong>Sparse Matrix Example (CSR format):</strong></p>
<ul>
<li><p><em>CSR (Compressed Sparse Row)</em> stores three arrays:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">values[]</span></code>: non-zero entries of the matrix</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">colIndex[]</span></code>: column indices for each non-zero</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rowPtr[]</span></code>: index into <code class="docutils literal notranslate"><span class="pre">values[]</span></code> for each row</p></li>
</ul>
</li>
<li><p>Sparse matrix-vector multiplication (SpMV):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">matrix</span><span class="o">:</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rowPtr</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">rowPtr</span><span class="p">[</span><span class="n">row</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">:</span>
<span class="w">        </span><span class="n">col</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">colIndex</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span><span class="w">      </span><span class="c1">// gather index</span>
<span class="w">        </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">values</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span><span class="w">        </span><span class="c1">// gather nonzero</span>
<span class="w">        </span><span class="n">y</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">col</span><span class="p">];</span><span class="w">   </span><span class="c1">// scatter result</span>
</pre></div>
</div>
</li>
</ul>
<p><strong>Characteristics:</strong></p>
<ul class="simple">
<li><p><strong>Gather:</strong> Each thread loads from potentially scattered locations
(<code class="docutils literal notranslate"><span class="pre">values[idx]</span></code> or <code class="docutils literal notranslate"><span class="pre">x[col]</span></code>).</p></li>
<li><p><strong>Scatter:</strong> Results may be written back to irregular output locations
(<code class="docutils literal notranslate"><span class="pre">y[row]</span></code>).</p></li>
<li><p><strong>Challenge: These accesses often break memory coalescing, leading to
multiple memory transactions. An example is shown as follows:</strong></p></li>
</ul>
<p><strong>Summary:</strong></p>
<ul class="simple">
<li><p>Gather–scatter is fundamental for sparse matrix access but typically
results in non-coalesced memory patterns.</p></li>
<li><p>Address coalescing is critical for high GPU throughput; restructuring
data to improve coalescing often provides significant performance gains.</p></li>
</ul>
</section>
<section id="vram-dgpu">
<h4><a class="toc-backref" href="#id346" role="doc-backlink">VRAM dGPU</a><a class="headerlink" href="#vram-dgpu" title="Link to this heading">¶</a></h4>
<figure class="align-default" id="id265">
<span id="mem"></span><div class="graphviz"><img src="_images/graphviz-328629f7399688d6d95bdb0681815ab51799ec25.png" alt="digraph gpu_memory {
  rankdir=LR;
  node [shape=box style=rounded fontsize=10];

  subgraph cluster_shared {
    label = &quot;Shared Memory (Integrated GPU)&quot;;
    CPU [label=&quot;CPU\n(Caches, DMA)&quot;];
    GPU [label=&quot;iGPU\n(DMA Engine)&quot;];
    MC [label=&quot;Shared\nMemory Controller&quot;];
    DRAM [label=&quot;System RAM\n(DDR/LPDDR)&quot;];

    CPU -&gt; MC -&gt; DRAM;
    GPU -&gt; MC;
    GPU -&gt; DRAM [style=dashed, label=&quot;DMA&quot;];
  }

  subgraph cluster_dedicated {
    label = &quot;Dedicated Memory (Discrete GPU)&quot;;
    CPU2 [label=&quot;CPU\n(Caches)&quot;];
    SYS_RAM [label=&quot;System RAM&quot;];
    GPU2 [label=&quot;dGPU\n(Caches, DMA)&quot;];
    VRAM [label=&quot;VRAM\n(GDDR/HBM)&quot;];

    CPU2 -&gt; SYS_RAM;
    GPU2 -&gt; VRAM;
  }

  edge [style=invis];
  DRAM -&gt; CPU2;
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 118 </span><span class="caption-text">iGPU versus dGPU</span><a class="headerlink" href="#id265" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p><strong>Reason:</strong></p>
<p><strong>1. Since CPU and GPU have different requirements, a shared memory design cannot
match the performance of dedicated GPU memory.</strong></p>
<p><strong>2. In systems with shared memory (like integrated GPUs), both the CPU and GPU
access the same physical memory (DRAM). This leads to several forms of
contention:</strong></p>
<blockquote>
<div><ul class="simple">
<li><ol class="loweralpha simple">
<li><p>Cache Coherency Overhead</p></li>
</ol>
</li>
<li><ol class="loweralpha simple" start="2">
<li><p>DMA Contention</p></li>
</ol>
</li>
<li><ol class="loweralpha simple" start="3">
<li><p>Bus &amp; Memory Controller Bottleneck</p></li>
</ol>
</li>
</ul>
</div></blockquote>
<p><strong>Advantages:</strong></p>
<p>A discrete GPU has its own dedicated memory (VRAM) while an integrated GPU (iGPU)
shares memory with the CPU as shown in <a class="reference internal" href="#mem"><span class="std std-numref">Fig. 118</span></a>.</p>
<p>Dedicated GPU memory (VRAM) outperforms shared CPU-GPU memory due to
higher bandwidth, lower latency, parallel access optimization, and no
contention with CPU resources.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Feature</p></th>
<th class="head"><p>Shared Memory (CPU + iGPU)</p></th>
<th class="head"><p>Dedicated GPU Memory (dGPU)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Bandwidth</p></td>
<td><p>Lower (DDR/LPDDR)</p></td>
<td><p>Higher (GDDR/HBM)</p></td>
</tr>
<tr class="row-odd"><td><p>Latency</p></td>
<td><p>Higher</p></td>
<td><p>Lower</p></td>
</tr>
<tr class="row-even"><td><p>Parallel Access</p></td>
<td><p>Limited</p></td>
<td><p>Optimized for many threads</p></td>
</tr>
<tr class="row-odd"><td><p>Cache Coherency</p></td>
<td><p>Required (with CPU)</p></td>
<td><p>Not required</p></td>
</tr>
<tr class="row-even"><td><p>DMA Bandwidth</p></td>
<td><p>Shared with CPU</p></td>
<td><p>GPU has exclusive DMA access</p></td>
</tr>
<tr class="row-odd"><td><p>Memory Contention</p></td>
<td><p>Yes</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-even"><td><p>Performance</p></td>
<td><p>Lower:
Bandwidth bottlenecks,
CPU-GPU interference and
Cache/DMA conflicts</p></td>
<td><p>Higher:
Wide memory bandwidth,
Parallel thread access and
Low latency memory access</p></td>
</tr>
</tbody>
</table>
<p>Dedicated memory allows the GPU to run high-throughput workloads without
interference from the CPU. It provides <strong>(1). wide bandwidth, (2). optimized
parallel access, and (3). low-latency paths</strong>, avoiding cache and DMA
conflicts for superior performance.**</p>
<p><strong>(1). Wide bandwidth:</strong> Dedicated GPU memory (VRAM) is often based on GDDR6,
GDDR6X, or HBM2/3, which are much faster than standard system RAM (DDR4/DDR5).</p>
<blockquote>
<div><p>Typical bandwidths:</p>
<blockquote>
<div><ul class="simple">
<li><p>GDDR6: ~448–768 GB/s</p></li>
<li><p>HBM2: up to 1 TB/s+</p></li>
<li><p>DDR5 (shared memory): ~50–80 GB/s</p></li>
</ul>
</div></blockquote>
<p>Impact: Faster access to textures, vertex buffers, and framebuffers—critical for rendering and compute tasks.</p>
</div></blockquote>
<p><strong>(2). Optimized parallel access:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>VRAM is optimized for the massively parallel architecture of GPUs.</p></li>
<li><p>It allows thousands of threads to access memory simultaneously without stalling.</p></li>
</ul>
<p>Shared system memory is optimized for CPU access patterns, not thousands of GPU threads.</p>
</div></blockquote>
<p><strong>(3). Low-latency paths:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>Dedicated memory is physically closer to the GPU die.</p></li>
<li><p>No need to traverse the PCIe bus like discrete GPUs accessing system RAM.</p></li>
</ul>
<p>In shared memory systems (like integrated GPUs), memory access may have to go through a memory controller shared with the CPU, adding delay.</p>
</div></blockquote>
</section>
<section id="regless-style-architectures">
<h4><a class="toc-backref" href="#id347" role="doc-backlink">RegLess-style architectures <a class="footnote-reference brackets" href="#reg-less" id="id135" role="doc-noteref"><span class="fn-bracket">[</span>47<span class="fn-bracket">]</span></a></a><a class="headerlink" href="#regless-style-architectures" title="Link to this heading">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>RegLess remains a research concept, not (as far as public evidence shows) a
commercial design in shipping GPUs.</strong></p>
</div>
<p><strong>Difference:</strong> Add <strong>Staging Buffer</strong> between Register Files and Execution Unit.</p>
<p>This section outlines the transition from traditional GPU operand coherence
using a monolithic register file and L1 data cache, to a RegLess-style
architecture that employs operand staging and register file-local coherence.</p>
<p>✅ Operand Delivery in Traditional GPU: <a class="reference internal" href="#no-regless"><span class="std std-numref">Fig. 119</span></a>:</p>
<figure class="align-default" id="id266">
<span id="no-regless"></span><div class="graphviz"><img src="_images/graphviz-0d852fae840859fab4ab7f9eaf50d587dff69295.png" alt="digraph TraditionalOperandDelivery {
     rankdir=LR;       
     node [shape=box, style=filled, fontname=&quot;Helvetica&quot;, fontsize=10];

     subgraph cluster_memory {
       label=&quot;Memory Hierarchy&quot;;                     
       style=filled;
       color=lightgray;
       GMEM [label=&quot;Global Memory&quot;];
       L1 [label=&quot;L1 Cache&quot;, fillcolor=lightyellow]; 
     }

     subgraph cluster_registers {
       label=&quot;Register File&quot;;                        
       style=filled;
       color=lightblue;
       RF [label=&quot;Register File&quot;]; 
     }                 

     subgraph cluster_execution {
       label=&quot;Execution Pipeline&quot;;
       style=filled;
       color=lightgreen;
       EU [label=&quot;Execution Unit&quot;];
     }

     GMEM -&gt; L1 [label=&quot;Coherence (Hardware-managed)&quot;, color=blue];
     L1 -&gt; RF [label=&quot;LD/ST (Compiler-controlled)&quot;, style=dashed];
     RF -&gt; EU [label=&quot;Operands&quot;];
     L1 -&gt; EU [label=&quot;Cached Data (optional)&quot;, style=dashed];
   }" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 119 </span><span class="caption-text"><strong>Operand Delivery in Traditional GPU
(Traditional Model: Register File + L1 Cache)</strong></span><a class="headerlink" href="#id266" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<dl class="simple">
<dt><strong>Architecture</strong>:</dt><dd><ul class="simple">
<li><p>Large monolithic register file per SM (e.g., 256KB, Maxwell, Pascal, Volta
and Ampere have 64K x 32-bit register file per SM, see
<a class="reference internal" href="#cfg-warps"><span class="std std-ref">Configurable maximum resident warps and allocated registers per
thread</span></a>)</p></li>
<li><p>Coherent with L1 data cache via write-through or write-back policies</p></li>
</ul>
</dd>
<dt><strong>Challenges</strong>:</dt><dd><ul class="simple">
<li><p>High energy cost due to cache coherence traffic</p></li>
<li><p>Complex invalidation and synchronization logic</p></li>
<li><p>Register pressure limits Warp occupancy (limit the number of ative Warps)</p></li>
<li><p>Redundant operand tracking across register file and cache</p></li>
</ul>
</dd>
</dl>
<p><strong>Example</strong>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v1</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="n">v2</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="n">v3</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>
<span class="n">v4</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">v3</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
<span class="n">v5</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">v4</span><span class="p">,</span> <span class="n">color</span><span class="p">)</span>

<span class="c1"># All operands reside in register file and may be cached in L1</span>
</pre></div>
</div>
<p>✅ Operand Delivery in RegLess GPU (with L1 Cache in LD Path): <a class="reference internal" href="#regless"><span class="std std-numref">Fig. 120</span></a>:</p>
<figure class="align-default" id="id267">
<span id="regless"></span><div class="graphviz"><img src="_images/graphviz-579c89897fc8057adcc00f3a7679c101c035d00f.png" alt="digraph RegLessOperandDeliveryWithL1 {
     rankdir=LR;
     node [shape=box, style=filled, fontname=&quot;Helvetica&quot;, fontsize=10];

     subgraph cluster_memory {
       label=&quot;Memory Hierarchy&quot;;
       style=filled;
       color=lightgray;
       GMEM [label=&quot;Global Memory&quot;];
       L1 [label=&quot;L1 Cache&quot;, fillcolor=lightyellow];
     }    

     subgraph cluster_registers {
       label=&quot;Register File&quot;;
       style=filled;
       color=lightblue;
       RF [label=&quot;Register File&quot;];
     }    

     subgraph cluster_execution {
       label=&quot;Execution Pipeline&quot;;
       style=filled;
       color=lightgreen;
       SB [label=&quot;Staging Buffer&quot;];
       EU [label=&quot;Execution Unit&quot;];
     }    

     GMEM -&gt; L1 [label=&quot;Coherence (Hardware-managed)&quot;, color=blue];
     L1 -&gt; RF [label=&quot;Operand Fetch (via LD)&quot;, style=dashed];
     RF -&gt; SB [label=&quot;Staging (Just-in-Time)&quot;, style=dashed];
     SB -&gt; EU [label=&quot;Transient Operands&quot;];
     RF -&gt; EU [label=&quot;Persistent Operands&quot;];
     RF -&gt; RF [label=&quot;Internal Coherence&quot;, color=green];
   }" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 120 </span><span class="caption-text"><strong>Operand Delivery in RegLess GPU (with L1 Cache in LD Path)</strong></span><a class="headerlink" href="#id267" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Description</p>
<ul class="simple">
<li><p><strong>Global Memory</strong>: Source of all operands and data.</p></li>
<li><p><strong>L1 Cache</strong>: Participates in memory hierarchy; may serve LD requests.</p></li>
<li><p><strong>Register File</strong>: Receives operands via LD; stages them into Staging Buffer
for Transient Operands.</p></li>
<li><p><strong>Staging Buffer</strong>: Holds transient operands for immediate execution.</p></li>
<li><p><strong>Execution Unit</strong>: Consumes operands from Staging Buffer for Transient
Operands and Register File for Persistent Operands.</p></li>
</ul>
<p>Notes</p>
<ul class="simple">
<li><p><strong>L1 Cache is not part of staging</strong>—it only serves LDs.</p></li>
<li><p><strong>Dashed arrows</strong>: Compiler-controlled operand movement.</p></li>
<li><p><strong>Solid arrows</strong>: Operand delivery to execution.</p></li>
<li><p><strong>Green self-loop</strong>: Internal coherence within Register File.</p></li>
</ul>
<p>RegLess Model: Staging-Aware Register File</p>
<dl class="simple">
<dt><strong>Architecture</strong>:</dt><dd><ul class="simple">
<li><p>Smaller register file (e.g., 64–128KB per SM)</p></li>
<li><p>For Transient Operands, no L1 cache coherence required</p></li>
<li><p>Operands staged dynamically based on lifetime</p></li>
</ul>
</dd>
<dt><strong>Key Concepts</strong>:</dt><dd><ul class="simple">
<li><p>Region slicing: compiler divides computation into operand regions</p></li>
<li><p>Operand tagging: transient, intermediate, persistent</p></li>
<li><p>Metadata compression: region-level hints, not per-instruction lifetimes</p></li>
</ul>
</dd>
<dt><strong>Benefits</strong>:</dt><dd><ul class="simple">
<li><p>~75% reduction in register file size</p></li>
<li><p>~11% energy savings</p></li>
<li><p>Simplified coherence model</p></li>
<li><p>Improved Warp occupancy</p></li>
</ul>
</dd>
</dl>
<p><strong>Example with Operand Staging</strong>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v1</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>         <span class="c1"># transient</span>
<span class="n">v2</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>         <span class="c1"># transient</span>
<span class="n">v3</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>          <span class="c1"># intermediate</span>
<span class="n">v4</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">v3</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>         <span class="c1"># intermediate</span>
<span class="n">v5</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">v4</span><span class="p">,</span> <span class="n">color</span><span class="p">)</span>       <span class="c1"># persistent</span>

<span class="c1"># v1 and v2 staged briefly, v3–v4 may be staged or registered, v5 fully</span>
<span class="c1"># registered</span>
</pre></div>
</div>
<p>Compiler-Hardware Interface</p>
<dl class="simple">
<dt><strong>Compiler Responsibilities</strong>:</dt><dd><ul class="simple">
<li><p>Emit structured IR with operand usage hints</p></li>
<li><p>Slice computation graph into regions</p></li>
<li><p>Avoid explicit staging register allocation</p></li>
</ul>
</dd>
<dt><strong>Hardware Responsibilities</strong>:</dt><dd><ul class="simple">
<li><p>Interpret operand lifetime metadata</p></li>
<li><p>Dynamically stage operands or allocate registers</p></li>
<li><p>For Transient Operands, eliminate L1 cache coherence logic</p></li>
</ul>
</dd>
<dt><strong>Metadata Compression Techniques</strong>:</dt><dd><ul class="simple">
<li><p>Region-level tagging</p></li>
<li><p>Operand class encoding</p></li>
<li><p>Profile-guided optimization</p></li>
<li><p>Off-chip metadata tables (e.g., DEER)</p></li>
</ul>
</dd>
</dl>
<p>Conclusion</p>
<p>The move to RegLess-style coherence simplifies GPU operand management, reduces
energy,
and enables more efficient shader execution. Compiler-guided operand staging and
region slicing allow hardware to dynamically optimize operand placement without
burdening the instruction stream with excessive metadata.</p>
</section>
</section>
<section id="specialized-units">
<h3><a class="toc-backref" href="#id348" role="doc-backlink">Specialized Units</a><a class="headerlink" href="#specialized-units" title="Link to this heading">¶</a></h3>
<p>As shown in <cite>section GPU Hardware Units</cite>,
the stages of the OpenGL rendering pipeline and the GPU hardware units
that accelerate them as shown in <a class="reference internal" href="#ogl-pipeline-hw2"><span class="std std-numref">Fig. 121</span></a>:</p>
<figure class="align-default" id="id268">
<span id="ogl-pipeline-hw2"></span><div class="graphviz"><img src="_images/graphviz-3ca0467b8878209cbbb4397d03ca6bde891369f0.png" alt="digraph OpenGL_GPU_Mapping {
    rankdir=TB;

    // Use HTML-like label for the whole graph
    label=&lt;
        &lt;TABLE BORDER=&quot;0&quot; CELLBORDER=&quot;0&quot; CELLSPACING=&quot;0&quot; ALIGN=&quot;LEFT&quot;&gt;
            &lt;TR&gt;&lt;TD&gt;&lt;/TD&gt;&lt;/TR&gt;
            &lt;TR&gt;&lt;TD&gt;&lt;/TD&gt;&lt;/TR&gt;
            &lt;TR&gt;&lt;TD&gt;&lt;FONT POINT-SIZE=&quot;16&quot; COLOR=&quot;darkblue&quot;&gt;&lt;B&gt;• OpenGL pipeline stages = Yellow&lt;/B&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;
            &lt;TR&gt;&lt;TD&gt;&lt;FONT POINT-SIZE=&quot;16&quot; COLOR=&quot;darkblue&quot;&gt;&lt;B&gt;• GPU hardware units = Blue&lt;/B&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;
            &lt;TR&gt;&lt;TD&gt;&lt;FONT POINT-SIZE=&quot;16&quot; COLOR=&quot;darkblue&quot;&gt;&lt;B&gt;• GPU-only internals = Gray&lt;/B&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;
            &lt;TR&gt;&lt;TD&gt;&lt;FONT POINT-SIZE=&quot;16&quot; COLOR=&quot;darkblue&quot;&gt;&lt;B&gt;• Dashed arrows indicate mapping from OpenGL stages to hardware&lt;/B&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;
        &lt;/TABLE&gt;
    &gt;;

    node [shape=box style=&quot;rounded,filled&quot; fontsize=16];

    // === OpenGL Pipeline (multi-rows) ===
    Application   [label=&quot;Application\n(CPU Side)&quot;, fillcolor=lightyellow];
    VertexSpec    [label=&quot;Vertex Specification\n(glDraw, VBOs)&quot;, fillcolor=lightyellow];

    OGL_Vertex    [label=&quot;Vertex Shader&quot;, fillcolor=lightyellow];
    TessCtrl      [label=&quot;Tessellation \nControl Shader&quot;, fillcolor=lightyellow];
    TessGen       [label=&quot;Tessellation \nPrimitive Generator&quot;, fillcolor=lightyellow];
    TessEval      [label=&quot;Tessellation \nEvaluation Shader&quot;, fillcolor=lightyellow];
    OGL_Geometry  [label=&quot;Geometry Shader / Clipping&quot;, fillcolor=lightyellow];

    OGL_Raster    [label=&quot;Rasterization&quot;, fillcolor=lightyellow];
    OGL_Fragment  [label=&quot;Fragment Shader&quot;, fillcolor=lightyellow];
    OGL_PerFrag   [label=&quot;Per-Fragment Ops\n(Depth, Stencil, Blend)&quot;, fillcolor=lightyellow];
    OGL_Framebuf  [label=&quot;Framebuffer&quot;, fillcolor=lightyellow];

    // OpenGL flow
    Application -&gt; VertexSpec -&gt; OGL_Vertex -&gt; TessCtrl -&gt; TessGen -&gt; TessEval -&gt; OGL_Geometry -&gt; OGL_Raster -&gt; OGL_Fragment -&gt; OGL_PerFrag -&gt; OGL_Framebuf;

    // === GPU Hardware Units (multi-rows) ===
    HW_Vertex    [label=&quot;SMs (Vertex Shader)\n(ALUs, SFUs, Load/Store)&quot;, fillcolor=lightblue];
    HW_Fragment  [label=&quot;SMs (Fragment Shader)\n(ALUs, SFUs, TMUs)&quot;, fillcolor=lightblue];
    HW_Geometry  [label=&quot;Geometry Units\n(Primitive Assembly, Clipping)&quot;, fillcolor=lightblue];
    HW_Raster    [label=&quot;Rasterization Units\n(Triangle → Fragments)&quot;, fillcolor=lightblue];
    ROP          [label=&quot;Render Output Units (ROPs)\n(Depth, Stencil, Blend)&quot;, fillcolor=lightblue];
    HW_Framebuf  [label=&quot;Framebuffer in VRAM&quot;, fillcolor=lightblue];
    TMU          [label=&quot;Texture Mapping Units (TMUs)\n(Texture Fetch/Filter)&quot;, fillcolor=lightgray];
    Display      [label=&quot;Display Controller\n(Output to Screen)&quot;, fillcolor=lightgray];

    // Memory hierarchy
    L1           [label=&quot;L1 / Shared Memory&quot;, fillcolor=lightgray];
    L2           [label=&quot;L2 Cache&quot;, fillcolor=lightgray];
    VRAM         [label=&quot;VRAM (GDDR/HBM)&quot;, fillcolor=lightgray];
    Coalescing   [label=&quot;Coalescing Unit&quot;, fillcolor=lightgray];
    GatherScatter[label=&quot;Gather–Scatter Unit&quot;, fillcolor=lightgray];

    // GPU flow
    HW_Vertex -&gt; HW_Geometry -&gt; HW_Raster -&gt; HW_Fragment;
    HW_Fragment -&gt; TMU;
    HW_Fragment -&gt; ROP -&gt; HW_Framebuf -&gt; Display;

    // Memory path
    HW_Vertex -&gt; L1;
    HW_Fragment -&gt; L1;
    L2 -&gt; Coalescing;
    L1 -&gt; L2 -&gt; VRAM;
    L2 -&gt; GatherScatter;
    TMU -&gt; L1 [label=&quot;Texture Fetch&quot;];
    VRAM -&gt; Display;

    // === Mapping edges (OpenGL → Hardware) ===
    OGL_Vertex   -&gt; HW_Vertex   [style=dashed color=blue];
    TessCtrl     -&gt; HW_Vertex   [style=dashed color=blue];
    TessEval     -&gt; HW_Vertex   [style=dashed color=blue];
    OGL_Geometry -&gt; HW_Geometry [style=dashed color=blue];
    OGL_Raster   -&gt; HW_Raster   [style=dashed color=blue];
    OGL_Fragment -&gt; HW_Fragment [style=dashed color=blue];
    OGL_PerFrag  -&gt; ROP         [style=dashed color=blue];
    OGL_Framebuf -&gt; HW_Framebuf [style=dashed color=blue];

    // === Layering for better spacing ===
    { rank = same; Application; VertexSpec }
    { rank = same; OGL_Vertex; TessCtrl; TessGen }
    { rank = same; TessEval; OGL_Geometry }
    { rank = same; OGL_Raster; OGL_Fragment; OGL_PerFrag; OGL_Framebuf }

    { rank = same; HW_Vertex; HW_Fragment }
    { rank = same; HW_Geometry; HW_Raster; ROP; HW_Framebuf; TMU }
    { rank = same; L1; L2; VRAM; Display }
    { rank = same; Coalescing; GatherScatter }
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 121 </span><span class="caption-text">The stages of OpenGL pipeline and GPU’s acceleration components</span><a class="headerlink" href="#id268" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>We now explain how these GPU hardware acceleration units—Geometry Units,
Rasterization Units, Texture Mapping Units (TMUs), and Render Output Units (ROPs)
—- work together with SMs to provide GPU-ISA instructions that accelerate the
graphics pipeline illustrated in <a class="reference internal" href="#short-rendering-pipeline2"><span class="std std-numref">Fig. 122</span></a> of
section <a class="reference internal" href="#rendering3d"><span class="std std-ref">3D Rendering</span></a>.</p>
<p class="rubric">Figure illustrated in section 3D Rendering</p>
<figure class="align-center" id="id269">
<span id="short-rendering-pipeline2"></span><a class="reference internal image-reference" href="_images/short-rendering-pipeline.png"><img alt="_images/short-rendering-pipeline.png" height="347" src="_images/short-rendering-pipeline.png" width="915" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 122 </span><span class="caption-text">3D Graphics Rendering Pipeline <a class="footnote-reference brackets" href="#cg-basictheory" id="id136" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></span><a class="headerlink" href="#id269" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<section id="geometry-units">
<h4><a class="toc-backref" href="#id349" role="doc-backlink">Geometry Units</a><a class="headerlink" href="#geometry-units" title="Link to this heading">¶</a></h4>
<p><strong>Function:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Raw Vertices &amp; Primitives → Transformed Vertices &amp; Primitives
</pre></div>
</div>
<p>Suppose the GLSL geometry shader looks like this:</p>
<p class="rubric">An example of GLSL geometry shader</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#version 450</span>
<span class="n">layout</span><span class="p">(</span><span class="n">triangles</span><span class="p">)</span><span class="w"> </span><span class="n">in</span><span class="p">;</span>
<span class="n">layout</span><span class="p">(</span><span class="n">line_strip</span><span class="p">,</span><span class="w"> </span><span class="n">max_vertices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="n">out</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gl_in</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">gl_Position</span><span class="p">;</span>
<span class="w">  </span><span class="n">EmitVertex</span><span class="p">();</span>

<span class="w">  </span><span class="n">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gl_in</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">gl_Position</span><span class="p">;</span>
<span class="w">  </span><span class="n">EmitVertex</span><span class="p">();</span>

<span class="w">  </span><span class="n">EndPrimitive</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The corresponding PTX instructions and pipeline flow as <a class="reference internal" href="#sm-geometry"><span class="std std-numref">Fig. 123</span></a>.</p>
<figure class="align-default" id="id270">
<span id="sm-geometry"></span><div class="graphviz"><img src="_images/graphviz-e30b52aa74f8c9915dfb4192649b626ef3838cb0.png" alt="digraph SM_Geometry_Assembly {
  rankdir=LR;
  bgcolor=&quot;white&quot;;
  node [shape=box, style=&quot;rounded,filled&quot;, fontname=&quot;Arial&quot;, fontsize=11];

  /* Graph-level title (left-aligned, bold) */
  label=&lt;
    &lt;TABLE BORDER=&quot;0&quot; CELLBORDER=&quot;0&quot; CELLSPACING=&quot;0&quot; ALIGN=&quot;LEFT&quot;&gt;
      &lt;TR&gt;&lt;TD&gt;&lt;FONT POINT-SIZE=&quot;14&quot; COLOR=&quot;#003366&quot;&gt;&lt;B&gt;SM → Geometry Unit: PTX-like Assembly Flow&lt;/B&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;&lt;FONT POINT-SIZE=&quot;10&quot; COLOR=&quot;#003366&quot;&gt;Example sequence showing loads/moves and {&#64;code call emit}/{&#64;code call cut} dispatching primitives&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;
    &lt;/TABLE&gt;
  &gt;;
  labelloc=top;

  /* SM thread node */
  SMThread [fillcolor=&quot;#FFF2CC&quot; label=&lt;
    &lt;TABLE BORDER=&quot;0&quot; CELLBORDER=&quot;0&quot; CELLSPACING=&quot;0&quot; ALIGN=&quot;LEFT&quot;&gt;
      &lt;TR&gt;&lt;TD&gt;&lt;B&gt;Thread running in SM&lt;/B&gt;&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;• Executes geometry shader program&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;• Issues compiled PTX-style microcode&lt;/TD&gt;&lt;/TR&gt;
    &lt;/TABLE&gt;
  &gt;];

  /* Instruction Fetch / Decoder */
  InstFetch [fillcolor=&quot;#E6F2FF&quot; label=&lt;
    &lt;TABLE BORDER=&quot;0&quot; CELLBORDER=&quot;0&quot; CELLSPACING=&quot;0&quot; ALIGN=&quot;LEFT&quot;&gt;
      &lt;TR&gt;&lt;TD&gt;&lt;B&gt;Instruction Fetch &amp;amp; Decode&lt;/B&gt;&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;• Fetches micro-instructions from shader code&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;• Decodes into ALU / LD / CALL operations&lt;/TD&gt;&lt;/TR&gt;
    &lt;/TABLE&gt;
  &gt;];

  /* Assembly sequence node showing PTX-like lines */
  AsmSeq [fillcolor=&quot;#FFFFFF&quot; penwidth=&quot;1&quot; label=&lt;
    &lt;TABLE BORDER=&quot;0&quot; CELLBORDER=&quot;0&quot; CELLSPACING=&quot;0&quot; ALIGN=&quot;LEFT&quot;&gt;
      &lt;TR&gt;&lt;TD&gt;&lt;B&gt;Compiled (PTX-like) Instruction Sequence&lt;/B&gt;&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;&lt;FONT FACE=&quot;monospace&quot;&gt;ld.global.v4.f32 {r0, r1, r2, r3}, [in_attr0];&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;&lt;FONT FACE=&quot;monospace&quot;&gt;mov.f32 o0, r0;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;&lt;FONT FACE=&quot;monospace&quot;&gt;mov.f32 o1, r1;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;&lt;FONT FACE=&quot;monospace&quot;&gt;mov.f32 o2, r2;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;&lt;FONT FACE=&quot;monospace&quot;&gt;mov.f32 o3, r3;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;&lt;FONT FACE=&quot;monospace&quot;&gt;&lt;B&gt;call emit;&lt;/B&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;&lt;FONT FACE=&quot;monospace&quot;&gt;ld.global.v4.f32 {r4, r5, r6, r7}, [in_attr1];&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;&lt;FONT FACE=&quot;monospace&quot;&gt;mov.f32 o0, r4;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;&lt;FONT FACE=&quot;monospace&quot;&gt;mov.f32 o1, r5;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;&lt;FONT FACE=&quot;monospace&quot;&gt;mov.f32 o2, r6;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;&lt;FONT FACE=&quot;monospace&quot;&gt;mov.f32 o3, r7;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;&lt;FONT FACE=&quot;monospace&quot;&gt;&lt;B&gt;call emit;&lt;/B&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;&lt;FONT FACE=&quot;monospace&quot;&gt;&lt;B&gt;call cut;&lt;/B&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;
    &lt;/TABLE&gt;
  &gt;];

  /* Output registers / buffers that hold emitted vertex data */
  OutRegs [shape=note, fillcolor=&quot;#FFFFE0&quot;, label=&lt;
    &lt;TABLE BORDER=&quot;0&quot; CELLBORDER=&quot;0&quot; CELLSPACING=&quot;0&quot; ALIGN=&quot;LEFT&quot;&gt;
      &lt;TR&gt;&lt;TD&gt;&lt;B&gt;Output Registers / Emit Buffer&lt;/B&gt;&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;• o0..oN hold per-vertex outputs (position, attrs)&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;• Emit buffer queues vertices for Geometry Unit&lt;/TD&gt;&lt;/TR&gt;
    &lt;/TABLE&gt;
  &gt;];

  /* Geometry Unit with internal stages (simplified) */
  GeoUnit [fillcolor=&quot;#D9E8FF&quot; label=&lt;
    &lt;TABLE BORDER=&quot;0&quot; CELLBORDER=&quot;0&quot; CELLSPACING=&quot;0&quot; ALIGN=&quot;LEFT&quot;&gt;
      &lt;TR&gt;&lt;TD&gt;&lt;B&gt;Geometry Unit (hardware)&lt;/B&gt;&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;• Accepts emitted vertices from SM output regs&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;• Primitive Assembly / Tessellation / GS handling&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;• Culling, Clipping, Viewport transform&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;• Primitive Setup → send to Rasterizer&lt;/TD&gt;&lt;/TR&gt;
    &lt;/TABLE&gt;
  &gt;];

  Rasterizer [fillcolor=&quot;#F2F8FF&quot; label=&lt;
    &lt;TABLE BORDER=&quot;0&quot; CELLBORDER=&quot;0&quot; CELLSPACING=&quot;0&quot; ALIGN=&quot;LEFT&quot;&gt;
      &lt;TR&gt;&lt;TD&gt;&lt;B&gt;Rasterizer&lt;/B&gt;&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;• Consumes prepared primitives&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;• Produces fragments for fragment shading&lt;/TD&gt;&lt;/TR&gt;
    &lt;/TABLE&gt;
  &gt;];

  /* Dataflow edges */
  SMThread -&gt; InstFetch [label=&quot; compiled microcode / instruction pointer&quot; fontsize=10];
  InstFetch -&gt; AsmSeq [label=&quot; decode -&gt; micro-ops&quot; fontsize=10];
  AsmSeq -&gt; OutRegs [label=&quot; write outputs (o0..oN)&quot; fontsize=10];
  OutRegs -&gt; GeoUnit [label=&quot; Emit vertex(s) (emit/cut triggers)&quot; fontsize=10];
  GeoUnit -&gt; Rasterizer [label=&quot; prepared primitives&quot; fontsize=10];

  /* Control arrows (illustrate call emit/cut semantics) */
  AsmSeq -&gt; GeoUnit [label=&quot; call emit / call cut (control msgs)&quot;, style=dashed, color=&quot;#3333CC&quot;];

  /* layout hints */
  { rank = same; SMThread; InstFetch; AsmSeq }
  { rank = same; OutRegs; GeoUnit; Rasterizer }
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 123 </span><span class="caption-text">Fetch a sequence of Geometry instructions and pass to Geometry Unit</span><a class="headerlink" href="#id270" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The <strong>Geometry Unit</strong> in a GPU is a collection of fixed-function and programmable stages
responsible for transforming assembled primitives (points, lines, triangles, patches)
into screen-space primitives ready for rasterization.
The emit and cut are compiler intrinsics that map to control messages to the
Geometry Unit.
When we say emit and cut in NVIDIA PTX (or HLSL/GLSL geometry shaders), they’re
not ALU instructions that run in the SM like add or mul. Instead, they act like
special control instructions that tell the GPU’s fixed-function Geometry Unit
what to do with the vertex data currently in the SM’s output registers
illustrated in <a class="reference internal" href="#emit-cut-flow"><span class="std std-numref">Fig. 124</span></a>.</p>
<figure class="align-default" id="id271">
<span id="emit-cut-flow"></span><div class="graphviz"><img src="_images/graphviz-b2fc4bb5f80934262b52b68b07e831e0834f323a.png" alt="digraph EmitCut_Flow {
    rankdir=LR;
    fontsize=12;
    labelloc=&quot;t&quot;;
    label=&quot;GPU Geometry Shader Dataflow — EmitVertex() and EndPrimitive()&quot;;

    node [shape=box, style=rounded, fontname=&quot;Helvetica&quot;];

    subgraph cluster_shader {
        label=&quot;Streaming Multiprocessor (SM)&quot;;
        color=lightblue;
        style=filled;
        fillcolor=&quot;#D8EFFF&quot;;

        thread [label=&quot;Shader Thread\n(Geometry Shader Instructions)&quot;, shape=box];
        emit [label=&quot;EmitVertex()\n• write varyings\n• commit vertex&quot;, shape=box];
        cut [label=&quot;EndPrimitive()\n• mark primitive boundary&quot;, shape=box];
        thread -&gt; emit -&gt; cut;
    }

    subgraph cluster_fifo {
        label=&quot;On-Chip FIFO / URB / LDS Buffer&quot;;
        color=gray;
        style=filled;
        fillcolor=&quot;#EEEEEE&quot;;
        fifo [label=&quot;FIFO Buffer\n(Holds emitted vertices\nand primitive markers)&quot;, shape=box];
    }

    subgraph cluster_geom {
        label=&quot;Geometry Unit / Primitive Assembler&quot;;
        color=lightgreen;
        style=filled;
        fillcolor=&quot;#E0FFE0&quot;;
        geom [label=&quot;Geometry Unit\n• reads FIFO entries\n• assembles primitives&quot;, shape=box];
    }

    subgraph cluster_rast {
        label=&quot;Rasterization Pipeline&quot;;
        color=lightgray;
        style=dashed;
        rast [label=&quot;Rasterizer\n• receives completed\ntriangles/lines&quot;, shape=box];
    }

    // Dataflow edges
    emit -&gt; fifo [label=&quot;write vertex data&quot;];
    cut -&gt; fifo [label=&quot;write primitive end marker&quot;];
    fifo -&gt; geom [label=&quot;fetch vertex packets&quot;];
    geom -&gt; rast [label=&quot;assembled primitives&quot;];

    // Control flow notes
    thread -&gt; emit [style=dashed, color=gray, label=&quot;shader executes intrinsics&quot;];
    geom -&gt; fifo [style=dotted, color=gray, label=&quot;read signals / ready flags&quot;];

    // Legend
    legend [shape=note, label=&quot;LEGEND:\nEmitVertex() = vertex data write\nEndPrimitive() = mark primitive end\nSM → FIFO → Geometry Unit → Rasterizer&quot;, fontsize=10];
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 124 </span><span class="caption-text">Micro-level flow: SM → Geometry Unit via Emit/Cut</span><a class="headerlink" href="#id271" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Unlike GLSL textures, which are converted into a specific hardware ISA, the
Geometry Shader in <a class="reference internal" href="#ogl-pipeline-hw2"><span class="std std-numref">Fig. 121</span></a> maps directly to the Geometry
Units instead of the SMs.</p>
<p>Geometry Unit bridges the <strong>vertex shading</strong> stage and the <strong>rasterization</strong>
stage as shown in <a class="reference internal" href="#geometry-unit"><span class="std std-numref">Fig. 125</span></a>.</p>
<figure class="align-default" id="id272">
<span id="geometry-unit"></span><div class="graphviz"><img src="_images/graphviz-e664e360f559181653583078d12eda881afee9b4.png" alt="digraph Geometry_Unit {
  rankdir=TB;
  bgcolor=&quot;white&quot;;
  node [shape=box, style=&quot;rounded,filled&quot;, fontname=&quot;Arial&quot;, fontsize=14];

  /* Graph-level left-aligned title (bold, dark blue) */
  label=&lt;
    &lt;TABLE BORDER=&quot;0&quot; CELLBORDER=&quot;0&quot; CELLSPACING=&quot;0&quot; ALIGN=&quot;LEFT&quot;&gt;
      &lt;TR&gt;
        &lt;TD&gt;
          &lt;FONT POINT-SIZE=&quot;18&quot; COLOR=&quot;#003366&quot;&gt;&lt;B&gt;GPU Geometry Unit - internal stages &amp;amp; dataflow&lt;/B&gt;&lt;/FONT&gt;
        &lt;/TD&gt;
      &lt;/TR&gt;
      &lt;TR&gt;
        &lt;TD&gt;
          &lt;FONT POINT-SIZE=&quot;14&quot; COLOR=&quot;#003366&quot;&gt;Flow: Vertex output - Primitive Assembly - (Tessellation) - Geometry Shader - Clipping - Viewport Transform - Primitive Setup - Rasterizer&lt;/FONT&gt;
        &lt;/TD&gt;
      &lt;/TR&gt;
    &lt;/TABLE&gt;
  &gt;;
  labelloc=top;

  /* External stages (vertex / rasterizer) */
  VertexOut [fillcolor=&quot;#FFF2CC&quot; label=&lt;
    &lt;TABLE BORDER=&quot;0&quot; CELLBORDER=&quot;0&quot; CELLSPACING=&quot;0&quot; ALIGN=&quot;LEFT&quot;&gt;
      &lt;TR&gt;&lt;TD&gt;&lt;B&gt;Vertex Shader Output&lt;/B&gt;&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;• Transformed vertices (clip/NDC)&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;• Per-vertex attributes (normals, UVs, colors)&lt;/TD&gt;&lt;/TR&gt;
    &lt;/TABLE&gt;
  &gt;];

  Rasterizer [fillcolor=&quot;#F2F8FF&quot; label=&lt;
    &lt;TABLE BORDER=&quot;0&quot; CELLBORDER=&quot;0&quot; CELLSPACING=&quot;0&quot; ALIGN=&quot;LEFT&quot;&gt;
      &lt;TR&gt;&lt;TD&gt;&lt;B&gt;Rasterizer&lt;/B&gt;&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;• Consumes prepared primitives&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;• Produces fragments for fragment shading&lt;/TD&gt;&lt;/TR&gt;
    &lt;/TABLE&gt;
  &gt;];

  /* Geometry Unit core blocks */
  Assembly [fillcolor=&quot;#D9E8FF&quot; label=&lt;
    &lt;TABLE BORDER=&quot;0&quot; CELLBORDER=&quot;0&quot; CELLSPACING=&quot;0&quot; ALIGN=&quot;LEFT&quot;&gt;
      &lt;TR&gt;&lt;TD&gt;&lt;B&gt;Primitive Assembly / Input Assembler&lt;/B&gt;&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;• Group vertices into primitives \n(triangles, lines, patches)&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;• Fetch index buffers, vertex attributes&lt;/TD&gt;&lt;/TR&gt;
    &lt;/TABLE&gt;
  &gt;];

  Tessellation [fillcolor=&quot;#E8F7E8&quot; label=&lt;
    &lt;TABLE BORDER=&quot;0&quot; CELLBORDER=&quot;0&quot; CELLSPACING=&quot;0&quot; ALIGN=&quot;LEFT&quot;&gt;
      &lt;TR&gt;&lt;TD&gt;&lt;B&gt;Tessellation (optional)&lt;/B&gt;&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;• Tessellation Control + Primitive Gen + Eval&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;• Patch subdivision, generate new vertices/primitives&lt;/TD&gt;&lt;/TR&gt;
    &lt;/TABLE&gt;
  &gt;];

  GeoShader [fillcolor=&quot;#D9E8FF&quot; label=&lt;
    &lt;TABLE BORDER=&quot;0&quot; CELLBORDER=&quot;0&quot; CELLSPACING=&quot;0&quot; ALIGN=&quot;LEFT&quot;&gt;
      &lt;TR&gt;&lt;TD&gt;&lt;B&gt;Geometry Shader / Stream Output (optional)&lt;/B&gt;&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;• Programmable stage: modify or emit primitives&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;• Can amplify primitives (performance cost)&lt;/TD&gt;&lt;/TR&gt;
    &lt;/TABLE&gt;
  &gt;];

  Culling [fillcolor=&quot;#FFF4D9&quot; label=&lt;
    &lt;TABLE BORDER=&quot;0&quot; CELLBORDER=&quot;0&quot; CELLSPACING=&quot;0&quot; ALIGN=&quot;LEFT&quot;&gt;
      &lt;TR&gt;&lt;TD&gt;&lt;B&gt;Primitive Culling &amp;amp; Clipping&lt;/B&gt;&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;• Frustum clipping, user-space frustum tests&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;• Back-face culling, scissor tests&lt;/TD&gt;&lt;/TR&gt;
    &lt;/TABLE&gt;
  &gt;];

  Viewport [fillcolor=&quot;#FFF4D9&quot; label=&lt;
    &lt;TABLE BORDER=&quot;0&quot; CELLBORDER=&quot;0&quot; CELLSPACING=&quot;0&quot; ALIGN=&quot;LEFT&quot;&gt;
      &lt;TR&gt;&lt;TD&gt;&lt;B&gt;Viewport / Screen Transform&lt;/B&gt;&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;• NDC → screen coordinates (viewport scale + offset)&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;• Apply depth range mapping&lt;/TD&gt;&lt;/TR&gt;
    &lt;/TABLE&gt;
  &gt;];

  Setup [fillcolor=&quot;#FFF4D9&quot; label=&lt;
    &lt;TABLE BORDER=&quot;0&quot; CELLBORDER=&quot;0&quot; CELLSPACING=&quot;0&quot; ALIGN=&quot;LEFT&quot;&gt;
      &lt;TR&gt;&lt;TD&gt;&lt;B&gt;Primitive Setup / Scan-conversion Prep&lt;/B&gt;&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;• Compute edge equations, slopes, barycentrics&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;• Prepare interpolants (dx/dy) for attributes&lt;/TD&gt;&lt;/TR&gt;
    &lt;/TABLE&gt;
  &gt;];

  /* Resource boxes / notes */
  Resources [shape=note, fillcolor=&quot;#FFFFE0&quot;, label=&lt;
    &lt;TABLE BORDER=&quot;0&quot; CELLBORDER=&quot;0&quot; CELLSPACING=&quot;0&quot; ALIGN=&quot;LEFT&quot;&gt;
      &lt;TR&gt;&lt;TD&gt;&lt;B&gt;Resources / HW considerations&lt;/B&gt;&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;• Shared scheduling with vertex units&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;• Dedicated small caches / FIFOs for index/vertex fetch&lt;/TD&gt;&lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;• Fixed-function blocks for edge setup (for performance)&lt;/TD&gt;&lt;/TR&gt;
    &lt;/TABLE&gt;
  &gt;];

  /* Edges: dataflow */
  VertexOut -&gt; Assembly [label=&quot; vertices + attributes&quot; fontsize=14];
  Assembly -&gt; Tessellation [label=&quot; primitives\n / patches&quot; fontsize=14];
  Tessellation -&gt; GeoShader [label=&quot; subdivided\n primitives&quot; fontsize=14];
  Assembly -&gt; GeoShader [label=&quot; primitives (if tess disabled)&quot; fontsize=14];
  GeoShader -&gt; Culling [label=&quot; emitted primitives&quot; fontsize=14];
  Culling -&gt; Viewport [label=&quot; clipped\n primitives&quot; fontsize=14];
  Viewport -&gt; Setup [label=&quot; screen-space verts\n + interpolants&quot; fontsize=14];
  Setup -&gt; Rasterizer [label=&quot; prepared primitives (edge eqns)&quot; fontsize=14];

  /* Optional arrows for control / fallback */
  Tessellation -&gt; Setup [label=&quot; bypass (if no geometry shader)&quot;, style=dashed];
  GeoShader -&gt; Setup [label=&quot; direct -&gt; setup (if no culling)&quot;, style=dashed];

  /* Resources placement */
  Resources -&gt; Assembly [style=dotted];
  Resources -&gt; Tessellation [style=dotted];
  Resources -&gt; GeoShader [style=dotted];

  /* Layout tweaks */
  { rank = same; Assembly; Tessellation; GeoShader }
  { rank = same; Culling; Viewport; Setup }
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 125 </span><span class="caption-text">Geometry Unit with its sub-functions (assembly, tessellation,
clipping, viewport transform, etc.)</span><a class="headerlink" href="#id272" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Role</p>
<ul class="simple">
<li><p>Organize and process geometry data after vertex shading.</p></li>
<li><p>Perform primitive-level operations such as assembly, tessellation, clipping,
viewport transform, and primitive setup.</p></li>
<li><p>Provide hardware acceleration for geometry amplification or reduction
before rasterization.</p></li>
</ul>
<p>Components</p>
<ul class="simple">
<li><p><strong>Primitive Assembly (Input Assembler)</strong></p>
<ul>
<li><p>Groups vertices into primitives (triangles, lines, patches).</p></li>
<li><p>Fetches indices and vertex attributes from memory.</p></li>
<li><p>Prepares data structures for downstream geometry stages.</p></li>
</ul>
</li>
<li><p><strong>Tessellation Engine (optional, OpenGL 4.0+ / DirectX 11+)</strong></p>
<ul>
<li><p>Subdivides patches into finer primitives.</p></li>
<li><p>Contains Tessellation Control Shader, Primitive Generator, and
Tessellation Evaluation Shader.</p></li>
<li><p>Used in terrain rendering, displacement mapping, and adaptive LOD.</p></li>
</ul>
</li>
<li><p><strong>Geometry Shader (optional, programmable stage)</strong></p>
<ul>
<li><p>Can generate new primitives or discard existing ones.</p></li>
<li><p>Enables shadow volume extrusion, point sprite expansion, or procedural geometry.</p></li>
<li><p>High flexibility but often limited in performance due to amplification.</p></li>
</ul>
</li>
<li><p><strong>Culling &amp; Clipping</strong></p>
<ul>
<li><p>Removes back-facing or out-of-view primitives.</p></li>
<li><p>Clips primitives against the view frustum or user-defined clipping planes.</p></li>
<li><p>Optimizes rendering by reducing fragment processing workload.</p></li>
</ul>
</li>
<li><p><strong>Viewport Transform</strong></p>
<ul>
<li><p>Maps Normalized Device Coordinates (NDC) to screen-space pixel coordinates.</p></li>
<li><p>Applies viewport scaling, offset, and depth range mapping.</p></li>
</ul>
</li>
<li><p><strong>Primitive Setup</strong></p>
<ul>
<li><p>Converts screen-space primitives into edge equations and interpolation rules.</p></li>
<li><p>Prepares slopes and barycentric coefficients for attribute interpolation in rasterization.</p></li>
<li><p>Ensures that per-fragment attributes (e.g., texture coordinates, normals)
are interpolated correctly.</p></li>
</ul>
</li>
</ul>
<p>Usage</p>
<ul class="simple">
<li><p>Reduces workload on the fragment stage by culling invisible primitives.</p></li>
<li><p>Provides tessellation and geometry shaders for advanced rendering effects.</p></li>
<li><p>Ensures efficient and accurate rasterization setup.</p></li>
<li><p>Works closely with specialized GPU fixed-function blocks such as
<strong>PolyMorph Engines</strong> (NVIDIA) or <strong>Geometry Processors</strong> (AMD).</p></li>
</ul>
<p>References</p>
<ul class="simple">
<li><p>Wikipedia – <a class="reference external" href="https://en.wikipedia.org/wiki/Graphics_pipeline">Graphics pipeline</a></p></li>
<li><p>NVIDIA – <a class="reference external" href="https://developer.nvidia.com/content/directx-11-gpu-architecture">DirectX 11 GPU Architecture (Geometry and PolyMorph Engine)</a></p></li>
<li><p>Intel – <a class="reference external" href="https://www.intel.com/content/www/us/en/developer/articles/technical/introduction-to-3d-pipeline.html">3D Pipeline Overview (including Geometry Stage)</a></p></li>
<li><p>LearnOpenGL – <a class="reference external" href="https://learnopengl.com/Advanced-OpenGL/Geometry-Shader">Geometry Shader</a></p></li>
<li><p>Microsoft Docs – <a class="reference external" href="https://learn.microsoft.com/en-us/windows/win32/direct3d11/overviews-direct3d-11-graphics-pipeline">Tessellation and Geometry Pipeline</a></p></li>
</ul>
</section>
<section id="rasterization-units">
<h4><a class="toc-backref" href="#id350" role="doc-backlink">Rasterization Units <a class="footnote-reference brackets" href="#raster-unit" id="id137" role="doc-noteref"><span class="fn-bracket">[</span>110<span class="fn-bracket">]</span></a></a><a class="headerlink" href="#rasterization-units" title="Link to this heading">¶</a></h4>
<p><strong>Function:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Transformed Vertices &amp; Primitives → Fragments
</pre></div>
</div>
<p>Overview</p>
<p>The rasterization unit is a critical component of the graphics pipeline in
modern GPUs. It converts geometric primitives (typically triangles) into
fragments that correspond to pixels on the screen. This process is essential
for rendering 3D scenes into 2D images.</p>
<p>The pipeline flow for Rasterization Units is shown as
<a class="reference internal" href="#rasterization-pipeline"><span class="std std-numref">Fig. 126</span></a>.</p>
<figure class="align-default" id="id273">
<span id="rasterization-pipeline"></span><div class="graphviz"><img src="_images/graphviz-e5e784dbed3152f4413a359d8ecffc3dea36342a.png" alt="digraph RasterizationPipeline {
    rankdir=TB;
    node [shape=box, style=filled, fillcolor=lightgray];

    FragmentShader [label=&quot;Fragment Shader (Pixel Shader)&quot;, fillcolor=lightblue];
    GeometryUnit [label=&quot;Geometry Unit\n(Vertex + Geometry Shader)&quot;, fillcolor=lightyellow];
    GeometryUnit -&gt; PreparedPrimitives;
    PreparedPrimitives [label=&quot;Prepared Primitives&quot;, shape=ellipse, fillcolor=white];

    PreparedPrimitives -&gt; TriangleSetup;
    TriangleSetup -&gt; ScanConversion;
    ScanConversion -&gt; AttributeInterpolation;
    AttributeInterpolation -&gt; EarlyZCulling;
    EarlyZCulling -&gt; FragmentGeneration;
    FragmentGeneration -&gt; FragmentShader;

    // === Layering for better spacing ===
    { rank = same; GeometryUnit; PreparedPrimitives; TriangleSetup }
    { rank = same; ScanConversion; AttributeInterpolation; EarlyZCulling }
    { rank = same; FragmentGeneration; FragmentShader }
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 126 </span><span class="caption-text">Rasterization pipeline</span><a class="headerlink" href="#id273" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Key Functions</p>
<ul class="simple">
<li><p><strong>Triangle Setup</strong>: Computes edge equations and bounding boxes for each
triangle.</p></li>
<li><p><strong>Scan Conversion</strong>: Determines which pixels are covered by the triangle.</p></li>
<li><p><strong>Attribute Interpolation</strong>: Calculates interpolated values (e.g., texture
coordinates, depth) for each fragment.</p></li>
<li><p><strong>Fragment Generation</strong>: Produces fragment data for downstream shading and
blending stages.</p></li>
</ul>
<p>Hardware Architecture</p>
<p>Modern GPUs implement rasterization in highly parallel hardware blocks to
maximize throughput. A simplified block diagram includes:</p>
<ul class="simple">
<li><p><strong>Primitive Assembly Unit</strong>: Groups vertices into triangles.</p></li>
<li><p><strong>Triangle Setup Engine</strong>: Prepares edge equations and bounding boxes.</p></li>
<li><p><strong>Rasterizer Core</strong>: Performs scan conversion and fragment generation.</p></li>
<li><p><strong>Early-Z Unit</strong>: Performs early depth testing to discard hidden fragments.</p></li>
<li><p><strong>Fragment Queue</strong>: Buffers fragments for shading.</p></li>
</ul>
<p>Optimization Techniques</p>
<ul class="simple">
<li><p><strong>Tile-Based Rasterization</strong>: Divides the screen into tiles to reduce memory
bandwidth.</p></li>
<li><p><strong>Early-Z Culling</strong>: Discards fragments before shading if they fail depth
tests.</p></li>
<li><p><strong>Compression</strong>: Reduces data transfer costs between pipeline stages.</p></li>
</ul>
<p>Use Cases</p>
<ul class="simple">
<li><p>Real-time rendering in games and simulations.</p></li>
<li><p>3D Gaussian Splatting acceleration for AI-based rendering.</p></li>
<li><p>Mobile GPUs with power-efficient rasterization pipelines.</p></li>
</ul>
<p>References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://arxiv.org/html/2503.16681v1">GauRast: Enhancing GPU Triangle Rasterizers</a></p></li>
<li><p><a class="reference external" href="https://images.nvidia.com/aem-dam/Solutions/geforce/ada/nvidia-ada-gpu-architecture.pdf">NVIDIA Ada GPU Architecture PDF</a></p></li>
<li><p><a class="reference external" href="https://gfxcourses.stanford.edu/cs248a/winter23content/media/gpuhardware/19_mobilegpu.pdf">Stanford CS248A Lecture on Rasterization</a></p></li>
</ul>
</section>
<section id="texture-mapping-units-tmus">
<h4><a class="toc-backref" href="#id351" role="doc-backlink">Texture Mapping Units (TMUs) <a class="footnote-reference brackets" href="#tpu" id="id138" role="doc-noteref"><span class="fn-bracket">[</span>67<span class="fn-bracket">]</span></a></a><a class="headerlink" href="#texture-mapping-units-tmus" title="Link to this heading">¶</a></h4>
<p><strong>Function:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Fragments → Processed Fragments
</pre></div>
</div>
<p>Overview</p>
<p>A Texture Mapping Unit (TMU) is a fixed-function hardware block inside a GPU
responsible for <em>fetching, filtering, and preparing texture data</em> that shaders
(sampled in fragment or compute stages) use during rendering.</p>
<p>As explained in previous
<a class="reference internal" href="#opengl-shader-compiler"><span class="std std-ref">section OpenGL Shader Compiler</span></a>, the texture
instruction using TMU to accelerate calculation as the following explanation
with <a class="reference internal" href="#texture-fetch"><span class="std std-numref">Fig. 127</span></a>.</p>
<p>TMUs sit between the shader cores (SMs/CUs) and the memory subsystem.
They provide high-performance, specialized texture access operations that
would be too slow or costly to emulate in general-purpose ALUs is shown as
<a class="reference internal" href="#texture-fetch"><span class="std std-numref">Fig. 127</span></a>.</p>
<figure class="align-default" id="id274">
<span id="texture-fetch"></span><div class="graphviz"><img src="_images/graphviz-2b43e4f4373d2bbbd36ef758572612ee17d011f8.png" alt="digraph TextureFetch {
  rankdir=TB;
  node [shape=box, fontname=&quot;Helvetica&quot;, fontsize=10, style=rounded];

  Thread [label=&quot;Thread in SM\n(executes texture() instr)&quot;];
  Instr [label=&quot;Decoded Texture Instruction\n(coords + sampler state)&quot;];
  TMU [label=&quot;Texture Mapping Unit (TMU)\n- Addressing\n- Filtering\n- LOD calc&quot;];
  TCache [label=&quot;Texture Cache (L1/L2)&quot;];
  VRAM [label=&quot;Texture Memory (VRAM)\n(GDDR/HBM)&quot;];
  Result [label=&quot;Sampled Texel(s)\n(return to SM thread)&quot;];

  Thread -&gt; Instr [label=&quot;1. issue\n texture()&quot;];
  Instr -&gt; TMU [label=&quot;2. send coords\n + state&quot;];
  TMU -&gt; TCache [label=&quot;3. fetch\n texels&quot;];
  TCache -&gt; VRAM [label=&quot;4. on\n cache miss&quot;];
  VRAM -&gt; TCache [label=&quot;5. load\n texels&quot;];
  TCache -&gt; TMU [label=&quot;6. return\n texels&quot;];
  TMU -&gt; Result [label=&quot;7. filtered\n texel&quot;];
  Result -&gt; Thread [label=&quot;8. write back result&quot;];

  { rank = same; Thread; Instr; TMU }
  { rank = same; TCache; Result }
  { rank = same; VRAM }
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 127 </span><span class="caption-text">The flow of issuing texture instruction from SM to TMU.</span><a class="headerlink" href="#id274" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Pipeline Role</p>
<ul class="simple">
<li><p>In the <strong>OpenGL / Direct3D graphics pipeline</strong>, TMUs are mainly used in the
<em>fragment shading stage</em>, where textured surfaces are shaded with data
from 2D/3D textures.</p></li>
<li><p>In <strong>compute shaders</strong>, TMUs are also used for image load/store operations
and texture sampling.</p></li>
</ul>
<p>Key Responsibilities</p>
<ol class="arabic">
<li><p>Texture Addressing</p>
<ul>
<li><p>Compute the correct texture coordinate for a given fragment or pixel.</p></li>
<li><p>Handle the following wrapping modes are shown as <a class="reference internal" href="#texture-wrap-2"><span class="std std-numref">Fig. 128</span></a>
and as <a class="reference internal" href="#texture-wrap"><span class="std std-numref">Fig. 129</span></a>:</p>
<p>Texture coordinates usually range from (0,0) to (1,1) but what happens if
we specify coordinates outside this range? OpenGL provides the following
wrapping modes for outside this range.</p>
<ul class="simple">
<li><p>Clamp-to-border (GL_CLAMP_TO_BORDER)</p>
<ul>
<li><p>When a texture coordinate falls outside the [0,1] range, the GPU
does not sample the nearest texel.</p></li>
<li><p>Instead, it returns a user-defined border color for that texture.</p></li>
<li><p>This is useful for effects like shadow maps, where sampling outside
the valid area should produce a consistent value.</p></li>
</ul>
</li>
<li><p>Repeat (GL_REPEAT): Wraps coordinates around (tiles the texture).</p></li>
<li><p>Clamp-to-edge (GL_CLAMP_TO_EDGE): Uses the edge texel when coordinates
are out of range.</p></li>
<li><p>Mirrored repeat (GL_MIRRORED_REPEAT): Mirrors the texture each repetition.</p>
<ul>
<li><p>For the middle row (t(V) in the range 0.0 to 1.0), the mirroring
operation applies only a left-right swap. For the top and bottom rows,
the mirroring includes both left-right and up-down swaps.</p></li>
</ul>
</li>
</ul>
<figure class="align-center" id="id275">
<span id="texture-wrap-2"></span><a class="reference internal image-reference" href="_images/texture-wrap-2.png"><img alt="_images/texture-wrap-2.png" height="186" src="_images/texture-wrap-2.png" width="669" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 128 </span><span class="caption-text">Texture Warpping</span><a class="headerlink" href="#id275" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id276">
<span id="texture-wrap"></span><a class="reference internal image-reference" href="_images/texture-wrap.png"><img alt="_images/texture-wrap.png" height="168" src="_images/texture-wrap.png" width="597" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 129 </span><span class="caption-text">Texture Warpping <a class="footnote-reference brackets" href="#texturewrapper" id="id139" role="doc-noteref"><span class="fn-bracket">[</span>72<span class="fn-bracket">]</span></a></span><a class="headerlink" href="#id276" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</li>
<li><p>Convert normalized texture coordinates into actual memory addresses.</p></li>
</ul>
</li>
<li><p>Texture Fetching</p>
<ul class="simple">
<li><p>Retrieve texels (texture elements) from texture memory (L1 texture cache,
then L2/VRAM on miss).</p></li>
<li><p>Handle different texture layouts:
- 1D, 2D, 3D textures
- Cubemaps
- Texture arrays</p></li>
<li><p>Support compressed texture formats (e.g., DXT, ASTC, ETC2).</p></li>
</ul>
</li>
<li><p>Texture Filtering</p>
<p>Give a Texture coordinates, OpenGL has to figure out which <strong>texture pixel
(also known as a texel)</strong> to map the texture coordinate to.</p>
<ul>
<li><p>Perform <em>interpolation</em> between texels to produce smooth visual results.</p></li>
<li><p>Filtering requires multiple texel reads + weighted average calculations.</p></li>
<li><p>Common filtering modes as the following are shown as
<a class="reference internal" href="#texture-filter"><span class="std std-numref">Fig. 132</span></a>:</p>
<ul>
<li><p>Nearest-neighbor (point sampling) (GL_NEAREST)</p>
<ul>
<li><p>When set to GL_NEAREST, OpenGL selects the color of the texel that
center is closest to the texture coordinate shown as the example in
<a class="reference internal" href="#nearest"><span class="std std-numref">Fig. 130</span></a>. ‘+’ is the coordinates of texel.
‘Returns’ is the color of result.</p>
<figure class="align-center" id="id277">
<span id="nearest"></span><a class="reference internal image-reference" href="_images/nearest.png"><img alt="_images/nearest.png" height="98" src="_images/nearest.png" width="162" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 130 </span><span class="caption-text">GL_NEAREST <a class="footnote-reference brackets" href="#texturewrapper" id="id140" role="doc-noteref"><span class="fn-bracket">[</span>72<span class="fn-bracket">]</span></a></span><a class="headerlink" href="#id277" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</li>
</ul>
</li>
<li><p>Bilinear (GL_LINEAR)</p>
<ul>
<li><p>The return color is the mix of four neighboring pixels. The smaller
the distance from the texture coordinate to a texel’s center, the more
that texel’s color contributes to the sampled color shown as the
example in <a class="reference internal" href="#linear"><span class="std std-numref">Fig. 131</span></a>.</p>
<figure class="align-center" id="id278">
<span id="linear"></span><a class="reference internal image-reference" href="_images/linear.png"><img alt="_images/linear.png" height="97" src="_images/linear.png" width="152" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 131 </span><span class="caption-text">GL_LINEAR <a class="footnote-reference brackets" href="#texturewrapper" id="id141" role="doc-noteref"><span class="fn-bracket">[</span>72<span class="fn-bracket">]</span></a></span><a class="headerlink" href="#id278" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</li>
</ul>
</li>
<li><p>Trilinear (with mipmaps)</p></li>
<li><p>Anisotropic filtering (for angled surfaces)</p></li>
<li><p>Let’s see how these methods work when using a texture with a low
resolution on a large object (texture is therefore scaled upwards and
individual texels are noticeable). The GL_NEAREST and GL_LINEAR as the
following <a class="reference internal" href="#texture-filter"><span class="std std-numref">Fig. 132</span></a>.
As result, GL_LINEAR produces a more blurred color and smooth edge’s
output.</p>
<figure class="align-center" id="id279">
<span id="texture-filter"></span><a class="reference internal image-reference" href="_images/texture-filter.png"><img alt="_images/texture-filter.png" height="534" src="_images/texture-filter.png" width="1080" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 132 </span><span class="caption-text">Texture Filter: GL_NEAREST has sharp color and jagged edge
<a class="footnote-reference brackets" href="#texturewrapper" id="id142" role="doc-noteref"><span class="fn-bracket">[</span>72<span class="fn-bracket">]</span></a></span><a class="headerlink" href="#id279" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Mipmap Level of Detail (LOD) Selection</p>
<ul class="simple">
<li><p>Choose the correct mipmap level based on screen-space derivatives of
texture coordinates.</p></li>
<li><p>Prevent aliasing and improve cache efficiency.</p></li>
<li><p>Optionally blend between mip levels for trilinear filtering.</p></li>
</ul>
</li>
<li><p>Texture Caching</p>
<ul class="simple">
<li><p>TMUs have a <strong>dedicated texture cache</strong> optimized for 2D/3D spatial
locality.</p></li>
<li><p>Neighboring threads in a Warp often fetch adjacent texels, improving cache
hits.</p></li>
<li><p>Caches reduce memory latency and improve bandwidth utilization.</p></li>
</ul>
</li>
<li><p>Specialized Operations</p>
<ul class="simple">
<li><p>Texture gather: fetch 4 neighboring texels around a coordinate.</p></li>
<li><p>Shadow mapping: compare fetched depth texel against reference value.</p></li>
<li><p>Multisample textures: fetch per-sample data for MSAA.</p></li>
<li><p>Border color application for out-of-bounds accesses.</p></li>
</ul>
</li>
</ol>
<p>Microarchitecture Aspects</p>
<ul class="simple">
<li><p>Each <strong>Streaming Multiprocessor (SM)</strong> or <strong>Compute Unit (CU)</strong> is paired
with several TMUs.</p></li>
<li><p>The number of TMUs is a key spec in GPU datasheets (e.g., “64 TMUs”).</p></li>
<li><p>TMU throughput is often measured in <strong>texels per clock cycle</strong>.</p></li>
<li><p>Modern GPUs balance <strong>TMUs per ALU</strong> to ensure shading and texture workloads
are not bottlenecked.</p></li>
</ul>
<p>Performance Considerations</p>
<ul class="simple">
<li><p><strong>Bandwidth-limited</strong>: TMUs rely heavily on memory bandwidth. Mipmapping
and caches reduce this pressure.</p></li>
<li><p><strong>Latency hiding</strong>: texture fetches may take hundreds of cycles, so GPUs
rely on massive multithreading to hide stalls.</p></li>
<li><p><strong>Workload dependent</strong>: texture-heavy games or rendering pipelines are
often limited by TMU throughput.</p></li>
</ul>
<p>Summary</p>
<p>TMUs are highly specialized GPU units that:</p>
<ul class="simple">
<li><p>Translate texture coordinates into addresses.</p></li>
<li><p>Fetch texels efficiently with dedicated caches.</p></li>
<li><p>Perform filtering and LOD computations in hardware.</p></li>
<li><p>Deliver high throughput for texture operations that are essential
in realistic rendering.</p></li>
</ul>
<p>Without TMUs, all these operations would fall on general-purpose ALUs,
resulting in drastically lower performance and efficiency.</p>
</section>
<section id="render-output-units-rops">
<h4><a class="toc-backref" href="#id352" role="doc-backlink">Render Output Units (ROPs) <a class="footnote-reference brackets" href="#rops" id="id143" role="doc-noteref"><span class="fn-bracket">[</span>111<span class="fn-bracket">]</span></a></a><a class="headerlink" href="#render-output-units-rops" title="Link to this heading">¶</a></h4>
<p><strong>Function:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Processed Fragments → Pixels
</pre></div>
</div>
<p>Overview</p>
<p>Render Output Units (ROPs), also known as Raster Operations Pipelines, are the
final stage in the GPU graphics pipeline before pixel data is written to the
framebuffer. ROPs handle pixel-level operations such as blending, depth and
stencil testing, multisample resolve, and writing to memory. They are crucial
for assembling the final image that appears on screen.</p>
<p>Pipeline Responsibilities</p>
<ul class="simple">
<li><p><strong>Fragment Reception</strong>: Accepts shaded fragments from the pixel shader.</p></li>
<li><p><strong>Depth and Stencil Testing</strong>: Compares fragment depth/stencil values against
buffers.</p></li>
<li><p><strong>Blending</strong>: Combines fragment color with existing framebuffer data.</p></li>
<li><p><strong>Multisample Resolve</strong>: Merges multiple samples into a final pixel (for MSAA).</p></li>
<li><p><strong>Framebuffer Write</strong>: Commits final pixel data to memory for display.</p></li>
</ul>
<p>The pipeline flow is shown as <a class="reference internal" href="#render-output-pipeline"><span class="std std-numref">Fig. 133</span></a>.</p>
<figure class="align-default" id="id280">
<span id="render-output-pipeline"></span><div class="graphviz"><img src="_images/graphviz-0ca2a2f0f8a04076216e8e204670460ef2b3fc1c.png" alt="digraph RenderOutputPipeline {
    rankdir=LR;
    node [shape=box, style=filled, fillcolor=lightgray];

    FragmentShader -&gt; ROP_Unit;
    ROP_Unit -&gt; DepthStencilTest;
    DepthStencilTest -&gt; Blending;
    Blending -&gt; MSAAResolve;
    MSAAResolve -&gt; FramebufferWrite;

    ROP_Unit [label=&quot;ROP Unit&quot;, fillcolor=lightyellow];
    FramebufferWrite [label=&quot;Framebuffer Write&quot;, fillcolor=lightblue];
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 133 </span><span class="caption-text">The pipeline for Render Output Units (ROPs)</span><a class="headerlink" href="#id280" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Performance Considerations</p>
<ul class="simple">
<li><p><strong>ROP Count</strong>: More ROPs can increase pixel throughput, especially at high
resolutions.</p></li>
<li><p><strong>Memory Bandwidth</strong>: ROPs are tightly coupled with memory controllers;
bandwidth limits can bottleneck performance.</p></li>
<li><p><strong>Antialiasing Support</strong>: Hardware MSAA and resolve operations are often
implemented in ROPs.</p></li>
<li><p><strong>Compression</strong>: Some GPUs use framebuffer compression to reduce bandwidth
usage.</p></li>
</ul>
<p>Vendor-Specific Notes</p>
<ul class="simple">
<li><p><strong>NVIDIA</strong>: Refers to these units as ROPs; tightly integrated with memory
partitions.</p></li>
<li><p><strong>AMD</strong>: Calls them Render Backends (RBs); RDNA architecture decouples ROPs
from shader engines.</p></li>
<li><p><strong>Intel &amp; ARM</strong>: Implement simplified ROPs for power-efficient mobile
rendering.</p></li>
</ul>
<p>References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Render_output_unit">Render Output Unit - Wikipedia</a></p></li>
<li><p><a class="reference external" href="https://www.corsair.com/us/en/explorer/gamer/gaming-pcs/what-is-a-rop-on-a-gpu/">What is a ROP on a GPU? - CORSAIR</a></p></li>
<li><p><a class="reference external" href="https://www.techpowerup.com/forums/threads/rops-and-tmus-what-is-it.227596/">TechPowerUp Forums: ROPs and TMUs</a></p></li>
</ul>
</section>
</section>
<section id="system-features-buffers">
<h3><a class="toc-backref" href="#id353" role="doc-backlink">System Features – Buffers</a><a class="headerlink" href="#system-features-buffers" title="Link to this heading">¶</a></h3>
<p>CPU and GPU provides different
Buffers to speedup OpenGL pipeline rendering <a class="footnote-reference brackets" href="#buffers-redbook" id="id144" role="doc-noteref"><span class="fn-bracket">[</span>48<span class="fn-bracket">]</span></a>.</p>
<table class="docutils align-default" id="id281">
<caption><span class="caption-number">Table 55 </span><span class="caption-text">Graphics Buffers</span><a class="headerlink" href="#id281" title="Link to this table">¶</a></caption>
<colgroup>
<col style="width: 20.0%" />
<col style="width: 10.0%" />
<col style="width: 14.0%" />
<col style="width: 16.0%" />
<col style="width: 20.0%" />
<col style="width: 20.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Buffer Type</p></th>
<th class="head"><p>Access</p></th>
<th class="head"><p>Location</p></th>
<th class="head"><p>API/Usage</p></th>
<th class="head"><p>Function</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Vertex Buffer (VBO)</p></td>
<td><p>Read</p></td>
<td><p>GPU</p></td>
<td><p>OpenGL, Vulkan</p></td>
<td><p>Store vertex attributes</p></td>
<td><p>Holds data like position, normal, and texture coords for drawing geometry.</p></td>
</tr>
<tr class="row-odd"><td><p>Index Buffer (IBO/EBO)</p></td>
<td><p>Read</p></td>
<td><p>GPU</p></td>
<td><p>OpenGL, Vulkan</p></td>
<td><p>Reuse vertex data</p></td>
<td><p>Stores indices into the vertex buffer to avoid duplication.</p></td>
</tr>
<tr class="row-even"><td><p>Uniform Buffer (UBO)</p></td>
<td><p>Read</p></td>
<td><p>GPU or Shared</p></td>
<td><p>OpenGL, Vulkan</p></td>
<td><p>Constant input data</p></td>
<td><p>Shares transformation matrices, lighting, or material data across shaders.</p></td>
</tr>
<tr class="row-odd"><td><p>Shader Storage Buffer (SSBO)</p></td>
<td><p>Read/Write</p></td>
<td><p>GPU or Shared</p></td>
<td><p>OpenGL, Vulkan</p></td>
<td><p>General data exchange</p></td>
<td><p>Flexible, large buffers accessible for structured shader I/O.</p></td>
</tr>
<tr class="row-even"><td><p>Constant Buffer</p></td>
<td><p>Read</p></td>
<td><p>GPU or Shared</p></td>
<td><p>DirectX, Vulkan</p></td>
<td><p>Fast uniform access</p></td>
<td><p>Optimized for fast access to frequently read small data.</p></td>
</tr>
<tr class="row-odd"><td><p>Image / Texture Buffer</p></td>
<td><p>Read/Write</p></td>
<td><p>GPU</p></td>
<td><p>OpenGL, Vulkan</p></td>
<td><p>Sample/store pixels</p></td>
<td><p>Stores image data for sampling or read/write image operations in shaders.</p></td>
</tr>
<tr class="row-even"><td><p>Color Buffer</p></td>
<td><p>Write</p></td>
<td><p>GPU</p></td>
<td><p>OpenGL, Vulkan</p></td>
<td><p>Store final pixel color</p></td>
<td><p>Stores output of fragment shaders; used for display or post-processing.</p></td>
</tr>
<tr class="row-odd"><td><p>Depth Buffer (Z-Buffer)</p></td>
<td><p>Write/Read</p></td>
<td><p>GPU</p></td>
<td><p>OpenGL, Vulkan</p></td>
<td><p>Visibility testing</p></td>
<td><p>Stores per-pixel depth values for hidden surface removal.</p></td>
</tr>
<tr class="row-even"><td><p>Frame Buffer</p></td>
<td><p>Write</p></td>
<td><p>GPU</p></td>
<td><p>OpenGL, Vulkan</p></td>
<td><p>Store render output</p></td>
<td><p>Holds final color, depth, or other rendered output.</p></td>
</tr>
<tr class="row-odd"><td><p>Stencil Buffer</p></td>
<td><p>Read/Write</p></td>
<td><p>GPU</p></td>
<td><p>OpenGL, Vulkan</p></td>
<td><p>Pixel masking</p></td>
<td><p>Used to conditionally discard or preserve pixels in the pipeline.</p></td>
</tr>
</tbody>
</table>
<ul>
<li><p>Color buffer</p>
<p>They contain the RGB or sRGB color data and may also contain alpha values for
each pixel in the framebuffer. There may be multiple color buffers in a
framebuffer.
You’ve already used double buffering for animation. Double buffering is done
by making the main color buffer have two parts: a front buffer that’s displayed
in your window; and a back buffer, which is where you render the new image
<a class="footnote-reference brackets" href="#redbook-p155" id="id145" role="doc-noteref"><span class="fn-bracket">[</span>84<span class="fn-bracket">]</span></a>.</p>
</li>
<li><p>Depth buffer (Z buffer)</p>
<p>Depth is measured in terms of distance to the eye, so pixels with larger
depth-buffer values are overwritten by pixels with smaller values
<a class="footnote-reference brackets" href="#redbook-p156" id="id146" role="doc-noteref"><span class="fn-bracket">[</span>85<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#z-buffer-wiki" id="id147" role="doc-noteref"><span class="fn-bracket">[</span>87<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#depthstencils-ogl" id="id148" role="doc-noteref"><span class="fn-bracket">[</span>88<span class="fn-bracket">]</span></a>.</p>
</li>
<li><p>Frame Buffer</p>
<p>OpenGL offers: the color, depth and stencil buffers.
This combination of buffers is known as the default framebuffer and as you’ve
seen, a framebuffer is an area in memory that can be rendered to
<a class="footnote-reference brackets" href="#framebuffers-ogl" id="id149" role="doc-noteref"><span class="fn-bracket">[</span>90<span class="fn-bracket">]</span></a>.</p>
</li>
<li><p>Stencil Buffer</p>
<p>In the simplest case, the stencil buffer is used to limit the area of
rendering (stenciling) <a class="footnote-reference brackets" href="#stencils-buffer-wiki" id="id150" role="doc-noteref"><span class="fn-bracket">[</span>89<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#depthstencils-ogl" id="id151" role="doc-noteref"><span class="fn-bracket">[</span>88<span class="fn-bracket">]</span></a>.</p>
</li>
</ul>
<table class="docutils align-default" id="id282">
<caption><span class="caption-number">Table 56 </span><span class="caption-text">Compute Buffers</span><a class="headerlink" href="#id282" title="Link to this table">¶</a></caption>
<colgroup>
<col style="width: 20.0%" />
<col style="width: 10.0%" />
<col style="width: 14.0%" />
<col style="width: 16.0%" />
<col style="width: 20.0%" />
<col style="width: 20.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Buffer Type</p></th>
<th class="head"><p>Access</p></th>
<th class="head"><p>Location</p></th>
<th class="head"><p>API/Usage</p></th>
<th class="head"><p>Function</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Compute Buffer</p></td>
<td><p>Read/Write</p></td>
<td><p>GPU or Shared</p></td>
<td><p>OpenCL, Vulkan, CUDA</p></td>
<td><p>Parallel compute data</p></td>
<td><p>Buffers used in compute kernels or shaders for general processing.</p></td>
</tr>
<tr class="row-odd"><td><p>Atomic Buffer</p></td>
<td><p>Read/Write (Atomic)</p></td>
<td><p>GPU</p></td>
<td><p>OpenGL, Vulkan</p></td>
<td><p>Shared counters/data</p></td>
<td><p>Used with atomic ops for synchronization or accumulation.</p></td>
</tr>
<tr class="row-even"><td><p>Acceleration Structure Buffer</p></td>
<td><p>Read</p></td>
<td><p>GPU</p></td>
<td><p>Vulkan RT, DXR</p></td>
<td><p>Ray tracing acceleration</p></td>
<td><p>Holds spatial hierarchy (BVH) for ray traversal efficiency.</p></td>
</tr>
<tr class="row-odd"><td><p>Indirect Draw Buffer</p></td>
<td><p>Read</p></td>
<td><p>GPU</p></td>
<td><p>Vulkan, DirectX</p></td>
<td><p>GPU-issued draw</p></td>
<td><p>Stores draw/dispatch args to issue commands without CPU.</p></td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><p>DXR: DirectX Raytracing — a D3D12 extension for real-time ray tracing using
GPU acceleration.</p></li>
<li><p>Indirect Draw Buffer: A GPU-side buffer holding draw parameters so that GPU
(not CPU) can issue rendering work dynamically.</p></li>
</ul>
<table class="docutils align-default" id="id283">
<caption><span class="caption-number">Table 57 </span><span class="caption-text">System-Level and Utility Buffers</span><a class="headerlink" href="#id283" title="Link to this table">¶</a></caption>
<colgroup>
<col style="width: 20.0%" />
<col style="width: 10.0%" />
<col style="width: 14.0%" />
<col style="width: 16.0%" />
<col style="width: 20.0%" />
<col style="width: 20.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Buffer Type</p></th>
<th class="head"><p>Access</p></th>
<th class="head"><p>Location</p></th>
<th class="head"><p>API/Usage</p></th>
<th class="head"><p>Function</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Command Buffer</p></td>
<td><p>Write (CPU) / Read (GPU)</p></td>
<td><p>Host → GPU</p></td>
<td><p>Vulkan, DirectX12</p></td>
<td><p>Submit work</p></td>
<td><p>Encapsulates commands like draw, dispatch, and memory ops.</p></td>
</tr>
<tr class="row-odd"><td><p>Parking / Staging Buffer</p></td>
<td><p>Read/Write</p></td>
<td><p>Host-visible</p></td>
<td><p>Vulkan, CUDA</p></td>
<td><p>Temporary transfer</p></td>
<td><p>Temporary CPU-visible buffer for uploading/downloading GPU data.</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="software-structure">
<h2><a class="toc-backref" href="#id354" role="doc-backlink">Software Structure</a><a class="headerlink" href="#software-structure" title="Link to this heading">¶</a></h2>
<p>As the previous section illustrated, GPU is a SIMT (SIMD) for data parallel
application.
This section introduces the GPU evolved from Graphics GPU to the General
purpose GPU (GPGPU) and the software architecture of GPUs and explores AI
software frameworks designed for GPUs, NPUs, and CPUs.</p>
<section id="general-purpose-gpu">
<h3><a class="toc-backref" href="#id355" role="doc-backlink">General purpose GPU</a><a class="headerlink" href="#general-purpose-gpu" title="Link to this heading">¶</a></h3>
<p>Since GLSL shaders provide a general way for writing C code in them, if applying
a software frame work instead of OpenGL API, then the system can run some data
parallel computation on GPU for speeding up and even get CPU and GPU executing
simultaneously. Furthmore, any language that allows the code running on the CPU to poll
a GPU shader for return values, can create a GPGPU framework <a class="footnote-reference brackets" href="#gpgpuwiki" id="id152" role="doc-noteref"><span class="fn-bracket">[</span>91<span class="fn-bracket">]</span></a>.</p>
<section id="mapping-data-in-gpu">
<span id="id153"></span><h4><a class="toc-backref" href="#id356" role="doc-backlink">Mapping data in GPU</a><a class="headerlink" href="#mapping-data-in-gpu" title="Link to this heading">¶</a></h4>
<p>As described in the previous section on GPUs, the subset of the array
calculation <cite>y[] = a * x[] + y[]</cite> is shown as follows:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>// Invoke DAXPY with 256 threads per Thread Block
__host__
int nblocks = (n+255) / 256;
daxpy&lt;&lt;&lt;nblocks, 256&gt;&gt;&gt;(n, 2.0, x, y);
// DAXPY in CUDA
__device__
void daxpy(int n, double a, double *x, double *y) {
  int i = blockIdx.x*blockDim.x + threadIdx.x;
  if (i &lt; n) y[i] = a*x[i] + y[i];
}
</pre></div>
</div>
<ul class="simple">
<li><p>name&lt;&lt;&lt;dimGrid, dimBlock&gt;&gt;&gt;(… parameter list …):</p>
<ul>
<li><p>dimGrid: Number of Blocks in Grid</p></li>
<li><p>dimBlock: 256 Threads in Block</p></li>
</ul>
</li>
</ul>
<p class="rubric">Assembly code of PTX (from page 300 of Quantitative book)</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>// code to set VLR, Vector Length Register, to (n % 256)
//   ...
//
shl.u32 R8, blockIdx, 9       ; Thread Block ID * Block size (512)
add.u32 R8, R8, threadIdx     ; R8 = i = my CUDA Thread ID
shl.u32 R8, R8, 3             ; byte offset
setp.neq.s32 P1, RD8, RD3     ; RD3 = n, P1 is predicate register 1
ld.global.f64 RD0, [X+R8]     ; RD0 = X[i]
ld.global.f64 RD2, [Y+R8]     ; RD2 = Y[i]
mul.f64 RD0, RD0, RD4         ; Product in RD0 = RD0 * RD4 (scalar a)
add.f64 RD0, RD0, RD2         ; SuminRD0 = RD0 + RD2 (Y[i])
st.global.f64 [Y+R8], RD0     ; Y[i] = sum (X[i]*a + Y[i])
</pre></div>
</div>
<ul class="simple">
<li><p>Need to set VLR if PTX has this instruction. Otherwise, set lane-mask in
the similar way of the code below.</p></li>
</ul>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>__device__
void lane-mask-ex( double *X, double *Y, double *Z) {
  if (X[i] != 0)
    X[i] = X[i] – Y[i];
  else X[i] = Z[i];
}
</pre></div>
</div>
<p class="rubric">Assembly code of Vector Processor</p>
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span><span class="nf">LV</span><span class="w"> </span><span class="no">V1</span><span class="p">,</span><span class="no">Rx</span><span class="w">         </span><span class="c1">;load vector X into V1</span>
<span class="nf">LV</span><span class="w"> </span><span class="no">V2</span><span class="p">,</span><span class="no">Ry</span><span class="w">         </span><span class="c1">;load vector Y</span>
<span class="nf">L.D</span><span class="w"> </span><span class="no">F0</span><span class="p">,</span><span class="mi">#0</span><span class="w">        </span><span class="c1">;load FP zero into F0</span>
<span class="nf">SNEVS.D</span><span class="w"> </span><span class="no">V1</span><span class="p">,</span><span class="no">F0</span><span class="w">    </span><span class="c1">;sets VM(i) to 1 if V1(i)!=F0</span>
<span class="nf">SUBVV.D</span><span class="w"> </span><span class="no">V1</span><span class="p">,</span><span class="no">V1</span><span class="p">,</span><span class="no">V2</span><span class="w"> </span><span class="c1">;subtract under vector mask</span>
<span class="nf">SV</span><span class="w"> </span><span class="no">V1</span><span class="p">,</span><span class="no">Rx</span><span class="w">         </span><span class="c1">;store the result in X</span>
</pre></div>
</div>
<p class="rubric">Assembly code of PTX (modified code from refering page 208 - 302 of
Quantitative book)</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>ld.global.f64 RD0, [X+R9]     ; RD0 = X[i]
setp.neq.s32 P1, RD0, #0      ; P1 is predicate register 1
@!P1, bra ELSE1, *Push        ; Push old mask, set new mask bits
                              ; if P1 false, go to ELSE1
ld.global.f64 RD2, [Y+R8]     ; RD2 = Y[i]
sub.f64 RD0, RD0, RD2         ; Difference in RD0
st.global.f64 [X+R8], RD0     ; X[i]=RD0
ELSE1:
ld.global.f64 RD0, [Z+R8]     ; RD0 = Z[i]
st.global.f64 [X+R8], RD0     ; X[i] = RD0
ENDIF1:
ret, *Pop                     ; pop to restore old mask
</pre></div>
</div>
<ul class="simple">
<li><p>For Lane Mask, refer to <a class="footnote-reference brackets" href="#vmr" id="id154" role="doc-noteref"><span class="fn-bracket">[</span>104<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#quantitative-gpu-asm-daxpy" id="id155" role="doc-noteref"><span class="fn-bracket">[</span>105<span class="fn-bracket">]</span></a>.</p></li>
</ul>
<p>The following table explains how the elements of <cite>saxpy()</cite> are mapped to the
Lanes of a SIMD Thread (Warp), which belongs to a Thread Block (Core) within
a Grid.</p>
<table class="docutils align-default" id="id284">
<caption><span class="caption-number">Table 58 </span><span class="caption-text">Mapping saxpy code to <a class="reference internal" href="#grid"><span class="std std-numref">Fig. 116</span></a>.</span><a class="headerlink" href="#id284" title="Link to this table">¶</a></caption>
<colgroup>
<col style="width: 10.0%" />
<col style="width: 21.2%" />
<col style="width: 68.8%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>saxpy(()</p></th>
<th class="head"><p>Instance in <a class="reference internal" href="#grid"><span class="std std-numref">Fig. 116</span></a></p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>blockDim.x</p></td>
<td><p>The index of Thread Block</p></td>
<td><p>blockDim: in this example configured as <a class="reference internal" href="#grid"><span class="std std-numref">Fig. 116</span></a> is 16(Thread Blocks) * 16(SIDM Threads) = 256</p></td>
</tr>
<tr class="row-odd"><td><p>blockIdx.x</p></td>
<td><p>The index of SIMD Thread</p></td>
<td><p>blockIdx: the index of Thread Block within the Grid</p></td>
</tr>
<tr class="row-even"><td><p>threadIdx.x</p></td>
<td><p>The index of elements</p></td>
<td><p>threadIdx: the index of the SIMD Thread within its Thread Block</p></td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><p>With Fermi, each 32-wide thread of SIMD instructions is mapped to 16 physical
SIMD Lanes, so each SIMD instruction in a thread of SIMD instructions takes
two clock cycles to complete.</p></li>
<li><p>You could say that it has 16 Lanes, the vector length would be 32, and the
Chime is 2 clock cycles.</p></li>
<li><p>The mape of <cite>y[0..31] = a * x[0..31] * y[0..31]</cite> to <cite>&lt;Core, Warp, Cuda Thread&gt;</cite>
of GPU as the following table. <cite>x[0..31]</cite> map to 32 Cuda Threads; <strong>two Cuda
Threads map to one SIMD Lane</strong> as <a class="reference internal" href="#warp-sched-pipeline"><span class="std std-numref">Fig. 115</span></a>..</p></li>
</ul>
<table class="docutils align-default" id="id285">
<caption><span class="caption-number">Table 59 </span><span class="caption-text">Map <cite>&lt;Core, Warp&gt;</cite> to saxpy</span><a class="headerlink" href="#id285" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><ul class="simple">
<li></li>
</ul>
</th>
<th class="head"><p>Warp-0</p></th>
<th class="head"><p>Warp-1</p></th>
<th class="head"><p>…</p></th>
<th class="head"><p>Warp-15</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Core-0</p></td>
<td><p>y[0..31] = a * x[0..31] * y[0..31]</p></td>
<td><p>y[32..63] = a * x[32..63] + y[32..63]</p></td>
<td><p>…</p></td>
<td><p>y[480..511] = a * x[480..511] + y[480..511]</p></td>
</tr>
<tr class="row-odd"><td><p>…</p></td>
<td><p>…</p></td>
<td><p>…</p></td>
<td><p>…</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-even"><td><p>Core-15</p></td>
<td><p>y[7680..7711] = a * …</p></td>
<td><p>…</p></td>
<td><p>…</p></td>
<td><p>y[8160..8191] = a * x[8160..8191] + y[8160..8191]</p></td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><p>Each Cuda Thread runs the GPU function code <cite>saxpy</cite>. Fermi has a register file
of size 32768 x 32-bit.
As shown in <a class="reference internal" href="#sm-left"><span class="std std-numref">Fig. 107</span></a>, the number of registers in a Thread Block is:
16 (SM) * 32 (Cuda Threads) * 64 (TLR, Thread Level Register) =
32768 x 32-bit (Register file).</p></li>
<li><p>When mapping to fragments/pixels in a graphics GPU, <cite>x[0..15]</cite> corresponds to
a two-dimensional tile of fragments/pixels at <cite>pixel[0..3][0..3]</cite>, since images
use tile-based grouping to cluster similar colors together.</p></li>
</ul>
</section>
<section id="work-between-cpu-and-gpu-in-cuda">
<h4><a class="toc-backref" href="#id357" role="doc-backlink">Work between CPU and GPU in Cuda</a><a class="headerlink" href="#work-between-cpu-and-gpu-in-cuda" title="Link to this heading">¶</a></h4>
<p>The previous <cite>daxpy()</cite> GPU code did not include the host (CPU) side code that
triggers the GPU function.</p>
<p>The following example shows the host (CPU) side of a CUDA program that calls
<cite>saxpy</cite> on the GPU <a class="footnote-reference brackets" href="#cudaex" id="id156" role="doc-noteref"><span class="fn-bracket">[</span>94<span class="fn-bracket">]</span></a>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>

<span class="n">__global__</span>
<span class="kt">void</span><span class="w"> </span><span class="n">saxpy</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="o">*</span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">d_x</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span><span class="w"> </span><span class="n">cudaMemcpyHostToDevice</span><span class="p">);</span>
<span class="w">  </span><span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">d_y</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span><span class="w"> </span><span class="n">cudaMemcpyHostToDevice</span><span class="p">);</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="n">saxpy</span><span class="o">&lt;&lt;&lt;</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">255</span><span class="p">)</span><span class="o">/</span><span class="mi">256</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="p">,</span><span class="w"> </span><span class="n">d_x</span><span class="p">,</span><span class="w"> </span><span class="n">d_y</span><span class="p">);</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">d_y</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span><span class="w"> </span><span class="n">cudaMemcpyDeviceToHost</span><span class="p">);</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <cite>main()</cite> function runs on the CPU, while <cite>saxpy()</cite> runs on the GPU.
The CPU copies data from <cite>x</cite> and <cite>y</cite> to the corresponding device arrays <cite>d_x</cite>
and <cite>d_y</cite> using <cite>cudaMemcpy</cite>.</p>
<p>The <cite>saxpy</cite> kernel is launched with the following statement:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">saxpy</span><span class="o">&lt;&lt;&lt;</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">255</span><span class="p">)</span><span class="o">/</span><span class="mi">256</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="p">,</span><span class="w"> </span><span class="n">d_x</span><span class="p">,</span><span class="w"> </span><span class="n">d_y</span><span class="p">);</span>
</pre></div>
</div>
<p>This launches the kernel with Thread Blocks containing 256 threads, and uses
integer arithmetic to determine the number of Thread Blocks needed to process
all <cite>N</cite> elements in the arrays. The expression <cite>(N+255)/256</cite> ensures full
coverage of the input data.</p>
<p>Using <cite>cudaMemcpyHostToDevice</cite> and <cite>cudaMemcpyDeviceToHost</cite>, the CPU can pass
data in <cite>x</cite> and <cite>y</cite> to the GPU, and retrieve the results back to <cite>y</cite>.</p>
<p>Since both memory transfers are handled by DMA and do not require CPU operation,
the performance can be improved by running CPU and GPU independently, each
accessing their own cache.</p>
<p>After the DMA copy from CPU memory to GPU memory, the GPU performs the full
matrix operation loop for <cite>y[] = a * x[] + y[];</cite> using a single Grid of threads.</p>
<p>DMA <cite>memcpy</cite> maps the data in CPU memory to each L1 cache of a core on GPU
memory.</p>
<p>Many GPUs support scatter and gather operations to access DRAM efficiently
for stream processing tasks <a class="footnote-reference brackets" href="#quantitative-gpu-sparse-matrix" id="id157" role="doc-noteref"><span class="fn-bracket">[</span>106<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#gpgpuwiki" id="id158" role="doc-noteref"><span class="fn-bracket">[</span>91<span class="fn-bracket">]</span></a>
<a class="footnote-reference brackets" href="#shadingl1" id="id159" role="doc-noteref"><span class="fn-bracket">[</span>107<span class="fn-bracket">]</span></a>.</p>
<p>When the GPU function is dense computation in array such as MPEG4 encoder or
deep learning for tuning weights, it may get much speed up <a class="footnote-reference brackets" href="#mpeg4speedup" id="id160" role="doc-noteref"><span class="fn-bracket">[</span>108<span class="fn-bracket">]</span></a>.
However when GPU function is matrix addition and CPU will idle for waiting
GPU’s result. It may slow down than doing matrix addition by CPU only.
Arithmetic intensity is defined as the number of operations performed per word of
memory transferred. It is important for GPGPU applications to have high arithmetic
intensity else the memory access latency will limit computational speedup
<a class="footnote-reference brackets" href="#gpgpuwiki" id="id161" role="doc-noteref"><span class="fn-bracket">[</span>91<span class="fn-bracket">]</span></a>.</p>
<p>Wiki here <a class="footnote-reference brackets" href="#gpuspeedup" id="id162" role="doc-noteref"><span class="fn-bracket">[</span>109<span class="fn-bracket">]</span></a> includes GPU-accelerated applications for speedup
as follows:</p>
<p>General Purpose Computing on GPU, has found its way into fields as diverse as
machine learning, oil exploration, scientific image processing, linear algebra,
statistics, 3D reconstruction and even stock options pricing determination.
In addition, section “GPU accelerated video decoding and encoding” for video
compressing <a class="footnote-reference brackets" href="#gpuspeedup" id="id163" role="doc-noteref"><span class="fn-bracket">[</span>109<span class="fn-bracket">]</span></a> gives the more applications for GPU acceleration.</p>
<table class="docutils align-default" id="id286">
<caption><span class="caption-number">Table 60 </span><span class="caption-text">The differences for speedup in architecture of CPU and GPU</span><a class="headerlink" href="#id286" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Item</p></th>
<th class="head"><p>CPU</p></th>
<th class="head"><p>GPU</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Application</p></td>
<td><p>Non-data parallel</p></td>
<td><p>Data parallel</p></td>
</tr>
<tr class="row-odd"><td><p>Architecture</p></td>
<td><p>SISD, small vector (eg.4*32bits)</p></td>
<td><p>Large SIMD (eg.16*32bits)</p></td>
</tr>
<tr class="row-even"><td><p>Cache</p></td>
<td><p>Smaller and faster</p></td>
<td><p>Larger and slower (ref. The following Note)</p></td>
</tr>
<tr class="row-odd"><td><p>ILP</p></td>
<td><p>Pipeline</p></td>
<td><p>Pipeline</p></td>
</tr>
<tr class="row-even"><td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>Superscalar, SMT</p></td>
<td><p>SIMT</p></td>
</tr>
<tr class="row-odd"><td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>Super-pipeline</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>Core</p></td>
<td><p>Smaller threads for SMT (2 or 4)</p></td>
<td><p>Larger threads (16 or 32)</p></td>
</tr>
<tr class="row-odd"><td><p>Branch</p></td>
<td><p>Conditional-instructions</p></td>
<td><p>Mask &amp; conditional-instructions</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>GPU-Cache</strong></p>
<p>In theory, for data-parallel applications using GPU’s SMT, the GPU can schedule
more threads and aims for throughput rather than speedup of a single thread,
as seen in SISD on CPUs.</p>
<p>However, in practice, GPUs provide only a small L1 cache, similar to CPUs,
and handle cache misses by scheduling another thread.</p>
<p>As a result, GPUs often lack L2 and L3 caches, which are common in CPUs with
deeper cache hierarchies.</p>
</div>
</section>
</section>
<section id="opencl-vulkan-and-spir-v">
<h3><a class="toc-backref" href="#id358" role="doc-backlink">OpenCL, Vulkan and spir-v</a><a class="headerlink" href="#opencl-vulkan-and-spir-v" title="Link to this heading">¶</a></h3>
<figure class="align-default" id="id287">
<span id="spirv"></span><div class="graphviz"><img src="_images/graphviz-2bc5c5193c3ea5662118149e273bcb3969bcc50c.png" alt="digraph G {
  rankdir=LR;

  compound=true;
  node [shape=record];
  SW_LAYER [label=&quot;{ GLSL | OpenCL } | SPIR-V | GPU machine code&quot;];
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 134 </span><span class="caption-text">OpenCL and GLSL(OpenGL)</span><a class="headerlink" href="#id287" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<table class="docutils align-default" id="id288">
<caption><span class="caption-number">Table 61 </span><span class="caption-text">OpenCL and OpenGL SW system</span><a class="headerlink" href="#id288" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Name of SW</p></th>
<th class="head"><p>GPU language</p></th>
<th class="head"><p>Level of GPU language</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>OpenCL</p></td>
<td><p>OpenCL</p></td>
<td><p>C99 dialect (with C pointer, …)</p></td>
</tr>
<tr class="row-odd"><td><p>OpenGL</p></td>
<td><p>GLSL</p></td>
<td><p>C-like (no C pointer, …)</p></td>
</tr>
<tr class="row-even"><td><p>Vulkan</p></td>
<td><p>SPIR-V</p></td>
<td><p>IR</p></td>
</tr>
</tbody>
</table>
<figure class="align-center" id="id289">
<span id="opencl-to-spirv"></span><a class="reference internal image-reference" href="_images/opencl-to-spirv-offine-compilation.png"><img alt="_images/opencl-to-spirv-offine-compilation.png" height="284" src="_images/opencl-to-spirv-offine-compilation.png" width="714" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 135 </span><span class="caption-text">Offline Compilation of OpenCL Kernels into SPIR-V Using Open Source Tooling <a class="footnote-reference brackets" href="#id194" id="id164" role="doc-noteref"><span class="fn-bracket">[</span>113<span class="fn-bracket">]</span></a></span><a class="headerlink" href="#id289" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<ul class="simple">
<li><p>clang: Compile OpenCL to spirv for runtime+driver. Or compile OpenCL to llvm, then
“SPIR-V LLVM Translator” translate llvm to spirv for runtime+driver.</p></li>
<li><p>clspv: Compile OpenCL to spirv directly.</p></li>
</ul>
<figure class="align-default" id="id290">
<span id="gpu-compiler-toolchain"></span><div class="graphviz"><img src="_images/graphviz-eaa1c1adef57f7a08f883ff241a92b8badf1ea7a.png" alt="digraph ShaderToLLVMIR {
    rankdir=LR;
    node [shape=record, style=filled, color=black];

    // Source Languages
    GLSL [label=&quot;GLSL ES (OpenGL)&quot;, fillcolor=white];
    OpenCL_C [label=&quot;OpenCL C&quot;, fillcolor=white];

    // Intermediate Representation
    SPIRV [label=&quot;SPIR-V&quot;, fillcolor=orange];

    GPU_ISA [label=&quot;GPU ISA in Assembly and Binary&quot;, fillcolor=grey];

    // LLVM IR
    LLVM_IR [label=&quot;LLVM IR&quot;, fillcolor=orange];

    // Tools with oval shapes
    node [shape=oval, style=filled, fillcolor=lightgreen];
    Glslang [label=&quot;glslangValidator&quot;, fillcolor=lightblue];
    CL_SPIRV [label=&quot;OpenCL-SPIRV Translator&quot;];

    // Tools with oval shapes
    node [shape=oval, style=filled, fillcolor=yellow];
    SPIRV_LLVM [label=&quot;SPIRV-LLVM Translator&quot;];
    LLVMCompiler [label=&quot;Backend Compiler&quot;];

    // Edges
    GLSL -&gt; Glslang -&gt; SPIRV;
    OpenCL_C -&gt; CL_SPIRV -&gt; SPIRV -&gt;  SPIRV_LLVM -&gt; LLVM_IR -&gt; LLVMCompiler -&gt; GPU_ISA;
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 136 </span><span class="caption-text">GPU Compiler Components and Flow</span><a class="headerlink" href="#id290" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The flow and relationships among GLSL, OpenCL, SPIR-V (Vulkan/OpenCL), LLVM IR,
and the GPU compiler are shown in the <a class="reference internal" href="#spirv"><span class="std std-numref">Fig. 134</span></a>,
<a class="reference internal" href="#opencl-to-spirv"><span class="std std-numref">Fig. 135</span></a> and <a class="reference internal" href="#gpu-compiler-toolchain"><span class="std std-numref">Fig. 136</span></a>.
As shown in <a class="reference internal" href="#gpu-compiler-toolchain"><span class="std std-numref">Fig. 136</span></a>, OpenCL-C to SPIR-V (OpenCL) can
be compiled using <strong>clang + llvm-spirv</strong> tools or a proprietary converter.</p>
<p>As shown in <a class="reference internal" href="#gpu-compiler-toolchain"><span class="std std-numref">Fig. 136</span></a>, both GLSL and OpenCL use frontend
tools to generate SPIR-V.
The driver can invoke either the GLSL or OpenCL compiler based on metadata
fields in the SPIR-V, as illustrated in <a class="reference internal" href="#spirv-deploy"><span class="std std-numref">Fig. 137</span></a> and the
following figures, which describe offline compilation from GLSL/OpenCL to
SPIR-V and online execution using the generated SPIR-V files.</p>
<figure class="align-default" id="id291">
<span id="spirv-deploy"></span><div class="graphviz"><img src="_images/graphviz-2bc7461ac50af10b847453fe0da75d1a3ddf5bf7.png" alt="digraph SPIRV_Deployment {
    rankdir=LR;
    node [shape=box, style=filled, fillcolor=lightgray, fontname=&quot;Helvetica&quot;];

    subgraph cluster_glsl {
        label = &quot;From GLSL&quot;;
        glsl_src [label=&quot;GLSL Shader\n (.vert/.frag/.comp)&quot;, fillcolor=lightblue];
        glsl_compiler [label=&quot;glslangValidator\n(or similar compiler)&quot;, fillcolor=lightgreen];
        spirv_glsl [label=&quot;SPIR-V\n (from GLSL)&quot;, fillcolor=gold];
        glsl_src -&gt; glsl_compiler -&gt; spirv_glsl;
    }

    subgraph cluster_opencl {
        label = &quot;From OpenCL C&quot;;
        opencl_src [label=&quot;OpenCL C (.cl)&quot;, fillcolor=lightblue];
        clang_spirv [label=&quot;Clang + SPIR-V Backend&quot;, fillcolor=lightgreen];
        spirv_opencl [label=&quot;SPIR-V\n (from OpenCL C)&quot;, fillcolor=gold];
        opencl_src -&gt; clang_spirv -&gt; spirv_opencl;
    }

    subgraph cluster_opencl_runtime {
        label = &quot;OpenCL Runtime (Host)&quot;;
        spirv_loader [label=&quot;clCreateProgramWithIL()&quot;, fillcolor=orange];
        spirv_glsl -&gt; spirv_loader;
        spirv_opencl -&gt; spirv_loader;
        spirv_loader -&gt; device_driver [label=&quot;Load\n SPIR-V\n into driver&quot;];
        device_driver [label=&quot;OpenCL Driver\n(SPIR-V → Device IR → Machine Code)&quot;, fillcolor=plum];
        device_driver -&gt; execution [label=&quot;Compiled &amp;\n Run on device&quot;];
        execution [label=&quot;Execute on\n OpenCL Device&quot;, fillcolor=lightyellow];
    }

    // Styling
    edge [fontname=&quot;Helvetica&quot;];
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 137 </span><span class="caption-text">Compiling and Deploying GPU Code from GLSL, Vulkan, and OpenCL</span><a class="headerlink" href="#id291" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Based on the flows above, the public standards OpenGL and OpenCL provide
tools for transferring these data format, as illustrated in
<a class="reference internal" href="#glsl-spirv"><span class="std std-numref">Fig. 138</span></a>.
The corresponding LLVM IR and SPIR-V formats are listed below.</p>
<figure class="align-default" id="id292">
<span id="glsl-spirv"></span><div class="graphviz"><img src="_images/graphviz-e76f03aa0cacc2b0edb5a70fc6147e5f3dbd12fa.png" alt="digraph G {
  rankdir=LR;

  // Data Nodes
  node [shape=record, style=filled, fillcolor=white];
  glsl [label=&quot;glsl&quot;];
  openclc [label=&quot;OpenCL C&quot;];
  spirv [label=&quot;spirv&quot;];
  llvm [label=&quot;llvm-ir&quot;];

  // Tools Nodes
  node [shape=oval, style=filled, fillcolor=lightgreen];
  glslang [label=&quot;glslangValidator&quot;];
  spirv_cross [label=&quot;spirv-cross&quot;];
  clspv [label=&quot;clspv&quot;];
  llvm_spirv [label=&quot;llvm-spirv&quot;];

  glsl -&gt; glslang -&gt; spirv;
  glsl -&gt; spirv_cross -&gt; spirv [dir=&quot;back&quot;];
  openclc -&gt; clspv -&gt; spirv;
  openclc -&gt; clspv -&gt; spirv [dir=&quot;back&quot;];
  spirv -&gt; llvm_spirv -&gt; llvm;
  llvm -&gt; llvm_spirv -&gt; spirv;
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 138 </span><span class="caption-text">Convertion between GLSL, OpenCL C, SPIRV-V and LLVM-IR</span><a class="headerlink" href="#id292" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p class="rubric">References/add-matrix.ll</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>; ModuleID = &#39;add-matrix.ll&#39;
target datalayout = &quot;e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v16:16:16-v24:32:32-v32:32:32-v48:64:64-v64:64:64-v96:128:128-v128:128:128-v192:256:256-v256:256:256-v512:512:512-v1024:1024:1024-G1&quot;
target triple = &quot;spir64-unknown-unknown&quot;

; Function Attrs: nounwind
define spir_func &lt;4 x i32&gt; @add_mat(&lt;4 x i32&gt; %a, &lt;4 x i32&gt; %b) #0 {
entry:
  %sum = add &lt;4 x i32&gt; %a, %b
  ret &lt;4 x i32&gt; %sum
}

attributes #0 = { nounwind }

!spirv.MemoryModel = !{!0}
!opencl.enable.FP_CONTRACT = !{}
!spirv.Source = !{!1}
!opencl.spir.version = !{!2}
!opencl.used.extensions = !{!3}
!opencl.used.optional.core.features = !{!3}
!spirv.Generator = !{!4}

!0 = !{i32 2, i32 2}
!1 = !{i32 0, i32 0}
!2 = !{i32 1, i32 2}
!3 = !{}
!4 = !{i16 6, i16 14}
</pre></div>
</div>
<p class="rubric">References/add-matrix.spvasm</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">;</span> <span class="n">SPIR</span><span class="o">-</span><span class="n">V</span>
<span class="p">;</span> <span class="n">Version</span><span class="p">:</span> <span class="mf">1.0</span>
<span class="p">;</span> <span class="n">Generator</span><span class="p">:</span> <span class="n">Khronos</span> <span class="n">LLVM</span><span class="o">/</span><span class="n">SPIR</span><span class="o">-</span><span class="n">V</span> <span class="n">Translator</span><span class="p">;</span> <span class="mi">14</span>
<span class="p">;</span> <span class="n">Bound</span><span class="p">:</span> <span class="mi">10</span>
<span class="p">;</span> <span class="n">Schema</span><span class="p">:</span> <span class="mi">0</span>
               <span class="n">OpCapability</span> <span class="n">Addresses</span>
               <span class="n">OpCapability</span> <span class="n">Linkage</span>
               <span class="n">OpCapability</span> <span class="n">Kernel</span>
          <span class="o">%</span><span class="mi">1</span> <span class="o">=</span> <span class="n">OpExtInstImport</span> <span class="s2">&quot;OpenCL.std&quot;</span>
               <span class="n">OpMemoryModel</span> <span class="n">Physical64</span> <span class="n">OpenCL</span>
               <span class="n">OpSource</span> <span class="n">Unknown</span> <span class="mi">0</span>
               <span class="n">OpName</span> <span class="o">%</span><span class="n">add_mat</span> <span class="s2">&quot;add_mat&quot;</span>
               <span class="n">OpName</span> <span class="o">%</span><span class="n">a</span> <span class="s2">&quot;a&quot;</span>
               <span class="n">OpName</span> <span class="o">%</span><span class="n">b</span> <span class="s2">&quot;b&quot;</span>
               <span class="n">OpName</span> <span class="o">%</span><span class="n">entry</span> <span class="s2">&quot;entry&quot;</span>
               <span class="n">OpName</span> <span class="o">%</span><span class="nb">sum</span> <span class="s2">&quot;sum&quot;</span>
               <span class="n">OpDecorate</span> <span class="o">%</span><span class="n">add_mat</span> <span class="n">LinkageAttributes</span> <span class="s2">&quot;add_mat&quot;</span> <span class="n">Export</span>
       <span class="o">%</span><span class="n">uint</span> <span class="o">=</span> <span class="n">OpTypeInt</span> <span class="mi">32</span> <span class="mi">0</span>
     <span class="o">%</span><span class="n">v4uint</span> <span class="o">=</span> <span class="n">OpTypeVector</span> <span class="o">%</span><span class="n">uint</span> <span class="mi">4</span>
          <span class="o">%</span><span class="mi">4</span> <span class="o">=</span> <span class="n">OpTypeFunction</span> <span class="o">%</span><span class="n">v4uint</span> <span class="o">%</span><span class="n">v4uint</span> <span class="o">%</span><span class="n">v4uint</span>
    <span class="o">%</span><span class="n">add_mat</span> <span class="o">=</span> <span class="n">OpFunction</span> <span class="o">%</span><span class="n">v4uint</span> <span class="kc">None</span> <span class="o">%</span><span class="mi">4</span>
          <span class="o">%</span><span class="n">a</span> <span class="o">=</span> <span class="n">OpFunctionParameter</span> <span class="o">%</span><span class="n">v4uint</span>
          <span class="o">%</span><span class="n">b</span> <span class="o">=</span> <span class="n">OpFunctionParameter</span> <span class="o">%</span><span class="n">v4uint</span>
      <span class="o">%</span><span class="n">entry</span> <span class="o">=</span> <span class="n">OpLabel</span>
        <span class="o">%</span><span class="nb">sum</span> <span class="o">=</span> <span class="n">OpIAdd</span> <span class="o">%</span><span class="n">v4uint</span> <span class="o">%</span><span class="n">a</span> <span class="o">%</span><span class="n">b</span>
               <span class="n">OpReturnValue</span> <span class="o">%</span><span class="nb">sum</span>
               <span class="n">OpFunctionEnd</span>
</pre></div>
</div>
<p class="rubric">Convert between spirv and llvm-ir</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">% </span><span class="nb">pwd</span>
<span class="gp">$</span>HOME/git/lbd/References
<span class="gp">% </span>llvm-as<span class="w"> </span>-o<span class="w"> </span>add-matrix.bc<span class="w"> </span>add-matrix.ll
<span class="gp">% </span>llvm-spirv<span class="w"> </span>-o<span class="w"> </span>add-matrix.spv<span class="w"> </span>add-matrix.bc
<span class="gp">% </span>spirv-dis<span class="w"> </span>-o<span class="w"> </span>add-matrix.spvasm<span class="w"> </span>add-matrix.spv
<span class="go">// Convert spirv to llvm-ir again and check the converted llvm-ir is same</span>
<span class="go">// with origin.</span>
<span class="gp">% </span>llvm-spirv<span class="w"> </span>-r<span class="w"> </span>add-matrix.spv<span class="w"> </span>-o<span class="w"> </span>add-matrix.spv.bc
<span class="gp">% </span>llvm-dis<span class="w"> </span>add-matrix.spv.bc<span class="w"> </span>-o<span class="w"> </span>add-matrix.spv.bc.ll
<span class="gp">% </span>diff<span class="w"> </span>add-matrix.ll<span class="w"> </span>add-matrix.spv.bc.ll
<span class="go">1c1</span>
<span class="go">&lt; ; ModuleID = &#39;add-matrix.ll&#39;</span>
<span class="go">---</span>
<span class="go">&gt; ; ModuleID = &#39;add-matrix.spv.bc&#39;</span>
</pre></div>
</div>
<p class="rubric">Install llvm-spriv and llvm with Brew-install</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">% </span>brew<span class="w"> </span>install<span class="w"> </span>spirv-llvm-translator
<span class="gp">% </span>brew<span class="w"> </span>install<span class="w"> </span>llvm
</pre></div>
</div>
<p><strong>The following explains how the driver identifies whether the SPIR-V source is
from GLSL or OpenCL.</strong></p>
<p>SPIR-V binaries contain metadata that can help identify whether they
were generated from OpenCL, GLSL, or another language.</p>
<ul>
<li><p>Execution Model</p>
<p>Defined by the <cite>OpEntryPoint</cite> instruction. It is a strong indicator
of the source language.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>ExecutionModel</p></th>
<th class="head"><p>Typical Source</p></th>
<th class="head"><p>Notes</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Kernel</p></td>
<td><p>OpenCL</p></td>
<td><p>Used only by OpenCL C</p></td>
</tr>
<tr class="row-odd"><td><p>GLCompute</p></td>
<td><p>GLSL or HLSL</p></td>
<td><p>Used in compute shaders</p></td>
</tr>
<tr class="row-even"><td><p>Fragment</p></td>
<td><p>GLSL or HLSL</p></td>
<td><p>For pixel shaders</p></td>
</tr>
<tr class="row-odd"><td><p>Vertex</p></td>
<td><p>GLSL or HLSL</p></td>
<td><p>For vertex shaders</p></td>
</tr>
</tbody>
</table>
</li>
<li><p>Capabilities</p>
<p>Declared using <cite>OpCapability</cite>. They provide clues about the SPIR-V’s
execution model and source.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Capability</p></th>
<th class="head"><p>Likely Source</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Kernel</p></td>
<td><p>OpenCL</p></td>
</tr>
<tr class="row-odd"><td><p>Addresses</p></td>
<td><p>OpenCL</p></td>
</tr>
<tr class="row-even"><td><p>Linkage</p></td>
<td><p>OpenCL</p></td>
</tr>
<tr class="row-odd"><td><p>Shader</p></td>
<td><p>GLSL or HLSL</p></td>
</tr>
</tbody>
</table>
</li>
<li><p>Extensions</p>
<p>Declared using <cite>OpExtension</cite>. Some are tied to specific compilers
or languages.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Extension</p></th>
<th class="head"><p>Likely Source</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>SPV_KHR_no_integer_wrap_decoration</p></td>
<td><p>OpenCL</p></td>
</tr>
<tr class="row-odd"><td><p>SPV_INTEL_unified_shared_memory</p></td>
<td><p>OpenCL (Intel)</p></td>
</tr>
<tr class="row-even"><td><p>SPV_AMD_shader_ballot</p></td>
<td><p>GLSL (graphics)</p></td>
</tr>
</tbody>
</table>
</li>
<li><p>Memory Model</p>
<p>Defined by <cite>OpMemoryModel</cite>.</p>
<ul class="simple">
<li><p><cite>OpenCL</cite>    → OpenCL source</p></li>
<li><p><cite>GLSL450</cite>   → GLSL or HLSL source</p></li>
</ul>
</li>
<li><p>How to Inspect</p>
<p>Use the <cite>spirv-dis</cite> tool to disassemble SPIR-V to human-readable form:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>spirv-dis<span class="w"> </span>kernel.spv<span class="w"> </span>-o<span class="w"> </span>kernel.spvasm
</pre></div>
</div>
<p>Look for these at the top of the file:</p>
<p>Example (GLSL):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>OpCapability Shader
OpMemoryModel Logical GLSL450
OpEntryPoint GLCompute %main &quot;main&quot;
</pre></div>
</div>
<p>Example (OpenCL):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>OpCapability Kernel
OpCapability Addresses
OpMemoryModel Logical OpenCL
OpEntryPoint Kernel %foo &quot;foo&quot;
</pre></div>
</div>
</li>
</ul>
<section id="summary">
<h4><a class="toc-backref" href="#id359" role="doc-backlink">Summary</a><a class="headerlink" href="#summary" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Feature</p></th>
<th class="head"><p>Indicates</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>OpEntryPoint Kernel</p></td>
<td><p>OpenCL</p></td>
</tr>
<tr class="row-odd"><td><p>OpCapability Shader</p></td>
<td><p>GLSL or HLSL</p></td>
</tr>
<tr class="row-even"><td><p>OpMemoryModel OpenCL</p></td>
<td><p>OpenCL</p></td>
</tr>
<tr class="row-odd"><td><p>OpMemoryModel GLSL450</p></td>
<td><p>GLSL or HLSL</p></td>
</tr>
</tbody>
</table>
<ul>
<li><p>Comparsion for OpenCL and OpenGL’s compute shader.</p>
<ul>
<li><p>Same:</p>
<p>Both are for General Computing of GPU.</p>
</li>
<li><p>Difference:</p>
<p>OpenCL include GPU and other accelerate device/processor.
OpenCL is C language on Device and C++ on Host based on OpenCL runtime.
Compute shader is GLSL shader language run on OpenGL graphic enviroment and
integrate and access data of OpenGL API easily <a class="footnote-reference brackets" href="#diff-compute-shader-opencl" id="id165" role="doc-noteref"><span class="fn-bracket">[</span>112<span class="fn-bracket">]</span></a>.</p>
</li>
</ul>
</li>
<li><p>OpenGL/GLSL vs Vulkan/spir-v.</p>
<ul class="simple">
<li><p>High level of API and shader: OpenGL, GLSL.</p></li>
<li><p>Low level of API and shader: Vulkan, spir-v.</p></li>
</ul>
</li>
</ul>
<p>Though OpenGL api existed in higher level with many advantages from sections
above, sometimes it cannot compete in efficience with direct3D providing
lower levels api for operating memory by user program <a class="footnote-reference brackets" href="#vulkanapiwiki" id="id166" role="doc-noteref"><span class="fn-bracket">[</span>114<span class="fn-bracket">]</span></a>.
Vulkan api is lower level’s C/C++ api to fill the gap allowing user program to
do these things in OpenGL to compete against Microsoft direct3D.
Here is an example <a class="footnote-reference brackets" href="#vulkanex" id="id167" role="doc-noteref"><span class="fn-bracket">[</span>115<span class="fn-bracket">]</span></a>. Meanwhile glsl is C-like language. The vulkan
infrastructure provides tool, glslangValidator <a class="footnote-reference brackets" href="#spirvtoolchain" id="id168" role="doc-noteref"><span class="fn-bracket">[</span>116<span class="fn-bracket">]</span></a>, to compile
glsl into an Intermediate Representation
Form (IR) called spir-v off-line.
As a result, it saves part of compilation time from glsl to gpu instructions
on-line
since spir-v is an IR of level closing to llvm IR <a class="footnote-reference brackets" href="#spirvwiki" id="id169" role="doc-noteref"><span class="fn-bracket">[</span>117<span class="fn-bracket">]</span></a>.
In addition, vulkan api reduces gpu drivers efforts in optimization and code
generation <a class="footnote-reference brackets" href="#vulkanapiwiki" id="id170" role="doc-noteref"><span class="fn-bracket">[</span>114<span class="fn-bracket">]</span></a>. These standards provide user programmer option to
using vulkan/spir-v instead of OpenGL/glsl, and allow them pre-compiling glsl
into spir-v off-line to saving part of on-line compilation time.</p>
<p>With vulkan and spir-v standard, the gpu can be used in OpenCL for Parallel
Programming of Heterogeneous Systems <a class="footnote-reference brackets" href="#opencl" id="id171" role="doc-noteref"><span class="fn-bracket">[</span>118<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#computekernelwiki" id="id172" role="doc-noteref"><span class="fn-bracket">[</span>119<span class="fn-bracket">]</span></a>.
Similar with Cuda, a OpenCL example for fast Fourier transform (FFT) is here
<a class="footnote-reference brackets" href="#openclexfft" id="id173" role="doc-noteref"><span class="fn-bracket">[</span>120<span class="fn-bracket">]</span></a>.
Once OpenCL grows into a popular standard when more computer languages or
framework supporting OpenCL language, GPU will take more jobs from CPU
<a class="footnote-reference brackets" href="#opencl-wiki-supported-lang" id="id174" role="doc-noteref"><span class="fn-bracket">[</span>121<span class="fn-bracket">]</span></a>.</p>
<p>Most GPUs have 16 or 32 Lanes in a SIMD processor (Warp), vulkan provides
Subgroup operations to data parallel programming on Lanes of SIMD processor
<a class="footnote-reference brackets" href="#vulkan-subgroup" id="id175" role="doc-noteref"><span class="fn-bracket">[</span>122<span class="fn-bracket">]</span></a>.</p>
<p>Subgroup operations provide a fast way for moving data between Lanes intra Warp.
Assuming each Warp has eight Lanes.
The following table lists result of reduce, inclusive and exclusive operations.</p>
<table class="docutils align-default" id="id293">
<caption><span class="caption-number">Table 62 </span><span class="caption-text">Lists each Lane’s value after <strong>Reduce</strong>, <strong>Inclusive</strong> and
<strong>Exclusive</strong> operations repectively</span><a class="headerlink" href="#id293" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Lane</p></th>
<th class="head"><p>0</p></th>
<th class="head"><p>1</p></th>
<th class="head"><p>2</p></th>
<th class="head"><p>3</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Initial value</p></td>
<td><p>a</p></td>
<td><p>b</p></td>
<td><p>c</p></td>
<td><p>d</p></td>
</tr>
<tr class="row-odd"><td><p>Reduce</p></td>
<td><p>OP(abcd)</p></td>
<td><p>OP(abcd)</p></td>
<td><p>OP(abcd)</p></td>
<td><p>OP(abcd)</p></td>
</tr>
<tr class="row-even"><td><p>Inclusive</p></td>
<td><p>OP(a)</p></td>
<td><p>OP(ab)</p></td>
<td><p>OP(abc)</p></td>
<td><p>OP(abcd)</p></td>
</tr>
<tr class="row-odd"><td><p>Exclusive</p></td>
<td><p>not define</p></td>
<td><p>OP(a)</p></td>
<td><p>OP(ab)</p></td>
<td><p>OP(abc)</p></td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><p>Reduce: e.g. subgroupAdd. Inclusive: e.g. subgroupInclusiveAdd. Exclusive:
e.g. subgroupExclusiveAdd.</p></li>
<li><p>For examples:</p>
<ul>
<li><p>ADD operation: OP(abcd) = a+b+c+d.</p></li>
<li><p>MAX operation: OP(abc) = MAX(a,b,c).</p></li>
</ul>
</li>
<li><p>When Lane i is inactive, it is value is none.</p>
<ul>
<li><p>For instance of Lane 0 is inactive, then MUL operation: OP(abcd) = b*c*d.</p></li>
</ul>
</li>
</ul>
<p>The following is a code example.</p>
<p class="rubric">An example of subgroup operations in glsl for vulkan</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">vec4</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec4</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">gl_SubgroupInvocationID</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">16u</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">subgroupAdd</span><span class="p">(</span><span class="n">in</span><span class="p">[</span><span class="n">gl_SubgroupInvocationID</span><span class="p">]);</span>
<span class="p">}</span>
<span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">subgroupInclusiveMul</span><span class="p">(</span><span class="n">in</span><span class="p">[</span><span class="n">gl_SubgroupInvocationID</span><span class="p">]);</span>
<span class="p">}</span>
<span class="n">subgroupMemoryBarrier</span><span class="p">();</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Nvidia’s GPU provides __syncWarp() for subgroupMemoryBarrier() or compiler to
sync for the Lanes in the same Warp.</p></li>
</ul>
<p>In order to let Lanes in the same SIMD processor work efficently, data unifomity
analysis will provide many optimization opporturnities in register allocation,
transformation and code generation <a class="footnote-reference brackets" href="#llvm-uniformity" id="id176" role="doc-noteref"><span class="fn-bracket">[</span>123<span class="fn-bracket">]</span></a>.</p>
<p>LLVM IR expansion from CPU to GPU is becoming increasingly influential.
In fact, LLVM IR has been expanding steadily from version 3.1 until now,
as I have observed.</p>
</section>
</section>
<section id="unified-ir-conversion-flows">
<h3><a class="toc-backref" href="#id360" role="doc-backlink">Unified IR Conversion Flows</a><a class="headerlink" href="#unified-ir-conversion-flows" title="Link to this heading">¶</a></h3>
<section id="graphics-and-opencl-compilation">
<h4><a class="toc-backref" href="#id361" role="doc-backlink">Graphics and OpenCL Compilation</a><a class="headerlink" href="#graphics-and-opencl-compilation" title="Link to this heading">¶</a></h4>
<p>This section outlines the intermediate representation (IR) flows for graphics
(Microsoft DirectX, OpenGL) and OpenCL compilation across major GPU vendors:
NVIDIA, AMD, ARM, Imagination Technologies, and Apple.</p>
</section>
<section id="graphics-compilation-flow-microsoft-directx-opengl">
<h4><a class="toc-backref" href="#id362" role="doc-backlink">Graphics Compilation Flow (Microsoft DirectX &amp; OpenGL)</a><a class="headerlink" href="#graphics-compilation-flow-microsoft-directx-opengl" title="Link to this heading">¶</a></h4>
<p>Graphics shaders are compiled from high-level languages (HLSL, GLSL) into
vendor-specific GPU binaries via intermediate representations like DXIL and
SPIR-V.</p>
<p class="rubric">✅ Each node in the graph is color-coded to indicate its category
or role within the structure.</p>
<div class="graphviz"><img src="_images/graphviz-a74f6bea943a022cb282ae6be819852518bafa2b.png" alt="digraph G {
    node [shape=box, style=filled];
    PUIR [label=&quot;Public standard of IRs&quot;, fillcolor=lightyellow];
    PRIR [label=&quot;Private IRs&quot;, fillcolor=lightgray];
    VD [label=&quot;Vendor Driver&quot;, shape=oval, fillcolor=lightgreen];
    GPU [label=&quot;GPU&quot;, fillcolor=lightblue];
}" class="graphviz" /></div>
<ul class="simple">
<li><p><strong>Vendor Driver will call Vendor Compiler</strong> for on-line compilation.</p></li>
</ul>
<figure class="align-default" id="id294">
<span id="ogl-ocl-flow"></span><div class="graphviz"><img src="_images/graphviz-f31784f2c1cea659a3c6e4c51e4c5a3c00dee795.png" alt="digraph OpenCL_OpenGL_Compilation {
    rankdir=LR;
    node [shape=box];

    // Source Languages
    OpenCL_C [style=filled, fillcolor=lightyellow];
    GLSL [style=filled, fillcolor=lightyellow];

    // Shared IRs
    SPIR [style=filled, fillcolor=lightyellow];
    SPIRV [label=&quot;SPIR-V IR&quot;, style=filled, fillcolor=lightyellow];
    LLVM_IR [style=filled, fillcolor=lightyellow];

    // Vendor Drivers
    node [shape=oval];
    &quot;NVIDIA Driver&quot; [style=filled, fillcolor=lightgreen];
    &quot;AMD Driver&quot; [style=filled, fillcolor=lightgreen];
    &quot;ARM Driver&quot; [style=filled, fillcolor=lightgreen];
    &quot;Imagination Driver&quot; [style=filled, fillcolor=lightgreen];
    &quot;Apple Driver&quot; [style=filled, fillcolor=lightgreen];

    // Private IRs
    node [shape=box];
    &quot;PTX IR&quot; [style=filled, fillcolor=gray];
    &quot;GCN IR&quot; [style=filled, fillcolor=gray];
    &quot;Burst IR&quot; [style=filled, fillcolor=gray];
    &quot;Metal IR&quot; [style=filled, fillcolor=gray];

    // GPU Targets
    &quot;NVIDIA GPU ISA&quot; [style=filled, fillcolor=lightblue];
    &quot;AMD GPU ISA&quot; [style=filled, fillcolor=lightblue];
    &quot;ARM Mali ISA&quot; [style=filled, fillcolor=lightblue];
    &quot;Imagination USC ISA&quot; [style=filled, fillcolor=lightblue];
    &quot;Apple GPU ISA&quot; [style=filled, fillcolor=lightblue];

    // OpenCL Flow
    OpenCL_C -&gt; SPIR -&gt; LLVM_IR;
    OpenCL_C -&gt; SPIRV;

    // OpenGL Flow
    GLSL -&gt; SPIRV -&gt; LLVM_IR;

    // LLVM based Compilation Flow
    LLVM_IR -&gt; &quot;PTX IR&quot; -&gt; &quot;NVIDIA Driver&quot; -&gt; &quot;NVIDIA GPU ISA&quot;;
    LLVM_IR -&gt; &quot;GCN IR&quot; -&gt; &quot;AMD Driver&quot; -&gt; &quot;AMD GPU ISA&quot;;
    LLVM_IR -&gt; &quot;ARM Driver&quot; -&gt; &quot;ARM Mali ISA&quot;;
    LLVM_IR -&gt; &quot;Burst IR&quot; -&gt; &quot;Imagination Driver&quot; -&gt; &quot;Imagination USC ISA&quot;;
    LLVM_IR -&gt; &quot;Metal IR&quot; -&gt; &quot;Apple Driver&quot; -&gt; &quot;Apple GPU ISA&quot;;
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 139 </span><span class="caption-text">Graphics and OpenCL Compiler IR Conversion Flow</span><a class="headerlink" href="#id294" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<ul class="simple">
<li><p>OpenCL C is the device side code in C language while Host side code is C/C++.</p></li>
<li><p>OpenCL C is compiled to SPIR-V in later versions of OpenCL, while earlier
versions used SPIR.
SPIR-V has now largely replaced SPIR as the standard intermediate
representation.</p></li>
</ul>
<table class="docutils align-default" id="id295">
<caption><span class="caption-number">Table 63 </span><span class="caption-text">Comparison of PTX, GCN IR, Burst IR, and Metal IR</span><a class="headerlink" href="#id295" title="Link to this table">¶</a></caption>
<colgroup>
<col style="width: 20.0%" />
<col style="width: 40.0%" />
<col style="width: 40.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>IR Layer</p></th>
<th class="head"><p>Abstraction Level</p></th>
<th class="head"><p>Register Model</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>PTX (NVIDIA)</p></td>
<td><p>Virtual ISA; portable across GPU generations; hides hardware scheduling</p></td>
<td><p><strong>Virtual registers (%r, %f); mapped to physical registers during SASS
lowering</strong></p></td>
</tr>
<tr class="row-odd"><td><p>GCN IR (AMD)</p></td>
<td><p>Machine IR; tightly coupled to GCN/RDNA architecture; exposes Wavefront
semantics</p></td>
<td><p>Explicit vector (vN) and scalar (sN) registers; register pressure affects
occupancy.
<strong>AMD’s compiler backend can lower vector operations to scalar
instructions on low-end GPUs, while preserving vector operations on
high-end architectures</strong>.</p></td>
</tr>
<tr class="row-even"><td><p>Burst IR (Imagination)</p></td>
<td><p>Power-aware IR; optimized for burst-core scheduling and latency hiding</p></td>
<td><p><strong>Operand staging model; abstracted register usage; mapped late to USC
ISA</strong></p></td>
</tr>
<tr class="row-odd"><td><p>Metal IR (Apple)</p></td>
<td><p>LLVM-inspired IR; abstracted from developers; tuned for tile shading and
threadgroup fusion</p></td>
<td><p><strong>Region-based register allocation; dynamic renaming; not exposed as
physical register model</strong></p></td>
</tr>
</tbody>
</table>
<dl class="simple">
<dt>✅ NVIDIA, AMD, ARM and Imagination all have exposed LLVM IR and convert SPIR-V IR to LLVM IR.</dt><dd><ul class="simple">
<li><p>SPIR:</p>
<ul>
<li><p>For OpenCL development, the IR started from SPIR (LLVM-based IR).</p></li>
<li><p>SPIRV’s Limitation: tightly coupled to specific LLVM versions, making it
brittle across.</p></li>
</ul>
</li>
<li><p>SPIR-V:</p>
<ul>
<li><p>A complete redesign: binary format, not tied to LLVM.</p></li>
<li><p>Designed for Vulkan, but also supports OpenCL and OpenGL.</p></li>
<li><p>Enables cross-vendor portability, shader reflection, and custom extensions.</p></li>
<li><p>Used in graphics and compute pipelines, including ML workloads via Vulkan compute.</p></li>
<li><p>A Vulkan shader written in GLSL is compiled to SPIR-V, then passed to the GPU driver.</p></li>
<li><p>An OpenCL kernel written in C can be compiled to SPIR-V, then lowered to LLVM IR internally by vendors like AMD or NVIDIA.</p></li>
</ul>
</li>
</ul>
</dd>
</dl>
<p>⚠️  Apple</p>
<ul class="simple">
<li><p>Uses LLVM IR Partially. Apple supports SPIR-V in Metal and OpenCL, but
LLVM IR is not always exposed.</p></li>
<li><p>Metal shaders are compiled via MetalIR, which is LLVM-inspired but not
standard LLVM IR. Metal
IR is not standard LLVM IR and is not exposed to developers.</p></li>
<li><p>Apple’s ML compiler stack may use LLVM IR internally, but it’s
abstracted from developers.</p></li>
<li><p>Apple is not a vendor of GPU IP, so it does not expose LLVM IR in its ML
or graphics APIs for the reasons below:</p>
<ul>
<li><p>Security: opaque compilation prevents tampering</p></li>
<li><p>Performance tuning: Apple controls the entire stack for optimal hardware use</p></li>
<li><p>Developer simplicity: high-level APIs reduce friction</p></li>
</ul>
</li>
</ul>
<p>Notes:</p>
<ul class="simple">
<li><p><strong>HLSL → DXIL → DirectX</strong> is Microsoft’s graphics pipeline, used on Windows and Xbox.</p></li>
<li><p><strong>GLSL → SPIR-V → OpenGL/Vulkan</strong> is cross-platform and supported by all vendors.</p></li>
<li><p>Final GPU ISA varies by vendor:</p>
<ul>
<li><p>NVIDIA: PTX → SASS</p></li>
<li><p>AMD: LLVM IR → GCN/RDNA</p></li>
<li><p>ARM: Mali ISA</p></li>
<li><p>Imagination: USC ISA</p></li>
<li><p>Apple: Metal GPU ISA</p></li>
</ul>
</li>
</ul>
<p>Notes:</p>
<ul class="simple">
<li><p><strong>OpenCL C → SPIR → Vendor Driver → GPU ISA</strong> is the standard compilation path.</p></li>
<li><p>Some vendors (e.g., AMD, NVIDIA) may bypass SPIR and compile directly to LLVM IR or PTX.</p></li>
<li><p>Apple deprecated OpenCL in favor of Metal, but legacy support remains.</p></li>
</ul>
<section id="references">
<h5><a class="toc-backref" href="#id363" role="doc-backlink">References</a><a class="headerlink" href="#references" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>OpenCL Specification: <a class="reference external" href="https://www.khronos.org/opencl/">https://www.khronos.org/opencl/</a></p></li>
<li><p>SPIR-V Specification: <a class="reference external" href="https://www.khronos.org/spir">https://www.khronos.org/spir</a></p></li>
<li><p>DirectX Shader Compiler: <a class="reference external" href="https://github.com/microsoft/DirectXShaderCompiler">https://github.com/microsoft/DirectXShaderCompiler</a></p></li>
<li><p>Imagination E-Series GPU: <a class="reference external" href="https://www.imaginationtech.com/">https://www.imaginationtech.com/</a></p></li>
<li><p>Apple Metal API: <a class="reference external" href="https://developer.apple.com/metal/">https://developer.apple.com/metal/</a></p></li>
</ul>
</section>
</section>
<section id="ml-and-gpu-compilation">
<h4><a class="toc-backref" href="#id364" role="doc-backlink">ML and GPU Compilation</a><a class="headerlink" href="#ml-and-gpu-compilation" title="Link to this heading">¶</a></h4>
<p>This section outlines the intermediate representation (IR) flows used by
NVIDIA, AMD, and ARM in machine learning and GPU compilation pipelines.
It includes both inference engines and compiler toolchains.</p>
<p class="rubric">✅ Each node in the graph is color-coded to indicate its category
or role within the structure. In AI, usually use runtime
instead of driver for graphics.</p>
<div class="graphviz"><img src="_images/graphviz-8772109fe3076546cd98705888b9aaecefb3e1aa.png" alt="digraph G {
    node [shape=box, style=filled];
    PUIR [label=&quot;Public standard of IRs&quot;, fillcolor=lightyellow];
    PRIR [label=&quot;Private IRs&quot;, fillcolor=lightgray];
    VDLR [label=&quot;Vendor Driver,\nLibrary or Runtime&quot;, shape=oval, fillcolor=lightgreen];
    MA [label=&quot;Machine&quot;, fillcolor=lightblue];
}" class="graphviz" /></div>
<section id="nvidia-ir-conversion-flow">
<h5><a class="toc-backref" href="#id365" role="doc-backlink">NVIDIA IR Conversion Flow</a><a class="headerlink" href="#nvidia-ir-conversion-flow" title="Link to this heading">¶</a></h5>
<p>NVIDIA supports both TensorRT-based inference and MLIR-based compilation
targeting CUDA GPUs is shown as <a class="reference internal" href="#nvidia-flow"><span class="std std-numref">Fig. 140</span></a>.</p>
<figure class="align-default" id="id296">
<span id="nvidia-flow"></span><div class="graphviz"><img src="_images/graphviz-f0d821a0d32e00e60d167a124e2cd0b597d45b93.png" alt="digraph NVIDIA_IR_Flow {
        rankdir=LR;
  
        node [shape=box]; 
  
        ONNX [style=filled, fillcolor=lightyellow];
        &quot;TensorRT Graph IR&quot; [style=filled, fillcolor=lightgray];
        &quot;CUDA Kernel IR&quot; [style=filled, fillcolor=lightgray];
        PTX [style=filled, fillcolor=lightyellow];
        SASS [label=&quot;SASS (NVIDIA GPU ISA)&quot;, style=filled, fillcolor=lightblue];
        TensorRT [style=filled, shape=oval, fillcolor=lightgreen];

        TOSA [style=filled, fillcolor=lightyellow];
        &quot;MLIR GPU Dialects&quot; [style=filled, fillcolor=lightyellow];
        &quot;LLVM IR&quot; [style=filled, fillcolor=lightyellow];

        ONNX -&gt; &quot;TensorRT Graph IR&quot; -&gt; &quot;CUDA Kernel IR&quot; -&gt; PTX;
        &quot;TensorRT Graph IR&quot; -&gt; TensorRT;

        TOSA -&gt; &quot;MLIR GPU Dialects&quot; -&gt; &quot;LLVM IR&quot; -&gt; PTX -&gt; SASS;
    }" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 140 </span><span class="caption-text">NVIDIA IR Conversion Flow</span><a class="headerlink" href="#id296" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<ul class="simple">
<li><p>SASS stands for Streaming ASSembler, and it represents the native instruction
set architecture (ISA) for NVIDIA GPUs.</p></li>
<li><p>TensorRT is a C++ library and runtime developed by NVIDIA for deep learning
inference—the phase where trained models make predictions.</p>
<ul>
<li><p>It works with models trained in frameworks like TensorFlow, PyTorch, and
ONNX, converting them into highly optimized engines for execution on NVIDIA
hardware <a class="footnote-reference brackets" href="#tensor-rt-nvidia" id="id177" role="doc-noteref"><span class="fn-bracket">[</span>124<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#tensor-rt-geeks" id="id178" role="doc-noteref"><span class="fn-bracket">[</span>125<span class="fn-bracket">]</span></a>.</p></li>
</ul>
</li>
<li><p><strong>CUDA Kernel IR</strong> is a bridge between LLVM IR and PTX/SASS, or a direct
output from TensorRT.</p></li>
<li><p><strong>LLVM IR</strong> is foundational in many flows, but <strong>TensorRT may skip it</strong> and
directly emit CUDA kernels.</p></li>
<li><p>Although MLIR dialects may be publicly available, they are typically
hardware-dependent and tailored to specific vendors’ GPU architectures.
As a result, their applicability is limited to the corresponding hardware
platforms.</p></li>
<li><p>MLIR GPU Dialects is public but it is for Nvidia’s GPU.</p></li>
</ul>
</section>
<section id="amd-ir-conversion-flow">
<h5><a class="toc-backref" href="#id366" role="doc-backlink">AMD IR Conversion Flow</a><a class="headerlink" href="#amd-ir-conversion-flow" title="Link to this heading">¶</a></h5>
<p>AMD uses ROCm and MIOpen for ML workloads, with LLVM-based compilation targeting
GCN or RDNA architectures is shown as <a class="reference internal" href="#amd-flow"><span class="std std-numref">Fig. 141</span></a>.</p>
<figure class="align-default" id="id297">
<span id="amd-flow"></span><div class="graphviz"><img src="_images/graphviz-fed368fdc6ec7ac89af5ace4adb4a3026d732d5a.png" alt="digraph ROCm_Runtime_PyTorch_MIOpen_PreMLIR_Flow {
    rankdir=LR;
    node [shape=box];

    // Entry points
    PyTorch_Model [label=&quot;PyTorch Model&quot;, style=filled, fillcolor=lightyellow];
    ONNX_Model [label=&quot;ONNX Model&quot;, style=filled, fillcolor=lightyellow];
    MLIR_TOSA [label=&quot;MLIR (TOSA dialect)&quot;, style=filled, fillcolor=lightyellow];

    // Pre-MLIR optimization
    MIOpen_PreMLIR [label=&quot;MIOpen Graph IR (Pre-MLIR)&quot;, style=filled, fillcolor=gray];

    // Compilation layers
    ONNX_MLIR [label=&quot;ONNX-MLIR&quot;, style=filled, fillcolor=lightyellow];
    MLIR_GPU [label=&quot;MLIR GPU dialect&quot;, style=filled, fillcolor=lightyellow];
    LLVM_IR [style=filled, fillcolor=lightyellow];
    ROCm_BC [label=&quot;ROCm device libraries (.bc)&quot;, shape=oval, style=filled, fillcolor=lightgreen];
    GCN_IR [style=filled, fillcolor=gray];

    // Post-GCN optimization
    MIOpen_IR [label=&quot;MIOpen Graph IR (Post-GCN)&quot;, style=filled, fillcolor=gray];

    // Runtime layers
    ROCr_Runtime [label=&quot;ROCr Runtime&quot;, shape=oval, style=filled, fillcolor=lightgreen];

    // GPU Targets
    GPU [label=&quot;AMD GPU ISA&quot;, style=filled, fillcolor=lightblue];
 
   // Flow paths
    PyTorch_Model -&gt; ONNX_Model;
    ONNX_Model -&gt; MIOpen_PreMLIR -&gt; ONNX_MLIR -&gt; LLVM_IR;
    MLIR_TOSA -&gt; MLIR_GPU -&gt; LLVM_IR;

    LLVM_IR -&gt; ROCm_BC;
    LLVM_IR -&gt; GCN_IR;
    GCN_IR -&gt; MIOpen_IR -&gt; ROCr_Runtime -&gt; GPU;

    // === Layering for better spacing ===
    { rank = same; MIOpen_PreMLIR; ONNX_MLIR }
    { rank = same; GCN_IR; MIOpen_IR }
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 141 </span><span class="caption-text">AMD IR Conversion Flow</span><a class="headerlink" href="#id297" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<ul class="simple">
<li><p><strong>ROCm</strong> is not just a compiler or driver — it includes a full runtime stack that
enables AMD GPUs to execute compute workloads across HIP
(Heterogeneous-compute Interface for Portability), OpenCL, and ML frameworks.
It’s <strong>analogous to NVIDIA’s CUDA runtime</strong> but built around open standards like
HSA (Heterogeneous System Architecture) <a class="footnote-reference brackets" href="#hsa" id="id179" role="doc-noteref"><span class="fn-bracket">[</span>126<span class="fn-bracket">]</span></a>  and LLVM.</p></li>
<li><p><strong>MIOpen Graph IR</strong> includes different form and structure. <strong>(Pre-MLIR) and
(Post-GCN)</strong> are different.</p>
<ul>
<li><p>Developers interact with MIOpen via high-level APIs
(e.g., miopenConvolutionForward) — not via direct IR manipulation.</p></li>
<li><p>While MIOpen itself is open source (GitHub repo), its graph IR format and
transformation passes are internal.</p></li>
</ul>
</li>
</ul>
</section>
<section id="arm-ir-conversion-flow">
<h5><a class="toc-backref" href="#id367" role="doc-backlink">ARM IR Conversion Flow</a><a class="headerlink" href="#arm-ir-conversion-flow" title="Link to this heading">¶</a></h5>
<p>ARM supports both CPU/NPU deployment (e.g., Ethos-U/N) and GPU execution (e.g.,
Mali via Vulkan). The IR flow diverges depending on the target is shown as
<a class="reference internal" href="#arm-flow"><span class="std std-numref">Fig. 142</span></a>.</p>
<figure class="align-default" id="id298">
<span id="arm-flow"></span><div class="graphviz"><img src="_images/graphviz-e1785d61ff2b3a5f41391d63e07907232fc16857.png" alt="digraph ARM_IR_Flow {
        rankdir=LR;

        node [shape=box];

        &quot;ONNX / TFLite&quot; [style=filled, fillcolor=lightyellow];
        TOSA [style=filled, fillcolor=lightyellow];
        &quot;MLIR Dialects&quot; [style=filled, fillcolor=lightgray];
        &quot;LLVM IR&quot; [style=filled, fillcolor=lightyellow];
        &quot;ARM Codegen&quot; [style=filled, shape=oval, fillcolor=white];
        &quot;Ethos-N / Cortex-M&quot; [style=filled, fillcolor=lightblue];
        &quot;MLIR GPU Dialects&quot; [style=filled, fillcolor=lightgray];
        SPIRV [style=filled, fillcolor=lightyellow];
        &quot;Mali GPU (Vulkan)&quot; [style=filled, fillcolor=lightblue];
        &quot;Ethos-N Driver&quot; [style=filled, shape=oval, fillcolor=lightgreen];
        Vulkan [style=filled, shape=oval, fillcolor=lightgreen];

        &quot;ONNX / TFLite&quot; -&gt; TOSA;

        TOSA -&gt; &quot;MLIR Dialects&quot; -&gt; &quot;LLVM IR&quot; -&gt; &quot;ARM Codegen&quot; -&gt;
        &quot;Ethos-N / Cortex-M&quot;;
        &quot;ARM Codegen&quot; -&gt; &quot;Ethos-N Driver&quot;;

        TOSA -&gt; &quot;MLIR GPU Dialects&quot; -&gt; SPIRV -&gt; &quot;Mali GPU (Vulkan)&quot;;
        SPIRV -&gt; Vulkan;
    }" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 142 </span><span class="caption-text">ARM IR Conversion Flow</span><a class="headerlink" href="#id298" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<ul class="simple">
<li><p>Node <strong>“Mali GPU (Vulkan)”</strong> is the SPIR-V compilation flow that illustrated in
the previous section.</p></li>
<li><p><strong>Ethos-N</strong> is ARM’s NPU. <strong>Cortex-M</strong> is ARM’s CPU.</p></li>
</ul>
<p><strong>ARM Codegen</strong> generally emits instructions for CPU/NPU execution, but for
certain NN operations (especially those requiring vendor-specific acceleration),
it may generate function calls into the Ethos-N driver, which then orchestrates
execution on the NPU.</p>
<p>✅ Common Case: Direct NPU/CPU Instruction Generation</p>
<ul class="simple">
<li><p>For operations that are well-supported by the NPU or CPU, the codegen backend
emits hardware-specific instructions or IR directly.</p></li>
<li><p>These are scheduled for execution on the CPU or passed to the Ethos-N via its
driver stack.</p></li>
</ul>
<p>⚙️ Special Case: Function Calls to Ethos-N Driver</p>
<ul class="simple">
<li><p>For complex or fused neural network operations (e.g., custom activation
functions, quantized convolutions, or optimized memory layouts), the codegen
may emit calls <strong>(LLVM-IR `call`)</strong> to precompiled driver functions.</p></li>
<li><p>These function calls act as entry points into the Ethos-N runtime, which
handles:</p>
<ul>
<li><p>Memory management</p></li>
<li><p>Scheduling</p></li>
<li><p>Firmware-level execution</p></li>
<li><p>Hardware-specific optimizations</p></li>
</ul>
</li>
</ul>
</section>
<section id="imagination-technologies-ir-conversion-flow">
<h5><a class="toc-backref" href="#id368" role="doc-backlink">Imagination Technologies IR Conversion Flow</a><a class="headerlink" href="#imagination-technologies-ir-conversion-flow" title="Link to this heading">¶</a></h5>
<figure class="align-default" id="id299">
<span id="imagination-flow"></span><div class="graphviz"><img src="_images/graphviz-797a8d509dbc0f3a61853b8bbb53d9c85da82e44.png" alt="digraph Imagination_IR_Flow {
        rankdir=LR;
        node [shape=box];

        &quot;ONNX / TFLite&quot; [style=filled, fillcolor=lightyellow];
        TVM [style=filled, fillcolor=lightgreen];
        oneAPI [style=filled, fillcolor=lightgreen];
        OpenCL [style=filled, fillcolor=lightgreen];
        &quot;E-Series Compiler IR&quot; [style=filled, fillcolor=lightgray];
        &quot;Burst Processor IR&quot; [style=filled, fillcolor=lightgray];
        &quot;Neural Core Execution&quot; [style=filled, fillcolor=lightblue];

        &quot;ONNX / TFLite&quot; -&gt; TVM -&gt; &quot;E-Series Compiler IR&quot; -&gt; &quot;Burst Processor IR&quot; -&gt; &quot;Neural Core Execution&quot;;
        &quot;ONNX / TFLite&quot; -&gt; oneAPI -&gt; &quot;E-Series Compiler IR&quot;;
        &quot;ONNX / TFLite&quot; -&gt; OpenCL -&gt; &quot;E-Series Compiler IR&quot;;
    }" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 143 </span><span class="caption-text">Imagination Technologies IR Conversion Flow</span><a class="headerlink" href="#id299" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Notes:</p>
<ul class="simple">
<li><p>E-Series GPUs support up to <strong>200 TOPS INT8/FP8</strong> for edge AI workloads [B](<a class="reference external" href="https://www.techpowerup.com/336545/imagination-announces-e-series-gpu-ip-with-burst-processors-and-up-to-200-tops?copilot_analytics_metadata=eyJldmVudEluZm9fY29udmVyc2F0aW9uSWQiOiJMSlNQWjRaWjY5Y2ZuN0VnWnJEVzEiLCJldmVudEluZm9fbWVzc2FnZUlkIjoidVZhb2U4blgyYVVQb1pQdWlKZ0FzIiwiZXZlbnRJbmZvX2NsaWNrRGVzdGluYXRpb24iOiJodHRwczpcL1wvd3d3LnRlY2hwb3dlcnVwLmNvbVwvMzM2NTQ1XC9pbWFnaW5hdGlvbi1hbm5vdW5jZXMtZS1zZXJpZXMtZ3B1LWlwLXdpdGgtYnVyc3QtcHJvY2Vzc29ycy1hbmQtdXAtdG8tMjAwLXRvcHMiLCJldmVudEluZm9fY2xpY2tTb3VyY2UiOiJjaXRhdGlvbkxpbmsifQ%3D%3D&amp;citationMarker=9F742443-6C92-4C44-BF58-8F5A7C53B6F1">https://www.techpowerup.com/336545/imagination-announces-e-series-gpu-ip-with-burst-processors-and-up-to-200-tops?copilot_analytics_metadata=eyJldmVudEluZm9fY29udmVyc2F0aW9uSWQiOiJMSlNQWjRaWjY5Y2ZuN0VnWnJEVzEiLCJldmVudEluZm9fbWVzc2FnZUlkIjoidVZhb2U4blgyYVVQb1pQdWlKZ0FzIiwiZXZlbnRJbmZvX2NsaWNrRGVzdGluYXRpb24iOiJodHRwczpcL1wvd3d3LnRlY2hwb3dlcnVwLmNvbVwvMzM2NTQ1XC9pbWFnaW5hdGlvbi1hbm5vdW5jZXMtZS1zZXJpZXMtZ3B1LWlwLXdpdGgtYnVyc3QtcHJvY2Vzc29ycy1hbmQtdXAtdG8tMjAwLXRvcHMiLCJldmVudEluZm9fY2xpY2tTb3VyY2UiOiJjaXRhdGlvbkxpbmsifQ%3D%3D&amp;citationMarker=9F742443-6C92-4C44-BF58-8F5A7C53B6F1</a>).</p></li>
<li><p>The architecture is <strong>programmable</strong>, supporting <strong>graphics and AI</strong> workloads simultaneously.</p></li>
<li><p>Developers can target the GPU using <strong>OpenCL</strong>, <strong>Apache TVM</strong>, or <strong>oneAPI</strong>.</p></li>
<li><p>The <strong>Burst Processor IR</strong> optimizes power efficiency and memory locality.</p></li>
<li><p>Final execution occurs on <strong>Neural Cores</strong>, deeply integrated into the GPU.</p></li>
</ul>
</section>
<section id="comparison-summary">
<h5><a class="toc-backref" href="#id369" role="doc-backlink">Comparison Summary</a><a class="headerlink" href="#comparison-summary" title="Link to this heading">¶</a></h5>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Vendor</p></th>
<th class="head"><p>High-Level IR</p></th>
<th class="head"><p>Mid-Level IR</p></th>
<th class="head"><p>Low-Level IR</p></th>
<th class="head"><p>Libraries / Runtimes</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>NVIDIA</p></td>
<td><p>ONNX, TensorRT IR</p></td>
<td><p>MLIR GPU Dialects</p></td>
<td><p>PTX → SASS</p></td>
<td><p>TensorRT</p></td>
</tr>
<tr class="row-odd"><td><p>AMD</p></td>
<td><p>ONNX, MIOpen IR</p></td>
<td><p>MLIR Dialects</p></td>
<td><p>LLVM IR → GCN ISA</p></td>
<td><p>MIOpen, ROCm</p></td>
</tr>
<tr class="row-even"><td><p>ARM</p></td>
<td><p>ONNX, TFLite</p></td>
<td><p>TOSA, MLIR Dialects</p></td>
<td><p>LLVM IR / SPIR-V</p></td>
<td><p>Ethos-N Driver, Vulkan</p></td>
</tr>
<tr class="row-odd"><td><p>Imagination</p></td>
<td><p>ONNX, TFLite</p></td>
<td><p>E-Series Compiler IR</p></td>
<td><p>Burst IR → Neural Core</p></td>
<td><p>OpenCL, TVM, oneAPI</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id180">
<h5><a class="toc-backref" href="#id370" role="doc-backlink">References</a><a class="headerlink" href="#id180" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>NVIDIA TensorRT: <a class="reference external" href="https://developer.nvidia.com/tensorrt">https://developer.nvidia.com/tensorrt</a></p></li>
<li><p>AMD ROCm: <a class="reference external" href="https://rocm.docs.amd.com/">https://rocm.docs.amd.com/</a></p></li>
<li><p>ARM ML Toolchain: <a class="reference external" href="https://developer.arm.com/solutions/machine-learning">https://developer.arm.com/solutions/machine-learning</a></p></li>
<li><p>Imagination:</p>
<ul>
<li><p>Imagination E-Series GPU IP: <a class="reference external" href="https://www.imaginationtech.com/">https://www.imaginationtech.com/</a></p></li>
<li><p>TechPowerUp E-Series Launch: <a class="reference external" href="https://www.techpowerup.com/336545/imagination-announces-e-series-gpu-ip-with-burst-processors-and-up-to-200">https://www.techpowerup.com/336545/imagination-announces-e-series-gpu-ip-with-burst-processors-and-up-to-200</a> [A](<a class="reference external" href="https://www.imaginationtech.com/?copilot_analytics_metadata=eyJldmVudEluZm9fY29udmVyc2F0aW9uSWQiOiJMSlNQWjRaWjY5Y2ZuN0VnWnJEVzEiLCJldmVudEluZm9fY2xpY2tTb3VyY2UiOiJjaXRhdGlvbkxpbmsiLCJldmVudEluZm9fY2xpY2tEZXN0aW5hdGlvbiI6Imh0dHBzOlwvXC93d3cuaW1hZ2luYXRpb250ZWNoLmNvbVwvIiwiZXZlbnRJbmZvX21lc3NhZ2VJZCI6InVWYW9lOG5YMmFVUG9aUHVpSmdBcyJ9&amp;citationMarker=9F742443-6C92-4C44-BF58-8F5A7C53B6F1)-tops">https://www.imaginationtech.com/?copilot_analytics_metadata=eyJldmVudEluZm9fY29udmVyc2F0aW9uSWQiOiJMSlNQWjRaWjY5Y2ZuN0VnWnJEVzEiLCJldmVudEluZm9fY2xpY2tTb3VyY2UiOiJjaXRhdGlvbkxpbmsiLCJldmVudEluZm9fY2xpY2tEZXN0aW5hdGlvbiI6Imh0dHBzOlwvXC93d3cuaW1hZ2luYXRpb250ZWNoLmNvbVwvIiwiZXZlbnRJbmZvX21lc3NhZ2VJZCI6InVWYW9lOG5YMmFVUG9aUHVpSmdBcyJ9&amp;citationMarker=9F742443-6C92-4C44-BF58-8F5A7C53B6F1)-tops</a> [B](<a class="reference external" href="https://www.techpowerup.com/336545/imagination-announces-e-series-gpu-ip-with-burst-processors-and-up-to-200-tops?copilot_analytics_metadata=eyJldmVudEluZm9fY2xpY2tTb3VyY2UiOiJjaXRhdGlvbkxpbmsiLCJldmVudEluZm9fbWVzc2FnZUlkIjoidVZhb2U4blgyYVVQb1pQdWlKZ0FzIiwiZXZlbnRJbmZvX2NsaWNrRGVzdGluYXRpb24iOiJodHRwczpcL1wvd3d3LnRlY2hwb3dlcnVwLmNvbVwvMzM2NTQ1XC9pbWFnaW5hdGlvbi1hbm5vdW5jZXMtZS1zZXJpZXMtZ3B1LWlwLXdpdGgtYnVyc3QtcHJvY2Vzc29ycy1hbmQtdXAtdG8tMjAwLXRvcHMiLCJldmVudEluZm9fY29udmVyc2F0aW9uSWQiOiJMSlNQWjRaWjY5Y2ZuN0VnWnJEVzEifQ%3D%3D&amp;citationMarker=9F742443-6C92-4C44-BF58-8F5A7C53B6F1">https://www.techpowerup.com/336545/imagination-announces-e-series-gpu-ip-with-burst-processors-and-up-to-200-tops?copilot_analytics_metadata=eyJldmVudEluZm9fY2xpY2tTb3VyY2UiOiJjaXRhdGlvbkxpbmsiLCJldmVudEluZm9fbWVzc2FnZUlkIjoidVZhb2U4blgyYVVQb1pQdWlKZ0FzIiwiZXZlbnRJbmZvX2NsaWNrRGVzdGluYXRpb24iOiJodHRwczpcL1wvd3d3LnRlY2hwb3dlcnVwLmNvbVwvMzM2NTQ1XC9pbWFnaW5hdGlvbi1hbm5vdW5jZXMtZS1zZXJpZXMtZ3B1LWlwLXdpdGgtYnVyc3QtcHJvY2Vzc29ycy1hbmQtdXAtdG8tMjAwLXRvcHMiLCJldmVudEluZm9fY29udmVyc2F0aW9uSWQiOiJMSlNQWjRaWjY5Y2ZuN0VnWnJEVzEifQ%3D%3D&amp;citationMarker=9F742443-6C92-4C44-BF58-8F5A7C53B6F1</a>)</p></li>
</ul>
</li>
<li><p>MLIR Project: <a class="reference external" href="https://mlir.llvm.org/">https://mlir.llvm.org/</a></p></li>
<li><p>Vulkan API: <a class="reference external" href="https://www.khronos.org/vulkan/">https://www.khronos.org/vulkan/</a></p></li>
<li><p>Apache TVM: <a class="reference external" href="https://tvm.apache.org/">https://tvm.apache.org/</a></p></li>
<li><p>oneAPI: <a class="reference external" href="https://www.oneapi.io/">https://www.oneapi.io/</a></p></li>
</ul>
</section>
</section>
</section>
<section id="accelerate-ml-dl-on-opencl-sycl">
<h3><a class="toc-backref" href="#id371" role="doc-backlink">Accelerate ML/DL on OpenCL/SYCL</a><a class="headerlink" href="#accelerate-ml-dl-on-opencl-sycl" title="Link to this heading">¶</a></h3>
<figure class="align-center" id="id300">
<span id="opengl-ml-graph"></span><a class="reference internal image-reference" href="_images/opencl_ml_graph.png"><img alt="_images/opencl_ml_graph.png" height="325" src="_images/opencl_ml_graph.png" width="918" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 144 </span><span class="caption-text">Implement ML graph scheduler both on compiler and runtime</span><a class="headerlink" href="#id300" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>As shown in <a class="reference internal" href="#opengl-ml-graph"><span class="std std-numref">Fig. 144</span></a>, the Device, such as a GPU or a CPU+NPU,
is capable of running the entire ML graph. However, if the Device has only
an NPU, then operations like Avg-Pool, which require CPU support, must run
on the Host side. This introduces communication overhead between the Host
and the Device.</p>
<p>Similar to OpenGL shaders, the “kernel” function may be compiled either
on-line or off-line and then sent to the GPU as a programmable function.</p>
<p>In order to run ML (Machine Learning) efficiently, all platforms for ML on
GPU/NPU implement scheduling SW both on graph compiler and runtime.
<strong>If OpenCL can extend to support ML graph, then graph compiler such as TVM or
Runtime from Open Source have chance to leverage the effort of scheduling SW from
programmers</strong> <a class="footnote-reference brackets" href="#paper-graph-on-opencl" id="id181" role="doc-noteref"><span class="fn-bracket">[</span>127<span class="fn-bracket">]</span></a>. Cuda graph is an idea  like this
<a class="footnote-reference brackets" href="#cuda-graph-blog" id="id182" role="doc-noteref"><span class="fn-bracket">[</span>128<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#cuda-graph-pytorch" id="id183" role="doc-noteref"><span class="fn-bracket">[</span>129<span class="fn-bracket">]</span></a> .</p>
<ul class="simple">
<li><p>SYCL: Using C++ templates to optimize and genertate code for OpenCL and Cuda.
Provides a consistent language, APIs, and ecosystem in which to write and tune
code for different accelerator architecture, CPUs, GPUs, and FPGAs <a class="footnote-reference brackets" href="#sycl" id="id184" role="doc-noteref"><span class="fn-bracket">[</span>130<span class="fn-bracket">]</span></a>.</p>
<ul>
<li><p>SYCL uses generic programming with templates and generic lambda functions to
enable higher-level application software to be cleanly coded with optimized
acceleration of kernel code across an extensive range of acceleration backend
APIs, such as OpenCL and CUDA <a class="footnote-reference brackets" href="#sycl-cuda" id="id185" role="doc-noteref"><span class="fn-bracket">[</span>131<span class="fn-bracket">]</span></a>.</p></li>
</ul>
</li>
</ul>
<figure class="align-center" id="id301">
<span id="sycl-role"></span><a class="reference internal image-reference" href="_images/sycl.png"><img alt="_images/sycl.png" height="448" src="_images/sycl.png" width="1158" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 145 </span><span class="caption-text">SYCL = C++ template and compiler for Data Parallel Applications on AI on CPUs,
GPUs and HPGAs.</span><a class="headerlink" href="#id301" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<ul>
<li><p>DPC++ (OneDPC) compiler: Based on SYCL, DPC++ can compile the DPC++ language
for both CPU host and GPU device. DPC++ (Data Parallel C++) is a language
developed by Intel and may be adopted into standard C++. The GPU-side
(kernel code) is written in C++ but does not support exception handling
<a class="footnote-reference brackets" href="#dpcpp" id="id186" role="doc-noteref"><span class="fn-bracket">[</span>132<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#dpcpp-book" id="id187" role="doc-noteref"><span class="fn-bracket">[</span>133<span class="fn-bracket">]</span></a>.</p>
<ul>
<li><p>Features of Kernel Code:</p>
<ul>
<li><p>Not supported:</p>
<p>Dynamic polymorphism, dynamic memory allocations (therefore no object
management using new or delete operators), static variables, function
pointers, runtime type information (RTTI), and <strong>exception handling</strong>.
No virtual member functions, and no variadic functions, are allowed to
be called from kernel code. Recursion is not allowed within kernel code.</p>
</li>
<li><p>Supported:</p>
<p>Lambdas, operator overloading, templates, classes, and static polymorphism
<a class="footnote-reference brackets" href="#dpcpp-features" id="id188" role="doc-noteref"><span class="fn-bracket">[</span>134<span class="fn-bracket">]</span></a>.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</section>
</section>
<section id="open-sources">
<h2><a class="toc-backref" href="#id372" role="doc-backlink">Open Sources</a><a class="headerlink" href="#open-sources" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p><a class="reference external" href="https://registry.khronos.org/OpenGL-Refpages/">https://registry.khronos.org/OpenGL-Refpages/</a></p></li>
<li><p><a class="reference external" href="https://www.mesa3d.org">https://www.mesa3d.org</a></p></li>
<li><p><a class="reference external" href="https://www.opengl.org/sdk/">https://www.opengl.org/sdk/</a>, <a class="reference external" href="https://www.opengl.org/sdk/libs/">https://www.opengl.org/sdk/libs/</a></p></li>
</ul>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="cg-basictheory" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id1">1</a>,<a role="doc-backlink" href="#id25">2</a>,<a role="doc-backlink" href="#id33">3</a>,<a role="doc-backlink" href="#id34">4</a>,<a role="doc-backlink" href="#id63">5</a>,<a role="doc-backlink" href="#id107">6</a>,<a role="doc-backlink" href="#id136">7</a>)</span>
<p><a class="reference external" href="https://www3.ntu.edu.sg/home/ehchua/programming/opengl/CG_BasicsTheory.html">https://www3.ntu.edu.sg/home/ehchua/programming/opengl/CG_BasicsTheory.html</a></p>
</aside>
<aside class="footnote brackets" id="polygon" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id2">1</a>,<a role="doc-backlink" href="#id3">2</a>)</span>
<p><a class="reference external" href="https://www.quora.com/Which-one-is-better-for-3D-modeling-Quads-or-Tris">https://www.quora.com/Which-one-is-better-for-3D-modeling-Quads-or-Tris</a></p>
</aside>
<aside class="footnote brackets" id="shading" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id4">1</a>,<a role="doc-backlink" href="#id82">2</a>)</span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Shading">https://en.wikipedia.org/wiki/Shading</a></p>
</aside>
<aside class="footnote brackets" id="texturemapping" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">4</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Texture_mapping">https://en.wikipedia.org/wiki/Texture_mapping</a></p>
</aside>
<aside class="footnote brackets" id="animation-state-video" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id7">1</a>,<a role="doc-backlink" href="#id8">2</a>)</span>
<p><a class="reference external" href="https://www.youtube.com/watch?v=7QIcd6_TTys">https://www.youtube.com/watch?v=7QIcd6_TTys</a></p>
</aside>
<aside class="footnote brackets" id="animation1" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id9">6</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.youtube.com/watch?v=f3Cr8Yx3GGA">https://www.youtube.com/watch?v=f3Cr8Yx3GGA</a></p>
</aside>
<aside class="footnote brackets" id="joglwiki" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id21">7</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Java_OpenGL">https://en.wikipedia.org/wiki/Java_OpenGL</a></p>
</aside>
<aside class="footnote brackets" id="node-editor-web1" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id11">1</a>,<a role="doc-backlink" href="#id12">2</a>)</span>
<p><a class="reference external" href="https://odysee.com/&#64;jsabbott:d/how-to-make-procedural-edge-wear-in:2">https://odysee.com/&#64;jsabbott:d/how-to-make-procedural-edge-wear-in:2</a></p>
</aside>
<aside class="footnote brackets" id="dfmt" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id13">1</a>,<a role="doc-backlink" href="#id14">2</a>,<a role="doc-backlink" href="#id15">3</a>)</span>
<p><a class="reference external" href="https://all3dp.com/3d-file-format-3d-files-3d-printer-3d-cad-vrml-stl-obj/">https://all3dp.com/3d-file-format-3d-files-3d-printer-3d-cad-vrml-stl-obj/</a></p>
</aside>
<aside class="footnote brackets" id="wiki-gpu" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id16">1</a>,<a role="doc-backlink" href="#id108">2</a>)</span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Graphics_processing_unit">https://en.wikipedia.org/wiki/Graphics_processing_unit</a></p>
</aside>
<aside class="footnote brackets" id="ogl-cpu-gpu" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>11<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id17">1</a>,<a role="doc-backlink" href="#id195">2</a>)</span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Vulkan">https://en.wikipedia.org/wiki/Vulkan</a></p>
</aside>
<aside class="footnote brackets" id="cpu-gpu-role" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id18">12</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://stackoverflow.com/questions/47426655/cpu-and-gpu-in-3d-game-whos-doing-what">https://stackoverflow.com/questions/47426655/cpu-and-gpu-in-3d-game-whos-doing-what</a></p>
</aside>
<aside class="footnote brackets" id="mesawiki" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>13<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id19">1</a>,<a role="doc-backlink" href="#id105">2</a>)</span>
<p>&lt;<a class="reference external" href="https://en.wikipedia.org/wiki/Mesa_(computer_graphics)">https://en.wikipedia.org/wiki/Mesa_(computer_graphics)</a>&gt;</p>
</aside>
<aside class="footnote brackets" id="csf" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id20">14</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://developer.arm.com/documentation/102813/0107/GPU-activity">https://developer.arm.com/documentation/102813/0107/GPU-activity</a></p>
</aside>
<aside class="footnote brackets" id="libclc" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id22">15</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://libclc.llvm.org">https://libclc.llvm.org</a></p>
</aside>
<aside class="footnote brackets" id="vbo" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>16<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id23">1</a>,<a role="doc-backlink" href="#id45">2</a>)</span>
<p><a class="reference external" href="http://www.songho.ca/opengl/gl_vbo.html">http://www.songho.ca/opengl/gl_vbo.html</a></p>
</aside>
<aside class="footnote brackets" id="classorvbo" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id24">17</a><span class="fn-bracket">]</span></span>
<p>If your models will be rigid, meaning you will not change each vertex individually, and you will render many frames with the same model, you will achieve the best performance not by storing the models in your class, but in vertex buffer objects (VBOs) <a class="reference external" href="https://gamedev.stackexchange.com/questions/19560/what-is-the-best-way-to-store-meshes-or-3d-models-in-a-class">https://gamedev.stackexchange.com/questions/19560/what-is-the-best-way-to-store-meshes-or-3d-models-in-a-class</a></p>
</aside>
<aside class="footnote brackets" id="g-sync" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id26">18</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.avadirect.com/blog/frame-rate-fps-vs-hz-refresh-rate/">https://www.avadirect.com/blog/frame-rate-fps-vs-hz-refresh-rate/</a></p>
</aside>
<aside class="footnote brackets" id="additive-colors-wiki" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id27">19</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/RGB_color_model">https://en.wikipedia.org/wiki/RGB_color_model</a></p>
</aside>
<aside class="footnote brackets" id="additive-colors-ytube" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id28">20</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.youtube.com/watch?v=kEnz_3miiAc">https://www.youtube.com/watch?v=kEnz_3miiAc</a></p>
</aside>
<aside class="footnote brackets" id="additive-colors-shade" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id29">21</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.tiktok.com/&#64;tonesterpaints/video/7059565281227853102">https://www.tiktok.com/&#64;tonesterpaints/video/7059565281227853102</a></p>
</aside>
<aside class="footnote brackets" id="wiki-transformation" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id30">22</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Transformation_matrix">https://en.wikipedia.org/wiki/Transformation_matrix</a></p>
</aside>
<aside class="footnote brackets" id="wiki-rotation" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id31">23</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Rotation_matrix">https://en.wikipedia.org/wiki/Rotation_matrix</a></p>
</aside>
<aside class="footnote brackets" id="wiki-quaternion" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id32">24</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Quaternion">https://en.wikipedia.org/wiki/Quaternion</a></p>
</aside>
<aside class="footnote brackets" id="wiki-prospective-projection" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id35">25</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/3D_projection#Perspective_projection">https://en.wikipedia.org/wiki/3D_projection#Perspective_projection</a></p>
</aside>
<aside class="footnote brackets" id="cross-product-wiki" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>26<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id37">1</a>,<a role="doc-backlink" href="#id42">2</a>)</span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Cross_product">https://en.wikipedia.org/wiki/Cross_product</a></p>
</aside>
<aside class="footnote brackets" id="cross-product-2d-proof" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id38">27</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.xarg.org/book/linear-algebra/2d-perp-product/">https://www.xarg.org/book/linear-algebra/2d-perp-product/</a></p>
</aside>
<aside class="footnote brackets" id="cross-product-2d-proof2" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id39">28</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.nagwa.com/en/explainers/175169159270/">https://www.nagwa.com/en/explainers/175169159270/</a></p>
</aside>
<aside class="footnote brackets" id="cgpap" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id40">29</a><span class="fn-bracket">]</span></span>
<p>Figure 7.19 of Book: Computer graphics principles and practice 3rd edition</p>
</aside>
<aside class="footnote brackets" id="wiki-point-in-polygon" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id41">30</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Point_in_polygon">https://en.wikipedia.org/wiki/Point_in_polygon</a></p>
</aside>
<aside class="footnote brackets" id="ogl-point-outwards" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id43">31</a><span class="fn-bracket">]</span></span>
<p>Normals are used to differentiate the front- and back-face, and for other processing such as lighting. Right-hand rule (or counter-clockwise) is used in OpenGL. The normal is pointing outwards, indicating the outer surface (or front-face). <a class="reference external" href="https://www3.ntu.edu.sg/home/ehchua/programming/opengl/CG_BasicsTheory.html">https://www3.ntu.edu.sg/home/ehchua/programming/opengl/CG_BasicsTheory.html</a></p>
</aside>
<aside class="footnote brackets" id="point-in-3d-object" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id44">32</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://stackoverflow.com/questions/63557043/how-to-determine-whether-a-point-is-inside-or-outside-a-3d-model-computationally">https://stackoverflow.com/questions/63557043/how-to-determine-whether-a-point-is-inside-or-outside-a-3d-model-computationally</a></p>
</aside>
<aside class="footnote brackets" id="ogl-frontface" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id46">33</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFrontFace.xhtml">https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFrontFace.xhtml</a></p>
</aside>
<aside class="footnote brackets" id="scene-graph-wiki" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id47">34</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Scene_graph">https://en.wikipedia.org/wiki/Scene_graph</a></p>
</aside>
<aside class="footnote brackets" id="drendering-wiki" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id61">35</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/3D_rendering">https://en.wikipedia.org/wiki/3D_rendering</a></p>
</aside>
<aside class="footnote brackets" id="rendering" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>36<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id64">1</a>,<a role="doc-backlink" href="#id67">2</a>,<a role="doc-backlink" href="#id70">3</a>)</span>
<p><a class="reference external" href="https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview">https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview</a></p>
</aside>
<aside class="footnote brackets" id="redbook" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>37<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id49">1</a>,<a role="doc-backlink" href="#id65">2</a>,<a role="doc-backlink" href="#id66">3</a>,<a role="doc-backlink" href="#id69">4</a>,<a role="doc-backlink" href="#id73">5</a>,<a role="doc-backlink" href="#id75">6</a>,<a role="doc-backlink" href="#id189">7</a>,<a role="doc-backlink" href="#id190">8</a>,<a role="doc-backlink" href="#id191">9</a>,<a role="doc-backlink" href="#id192">10</a>,<a role="doc-backlink" href="#id193">11</a>)</span>
<p><a class="reference external" href="http://www.opengl-redbook.com">http://www.opengl-redbook.com</a></p>
</aside>
<aside class="footnote brackets" id="ts-tu30" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id72">38</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://ogldev.org/www/tutorial30/tutorial30.html">https://ogldev.org/www/tutorial30/tutorial30.html</a></p>
</aside>
<aside class="footnote brackets" id="danimation" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id74">39</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://tw.video.search.yahoo.com/search/video?fr=yfp-search-sb&amp;p=2d+animation#id=12&amp;vid=46be09edf57b960ae79e9cd077eea1ea&amp;action=view">https://tw.video.search.yahoo.com/search/video?fr=yfp-search-sb&amp;p=2d+animation#id=12&amp;vid=46be09edf57b960ae79e9cd077eea1ea&amp;action=view</a></p>
</aside>
<aside class="footnote brackets" id="redbook-p36" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>40<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id68">1</a>,<a role="doc-backlink" href="#id71">2</a>)</span>
<p>Page 36 of book “OpenGL Programming Guide 9th Edition” <a class="footnote-reference brackets" href="#redbook" id="id189" role="doc-noteref"><span class="fn-bracket">[</span>37<span class="fn-bracket">]</span></a>.</p>
</aside>
<aside class="footnote brackets" id="arm-gs" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id76">41</a><span class="fn-bracket">]</span></span>
<p>ARM Developer: <em>Why mobile GPUs avoid geometry shaders</em>
<a class="reference external" href="https://developer.arm.com/documentation/102476/latest/">https://developer.arm.com/documentation/102476/latest/</a></p>
</aside>
<aside class="footnote brackets" id="img-gs" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id77">42</a><span class="fn-bracket">]</span></span>
<p>Imagination Technologies: <em>Why Geometry Shaders Are Not Supported</em>
<a class="reference external" href="https://www.imgtec.com/blog/why-powervr-does-not-support-geometry-shaders/">https://www.imgtec.com/blog/why-powervr-does-not-support-geometry-shaders/</a></p>
</aside>
<aside class="footnote brackets" id="redbook-examples" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id50">43</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://github.com/openglredbook/examples">https://github.com/openglredbook/examples</a></p>
</aside>
<aside class="footnote brackets" id="vao-vbo-binding" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id51">44</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://stackoverflow.com/questions/21652546/what-is-the-role-of-glbindvertexarrays-vs-glbindbuffer-and-what-is-their-relatio">https://stackoverflow.com/questions/21652546/what-is-the-role-of-glbindvertexarrays-vs-glbindbuffer-and-what-is-their-relatio</a></p>
</aside>
<aside class="footnote brackets" id="ogl-vavb" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id52">45</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindVertexBuffer.xhtml">https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindVertexBuffer.xhtml</a></p>
</aside>
<aside class="footnote brackets" id="ogl-bluebook-p152" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id53">46</a><span class="fn-bracket">]</span></span>
<p>Page 152 of Blue book: OpenGL SuperBible 7th Edition.</p>
</aside>
<aside class="footnote brackets" id="reg-less" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id135">47</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://cccp.eecs.umich.edu/papers/jklooste-micro17.pdf">https://cccp.eecs.umich.edu/papers/jklooste-micro17.pdf</a></p>
</aside>
</aside>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="buffers-redbook" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id144">48</a><span class="fn-bracket">]</span></span>
<p>Page 155 - 185 of book “OpenGL Programming Guide 9th Edition” <a class="footnote-reference brackets" href="#redbook" id="id190" role="doc-noteref"><span class="fn-bracket">[</span>37<span class="fn-bracket">]</span></a>.</p>
</aside>
<aside class="footnote brackets" id="monstar-lab-opengl" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id59">49</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://engineering.monstar-lab.com/en/post/2022/03/01/Introduction-To-GPUs-With-OpenGL/">https://engineering.monstar-lab.com/en/post/2022/03/01/Introduction-To-GPUs-With-OpenGL/</a></p>
</aside>
<aside class="footnote brackets" id="glumpy-shaders" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id60">50</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://glumpy.github.io/modern-gl.html">https://glumpy.github.io/modern-gl.html</a></p>
</aside>
<aside class="footnote brackets" id="ogl-qualifier" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id55">51</a><span class="fn-bracket">]</span></span>
<p>&lt;<a class="reference external" href="https://www.khronos.org/opengl/wiki/Type_Qualifier_(GLSL)">https://www.khronos.org/opengl/wiki/Type_Qualifier_(GLSL)</a>&gt;</p>
</aside>
<aside class="footnote brackets" id="ogl-qualifier-deprecate" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id56">52</a><span class="fn-bracket">]</span></span>
<p>&lt;<a class="reference external" href="https://www.khronos.org/opengl/wiki/Type_Qualifier_(GLSL">https://www.khronos.org/opengl/wiki/Type_Qualifier_(GLSL</a>)#Removed_qualifiers&gt;</p>
</aside>
<aside class="footnote brackets" id="github-attr-varying-depr" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id57">53</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://github.com/vispy/vispy/issues/242">https://github.com/vispy/vispy/issues/242</a></p>
</aside>
<aside class="footnote brackets" id="ogl-layout-q" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id58">54</a><span class="fn-bracket">]</span></span>
<p>&lt;<a class="reference external" href="https://www.khronos.org/opengl/wiki/Layout_Qualifier_(GLSL)">https://www.khronos.org/opengl/wiki/Layout_Qualifier_(GLSL)</a>&gt;</p>
</aside>
<aside class="footnote brackets" id="fragmentshader-reason" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id78">55</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://community.khronos.org/t/pixel-vs-fragment-shader/52838">https://community.khronos.org/t/pixel-vs-fragment-shader/52838</a></p>
</aside>
<aside class="footnote brackets" id="shaderswiki" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id79">56</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.m.wikipedia.org/wiki/OpenGL_Shading_Language">https://en.m.wikipedia.org/wiki/OpenGL_Shading_Language</a></p>
</aside>
<aside class="footnote brackets" id="shadersex" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id80">57</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://learnopengl.com/Getting-started/Shaders">https://learnopengl.com/Getting-started/Shaders</a></p>
</aside>
<aside class="footnote brackets" id="glsleffect" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id81">58</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.youtube.com/watch?v=LyoSSoYyfVU">https://www.youtube.com/watch?v=LyoSSoYyfVU</a> at 5:25 from beginning: combine different textures.</p>
</aside>
<aside class="footnote brackets" id="smoothshadingex" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id83">59</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://github.com/ruange/Gouraud-Shading-and-Phong-Shading">https://github.com/ruange/Gouraud-Shading-and-Phong-Shading</a></p>
</aside>
<aside class="footnote brackets" id="on-line" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id84">60</a><span class="fn-bracket">]</span></span>
<p>Compiler and interpreter: (<a class="reference external" href="https://www.guru99.com/difference-compiler-vs-interpreter.html">https://www.guru99.com/difference-compiler-vs-interpreter.html</a>). AOT compiler: compiles before running; JIT compiler: compiles while running; interpreter: runs (reference <a class="reference external" href="https://softwareengineering.stackexchange.com/questions/246094/understanding-the-differences-traditional-interpreter-jit-compiler-jit-interp">https://softwareengineering.stackexchange.com/questions/246094/understanding-the-differences-traditional-interpreter-jit-compiler-jit-interp</a>). Both online and offline compiler are AOT compiler. User call OpenGL api to run their program and the driver call call online compiler to compile user’s shaders without user compiling their shader before running their program. When user run a CPU program of C language, he must compile C program before running the program. This is offline compiler.</p>
</aside>
<aside class="footnote brackets" id="onlinecompile" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id85">61</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://community.khronos.org/t/offline-glsl-compilation/61784">https://community.khronos.org/t/offline-glsl-compilation/61784</a></p>
</aside>
<aside class="footnote brackets" id="openglspec" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id87">62</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.khronos.org/registry/OpenGL-Refpages/">https://www.khronos.org/registry/OpenGL-Refpages/</a></p>
</aside>
<aside class="footnote brackets" id="opengleswiki" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id88">63</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/OpenGL_ES">https://en.wikipedia.org/wiki/OpenGL_ES</a></p>
</aside>
<aside class="footnote brackets" id="textureapi" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id89">64</a><span class="fn-bracket">]</span></span>
<p>All the api listed in section 8.9 of <a class="reference external" href="https://www.khronos.org/registry/OpenGL/specs/es/3.2/GLSL_ES_Specification_3.20.html#texture-functions">https://www.khronos.org/registry/OpenGL/specs/es/3.2/GLSL_ES_Specification_3.20.html#texture-functions</a></p>
</aside>
<aside class="footnote brackets" id="intrinsiccpu0" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id90">65</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://jonathan2251.github.io/lbd/funccall.html#add-specific-backend-intrinsic-function">http://jonathan2251.github.io/lbd/funccall.html#add-specific-backend-intrinsic-function</a></p>
</aside>
<aside class="footnote brackets" id="textureobject" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>66<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id91">1</a>,<a role="doc-backlink" href="#id92">2</a>,<a role="doc-backlink" href="#id93">3</a>,<a role="doc-backlink" href="#id94">4</a>)</span>
<p><a class="reference external" href="http://ogldev.atspace.co.uk/www/tutorial16/tutorial16.html">http://ogldev.atspace.co.uk/www/tutorial16/tutorial16.html</a></p>
</aside>
<aside class="footnote brackets" id="tpu" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>67<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id95">1</a>,<a role="doc-backlink" href="#id96">2</a>,<a role="doc-backlink" href="#id103">3</a>,<a role="doc-backlink" href="#id138">4</a>)</span>
<p><a class="reference external" href="http://math.hws.edu/graphicsbook/c6/s4.html">http://math.hws.edu/graphicsbook/c6/s4.html</a></p>
</aside>
<aside class="footnote brackets" id="metadata" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id98">68</a><span class="fn-bracket">]</span></span>
<p>This can be done by llvm metadata. <a class="reference external" href="http://llvm.org/docs/LangRef.html#namedmetadatastructure">http://llvm.org/docs/LangRef.html#namedmetadatastructure</a> <a class="reference external" href="http://llvm.org/docs/LangRef.html#metadata">http://llvm.org/docs/LangRef.html#metadata</a></p>
</aside>
<aside class="footnote brackets" id="ptxtex" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>69<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id100">1</a>,<a role="doc-backlink" href="#id102">2</a>)</span>
<p>page 84: tex instruction, p24: texture memory <a class="reference external" href="https://www.nvidia.com/content/CUDA-ptx_isa_1.4.pdf">https://www.nvidia.com/content/CUDA-ptx_isa_1.4.pdf</a></p>
</aside>
<aside class="footnote brackets" id="samplervar" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id97">70</a><span class="fn-bracket">]</span></span>
<p>The type of ‘sampler uniform variable’ called “sampler variables”. <a class="reference external" href="http://math.hws.edu/graphicsbook/c6/s4.html">http://math.hws.edu/graphicsbook/c6/s4.html</a></p>
</aside>
<aside class="footnote brackets" id="descriptorreg" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>71<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id99">1</a>,<a role="doc-backlink" href="#id101">2</a>)</span>
<p>When performing a texture fetch, the addresses to read pixel data from are computed by reading the GPRs that hold the texture descriptor and the GPRs that hold the texture coordinates. It’s mostly just general purpose memory fetching. <a class="reference external" href="https://www.gamedev.net/forums/topic/681503-texture-units/">https://www.gamedev.net/forums/topic/681503-texture-units/</a></p>
</aside>
<aside class="footnote brackets" id="texturewrapper" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>72<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id104">1</a>,<a role="doc-backlink" href="#id139">2</a>,<a role="doc-backlink" href="#id140">3</a>,<a role="doc-backlink" href="#id141">4</a>,<a role="doc-backlink" href="#id142">5</a>)</span>
<p><a class="reference external" href="https://learnopengl.com/Getting-started/Textures">https://learnopengl.com/Getting-started/Textures</a></p>
</aside>
<aside class="footnote brackets" id="mesa" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id106">73</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.mesa3d.org/">https://www.mesa3d.org/</a></p>
</aside>
<aside class="footnote brackets" id="simt-wiki" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id111">74</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Single_instruction,_multiple_threads">https://en.wikipedia.org/wiki/Single_instruction,_multiple_threads</a></p>
</aside>
<aside class="footnote brackets" id="quantitative-grid" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id128">75</a><span class="fn-bracket">]</span></span>
<p>Book Figure 4.13 of Computer Architecture: A Quantitative Approach 5th edition (The
Morgan Kaufmann Series in Computer Architecture and Design)</p>
</aside>
<aside class="footnote brackets" id="mapping-blocks-to-sm" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>76<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id119">1</a>,<a role="doc-backlink" href="#id120">2</a>,<a role="doc-backlink" href="#id126">3</a>)</span>
<p>&lt;<a class="reference external" href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#warps">https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#warps</a>&gt;</p>
</aside>
<aside class="footnote brackets" id="cuda-sm" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id114">77</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.tomshardware.com/reviews/geforce-gtx-480,2585-18.html">https://www.tomshardware.com/reviews/geforce-gtx-480,2585-18.html</a></p>
</aside>
<aside class="footnote brackets" id="fermi" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id115">78</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.nvidia.com/content/PDF/fermi_white_papers/NVIDIA_Fermi_Compute_architecture_Whitepaper.pdf?utm_source=chatgpt.com">https://www.nvidia.com/content/PDF/fermi_white_papers/NVIDIA_Fermi_Compute_architecture_Whitepaper.pdf?utm_source=chatgpt.com</a></p>
</aside>
<aside class="footnote brackets" id="chime" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id116">79</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.cs.cmu.edu/afs/cs/academic/class/15418-s12/www/lectures/02_multicore.pdf">https://www.cs.cmu.edu/afs/cs/academic/class/15418-s12/www/lectures/02_multicore.pdf</a></p>
</aside>
<aside class="footnote brackets" id="quantitative-threads-lanes" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id112">80</a><span class="fn-bracket">]</span></span>
<p>The SIMD Thread Scheduler includes a scoreboard that lets it know which threads of SIMD instructions are ready to run, and then it sends them off to a dispatch unit to be run on the multithreaded SIMD Processor. It is identical to a hardware thread scheduler in a traditional multithreaded processor (see Chapter 3), just that it is scheduling threads of SIMD instructions. Thus, GPU hardware has two levels of hardware schedulers: (1) the Thread Block Scheduler that assigns Thread Blocks (bodies of vectorized loops) to multi- threaded SIMD Processors, which ensures that Thread Blocks are assigned to the processors whose local memories have the corresponding data, and (2) the SIMD Thread Scheduler within a SIMD Processor, which schedules when threads of SIMD instructions should run.
Book Figure 4.14 of Computer Architecture: A Quantitative Approach 5th edition (The
Morgan Kaufmann Series in Computer Architecture and Design)</p>
</aside>
<aside class="footnote brackets" id="quantitative-gpu-sm" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id113">81</a><span class="fn-bracket">]</span></span>
<p>Book Figure 4.20 of Computer Architecture: A Quantitative Approach 5th edition (The
Morgan Kaufmann Series in Computer Architecture and Design)</p>
</aside>
<aside class="footnote brackets" id="chatgpt-pumh" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id124">82</a><span class="fn-bracket">]</span></span>
<p>chatgpt: Give me a memory hierarchy for L1, L2, local memory,
shared memory for these processing units of hierarchy in reST and
seperate dot graph.</p>
</aside>
<aside class="footnote brackets" id="quantitative-gpu-mem" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id125">83</a><span class="fn-bracket">]</span></span>
<p>Book Figure 4.17 of Computer Architecture: A Quantitative Approach 5th edition (The
Morgan Kaufmann Series in Computer Architecture and Design)</p>
</aside>
<aside class="footnote brackets" id="redbook-p155" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id145">84</a><span class="fn-bracket">]</span></span>
<p>Page 155 of book “OpenGL Programming Guide 9th Edition” <a class="footnote-reference brackets" href="#redbook" id="id191" role="doc-noteref"><span class="fn-bracket">[</span>37<span class="fn-bracket">]</span></a>.</p>
</aside>
<aside class="footnote brackets" id="redbook-p156" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id146">85</a><span class="fn-bracket">]</span></span>
<p>Page 156 of book “OpenGL Programming Guide 9th Edition” <a class="footnote-reference brackets" href="#redbook" id="id192" role="doc-noteref"><span class="fn-bracket">[</span>37<span class="fn-bracket">]</span></a>.</p>
</aside>
<aside class="footnote brackets" id="redbook-colorbuffer" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id54">86</a><span class="fn-bracket">]</span></span>
<p>Section of Color Buffer, page 222-223 of book “OpenGL Programming Guide 9th Edition” <a class="footnote-reference brackets" href="#redbook" id="id193" role="doc-noteref"><span class="fn-bracket">[</span>37<span class="fn-bracket">]</span></a>.</p>
</aside>
<aside class="footnote brackets" id="z-buffer-wiki" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id147">87</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Z-buffering">https://en.wikipedia.org/wiki/Z-buffering</a></p>
</aside>
<aside class="footnote brackets" id="depthstencils-ogl" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>88<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id148">1</a>,<a role="doc-backlink" href="#id151">2</a>)</span>
<p><a class="reference external" href="https://open.gl/depthstencils">https://open.gl/depthstencils</a></p>
</aside>
<aside class="footnote brackets" id="stencils-buffer-wiki" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id150">89</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Stencil_buffer">https://en.wikipedia.org/wiki/Stencil_buffer</a></p>
</aside>
<aside class="footnote brackets" id="framebuffers-ogl" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id149">90</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://open.gl/framebuffers">https://open.gl/framebuffers</a></p>
</aside>
<aside class="footnote brackets" id="gpgpuwiki" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>91<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id152">1</a>,<a role="doc-backlink" href="#id158">2</a>,<a role="doc-backlink" href="#id161">3</a>)</span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/General-purpose_computing_on_graphics_processing_units">https://en.wikipedia.org/wiki/General-purpose_computing_on_graphics_processing_units</a></p>
</aside>
<aside class="footnote brackets" id="quantitative-gpu-terms" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id127">92</a><span class="fn-bracket">]</span></span>
<p>Book Figure 4.12 of Computer Architecture: A Quantitative Approach 5th edition (The
Morgan Kaufmann Series in Computer Architecture and Design)</p>
</aside>
<aside class="footnote brackets" id="quantitative-gpu-l1" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id117">93</a><span class="fn-bracket">]</span></span>
<p>Page 306 of Computer Architecture: A Quantitative Approach 5th edition (The
Morgan Kaufmann Series in Computer Architecture and Design)</p>
</aside>
<aside class="footnote brackets" id="cudaex" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id156">94</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://devblogs.nvidia.com/easy-introduction-cuda-c-and-c/">https://devblogs.nvidia.com/easy-introduction-cuda-c-and-c/</a></p>
</aside>
<aside class="footnote brackets" id="quantitative-gpu-threadblock" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>95<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id129">1</a>,<a role="doc-backlink" href="#id130">2</a>)</span>
<p>Figure 4.15 Floor plan of the Fermi GTX 480
GPU of A Quantitative Approach 5th edition (The Morgan Kaufmann Series in
Computer Architecture and Design). <strong>Giga Thread</strong> is the name of the
scheduler that distributes Thread Blocks to Multiprocessors, each of
which has its own SIMD Thread Scheduler.</p>
</aside>
<aside class="footnote brackets" id="wiki-ray-tracing" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id109">96</a><span class="fn-bracket">]</span></span>
<p>&lt;<a class="reference external" href="https://en.wikipedia.org/wiki/Ray_tracing_(graphics)">https://en.wikipedia.org/wiki/Ray_tracing_(graphics)</a>&gt;</p>
</aside>
<aside class="footnote brackets" id="vrs" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id110">97</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://developer.nvidia.com/vrworks/graphics/variablerateshading">https://developer.nvidia.com/vrworks/graphics/variablerateshading</a></p>
</aside>
<aside class="footnote brackets" id="quantitative-gpu-gs" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id134">98</a><span class="fn-bracket">]</span></span>
<p>Page 280 of Computer Architecture: A Quantitative Approach 5th edition (The
Morgan Kaufmann Series in Computer Architecture and Design)</p>
</aside>
<aside class="footnote brackets" id="quantitative-gpu-ac" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id133">99</a><span class="fn-bracket">]</span></span>
<p>Page 300 of Computer Architecture: A Quantitative Approach 5th edition (The
Morgan Kaufmann Series in Computer Architecture and Design)</p>
</aside>
<aside class="footnote brackets" id="wiki-tbcp" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>100<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id118">1</a>,<a role="doc-backlink" href="#id121">2</a>,<a role="doc-backlink" href="#id122">3</a>)</span>
<p>&lt;<a class="reference external" href="https://en.wikipedia.org/wiki/Thread_block_(CUDA_programming)">https://en.wikipedia.org/wiki/Thread_block_(CUDA_programming)</a>&gt;</p>
</aside>
<aside class="footnote brackets" id="gpu-core" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id131">101</a><span class="fn-bracket">]</span></span>
<p>Copilot: Is GPU core meaning SM in NVidia?</p>
</aside>
<aside class="footnote brackets" id="quantitative-gpu-warp" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id132">102</a><span class="fn-bracket">]</span></span>
<p>Book Figure 4.14 and 4.24 of Computer Architecture: A Quantitative Approach 5th edition (The
Morgan Kaufmann Series in Computer Architecture and Design)</p>
</aside>
<aside class="footnote brackets" id="volta" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id123">103</a><span class="fn-bracket">]</span></span>
<p>See the same Figures from <a class="reference external" href="https://images.nvidia.com/content/volta-architecture/pdf/volta-architecture-whitepaper.pdf">https://images.nvidia.com/content/volta-architecture/pdf/volta-architecture-whitepaper.pdf</a></p>
</aside>
<aside class="footnote brackets" id="vmr" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id154">104</a><span class="fn-bracket">]</span></span>
<p>subsection Vector Mask Registers: Handling IF Statements in Vector Loops of Computer Architecture: A Quantitative Approach 5th edition (The
Morgan Kaufmann Series in Computer Architecture and Design)</p>
</aside>
<aside class="footnote brackets" id="quantitative-gpu-asm-daxpy" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id155">105</a><span class="fn-bracket">]</span></span>
<p>Code written by refering page 208 - 302 of Computer Architecture: A Quantitative Approach 5th edition (The
Morgan Kaufmann Series in Computer Architecture and Design)</p>
</aside>
<aside class="footnote brackets" id="quantitative-gpu-sparse-matrix" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id157">106</a><span class="fn-bracket">]</span></span>
<p>Reference “Gather-Scatter: Handling Sparse Matrices in Vector Architectures”: section 4.2 Vector Architecture of A Quantitative Approach 5th edition (The
Morgan Kaufmann Series in Computer Architecture and Design)</p>
</aside>
<aside class="footnote brackets" id="shadingl1" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id159">107</a><span class="fn-bracket">]</span></span>
<p>The whole chip shares a single L2 cache, but the different units will have individual L1 caches. <a class="reference external" href="https://computergraphics.stackexchange.com/questions/355/how-does-texture-cache-work-considering-multiple-shader-units">https://computergraphics.stackexchange.com/questions/355/how-does-texture-cache-work-considering-multiple-shader-units</a></p>
</aside>
<aside class="footnote brackets" id="mpeg4speedup" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id160">108</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.manchestervideo.com/2016/06/11/speed-h-264-encoding-budget-gpu/">https://www.manchestervideo.com/2016/06/11/speed-h-264-encoding-budget-gpu/</a></p>
</aside>
<aside class="footnote brackets" id="gpuspeedup" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>109<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id162">1</a>,<a role="doc-backlink" href="#id163">2</a>)</span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Graphics_processing_unit">https://en.wikipedia.org/wiki/Graphics_processing_unit</a></p>
</aside>
<aside class="footnote brackets" id="raster-unit" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id137">110</a><span class="fn-bracket">]</span></span>
<p>copilot: Please provide detailed information about the Rasterization Unit and its pipeline, including a separated dot graph and relevant website references in reStructuredText (reST) format.</p>
</aside>
<aside class="footnote brackets" id="rops" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id143">111</a><span class="fn-bracket">]</span></span>
<p>copilot: Please provide detailed information about the Render Output Units (ROPs) and its pipeline, including a dot graph and relevant website references in reStructuredText (reST) format.</p>
</aside>
<aside class="footnote brackets" id="diff-compute-shader-opencl" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id165">112</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://stackoverflow.com/questions/15868498/what-is-the-difference-between-opencl-and-opengls-compute-shader">https://stackoverflow.com/questions/15868498/what-is-the-difference-between-opencl-and-opengls-compute-shader</a></p>
</aside>
<aside class="footnote brackets" id="id194" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id164">113</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.khronos.org/blog/offline-compilation-of-opencl-kernels-into-spir-v-using-open-source-tooling">https://www.khronos.org/blog/offline-compilation-of-opencl-kernels-into-spir-v-using-open-source-tooling</a></p>
</aside>
<aside class="footnote brackets" id="vulkanapiwiki" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>114<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id166">1</a>,<a role="doc-backlink" href="#id170">2</a>)</span>
<p>Vulkan offers lower overhead, more direct control over the GPU, and lower CPU usage… By allowing shader pre-compilation, application initialization speed is improved… A Vulkan driver only needs to do GPU specific optimization and code generation, resulting in easier driver maintenance… <a class="footnote-reference brackets" href="#ogl-cpu-gpu" id="id195" role="doc-noteref"><span class="fn-bracket">[</span>11<span class="fn-bracket">]</span></a> <a class="reference external" href="https://en.wikipedia.org/wiki/Vulkan#OpenGL_vs._Vulkan">https://en.wikipedia.org/wiki/Vulkan#OpenGL_vs._Vulkan</a></p>
</aside>
<aside class="footnote brackets" id="vulkanex" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id167">115</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://github.com/SaschaWillems/Vulkan/blob/master/examples/triangle/triangle.cpp">https://github.com/SaschaWillems/Vulkan/blob/master/examples/triangle/triangle.cpp</a></p>
</aside>
<aside class="footnote brackets" id="spirvtoolchain" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id168">116</a><span class="fn-bracket">]</span></span>
<p>glslangValidator is the tool used to compile GLSL shaders into SPIR-V, Vulkan’s shader format. <a class="reference external" href="https://vulkan.lunarg.com/doc/sdk/latest/windows/spirv_toolchain.html">https://vulkan.lunarg.com/doc/sdk/latest/windows/spirv_toolchain.html</a></p>
</aside>
<aside class="footnote brackets" id="spirvwiki" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id169">117</a><span class="fn-bracket">]</span></span>
<p>SPIR 2.0: LLVM IR version 3.4. SPIR-V 1.X: 100% Khronos defined Round-trip lossless conversion to llvm.  <a class="reference external" href="https://en.wikipedia.org/wiki/Standard_Portable_Intermediate_Representation">https://en.wikipedia.org/wiki/Standard_Portable_Intermediate_Representation</a></p>
</aside>
<aside class="footnote brackets" id="opencl" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id171">118</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.khronos.org/opencl/">https://www.khronos.org/opencl/</a></p>
</aside>
<aside class="footnote brackets" id="computekernelwiki" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id172">119</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Compute_kernel">https://en.wikipedia.org/wiki/Compute_kernel</a></p>
</aside>
<aside class="footnote brackets" id="openclexfft" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id173">120</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/OpenCL">https://en.wikipedia.org/wiki/OpenCL</a></p>
</aside>
<aside class="footnote brackets" id="opencl-wiki-supported-lang" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id174">121</a><span class="fn-bracket">]</span></span>
<p>The OpenCL standard defines host APIs for C and C++; third-party APIs exist for other programming languages and platforms such as Python,[15] Java, Perl[15] and .NET.[11]:15 <a class="reference external" href="https://en.wikipedia.org/wiki/OpenCL">https://en.wikipedia.org/wiki/OpenCL</a></p>
</aside>
<aside class="footnote brackets" id="vulkan-subgroup" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id175">122</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.khronos.org/blog/vulkan-subgroup-tutorial">https://www.khronos.org/blog/vulkan-subgroup-tutorial</a></p>
</aside>
<aside class="footnote brackets" id="llvm-uniformity" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id176">123</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://llvm.org/docs/ConvergenceAndUniformity.html">https://llvm.org/docs/ConvergenceAndUniformity.html</a></p>
</aside>
<aside class="footnote brackets" id="tensor-rt-nvidia" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id177">124</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://resources.nvidia.com/en-us-inference-resources/nvidia-tensorrt">https://resources.nvidia.com/en-us-inference-resources/nvidia-tensorrt</a></p>
</aside>
<aside class="footnote brackets" id="tensor-rt-geeks" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id178">125</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.geeksforgeeks.org/deep-learning/what-is-tensorrt/">https://www.geeksforgeeks.org/deep-learning/what-is-tensorrt/</a></p>
</aside>
<aside class="footnote brackets" id="hsa" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id179">126</a><span class="fn-bracket">]</span></span>
<p>HSA is an open standard developed to simplify programming across
heterogeneous systems — especially those combining CPUs and GPUs.
It defines:</p>
<ul class="simple">
<li><p>Agents: CPUs, GPUs, and other compute units treated uniformly</p></li>
<li><p>Queues: Asynchronous command queues for dispatching kernels</p></li>
<li><p>Memory model: Shared virtual memory across agents</p></li>
<li><p>Signals: Lightweight synchronization primitives</p></li>
</ul>
</aside>
<aside class="footnote brackets" id="paper-graph-on-opencl" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id181">127</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://easychair.org/publications/preprint/GjhX">https://easychair.org/publications/preprint/GjhX</a></p>
</aside>
<aside class="footnote brackets" id="cuda-graph-blog" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id182">128</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://developer.nvidia.com/blog/cuda-graphs/">https://developer.nvidia.com/blog/cuda-graphs/</a></p>
</aside>
<aside class="footnote brackets" id="cuda-graph-pytorch" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id183">129</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://pytorch.org/blog/accelerating-pytorch-with-cuda-graphs/">https://pytorch.org/blog/accelerating-pytorch-with-cuda-graphs/</a></p>
</aside>
<aside class="footnote brackets" id="sycl" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id184">130</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.khronos.org/sycl/">https://www.khronos.org/sycl/</a></p>
</aside>
<aside class="footnote brackets" id="sycl-cuda" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id185">131</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://github.com/codeplaysoftware/sycl-for-cuda/blob/cuda/sycl/doc/GetStartedWithSYCLCompiler.md">https://github.com/codeplaysoftware/sycl-for-cuda/blob/cuda/sycl/doc/GetStartedWithSYCLCompiler.md</a></p>
</aside>
<aside class="footnote brackets" id="dpcpp" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id186">132</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.intel.com/content/www/us/en/developer/tools/oneapi/dpc-compiler.html#gs.cxolyy">https://www.intel.com/content/www/us/en/developer/tools/oneapi/dpc-compiler.html#gs.cxolyy</a></p>
</aside>
<aside class="footnote brackets" id="dpcpp-book" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id187">133</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://link.springer.com/book/10.1007/978-1-4842-5574-2">https://link.springer.com/book/10.1007/978-1-4842-5574-2</a></p>
</aside>
<aside class="footnote brackets" id="dpcpp-features" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id188">134</a><span class="fn-bracket">]</span></span>
<p>Page 14 of DPC++ book.</p>
</aside>
</aside>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="Bottom">
      
        <p>
        «&#160;&#160;<a href="verilog.html">Verify backend on Verilog simulator</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="install.html">Appendix A: Getting Started: Installing LLVM and the Cpu0 Example Code</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
    &#169; Copyright 2016, Chen Chung-Shu.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 9.1.0.
    </div>
  </body>
</html>