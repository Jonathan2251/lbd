
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>The concept of GPU compiler &#8212; Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Appendix A: Getting Started: Installing LLVM and the Cpu0 example code" href="install.html" />
    <link rel="prev" title="Verify backend on Verilog simulator" href="verilog.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</span></a></h1>
        <h2 class="heading"><span>The concept of GPU compiler</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="verilog.html">Verify backend on Verilog simulator</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="install.html">Appendix A: Getting Started: Installing LLVM and the Cpu0 example code</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="the-concept-of-gpu-compiler">
<span id="sec-gpu"></span><h1>The concept of GPU compiler<a class="headerlink" href="#the-concept-of-gpu-compiler" title="Permalink to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#concept-in-graphic-and-system" id="id201">Concept in graphic and system</a></p>
<ul>
<li><p><a class="reference internal" href="#d-modeling" id="id202">3D modeling</a></p></li>
<li><p><a class="reference internal" href="#graphic-hw-and-sw-stack" id="id203">Graphic HW and SW stack</a></p></li>
<li><p><a class="reference internal" href="#basic-geometry-in-computer-graphics" id="id204">Basic geometry in computer graphics</a></p>
<ul>
<li><p><a class="reference internal" href="#color" id="id205">Color</a></p></li>
<li><p><a class="reference internal" href="#transformation" id="id206">Transformation</a></p></li>
<li><p><a class="reference internal" href="#projection" id="id207">Projection</a></p></li>
<li><p><a class="reference internal" href="#cross-product" id="id208">Cross product</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#opengl" id="id209">OpenGL</a></p>
<ul>
<li><p><a class="reference internal" href="#example-of-opengl-program" id="id210">Example of OpenGL program</a></p></li>
<li><p><a class="reference internal" href="#d-rendering" id="id211">3D Rendering</a></p></li>
<li><p><a class="reference internal" href="#glsl-gl-shader-language" id="id212">GLSL (GL Shader Language)</a></p></li>
<li><p><a class="reference internal" href="#opengl-shader-compiler" id="id213">OpenGL Shader compiler</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#gpu-architecture" id="id214">GPU Architecture</a></p>
<ul>
<li><p><a class="reference internal" href="#simt" id="id215">SIMT</a></p></li>
<li><p><a class="reference internal" href="#vertex-unit" id="id216">Vertex unit</a></p>
<ul>
<li><p><a class="reference internal" href="#var-unit" id="id217">VAR unit</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#texture-unit" id="id218">Texture unit</a></p></li>
<li><p><a class="reference internal" href="#speedup-features" id="id219">Speedup Features</a></p></li>
<li><p><a class="reference internal" href="#buffers" id="id220">Buffers</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#general-purpose-gpu" id="id221">General purpose GPU</a></p>
<ul>
<li><p><a class="reference internal" href="#mapping-data-in-gpu" id="id222">Mapping data in GPU</a></p></li>
<li><p><a class="reference internal" href="#work-between-cpu-and-gpu-in-cuda" id="id223">Work between CPU and GPU in Cuda</a></p></li>
<li><p><a class="reference internal" href="#volta-cuda-thread-simd-lane-with-pc-program-couner-and-call-stack" id="id224">Volta (Cuda thread/SIMD lane with PC, Program Couner and Call Stack)</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#opencl-vulkan-and-spir-v" id="id225">OpenCL, Vulkan and spir-v</a></p></li>
<li><p><a class="reference internal" href="#accelerate-ml-dl-on-opencl-sycl" id="id226">Accelerate ML/DL on OpenCL/SYCL</a></p></li>
<li><p><a class="reference internal" href="#open-sources" id="id227">Open Sources</a></p></li>
</ul>
</nav>
<p>Basicly CPU is SISD (Single Instruction Single Data) Architecture in each core.
The multimedia instructions in CPU are smaller scaled of SIMD (Single
Instruction Multiple Data) while GPU is a large scaled of SIMD processor,
coloring millions of pixels of image in few mini seconds.
Since the 2D or 3D graphic processing provides large opportunity in parallel
data processing, GPU hardware usually composed tens thousands of functional
units in each chip for N-Vidia and other’s manufacturers.</p>
<p>This chapter is giving an overview for how 3D animation to be created and run on
CPU+GPU first.
After that, providing a concept in GPU compiler and HW featrues for graphic
application.
Finally, explaining how GPU has taking more applications from
CPU through GPGPU concept and related standards emerged.</p>
<p>Webiste, Basic theory of 3D graphics with OpenGL, <a class="footnote-reference brackets" href="#cg-basictheory" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>.</p>
<section id="concept-in-graphic-and-system">
<h2><a class="toc-backref" href="#id201" role="doc-backlink">Concept in graphic and system</a><a class="headerlink" href="#concept-in-graphic-and-system" title="Permalink to this heading">¶</a></h2>
<section id="d-modeling">
<h3><a class="toc-backref" href="#id202" role="doc-backlink">3D modeling</a><a class="headerlink" href="#d-modeling" title="Permalink to this heading">¶</a></h3>
<p>Through creating 3D model with Triangles or Quads along on skin, the 3D model
is created with polygon mesh <a class="footnote-reference brackets" href="#polygon" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> formed by all the vertices on the first image
as <a class="reference internal" href="#modeling1"><span class="std std-numref">Fig. 58</span></a>.</p>
<figure class="align-center" id="id156">
<span id="modeling1"></span><a class="reference internal image-reference" href="_images/modeling1.png"><img alt="_images/modeling1.png" src="_images/modeling1.png" style="width: 688.0px; height: 393.6px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 58 </span><span class="caption-text">Creating 3D model and texturing</span><a class="headerlink" href="#id156" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>After the next smooth shading <a class="footnote-reference brackets" href="#polygon" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>, the vertices and edge lines are covered
with color (or remove edges, actually edge never has black line), and model looks
much more smooth <a class="footnote-reference brackets" href="#shading" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>.
Further, after texturing (texture mapping), the model looks real more
<a class="footnote-reference brackets" href="#texturemapping" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a>.</p>
<p>To get to know how animation for a 3D modeling, please look video here <a class="footnote-reference brackets" href="#animation1" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a>.
According to the video for skeleton animation, setting the joints poistion at different
poses and giving time to each pose (keyframe) as <a class="reference internal" href="#animation"><span class="std std-numref">Fig. 59</span></a>.</p>
<figure class="align-center" id="id157">
<span id="animation"></span><a class="reference internal image-reference" href="_images/animation.png"><img alt="_images/animation.png" src="_images/animation.png" style="width: 962.0px; height: 497.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 59 </span><span class="caption-text">Set time point at keyframes</span><a class="headerlink" href="#id157" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>In this series of videos, you find the 3D modeling tools creating Java instead of
C/C++ code calling OpenGL api and shaders. It’s because Java can call OpenGL api
through a wrapper library <a class="footnote-reference brackets" href="#joglwiki" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a>.</p>
<p>Every CAD software manufacturer such as AutoDesk and Blender has their own proprietary
format. To solve the problem of interoperability, neutral or open source formats were
invented as intermediate formats for converting between two proprietary formats.
Naturally, these formats have become hugely popular now.
Two famous examples of neutral formats are STL (with a .STL extension) and COLLADA
(with a .DAE extension). Here is the list, where the 3D file formats are marked
with their type.</p>
<table class="docutils align-default" id="id158">
<caption><span class="caption-number">Table 42 </span><span class="caption-text">3D file formats <a class="footnote-reference brackets" href="#dfmt" id="id8" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a></span><a class="headerlink" href="#id158" title="Permalink to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>3D file format</p></th>
<th class="head"><p>Type</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>STL</p></td>
<td><p>Neutral</p></td>
</tr>
<tr class="row-odd"><td><p>OBJ</p></td>
<td><p>ASCII variant is neutral, binary variant is proprietary</p></td>
</tr>
<tr class="row-even"><td><p>FBX</p></td>
<td><p>Proprietary</p></td>
</tr>
<tr class="row-odd"><td><p>COLLADA</p></td>
<td><p>Neutral</p></td>
</tr>
<tr class="row-even"><td><p>3DS</p></td>
<td><p>Proprietary</p></td>
</tr>
<tr class="row-odd"><td><p>IGES</p></td>
<td><p>Neutral</p></td>
</tr>
<tr class="row-even"><td><p>STEP</p></td>
<td><p>Neutral</p></td>
</tr>
<tr class="row-odd"><td><p>VRML/X3D</p></td>
<td><p>Neutral</p></td>
</tr>
</tbody>
</table>
<p>The four key features a 3D file can store include the model’s geometry, the
model’s surface texture, scene details, and animation of the model <a class="footnote-reference brackets" href="#dfmt" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a>.</p>
<p>Specifically, they can store details about four key features of a 3D model,
though it’s worth bearing in mind that you may not always take advantage of
all four features in all projects, and not all file formats support all four
features!</p>
<p>3D printer applications do not to support animation. CAD and CAM such as
designing airplane does not need feature of scene details.</p>
<p>DAE (Collada) appeared in the video animation above.
Collada files  belong to a neutral format used heavily in the video game and
film industries. It’s managed by the non-profit technology consortium, the
Khronos Group.</p>
<p>The file extension for the Collada format is .dae.
The Collada format stores data using the XML mark-up language.</p>
<p>The original intention behind the Collada format was to become a standard among
3D file formats. Indeed, in 2013, it was adopted by ISO as a publicly available
specification, ISO/PAS 17506. As a result, many 3D modeling programs support
the Collada format.</p>
<p>That said, the consensus is that the Collada format hasn’t kept up with the
times. It was once used heavily as an interchange format for Autodesk Max/Maya
in film production, but the industry has now shifted more towards OBJ, FBX,
and Alembic <a class="footnote-reference brackets" href="#dfmt" id="id10" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a>.</p>
</section>
<section id="graphic-hw-and-sw-stack">
<h3><a class="toc-backref" href="#id203" role="doc-backlink">Graphic HW and SW stack</a><a class="headerlink" href="#graphic-hw-and-sw-stack" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Free_and_open-source_graphics_device_driver">https://en.wikipedia.org/wiki/Free_and_open-source_graphics_device_driver</a></p></li>
</ul>
<p>The block diagram of Graphic Processing Unit (GPU) as
<a class="reference internal" href="#gpu-block-diagram"><span class="std std-numref">Fig. 60</span></a>.</p>
<figure class="align-center" id="id159">
<span id="gpu-block-diagram"></span><a class="reference internal image-reference" href="_images/gpu-block-diagram.png"><img alt="_images/gpu-block-diagram.png" src="_images/gpu-block-diagram.png" style="width: 400.0px; height: 375.5px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 60 </span><span class="caption-text">Components of a GPU: GPU has accelerated video decoding and encoding
<a class="footnote-reference brackets" href="#wiki-gpu" id="id11" role="doc-noteref"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></a></span><a class="headerlink" href="#id159" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>The role of CPU and GPU for graphic animation as <a class="reference internal" href="#graphic-cpu-gpu"><span class="std std-numref">Fig. 61</span></a>.</p>
<figure class="align-center" id="id160">
<span id="graphic-cpu-gpu"></span><a class="reference internal image-reference" href="_images/graphic-cpu-gpu.png"><img alt="_images/graphic-cpu-gpu.png" src="_images/graphic-cpu-gpu.png" style="width: 508.0px; height: 291.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 61 </span><span class="caption-text">OpenGL and Vulkan are both rendering APIs. In both cases, the GPU executes
shaders, while the CPU executes everything else <a class="footnote-reference brackets" href="#ogl-cpu-gpu" id="id12" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a>.</span><a class="headerlink" href="#id160" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<ul class="simple">
<li><p>GPU can’t directly read user input from, say, keyboard, mouse, gamepad, or
play audio, or load files from a hard drive, or anything like that. In this
situation, cannot let GPU handle the animation work <a class="footnote-reference brackets" href="#cpu-gpu-role" id="id13" role="doc-noteref"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></a>.</p></li>
<li><p>A graphics driver consists of an implementation of the OpenGL state machine
and a compilation stack to compile the shaders into the GPU’s machine language.
This compilation, as well as pretty much anything else, is executed on the CPU,
then the compiled shaders are sent to the GPU and are executed by it.
(SDL = Simple DirectMedia Layer) <a class="footnote-reference brackets" href="#mesawiki" id="id14" role="doc-noteref"><span class="fn-bracket">[</span>11<span class="fn-bracket">]</span></a>.</p></li>
</ul>
<figure class="align-center" id="id161">
<span id="graphic-gpu-csf"></span><a class="reference internal image-reference" href="_images/graphic-gpu-csf.png"><img alt="_images/graphic-gpu-csf.png" src="_images/graphic-gpu-csf.png" style="width: 459.0px; height: 436.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 62 </span><span class="caption-text">MCU and specific HW circuits to speedup the processing of CSF
(Command Stream Fronted) <a class="footnote-reference brackets" href="#csf" id="id15" role="doc-noteref"><span class="fn-bracket">[</span>12<span class="fn-bracket">]</span></a>.</span><a class="headerlink" href="#id161" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>The GPU driver write command and data from CPU to GPU’s system memory through
PCIe. These commands are called Command Stream Fronted (CSF) in the memory of
GPU. A chipset of GPU includes tens of SIMD processors (cores). In order to
speedup the GPU driver’s processing, the CSF is designed to a simpler form.
As result, GPU chipset include MCU (Micro Chip Unit) and specfic HW to transfer
the CSF into individual data structure for each SIMD processor to execute as
<a class="reference internal" href="#graphic-gpu-csf"><span class="std std-numref">Fig. 62</span></a>. The firmware version of MCU is updated by MCU itself
usually.</p>
<p>The driver run on CPU side as <a class="reference internal" href="#graphic-sw-stack"><span class="std std-numref">Fig. 63</span></a>.
The OpenGL Api will call
driver’s function eventually and driver finish the function’s work via issuing
GPU-HW’s command and/or sending data to GPU.
Even so, GPU’s rendor work from the data of 3D vertex, colors, … sending from
CPU and storing in GPU’s memory or shared memory consume more computing power
than CPU.</p>
<figure class="align-default" id="id162">
<span id="graphic-sw-stack"></span><div class="graphviz"><img src="_images/graphviz-2bb1223b868cee8597e80f1f0f99c9ccb217bab1.png" alt="digraph G {
  rankdir=LR;
  
  compound=true;
  node [shape=record];
  subgraph cluster_cpu {
    label = &quot;CPU (Client)&quot;;
    CPU_SW [label=&quot; 3D Model | JAVA | JOGL | { OpenGL API | Shaders \n (buitin-functions)} | &lt;f1&gt; Driver&quot;];
  }
  subgraph cluster_gpu {
    label = &quot;GPU HW (Server)&quot;
    GPU_SW [label=&quot;&lt;f1&gt; 3D Rendering-pipeline \ndescribed in next section&quot;];
  }
  CPU_SW:f1 -&gt; GPU_SW:f1 [label=&quot; VAO, texture, ..., from 3D model, \n shader-exectuable-code&quot;];
    
//  label = &quot;Graphic SW Stack&quot;;
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 63 </span><span class="caption-text">Graphic SW Stack</span><a class="headerlink" href="#id162" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<ul class="simple">
<li><p>According the previous section, after user create skeleton and skin for each
model and set keyframes time through 3D modeling tool, the 3D modeling tool
can either generate Java code which calling JOGL (Java OpenGL) <a class="footnote-reference brackets" href="#joglwiki" id="id16" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a>,
or generate OpenCL API directly. The frame data can be calculated from
interplation between keyframes.</p></li>
<li><p>As above, every animation the client CPU program set new position of obect
(vertices) and colors, the data of one frame, server (driver and GPU) does
the 3D to 2D rendering. Higher-level
libraries and frameworks on top of OpenGL provide animation framework and
tools to generate OpenGL API and shaders from 3D model.</p></li>
<li><p>Shader may call Builtin-functions which written from Compute Shader, spriv or
LLVM-IR. LLVM libclc is a project for builtin-functions in OpenCL which can
be used in OpenGL too <a class="footnote-reference brackets" href="#libclc" id="id17" role="doc-noteref"><span class="fn-bracket">[</span>13<span class="fn-bracket">]</span></a>.
Like CPU’s builtin-functions, new GPU ISA/architecture has to implement their
builtin-functions or porting from open source such as libclc.</p></li>
<li><p>3D model (CPU) does the rendering animation to generate each frame between
keyframes (poses) while GPU does the rendering pipeline from each frame to
each pixel’s value.</p></li>
<li><p>These frames data existed in the form of VAO (Vertex Array Object) in OpenGL.
It will be explaned in later <a class="reference external" href="http://jonathan2251.github.io/lbd/gpu.html#opengl">section OpenGL</a>.</p></li>
<li><p>In addition, OpenGL provides vertex buffer object (VBO) allowing
vertex array data to be stored in high-performance graphics memory on the
server side and promotes efficient data transfer <a class="footnote-reference brackets" href="#vbo" id="id18" role="doc-noteref"><span class="fn-bracket">[</span>14<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#classorvbo" id="id19" role="doc-noteref"><span class="fn-bracket">[</span>15<span class="fn-bracket">]</span></a>.</p></li>
<li><p>3D animation SW provides a lot of builtin shaders. Programmer can write
their shaders to the game engine.</p></li>
</ul>
<p>The flow for 3D/2D graphic processing as <a class="reference internal" href="#opengl-flow"><span class="std std-numref">Fig. 64</span></a>.</p>
<figure class="align-default" id="id163">
<span id="opengl-flow"></span><div class="graphviz"><img src="_images/graphviz-f17b1aa5311f9a0521d18bf3c8d018edc6cdaa1c.png" alt="digraph G {
  rankdir=LR;

  compound=true;
  node [shape=record];
  subgraph cluster_3d {
    label = &quot;3D/2D modeling software&quot;;
    subgraph cluster_code {
      label = &quot;3D/2D's code: engine, lib, shader, ...&quot;;
      Api [label=&quot;&lt;g&gt; Generated Code | &lt;a&gt; OpenGL API | lib | &lt;s&gt; Shaders (3D animation's shaders \n or programmer writing shaders&quot;];
    }
  }
  subgraph cluster_driver {
    label = &quot;Driver&quot;
    Compiler [label=&quot;On-line Compiler&quot;];
    Obj [label=&quot;obj&quot;];
    Linker [label=&quot;On-line binding (Linker)&quot;];
    Exe [label=&quot;exe&quot;];
  }
  Api:a -&gt; Obj [lhead =&quot;cluster_driver&quot;];
  Api:s -&gt; Compiler;
  Compiler -&gt; Obj -&gt; Linker -&gt; Exe;
  Exe -&gt; GPU;
  Exe -&gt; CPU [ltail =&quot;cluster_driver&quot;]; 

//  label = &quot;OpenGL Flow&quot;;
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 64 </span><span class="caption-text">OpenGL Flow</span><a class="headerlink" href="#id163" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id164">
<span id="db-vsync"></span><a class="reference internal image-reference" href="_images/db-vsync.png"><img alt="_images/db-vsync.png" src="_images/db-vsync.png" style="width: 348.0px; height: 324.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 65 </span><span class="caption-text">VSync</span><a class="headerlink" href="#id164" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p class="rubric">VSync</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>No tearing, GPU and Display run at same refresh rate since GPU refresh faster
than Display.

              A    B

GPU      | ----| ----|

Display  |-----|-----|

            B      A

Tearing, GPU has exactly refresh cycles but VSync takes one cycle more.
than Display.

              A

GPU      | -----|

Display  |-----|-----|

            B      A

Avoid tearing, GPU has refresh rate 1/2 of Display&#39;s refresh rate.
than Display.

              A          B

GPU      | -----|    | -----|

Display  |-----|-----|-----|-----|

            B      B    A     A
</pre></div>
</div>
<ul>
<li><p>Double Buffering</p>
<p>While the display is reading from the frame buffer to display the current
frame, we might be updating its contents for the next frame (not necessarily
in raster-scan manner). This would result in the so-called tearing, in which
the screen shows parts of the old frame and parts of the new frame.
This could be resolved by using so-called double buffering. Instead of using
a single frame buffer, modern GPU uses two of them: a front buffer and a back
buffer. The display reads from the front buffer, while we can write the next
frame to the back buffer. When we finish, we signal to GPU to swap the front
and back buffer (known as buffer swap or page flip).</p>
</li>
<li><p>VSync</p>
<p>Double buffering alone does not solve the entire problem, as the buffer swap
might occur at an inappropriate time, for example, while the display is in
the middle of displaying the old frame. This is resolved via the so-called
vertical synchronization (or VSync) at the end of the raster-scan.
When we signal to the GPU to do a buffer swap, the GPU will wait till the next
VSync to perform the actual swap, after the entire current frame is displayed.</p>
<p>As above text digram.
The most important point is: When the VSync buffer-swap is enabled, you cannot
refresh the display faster than the refresh rate of the display!!!
If GPU is capable of producing higher frame rates than the display’s
refresh rate, then GPU can use fast rate without tearing.
If GPU has same or less frame rates then display’s and you application
refreshes at a fixed rate, the resultant refresh rate is
likely to be an integral factor of the display’s refresh rate, i.e., 1/2, 1/3,
1/4, etc. Otherwise it will cause tearing <a class="footnote-reference brackets" href="#cg-basictheory" id="id20" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>.</p>
</li>
<li><p>NVIDIA G-SYNC and AMD FreeSync</p>
<p>If your monitor and graphics card both in your customer computer support
NVIDIA G-SYNC, you’re in luck. With this technology, a special chip in the
display communicates with the graphics card. This lets the monitor vary the
refresh rate to match the frame rate of the NVIDIA GTX graphics card, up to
the maximum refresh rate of the display. This means that the frames are
displayed as soon as they are rendered by the GPU, eliminating screen tearing
and reducing stutter for when the frame rate is both higher and lower than
the refresh rate of the display. This makes it perfect for situations where
the frame rate varies, which happens a lot when gaming.
Today, you can even find G-SYNC technology in gaming laptops!</p>
<p>AMD has a similar solution called FreeSync. However, this doesn’t require a
proprietary chip in the monitor.
In FreeSync, the AMD Radeon driver, and the display firmware handle the
communication.
Generally, FreeSync monitors are less expensive than their G-SYNC counterparts,
but gamers generally prefer G-SYNC over FreeSync as the latter may cause
ghosting, where old images leave behind artifacts <a class="footnote-reference brackets" href="#g-sync" id="id21" role="doc-noteref"><span class="fn-bracket">[</span>16<span class="fn-bracket">]</span></a>.</p>
</li>
</ul>
</section>
<section id="basic-geometry-in-computer-graphics">
<h3><a class="toc-backref" href="#id204" role="doc-backlink">Basic geometry in computer graphics</a><a class="headerlink" href="#basic-geometry-in-computer-graphics" title="Permalink to this heading">¶</a></h3>
<p>This section instroduces the basic geometry math for computer graphics.
The complete concept can be found in
Book: “Computer graphics principles and practice 3rd editon, authors: JOHN F,
…”. But it is 1 thousand of pages.
This book is very complete and may take much time to understand every detail.</p>
<section id="color">
<h4><a class="toc-backref" href="#id205" role="doc-backlink">Color</a><a class="headerlink" href="#color" title="Permalink to this heading">¶</a></h4>
<ul class="simple">
<li><p>Additive colors in light as <a class="reference internal" href="#additive-colors"><span class="std std-numref">Fig. 66</span></a> <a class="footnote-reference brackets" href="#additive-colors-wiki" id="id22" role="doc-noteref"><span class="fn-bracket">[</span>17<span class="fn-bracket">]</span></a>
<a class="footnote-reference brackets" href="#additive-colors-ytube" id="id23" role="doc-noteref"><span class="fn-bracket">[</span>18<span class="fn-bracket">]</span></a>. If in paints, it adds shade and become light grey
since it add shade (dark color) <a class="footnote-reference brackets" href="#additive-colors-shade" id="id24" role="doc-noteref"><span class="fn-bracket">[</span>19<span class="fn-bracket">]</span></a>.</p></li>
</ul>
<figure class="align-center" id="id165">
<span id="additive-colors"></span><a class="reference internal image-reference" href="_images/additive-colors.png"><img alt="_images/additive-colors.png" src="_images/additive-colors.png" style="width: 954.0px; height: 346.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 66 </span><span class="caption-text">Additive colors in light</span><a class="headerlink" href="#id165" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>Additive colors</strong></p>
<p>I know it’s not match human’s intuition. However the additive colors RGB in
light become totally white light, and the additive colors RGB in paints become
light grey paint is reasonalbe since light has no shade. This result comes from
the sense of human’s eyes. When no light no color can be sensed by eyes.
Computer engineers should know if you try to explore the very basic nature,
then it is fields of physics or human’s eyes structure in bilogy.</p>
</div>
</section>
<section id="transformation">
<h4><a class="toc-backref" href="#id206" role="doc-backlink">Transformation</a><a class="headerlink" href="#transformation" title="Permalink to this heading">¶</a></h4>
<p>Objects (Triangle/Quad) can be moved in 2D/3D with martix representation in wiki
here <a class="footnote-reference brackets" href="#wiki-transformation" id="id25" role="doc-noteref"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></a>. The rotation matrix in wiki is derived from wiki
here <a class="footnote-reference brackets" href="#wiki-rotation" id="id26" role="doc-noteref"><span class="fn-bracket">[</span>21<span class="fn-bracket">]</span></a>.</p>
<p>Every
computer graphics book has provided topics of transformation of object and
position in space. Chapter 4 of Blue book: OpenGL SuperBible 7th Edition give
a short description (40 pages) and useful concept is a good material for
knowing the concept. Given the following for Quaternion Product (Hamilton
product) from Wiki <a class="footnote-reference brackets" href="#wiki-quaternion" id="id27" role="doc-noteref"><span class="fn-bracket">[</span>22<span class="fn-bracket">]</span></a> since the book miss this.</p>
<div class="math notranslate nohighlight">
\[\mathbf ij = -ji = k, jk = -kj = i, ki = -ik = j.\]</div>
<figure class="align-center" id="id166">
<span id="trans-steps"></span><a class="reference internal image-reference" href="_images/trans-steps.png"><img alt="_images/trans-steps.png" src="_images/trans-steps.png" style="width: 877.0px; height: 156.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 67 </span><span class="caption-text">Cooridinates Transform Pipeline <a class="footnote-reference brackets" href="#cg-basictheory" id="id28" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></span><a class="headerlink" href="#id166" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>Detail for <a class="reference internal" href="#trans-steps"><span class="std std-numref">Fig. 67</span></a> on website <a class="footnote-reference brackets" href="#cg-basictheory" id="id29" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>.</p>
</section>
<section id="projection">
<h4><a class="toc-backref" href="#id207" role="doc-backlink">Projection</a><a class="headerlink" href="#projection" title="Permalink to this heading">¶</a></h4>
<figure class="align-center" id="viewfrustum">
<a class="reference internal image-reference" href="_images/ViewFrustum.png"><img alt="_images/ViewFrustum.png" src="_images/ViewFrustum.png" style="width: 222.6px; height: 182.1px;" /></a>
</figure>
<p>Only objects in the cone between near and far planes are projected to 2D for
prospective projection..</p>
<p>Prospective projection and orthographic projection (used in CAD tools) from 3D
to 2D can be represented by transformation matrix in the previous section
<a class="footnote-reference brackets" href="#wiki-prospective-projection" id="id30" role="doc-noteref"><span class="fn-bracket">[</span>23<span class="fn-bracket">]</span></a>.</p>
</section>
<section id="cross-product">
<h4><a class="toc-backref" href="#id208" role="doc-backlink">Cross product</a><a class="headerlink" href="#cross-product" title="Permalink to this heading">¶</a></h4>
<p>Both Triangles or Quads are ploygon. So, objects can be formed with ploygon in
both 2D and 3D. About transfermation in 2D or 3D, almost every book of computer
graphics has mentioned well already. This section introduces the most important
concept and method for deciding Inner and Outer planes, then a point or object
can be checked for showing or hidding during 2D or 3D rendering.</p>
<p>Any <strong>area</strong> of polygon can be calculated by dividing into Triangles or Quads. And
any area of Triangle or Quad can be calculated by cross product in 3D.
The cross product in <strong>3D</strong> is defined by the formula and can be represented with
matrix notation as proved here <a class="footnote-reference brackets" href="#cross-product-wiki" id="id31" role="doc-noteref"><span class="fn-bracket">[</span>24<span class="fn-bracket">]</span></a>.</p>
<div class="math notranslate nohighlight">
\[\mathbf a \mathsf x \mathbf b = \Vert a \Vert \Vert b \Vert sin(\Theta) n\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf a \mathsf x \mathbf b =
\begin{vmatrix}
\mathbf i &amp; \mathbf j&amp; \mathbf k\\
a_1&amp; a_2&amp; a_3\\
b_1&amp; b_2&amp; b_3
\end{vmatrix}\end{split}\]</div>
<p>The cross product in <strong>2D</strong> is defined by the formula and can be represented with matrix
notation as proved here
<a class="footnote-reference brackets" href="#cross-product-2d-proof" id="id32" role="doc-noteref"><span class="fn-bracket">[</span>25<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#cross-product-2d-proof2" id="id33" role="doc-noteref"><span class="fn-bracket">[</span>26<span class="fn-bracket">]</span></a>.</p>
<div class="math notranslate nohighlight">
\[\mathbf a \mathsf x \mathbf b = \Vert a \Vert \Vert b \Vert sin(\Theta)\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf a \mathsf x \mathbf b =
\begin{vmatrix}
\mathbf i &amp; \mathbf j&amp; \mathbf k\\
a_1&amp; a_2&amp; 0\\
b_1&amp; b_2&amp; 0
\end{vmatrix} =
\begin{bmatrix}
a_1&amp; a_2 \\
b_1&amp; b_2
\end{bmatrix}\end{split}\]</div>
<p>After above matrix form is proved, the Antisymmetric may be proved as follows,</p>
<div class="math notranslate nohighlight">
\[\begin{split}a \mathsf x b = \mathsf x&amp;
\begin{bmatrix}
a \\
b
\end{bmatrix} =
\begin{bmatrix}
a_1&amp; a_2 \\
b_1&amp; b_2
\end{bmatrix} =
a_1b_2 - a_2b_1 =\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}-b_1a_2 - (-b_2a_1) =
\begin{bmatrix}
- b_1&amp; - b_2 \\
a_1&amp; a_2
\end{bmatrix} =
\mathsf x&amp;
\begin{bmatrix}
-b \\
a
\end{bmatrix} =
-b \mathsf x a\end{split}\]</div>
<p>In 2D, any two points <span class="math notranslate nohighlight">\(\text{ from } P_i \text{ to } P_{i+1}\)</span> can form a
vector and decide inner side or outer side.
For example, as <a class="reference internal" href="#inward-edge-normals"><span class="std std-numref">Fig. 68</span></a>, <span class="math notranslate nohighlight">\(\Theta\)</span> is the angle
from <span class="math notranslate nohighlight">\(P_iP_{i+1}\)</span> to <span class="math notranslate nohighlight">\(P_iP'_{i+1} = 180^\circ\)</span>.
So, with right-hand rule, counter clockwise order, any
<span class="math notranslate nohighlight">\(P_iQ\)</span> between <span class="math notranslate nohighlight">\(P_iP_{i+1}\)</span> to <span class="math notranslate nohighlight">\(P_iP'_{i+1}\)</span>, the angle of
<span class="math notranslate nohighlight">\(P_iP_{i+1}\)</span> to <span class="math notranslate nohighlight">\(P_iQ = \theta, 0^\circ &lt; \theta &lt; 180^\circ\)</span>
then the inward direction be decided.</p>
<figure class="align-center" id="id167">
<span id="inward-edge-normals"></span><a class="reference internal image-reference" href="_images/inward-edge-normals.png"><img alt="_images/inward-edge-normals.png" src="_images/inward-edge-normals.png" style="width: 676.0px; height: 265.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 68 </span><span class="caption-text">Inward edge normals</span><a class="headerlink" href="#id167" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id168">
<span id="d-vector-inward"></span><a class="reference internal image-reference" href="_images/2d-vector-inward.png"><img alt="_images/2d-vector-inward.png" src="_images/2d-vector-inward.png" style="width: 418.0px; height: 203.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 69 </span><span class="caption-text">Inward and outward in 2D for a vector.</span><a class="headerlink" href="#id168" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>Base on this observation, the rule for inward and outward to any vector as
<a class="reference internal" href="#inward-edge-normals"><span class="std std-numref">Fig. 68</span></a>. Face the same direction of a specific vector,
the left side is inward and right side is outward as
<a class="reference internal" href="#d-vector-inward"><span class="std std-numref">Fig. 69</span></a>.</p>
<p>For each edge <span class="math notranslate nohighlight">\(P_i - P_{i+1}\)</span>, the inward edge normal is the vector
<span class="math notranslate nohighlight">\(\mathsf x\; v_i\)</span>; the outward edge normal is <span class="math notranslate nohighlight">\(\; -\; \mathsf x\; v_i\)</span>.
Where <span class="math notranslate nohighlight">\(\; \mathsf x\; v_i\)</span> is coss-product(<span class="math notranslate nohighlight">\(\mathsf v_i\)</span>) as
<a class="reference internal" href="#inward-edge-normals"><span class="std std-numref">Fig. 68</span></a>.</p>
<p>Polygon can be created from vertices.
Suppose that <span class="math notranslate nohighlight">\((P_0, P_1, ..., P_n)\)</span> is a polygon. The line segments
<span class="math notranslate nohighlight">\(P_0P_1, P_1P_2\)</span>, etc., are the edges of the polygon; the vectors
<span class="math notranslate nohighlight">\(v_0 = P_1 - P_0, v_1 = P_2 - P_1, ..., v_n = P_0 - P_n\)</span> are the edges
of the polygon. Through counter clockwise, the left side is inward, then the
inward region of polygon can be decided.</p>
<p>For a convex polygon whose vertices are listed in counter clockwise order, the
inward edge normals point toward the interior of the polygon, and the outward
edge normals point toward the unbounded exterior of the polygon,
corresponding to our ordinary intuition. But if the vertices of a polygon are
given in clockwise order, the interior and exterior swap roles.</p>
<p>This cross product has an important property: Going from v to ×v involves a
rotation by 90◦ in the same direction as the rotation that takes the positive
x-axis to the positive y-axis.</p>
<figure class="align-center" id="id169">
<span id="in-polygon"></span><a class="reference internal image-reference" href="_images/polygon.png"><img alt="_images/polygon.png" src="_images/polygon.png" style="width: 237.0px; height: 160.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 70 </span><span class="caption-text">Draw a polygon with vectices counter clockwise</span><a class="headerlink" href="#id169" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>As <a class="reference internal" href="#in-polygon"><span class="std std-numref">Fig. 70</span></a>, when drawing polygon with vectors(lines) counter
clockwise, the ploygon will be created and the two sides of a vector(line)
can be indentified <a class="footnote-reference brackets" href="#cgpap" id="id34" role="doc-noteref"><span class="fn-bracket">[</span>27<span class="fn-bracket">]</span></a>.
Further a point in polygon or out of polygon can be identified.
One simple way of finding whether the point is inside or outside a simple
polygon is to test how many times a ray, starting from the point and going in
any fixed direction, intersects the edges of the polygon. If the point is on
the outside of the polygon the ray will intersect its edge an even number of
times. If the point is on the inside of the polygon then it will intersect the
edge an odd number of times <a class="footnote-reference brackets" href="#wiki-point-in-polygon" id="id35" role="doc-noteref"><span class="fn-bracket">[</span>28<span class="fn-bracket">]</span></a>.</p>
<figure class="align-center" id="id170">
<span id="d-cross-product"></span><a class="reference internal image-reference" href="_images/3d-cross-product.png"><img alt="_images/3d-cross-product.png" src="_images/3d-cross-product.png" style="width: 230.0px; height: 355.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 71 </span><span class="caption-text">Cross product definition in 3D</span><a class="headerlink" href="#id170" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>In the same way, through following the same direction counter clockwise to
create 2D polygon one by one, then the 3D polygon will be created.
As <a class="reference internal" href="#d-cross-product"><span class="std std-numref">Fig. 71</span></a> from wiki <a class="footnote-reference brackets" href="#cross-product-wiki" id="id36" role="doc-noteref"><span class="fn-bracket">[</span>24<span class="fn-bracket">]</span></a>, the inward
direction can be decided with a x b &lt; 0 and outward is a x b &gt; 0 in OpenGL.
Replace a, b with x, y as <a class="reference internal" href="#ogl-pointing-outwards"><span class="std std-numref">Fig. 72</span></a> axis z+ is the
outer surface and z- is the inner surface <a class="footnote-reference brackets" href="#ogl-point-outwards" id="id37" role="doc-noteref"><span class="fn-bracket">[</span>29<span class="fn-bracket">]</span></a>.</p>
<figure class="align-center" id="id171">
<span id="ogl-pointing-outwards"></span><a class="reference internal image-reference" href="_images/ogl-pointing-outwards.png"><img alt="_images/ogl-pointing-outwards.png" src="_images/ogl-pointing-outwards.png" style="width: 685.0px; height: 320.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 72 </span><span class="caption-text">OpenGL pointing outwards, indicating the outer surface (z axis is +)</span><a class="headerlink" href="#id171" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id172">
<span id="in-3d-polygon"></span><a class="reference internal image-reference" href="_images/3d-polygon.png"><img alt="_images/3d-polygon.png" src="_images/3d-polygon.png" style="width: 285.0px; height: 243.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 73 </span><span class="caption-text">3D polygon with directions on each plane</span><a class="headerlink" href="#id172" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>The <a class="reference internal" href="#in-3d-polygon"><span class="std std-numref">Fig. 73</span></a> is an example of 3D polygon created by 2D triangles.
The direction of plane (triangle) as the line perpendicular to the plane.</p>
<p>Cast a ray from the 3D point along X-axis and check how many intersections with
outer object you find. Depending on the intersection number on each axis (even
or odd) you can understand if your point is inside or outside
<a class="footnote-reference brackets" href="#point-in-3d-object" id="id38" role="doc-noteref"><span class="fn-bracket">[</span>30<span class="fn-bracket">]</span></a>.
Inside is odd and outside is even. As <a class="reference internal" href="#in-3d-object"><span class="std std-numref">Fig. 74</span></a>, points on the
line going through the object satisfy this rule.</p>
<figure class="align-center" id="id173">
<span id="in-3d-object"></span><a class="reference internal image-reference" href="_images/in-3d-object.png"><img alt="_images/in-3d-object.png" src="_images/in-3d-object.png" style="width: 190.0px; height: 238.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 74 </span><span class="caption-text">Point in or out 3D object</span><a class="headerlink" href="#id173" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p class="rubric">OpenGL uses counter clockwise and pointing outwards as default <a class="footnote-reference brackets" href="#vbo" id="id39" role="doc-noteref"><span class="fn-bracket">[</span>14<span class="fn-bracket">]</span></a>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// unit cube</span>
<span class="c1">// A cube has 6 sides and each side has 4 vertices, therefore, the total number</span>
<span class="c1">// of vertices is 24 (6 sides * 4 verts), and 72 floats in the vertex array</span>
<span class="c1">// since each vertex has 3 components (x,y,z) (= 24 * 3)</span>
<span class="c1">//    v6----- v5</span>
<span class="c1">//   /|      /|</span>
<span class="c1">//  v1------v0|</span>
<span class="c1">//  | |     | |</span>
<span class="c1">//  | v7----|-v4</span>
<span class="c1">//  |/      |/</span>
<span class="c1">//  v2------v3</span>

<span class="c1">// vertex position array</span>
<span class="n">GLfloat</span><span class="w"> </span><span class="n">vertices</span><span class="p">[]</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="mf">.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="w">  </span><span class="mf">-.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="w">  </span><span class="mf">-.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="w">  </span><span class="mf">.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="w"> </span><span class="c1">// v0,v1,v2,v3 (front)</span>
<span class="w">   </span><span class="mf">.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="w">   </span><span class="mf">.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="w">   </span><span class="mf">.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="w">  </span><span class="mf">.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="w"> </span><span class="c1">// v0,v3,v4,v5 (right)</span>
<span class="w">   </span><span class="mf">.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="w">   </span><span class="mf">.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="w">  </span><span class="mf">-.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">-.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="w"> </span><span class="c1">// v0,v5,v6,v1 (top)</span>
<span class="w">  </span><span class="mf">-.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="w">  </span><span class="mf">-.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="w">  </span><span class="mf">-.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">-.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="w"> </span><span class="c1">// v1,v6,v7,v2 (left)</span>
<span class="w">  </span><span class="mf">-.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="w">   </span><span class="mf">.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="w">   </span><span class="mf">.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">-.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="w"> </span><span class="c1">// v7,v4,v3,v2 (bottom)</span>
<span class="w">   </span><span class="mf">.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="w">  </span><span class="mf">-.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="w">  </span><span class="mf">-.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="p">,</span><span class="w">  </span><span class="mf">.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">.5f</span><span class="p">,</span><span class="mf">-.5f</span><span class="w">  </span><span class="c1">// v4,v7,v6,v5 (back)</span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>From code above, we can see that OpenGL uses counter clockwise and pointing
outwards as default. However OpenGL provides glFrontFace(GL_CW) for clockwise
<a class="footnote-reference brackets" href="#ogl-frontface" id="id40" role="doc-noteref"><span class="fn-bracket">[</span>31<span class="fn-bracket">]</span></a>.</p>
<p>For group of objects, scene graph provides better animation and saving memory
<a class="footnote-reference brackets" href="#scene-graph-wiki" id="id41" role="doc-noteref"><span class="fn-bracket">[</span>32<span class="fn-bracket">]</span></a>.</p>
</section>
</section>
</section>
<section id="opengl">
<h2><a class="toc-backref" href="#id209" role="doc-backlink">OpenGL</a><a class="headerlink" href="#opengl" title="Permalink to this heading">¶</a></h2>
<section id="example-of-opengl-program">
<h3><a class="toc-backref" href="#id210" role="doc-backlink">Example of OpenGL program</a><a class="headerlink" href="#example-of-opengl-program" title="Permalink to this heading">¶</a></h3>
<p>The following example from openGL redbook and example code <a class="footnote-reference brackets" href="#redbook" id="id42" role="doc-noteref"><span class="fn-bracket">[</span>37<span class="fn-bracket">]</span></a>
<a class="footnote-reference brackets" href="#redbook-examples" id="id43" role="doc-noteref"><span class="fn-bracket">[</span>38<span class="fn-bracket">]</span></a>.</p>
<p class="rubric">References/triangles.vert</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="c1">#version 400 core</span>

<span class="n">layout</span><span class="p">(</span> <span class="n">location</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">)</span> <span class="ow">in</span> <span class="n">vec4</span> <span class="n">vPosition</span><span class="p">;</span>

<span class="n">void</span>
<span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">vPosition</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">References/triangles.frag</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#version 450 core</span>

<span class="n">out</span> <span class="n">vec4</span> <span class="n">fColor</span><span class="p">;</span>

<span class="n">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">fColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">References/01-triangles.cpp</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">  1</span><span class="c1">//////////////////////////////////////////////////////////////////////////////</span>
<span class="linenos">  2</span><span class="c1">//</span>
<span class="linenos">  3</span><span class="c1">//  Triangles.cpp</span>
<span class="linenos">  4</span><span class="c1">//</span>
<span class="linenos">  5</span><span class="c1">//////////////////////////////////////////////////////////////////////////////</span>
<span class="linenos">  6</span>
<span class="linenos">  7</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;vgl.h&quot;</span><span class="cp"></span>
<span class="linenos">  8</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;LoadShaders.h&quot;</span><span class="cp"></span>
<span class="linenos">  9</span>
<span class="linenos"> 10</span><span class="k">enum</span><span class="w"> </span><span class="nc">VAO_IDs</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Triangles</span><span class="p">,</span><span class="w"> </span><span class="n">NumVAOs</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="linenos"> 11</span><span class="k">enum</span><span class="w"> </span><span class="nc">Buffer_IDs</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ArrayBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">NumBuffers</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="linenos"> 12</span><span class="k">enum</span><span class="w"> </span><span class="nc">Attrib_IDs</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">vPosition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="linenos"> 13</span>
<span class="linenos"> 14</span><span class="n">GLuint</span><span class="w">  </span><span class="n">VAOs</span><span class="p">[</span><span class="n">NumVAOs</span><span class="p">];</span><span class="w"></span>
<span class="linenos"> 15</span><span class="n">GLuint</span><span class="w">  </span><span class="n">Buffers</span><span class="p">[</span><span class="n">NumBuffers</span><span class="p">];</span><span class="w"></span>
<span class="linenos"> 16</span>
<span class="linenos"> 17</span><span class="k">const</span><span class="w"> </span><span class="n">GLuint</span><span class="w">  </span><span class="n">NumVertices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 18</span>
<span class="linenos"> 19</span><span class="c1">//----------------------------------------------------------------------------</span>
<span class="linenos"> 20</span><span class="c1">//</span>
<span class="linenos"> 21</span><span class="c1">// init</span>
<span class="linenos"> 22</span><span class="c1">//</span>
<span class="linenos"> 23</span>
<span class="linenos"> 24</span><span class="kt">void</span><span class="w"></span>
<span class="linenos"> 25</span><span class="nf">init</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="linenos"> 26</span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 27</span><span class="w">    </span><span class="n">glGenVertexArrays</span><span class="p">(</span><span class="w"> </span><span class="n">NumVAOs</span><span class="p">,</span><span class="w"> </span><span class="n">VAOs</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">// Same with glCreateVertexArray( NumVAOs, VAOs ); </span>
<span class="linenos"> 28</span><span class="w">      </span><span class="c1">// https://stackoverflow.com/questions/24441430/glgen-vs-glcreate-naming-convention</span>
<span class="linenos"> 29</span><span class="w">    </span><span class="c1">// Make the new VAO:VAOs[Triangles] active, creating it if necessary.</span>
<span class="linenos"> 30</span><span class="w">    </span><span class="n">glBindVertexArray</span><span class="p">(</span><span class="w"> </span><span class="n">VAOs</span><span class="p">[</span><span class="n">Triangles</span><span class="p">]</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 31</span><span class="w">    </span><span class="c1">// opengl-&gt;current_array_buffer = VAOs[Triangles]</span>
<span class="linenos"> 32</span><span class="w">    </span>
<span class="linenos"> 33</span><span class="w">    </span><span class="n">GLfloat</span><span class="w">  </span><span class="n">vertices</span><span class="p">[</span><span class="n">NumVertices</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 34</span><span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="mf">-0.90f</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.90f</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="mf">0.85f</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.90f</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">-0.90f</span><span class="p">,</span><span class="w">  </span><span class="mf">0.85f</span><span class="w"> </span><span class="p">},</span><span class="w">  </span><span class="c1">// Triangle 1</span>
<span class="linenos"> 35</span><span class="w">        </span><span class="p">{</span><span class="w">  </span><span class="mf">0.90f</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.85f</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="mf">0.90f</span><span class="p">,</span><span class="w">  </span><span class="mf">0.90f</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">-0.85f</span><span class="p">,</span><span class="w">  </span><span class="mf">0.90f</span><span class="w"> </span><span class="p">}</span><span class="w">   </span><span class="c1">// Triangle 2</span>
<span class="linenos"> 36</span><span class="w">    </span><span class="p">};</span><span class="w"></span>
<span class="linenos"> 37</span>
<span class="linenos"> 38</span><span class="w">    </span><span class="n">glCreateBuffers</span><span class="p">(</span><span class="w"> </span><span class="n">NumBuffers</span><span class="p">,</span><span class="w"> </span><span class="n">Buffers</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 39</span><span class="w">    </span>
<span class="linenos"> 40</span><span class="w">    </span><span class="c1">// Make the buffer the active array buffer.</span>
<span class="linenos"> 41</span><span class="w">    </span><span class="n">glBindBuffer</span><span class="p">(</span><span class="w"> </span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">Buffers</span><span class="p">[</span><span class="n">ArrayBuffer</span><span class="p">]</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 42</span><span class="w">    </span><span class="c1">// Attach the active VBO:Buffers[ArrayBuffer] to VAOs[Triangles]</span>
<span class="linenos"> 43</span><span class="w">    </span><span class="c1">// as an array of vectors with 4 floats each.</span>
<span class="linenos"> 44</span><span class="w">    </span><span class="c1">// Kind of like:</span>
<span class="linenos"> 45</span><span class="w">    </span><span class="c1">// opengl-&gt;current_vertex_array-&gt;attributes[attr] = {</span>
<span class="linenos"> 46</span><span class="w">    </span><span class="c1">//     type = GL_FLOAT,</span>
<span class="linenos"> 47</span><span class="w">    </span><span class="c1">//     size = 4,</span>
<span class="linenos"> 48</span><span class="w">    </span><span class="c1">//     data = opengl-&gt;current_array_buffer</span>
<span class="linenos"> 49</span><span class="w">    </span><span class="c1">// }</span>
<span class="linenos"> 50</span><span class="w">    </span><span class="c1">// Can be replaced with glVertexArrayVertexBuffer(VAOs[Triangles], Triangles, </span>
<span class="linenos"> 51</span><span class="w">    </span><span class="c1">// buffer[ArrayBuffer], ArrayBuffer, sizeof(vmath::vec2));, glVertexArrayAttribFormat(), ...</span>
<span class="linenos"> 52</span><span class="w">    </span><span class="c1">// in OpenGL 4.5.</span>
<span class="linenos"> 53</span><span class="w">    </span>
<span class="linenos"> 54</span><span class="w">    </span><span class="n">glBufferStorage</span><span class="p">(</span><span class="w"> </span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span><span class="w"> </span><span class="n">vertices</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 55</span>
<span class="linenos"> 56</span><span class="w">    </span><span class="n">ShaderInfo</span><span class="w">  </span><span class="n">shaders</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="linenos"> 57</span><span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 58</span><span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="n">GL_VERTEX_SHADER</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;media/shaders/triangles/triangles.vert&quot;</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="linenos"> 59</span><span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="n">GL_FRAGMENT_SHADER</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;media/shaders/triangles/triangles.frag&quot;</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="linenos"> 60</span><span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="n">GL_NONE</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="linenos"> 61</span><span class="w">    </span><span class="p">};</span><span class="w"></span>
<span class="linenos"> 62</span>
<span class="linenos"> 63</span><span class="w">    </span><span class="n">GLuint</span><span class="w"> </span><span class="n">program</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LoadShaders</span><span class="p">(</span><span class="w"> </span><span class="n">shaders</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 64</span><span class="w">    </span><span class="n">glUseProgram</span><span class="p">(</span><span class="w"> </span><span class="n">program</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 65</span>
<span class="linenos"> 66</span><span class="w">    </span><span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="w"> </span><span class="n">vPosition</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FLOAT</span><span class="p">,</span><span class="w"></span>
<span class="linenos"> 67</span><span class="w">                           </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">BUFFER_OFFSET</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 68</span><span class="w">    </span><span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="w"> </span><span class="n">vPosition</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 69</span><span class="w">    </span><span class="c1">// Above two functions specify vPosition to vertex shader at layout (location = 0)</span>
<span class="linenos"> 70</span><span class="p">}</span><span class="w"></span>
<span class="linenos"> 71</span>
<span class="linenos"> 72</span><span class="c1">//----------------------------------------------------------------------------</span>
<span class="linenos"> 73</span><span class="c1">//</span>
<span class="linenos"> 74</span><span class="c1">// display</span>
<span class="linenos"> 75</span><span class="c1">//</span>
<span class="linenos"> 76</span>
<span class="linenos"> 77</span><span class="kt">void</span><span class="w"></span>
<span class="linenos"> 78</span><span class="nf">display</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="linenos"> 79</span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 80</span><span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">black</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="linenos"> 81</span>
<span class="linenos"> 82</span><span class="w">    </span><span class="n">glClearBufferfv</span><span class="p">(</span><span class="n">GL_COLOR</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">black</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 83</span>
<span class="linenos"> 84</span><span class="w">    </span><span class="n">glBindVertexArray</span><span class="p">(</span><span class="w"> </span><span class="n">VAOs</span><span class="p">[</span><span class="n">Triangles</span><span class="p">]</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 85</span><span class="w">    </span><span class="n">glDrawArrays</span><span class="p">(</span><span class="w"> </span><span class="n">GL_TRIANGLES</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">NumVertices</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 86</span><span class="p">}</span><span class="w"></span>
<span class="linenos"> 87</span>
<span class="linenos"> 88</span><span class="c1">//----------------------------------------------------------------------------</span>
<span class="linenos"> 89</span><span class="c1">//</span>
<span class="linenos"> 90</span><span class="c1">// main</span>
<span class="linenos"> 91</span><span class="c1">//</span>
<span class="linenos"> 92</span>
<span class="linenos"> 93</span><span class="cp">#ifdef _WIN32</span>
<span class="linenos"> 94</span><span class="kt">int</span><span class="w"> </span><span class="n">CALLBACK</span><span class="w"> </span><span class="nf">WinMain</span><span class="p">(</span><span class="w"></span>
<span class="linenos"> 95</span><span class="w">  </span><span class="n">_In_</span><span class="w"> </span><span class="n">HINSTANCE</span><span class="w"> </span><span class="n">hInstance</span><span class="p">,</span><span class="w"></span>
<span class="linenos"> 96</span><span class="w">  </span><span class="n">_In_</span><span class="w"> </span><span class="n">HINSTANCE</span><span class="w"> </span><span class="n">hPrevInstance</span><span class="p">,</span><span class="w"></span>
<span class="linenos"> 97</span><span class="w">  </span><span class="n">_In_</span><span class="w"> </span><span class="n">LPSTR</span><span class="w">     </span><span class="n">lpCmdLine</span><span class="p">,</span><span class="w"></span>
<span class="linenos"> 98</span><span class="w">  </span><span class="n">_In_</span><span class="w"> </span><span class="kt">int</span><span class="w">       </span><span class="n">nCmdShow</span><span class="w"></span>
<span class="linenos"> 99</span><span class="p">)</span><span class="w"></span>
<span class="linenos">100</span><span class="cp">#else</span>
<span class="linenos">101</span><span class="kt">int</span><span class="w"></span>
<span class="linenos">102</span><span class="n">main</span><span class="p">(</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="linenos">103</span><span class="cp">#endif</span>
<span class="linenos">104</span><span class="p">{</span><span class="w"></span>
<span class="linenos">105</span><span class="w">    </span><span class="n">glfwInit</span><span class="p">();</span><span class="w"></span>
<span class="linenos">106</span>
<span class="linenos">107</span><span class="w">    </span><span class="n">GLFWwindow</span><span class="o">*</span><span class="w"> </span><span class="n">window</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glfwCreateWindow</span><span class="p">(</span><span class="mi">800</span><span class="p">,</span><span class="w"> </span><span class="mi">600</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Triangles&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span><span class="w"></span>
<span class="linenos">108</span>
<span class="linenos">109</span><span class="w">    </span><span class="n">glfwMakeContextCurrent</span><span class="p">(</span><span class="n">window</span><span class="p">);</span><span class="w"></span>
<span class="linenos">110</span><span class="w">    </span><span class="n">gl3wInit</span><span class="p">();</span><span class="w"></span>
<span class="linenos">111</span>
<span class="linenos">112</span><span class="w">    </span><span class="n">init</span><span class="p">();</span><span class="w"></span>
<span class="linenos">113</span>
<span class="linenos">114</span><span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">glfwWindowShouldClose</span><span class="p">(</span><span class="n">window</span><span class="p">))</span><span class="w"></span>
<span class="linenos">115</span><span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="linenos">116</span><span class="w">        </span><span class="n">display</span><span class="p">();</span><span class="w"></span>
<span class="linenos">117</span><span class="w">        </span><span class="n">glfwSwapBuffers</span><span class="p">(</span><span class="n">window</span><span class="p">);</span><span class="w"></span>
<span class="linenos">118</span><span class="w">        </span><span class="n">glfwPollEvents</span><span class="p">();</span><span class="w"></span>
<span class="linenos">119</span><span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="linenos">120</span>
<span class="linenos">121</span><span class="w">    </span><span class="n">glfwDestroyWindow</span><span class="p">(</span><span class="n">window</span><span class="p">);</span><span class="w"></span>
<span class="linenos">122</span>
<span class="linenos">123</span><span class="w">    </span><span class="n">glfwTerminate</span><span class="p">();</span><span class="w"></span>
<span class="linenos">124</span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Init():</p>
<ul>
<li><p>Generate Vertex Array VAOs and bind VAOs[0].</p>
<p>(glGenVertexArrays( NumVAOs, VAOs ); glBindVertexArray( VAOs[Triangles] );
glCreateBuffers( NumBuffers, Buffers );)
A vertex-array object holds various data related to a collection of vertices.
Those data are stored in buffer objects and managed by the currently bound
vertex-array object.</p>
<ul>
<li><p>glBindBuffer( GL_ARRAY_BUFFER, Buffers[ArrayBuffer] );</p>
<p>Because there are many different places where buffer objects can be in OpenGL, when we bind a buffer, we need to specify which what we’d like to use it for. In our example, because we’re storing vertex data into the buffer, we use GL_ARRAY_BUFFER. The place where the buffer is bound is known as the binding target.</p>
</li>
</ul>
</li>
<li><p>According counter clockwise rule in previous section, Triangle Primitives are
defined in varaible vertices. After binding OpenGL
VBO Buffers[0] to vertices, vertices data will send to memory of
server(gpu).
Think of the “active” buffer as just a global variable, and there are a bunch
of functions which use the active buffer instead of using a parameter.
These global state variables are the ugly side of OpenGL <a class="footnote-reference brackets" href="#vao-vbo-binding" id="id44" role="doc-noteref"><span class="fn-bracket">[</span>39<span class="fn-bracket">]</span></a>
and can be replaced with glVertexArrayVertexBuffer(),
glVertexArrayAttribFormat(), …, then call glBindVertexArray(vao)
before drawing in OpenGL 4.5 <a class="footnote-reference brackets" href="#ogl-vavb" id="id45" role="doc-noteref"><span class="fn-bracket">[</span>40<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#ogl-bluebook-p152" id="id46" role="doc-noteref"><span class="fn-bracket">[</span>41<span class="fn-bracket">]</span></a>.</p></li>
<li><p>glVertexAttribPointer( vPosition, 2, GL_FLOAT, GL_FALSE, 0, BUFFER_OFFSET(0) ):
During gpu rendering, each vertex position will be held in vPosition and pass
to “triangles.vert” shader because LoadShaders( shaders ).</p></li>
</ul>
<p>glfwSwapBuffers(window):</p>
<ul class="simple">
<li><p>You’ve already used double buffering for animation. Double buffering is done
by making the main color buffer have two parts: a front buffer that’s
displayed in your window; and a back buffer, which is where you render the
new image. When you swap the buffers (by calling glfwSwapBuffers(), for
example), the front and back buffers are exchanged <a class="footnote-reference brackets" href="#redbook-colorbuffer" id="id47" role="doc-noteref"><span class="fn-bracket">[</span>78<span class="fn-bracket">]</span></a>.</p></li>
</ul>
<p>display():</p>
<ul class="simple">
<li><p>Bind VAOs[0], set render mode to GL_TRIANGLES and send vertex data to Buffer
(gpu memory, OpenGL pipeline). Next, GPU will do rendering pipeline descibed
in next section.</p></li>
</ul>
<p>The triangles.vert has input vPosition and no output variable, so using
gl_Position default varaible without declaration. The triangles.frag has not
defined input variable and has defined output variable fColor instead of using
gl_FragColor.</p>
<p>The “in” and “out” in shaders above are “type qualifier”.
A type qualifier is used in the OpenGL Shading Language (GLSL) to modify the
storage or behavior of global and locally defined variables. These qualifiers
change particular aspects of the variable, such as where they get their data
from and so forth <a class="footnote-reference brackets" href="#ogl-qualifier" id="id48" role="doc-noteref"><span class="fn-bracket">[</span>45<span class="fn-bracket">]</span></a>.</p>
<p>Though attribute and varying are removed from later version 1.4 of OpenGL,
many materials in website using them <a class="footnote-reference brackets" href="#ogl-qualifier-deprecate" id="id49" role="doc-noteref"><span class="fn-bracket">[</span>46<span class="fn-bracket">]</span></a>
<a class="footnote-reference brackets" href="#github-attr-varying-depr" id="id50" role="doc-noteref"><span class="fn-bracket">[</span>47<span class="fn-bracket">]</span></a>.
It’s better to use “in” and “out” to replace
them as the following code.
OpenGL has a few ways to binding API’s variable with shader’s variable.
glVertexAttrib* as the following code and glBindAttribLocation()
<a class="footnote-reference brackets" href="#ogl-layout-q" id="id51" role="doc-noteref"><span class="fn-bracket">[</span>48<span class="fn-bracket">]</span></a>, …</p>
<p class="rubric">replace attribute and varying with in and out</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">uniform</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">scale</span><span class="p">;</span><span class="w"></span>
<span class="n">layout</span><span class="w"> </span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">attribute</span><span class="w"> </span><span class="n">vec2</span><span class="w"> </span><span class="n">position</span><span class="p">;</span><span class="w"></span>
<span class="c1">// layout (location = 0) in vec2 position;</span>
<span class="n">layout</span><span class="w"> </span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">attribute</span><span class="w"> </span><span class="n">vec4</span><span class="w"> </span><span class="n">color</span><span class="p">;</span><span class="w"></span>
<span class="c1">// layout (location = 1) in vec4 color;</span>
<span class="n">varying</span><span class="w"> </span><span class="n">vec4</span><span class="w"> </span><span class="n">v_color</span><span class="p">;</span><span class="w"></span>
<span class="c1">// out v_color</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec4</span><span class="p">(</span><span class="n">position</span><span class="o">*</span><span class="n">scale</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">v_color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">color</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// OpenGL API</span>
<span class="n">GLfloat</span><span class="w"> </span><span class="n">attrib</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.6f</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="o">*</span><span class="w"> </span><span class="mf">0.4f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="c1">// Update the value of input attribute 1 : layout (location = 1) in vec4 color</span>
<span class="n">glVertexAttrib4fv</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">attrib</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">varying</span><span class="w"> </span><span class="n">vec4</span><span class="w"> </span><span class="n">v_color</span><span class="p">;</span><span class="w"></span>
<span class="c1">// in vec4 v_color;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">gl_FragColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v_color</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>An OpenGL program is made of two shaders <a class="footnote-reference brackets" href="#monstar-lab-opengl" id="id52" role="doc-noteref"><span class="fn-bracket">[</span>43<span class="fn-bracket">]</span></a>
<a class="footnote-reference brackets" href="#glumpy-shaders" id="id53" role="doc-noteref"><span class="fn-bracket">[</span>44<span class="fn-bracket">]</span></a>:</p>
<ul class="simple">
<li><p>The vertex shader is (commonly) executed once for every vertex we want to
draw. It receives some attributes as input, computes the position of this
vertex in space and returns it in a variable called gl_Position. It also
defines some varyings.</p></li>
<li><p>The fragment shader is executed once for each pixel to be rendered. It
receives some varyings as input, computes the color of this pixel and
returns it in a variable called fColor.</p></li>
</ul>
<p>Since we have 6 vertices in our buffer, this shader will be executed 6 times by
the GPU (once per vertex)! We can also expect all 6 instances of the shader to
be executed in parallel, since a GPU have so many cores.</p>
</section>
<section id="d-rendering">
<h3><a class="toc-backref" href="#id211" role="doc-backlink">3D Rendering</a><a class="headerlink" href="#d-rendering" title="Permalink to this heading">¶</a></h3>
<p>Based on the previous section of 3D modeling, the 3D modeling tool will generate
3D vertex model and OpenGL code, then programmers may hand-change OpenGL code and
add or modify shaders. The 3D animation will trigger the 3D rendering for each
2D image drawing.</p>
<p>3D rendering is the process of converting 3D models into 2D images on a computer
<a class="footnote-reference brackets" href="#drendering-wiki" id="id54" role="doc-noteref"><span class="fn-bracket">[</span>33<span class="fn-bracket">]</span></a>.
The steps as the following <a class="reference internal" href="#short-rendering-pipeline"><span class="std std-numref">Fig. 75</span></a>.</p>
<figure class="align-center" id="id174">
<span id="short-rendering-pipeline"></span><a class="reference internal image-reference" href="_images/short-rendering-pipeline.png"><img alt="_images/short-rendering-pipeline.png" src="_images/short-rendering-pipeline.png" style="width: 915.0px; height: 347.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 75 </span><span class="caption-text">3D Graphics Rendering Pipeline</span><a class="headerlink" href="#id174" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<ul class="simple">
<li><p>A fragment can be treated as a pixel in 3D spaces, which is aligned with the
pixel grid, with attributes such as position, color, normal and texture.</p></li>
</ul>
<p>The complete steps as the following <a class="reference internal" href="#rendering-pipeline1"><span class="std std-numref">Fig. 76</span></a>
from OpenGL website <a class="footnote-reference brackets" href="#rendering" id="id55" role="doc-noteref"><span class="fn-bracket">[</span>34<span class="fn-bracket">]</span></a> and the website has descripiton for each stage.</p>
<figure class="align-center" id="id175">
<span id="rendering-pipeline1"></span><a class="reference internal image-reference" href="_images/rendering_pipeline.png"><img alt="_images/rendering_pipeline.png" src="_images/rendering_pipeline.png" style="width: 200.8px; height: 467.20000000000005px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 76 </span><span class="caption-text">Diagram of the Rendering Pipeline. The blue boxes are programmable shader stages.</span><a class="headerlink" href="#id175" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>In addition, list OpenGL rendering pipeline Figure 1.2 and stage from book
“OpenGL Programming Guide 9th Edition” <a class="footnote-reference brackets" href="#redbook" id="id56" role="doc-noteref"><span class="fn-bracket">[</span>37<span class="fn-bracket">]</span></a> as follows,</p>
<figure class="align-center" id="opengl-pipeline">
<a class="reference internal image-reference" href="_images/OpenGL-pipeline.png"><img alt="_images/OpenGL-pipeline.png" src="_images/OpenGL-pipeline.png" style="width: 854.0px; height: 543.0px;" /></a>
</figure>
<table class="docutils align-default" id="id176">
<caption><span class="caption-number">Table 43 </span><span class="caption-text">OpenGL rendering pipeline from page 10 of book “OpenGL Programming Guide 9th Edition” <a class="footnote-reference brackets" href="#redbook" id="id57" role="doc-noteref"><span class="fn-bracket">[</span>37<span class="fn-bracket">]</span></a> and <a class="footnote-reference brackets" href="#rendering" id="id58" role="doc-noteref"><span class="fn-bracket">[</span>34<span class="fn-bracket">]</span></a>.</span><a class="headerlink" href="#id176" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 25%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Stage.</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Vertex Specification</p></td>
<td><p>After setting data as the example of previous section, glDrawArrays() will send data to gpu through buffer objects.</p></td>
</tr>
<tr class="row-odd"><td><p>Vertex Shading</p></td>
<td><p><strong>Vertex -&gt; Vertex and other data such as color for later passes.</strong> For each vertex that is issued by a drawing command, a vertex shader will be called to process the data associated with that vertex.</p></td>
</tr>
<tr class="row-even"><td><p>Tessellation Shading</p></td>
<td><p><strong>Create more detail on demand when room in.</strong> After the vertex shader has processed each vertex’s associated data, the tessellation shader stage will continue processing that data, if it’s been activated. Reference below.</p></td>
</tr>
<tr class="row-odd"><td><p>Geometry Shading</p></td>
<td><p><strong>The next shader stage, geometry shading, allows additional processing of individual geometric primitives, including creating new ones, before rasterization.</strong> Chapter 10 of Red Book <a class="footnote-reference brackets" href="#redbook" id="id59" role="doc-noteref"><span class="fn-bracket">[</span>37<span class="fn-bracket">]</span></a> has details.</p></td>
</tr>
<tr class="row-even"><td><p>Primitive Assembly</p></td>
<td><p>The previous shading stages all operate on vertices, with the information about how those vertices are organized into geometric primitives being carried along internal to OpenGL. <strong>The primitive assembly stage organizes the vertices into their associated geometric primitives in preparation for clipping and rasterization.</strong></p></td>
</tr>
<tr class="row-odd"><td><p>Clipping</p></td>
<td><p><strong>Clipping hidden parts.</strong> Occasionally, vertices will be outside of the viewport—the region of the window where you’re permitted to draw—and cause the primitive associated with that vertex to be modified so none of its pixels are outside of the viewport. This operation is called clipping and is handled automatically by OpenGL.</p></td>
</tr>
<tr class="row-even"><td><p>Rasterization</p></td>
<td><p><strong>Vertex -&gt; Fragment.</strong> The job of the rasterizer is to determine which screen locations are covered by a particular piece of geometry (point, line, or triangle). Knowing those locations, along with the input vertex data, the rasterizer linearly interpolates the data values for each varying variable in the fragment shader and sends those values as inputs into your fragment shader. A fragment can be treated as a pixel in 3D spaces, which is aligned with the pixel grid, with attributes such as position, color, normal and texture.</p></td>
</tr>
<tr class="row-odd"><td><p>Fragment Shading</p></td>
<td><p><strong>Determine color for each pixel.</strong> The final stage where you have programmable control over the color of a screen location is fragment shading. In this shader stage, you use a shader to determine the fragment’s final color (although the next stage, per-fragment operations, can modify the color one last time) and potentially its depth value. Fragment shaders are very powerful, as they often employ texture mapping to augment the colors provided by the vertex processing stages. A fragment shader may also terminate processing a fragment if it determines the fragment shouldn’t be drawn; this process is called fragment discard. A helpful way of thinking about the difference between shaders that deal with vertices and fragment shaders is this: vertex shading (including tessellation and geometry shading) determines where on the screen a primitive is, while fragment shading uses that information to determine what color that fragment will be.</p></td>
</tr>
<tr class="row-even"><td><p>Per-Fragment Operations</p></td>
<td><p>During this stage, a fragment’s visibility is determined using depth testing (also commonly known as z-buffering) and stencil testing. If a fragment successfully makes it through all of the enabled tests, it may be written directly to the framebuffer, updating the color (and possibly depth value) of its pixel, or <strong>if blending is enabled, the fragment’s color will be combined with the pixel’s current color to generate a new color that is written into the framebuffer.</strong></p></td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><p>Tessellation Shading:
The core problem that Tessellation deals with is the static nature of 3D models
in terms of their detail and polygon count. The thing is that when we look at
a complex model such as a human face up close we prefer to use a highly
detailed model that will bring out the tiny details (e.g. skin bumps, etc).
A highly detailed model automatically translates to more triangles and more
compute power required for processing. …
One possible way to solve this problem using the existing features of OpenGL
is to generate the same model at multiple levels of detail (LOD). For example,
highly detailed, average and low. We can then select the version to use based
on the distance from the camera. This, however, will require more artist
resources and often will not be flexible enough. …
Let’s take a look at how Tessellation has been implemented in the graphics
pipeline. The core components that are responsible for Tessellation are two
new shader stages and in between them a fixed function stage that can be
configured to some degree but does not run a shader. The first shader stage
is called Tessellation Control Shader (TCS), the fixed function stage is
called the Primitive Generator (PG), and the second shader stage is called
Tessellation Evaluation Shader (TES).
Some GPU havn’t this fixed function stage implemented in HW and even havn’t
provide these TCS, TES and Gemoetry Shader. User can write Compute Shaders
instead for this on-fly detail display.
This surface is usually defined by some polynomial formula and the idea is
that moving a CP has an effect on the entire surface. …
The group of CPs is usually called a Patch <a class="footnote-reference brackets" href="#ts-tu30" id="id60" role="doc-noteref"><span class="fn-bracket">[</span>35<span class="fn-bracket">]</span></a>.
Chapter 9 of Red Book <a class="footnote-reference brackets" href="#redbook" id="id61" role="doc-noteref"><span class="fn-bracket">[</span>37<span class="fn-bracket">]</span></a> has details.</p></li>
</ul>
<p>For 2D animation, the model is created by 2D only (1 face only), so it only can be
viewed from the same face of model. If you want to display different faces of model,
multiple 2D models need to be created and switch these 2D models from face(flame) to
face(flame) from time to time <a class="footnote-reference brackets" href="#danimation" id="id62" role="doc-noteref"><span class="fn-bracket">[</span>36<span class="fn-bracket">]</span></a>.</p>
</section>
<section id="glsl-gl-shader-language">
<h3><a class="toc-backref" href="#id212" role="doc-backlink">GLSL (GL Shader Language)</a><a class="headerlink" href="#glsl-gl-shader-language" title="Permalink to this heading">¶</a></h3>
<p>OpenGL is a standard for designing 2D/3D animation in computer graphic.
To do animation well, OpenGL provides a lots of api(functions) call for
graphic processing. The 3D model construction tools such as Maya, Blender, …, etc,
only need to call this api to finish the 3D to 2D projecting function in computer.
Any GPU hardware dependent code in these api provided by GPU manufacturer.
An OpenGL program looks like the following,</p>
<p class="rubric">Vertex shader</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#version 330 core</span>
<span class="n">layout</span><span class="w"> </span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">aPos</span><span class="p">;</span><span class="w"> </span><span class="c1">// the position variable has attribute position 0</span>

<span class="n">out</span><span class="w"> </span><span class="n">vec4</span><span class="w"> </span><span class="n">vertexColor</span><span class="p">;</span><span class="w"> </span><span class="c1">// specify a color output to the fragment shader</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span><span class="w"> </span><span class="c1">// see how we directly give a vec3 to vec4&#39;s constructor</span>
<span class="w">    </span><span class="n">vertexColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec4</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span><span class="w"> </span><span class="c1">// set the output variable to a dark-red color</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">Fragment shader</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#version 330 core</span>
<span class="n">out</span><span class="w"> </span><span class="n">vec4</span><span class="w"> </span><span class="n">FragColor</span><span class="p">;</span><span class="w"></span>

<span class="n">in</span><span class="w"> </span><span class="n">vec4</span><span class="w"> </span><span class="n">vertexColor</span><span class="p">;</span><span class="w"> </span><span class="c1">// the input variable from the vertex shader (same name and same type)</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">FragColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">computeColorOfThisPixel</span><span class="p">(...);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">OpenGl user program</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// init window, detect user input and do corresponding animation by calling opengl api</span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The last main() is programed by user obviously. Let’s explain what the first two
main() work for.
As you know, the OpenGL is a lots of api to let programmer display the 3D object
into 2D computer screen explained from book of concept of computer graphic.
3D graphic model can set light and object texture by user firstly, and calculating the
postion of each vertex secondly, then color for each pixel automatically by 3D software
and GPU thirdly, finally display the color of each pixel in computer screen.
But in order to let user/programmer add some special effect or decoration in
coordinate for each vertex or in color for each pixel, OpenGL provides these two
functions to do it.
OpenGL uses fragment shader instead of pixel is : “Fragment shaders are a more
accurate name for the same functionality as Pixel shaders. They aren’t pixels
yet, since the output still has to past several tests (depth, alpha, stencil)
as well as the fact that one may be using antialiasing, which renders
one-fragment-to-one-pixel non-true <a class="footnote-reference brackets" href="#fragmentshader-reason" id="id63" role="doc-noteref"><span class="fn-bracket">[</span>49<span class="fn-bracket">]</span></a>.
Programmer is allowed to add their converting functions that compiler translate them
into GPU instructions running on GPU processor. With these two shaders, new
features have been added to allow for increased flexibility in the rendering
pipeline at the vertex and fragment level <a class="footnote-reference brackets" href="#shaderswiki" id="id64" role="doc-noteref"><span class="fn-bracket">[</span>50<span class="fn-bracket">]</span></a>.
Unlike the shaders example here <a class="footnote-reference brackets" href="#shadersex" id="id65" role="doc-noteref"><span class="fn-bracket">[</span>51<span class="fn-bracket">]</span></a>, some converting functions
for coordinate in vertex shader or for color in fragment shade are more
complicated according the scenes of
animation. Here is an example <a class="footnote-reference brackets" href="#glsleffect" id="id66" role="doc-noteref"><span class="fn-bracket">[</span>52<span class="fn-bracket">]</span></a>.
In wiki shading page <a class="footnote-reference brackets" href="#shading" id="id67" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>, Gourand and Phong shading methods make the
surface of object more smooth by glsl. Example glsl code of Gourand
and Phong shading on OpenGL api are here <a class="footnote-reference brackets" href="#smoothshadingex" id="id68" role="doc-noteref"><span class="fn-bracket">[</span>53<span class="fn-bracket">]</span></a>.
Since the hardware of graphic card and software graphic driver can be replaced,
the compiler is run on-line meaning driver will compile the shaders program when
it is run at first time and kept in cache after compilation <a class="footnote-reference brackets" href="#on-line" id="id69" role="doc-noteref"><span class="fn-bracket">[</span>54<span class="fn-bracket">]</span></a>.</p>
<p>The shaders program is C-like syntax and can be compiled in few mini-seconds,
add up this few mini-seconds of on-line compilation time in running OpenGL
program is a good choice for dealing the cases of driver software or gpu
hardware replacement <a class="footnote-reference brackets" href="#onlinecompile" id="id70" role="doc-noteref"><span class="fn-bracket">[</span>55<span class="fn-bracket">]</span></a>.</p>
</section>
<section id="opengl-shader-compiler">
<h3><a class="toc-backref" href="#id213" role="doc-backlink">OpenGL Shader compiler</a><a class="headerlink" href="#opengl-shader-compiler" title="Permalink to this heading">¶</a></h3>
<p>OpenGL standard is here <a class="footnote-reference brackets" href="#openglspec" id="id71" role="doc-noteref"><span class="fn-bracket">[</span>56<span class="fn-bracket">]</span></a>. The OpenGL is for desktop computer or server
while the OpenGL ES is for embedded system <a class="footnote-reference brackets" href="#opengleswiki" id="id72" role="doc-noteref"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></a>. Though shaders are only
a small part of the whole OpenGL software/hardware system. It is still a large effort
to finish the compiler implementation since there are lots of api need to be
implemented.
For example, there are 80 related texture APIs <a class="footnote-reference brackets" href="#textureapi" id="id73" role="doc-noteref"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></a>.
This implementation can be done by generating llvm extended intrinsic functions
from shader parser of frontend compiler as well as llvm backend converting those intrinsic
to gpu instructions as follows,</p>
<p class="rubric">Fragment shader</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#version 320 es</span>
<span class="n">uniform</span><span class="w"> </span><span class="n">sampler2D</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="n">out</span><span class="w"> </span><span class="n">vec4</span><span class="w"> </span><span class="n">FragColor</span><span class="p">;</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">FragColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">texture</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">uv_2d</span><span class="p">,</span><span class="w"> </span><span class="n">bias</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">llvm-ir</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>...
!1 = !{!&quot;sampler_2d&quot;}
!2 = !{i32 SAMPLER_2D} ; SAMPLER_2D is integer value for sampler2D, for example: 0x0f02
; A named metadata.
!x_meta = !{!1, !2}

define void @main() #0 {
    ...
    %1 = @llvm.gpu0.texture(metadata !x_meta, %1, %2, %3); ; %1: %sampler_2d, %2: %uv_2d, %3: %bias
    ...
}
</pre></div>
</div>
<p class="rubric">asm of gpu</p>
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span><span class="na">...</span><span class="w"></span>
<span class="c1">// gpu machine code</span>
<span class="nf">load</span><span class="w"> </span><span class="no">$1</span><span class="p">,</span><span class="w"> </span><span class="no">tex_a</span><span class="c1">;</span>
<span class="nf">sample2d_inst</span><span class="w"> </span><span class="no">$1</span><span class="p">,</span><span class="w"> </span><span class="no">$2</span><span class="p">,</span><span class="w"> </span><span class="no">$3</span><span class="w"> </span><span class="c1">// $1: tex_a, $2: %uv_2d, $3: %bias</span>

<span class="na">.tex_a</span><span class="w"> </span><span class="c1">// Driver set the index of gpu descriptor regsters here</span>
</pre></div>
</div>
<p>As the bottom of code above, .tex_a memory address includes the Texture Object
which binding by driver in on-line compilation/linking. Through binding Texture
Object (SW) and Texture Unit (HW) with OpenGL API, gpu will uses Texture Unit HW
resources efficiently. Explaining it the following.</p>
<p>About llvm intrinsic extended function, please refer this book here <a class="footnote-reference brackets" href="#intrinsiccpu0" id="id74" role="doc-noteref"><span class="fn-bracket">[</span>59<span class="fn-bracket">]</span></a>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">gvec4</span><span class="w"> </span><span class="nf">texture</span><span class="p">(</span><span class="n">gsampler2D</span><span class="w"> </span><span class="n">sampler</span><span class="p">,</span><span class="w"> </span><span class="n">vec2</span><span class="w"> </span><span class="n">P</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="kt">float</span><span class="w"> </span><span class="n">bias</span><span class="p">]);</span><span class="w"></span>
</pre></div>
</div>
<p>GPU provides ‘Texture Unit’ to speedup fragment shader. However the
‘Texture Unit’ HW is expensive resouce and only few of them in a GPU.
Driver can associate ‘Texture Unit’ to sampler variable by OpenGL api
and switch between shaders as the following statements.</p>
<figure class="align-center" id="id177">
<span id="sampling"></span><a class="reference internal image-reference" href="_images/sampling_diagram.png"><img alt="_images/sampling_diagram.png" src="_images/sampling_diagram.png" style="width: 489.59999999999997px; height: 330.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 77 </span><span class="caption-text">Relationships between the texturing concept <a class="footnote-reference brackets" href="#textureobject" id="id75" role="doc-noteref"><span class="fn-bracket">[</span>60<span class="fn-bracket">]</span></a>.</span><a class="headerlink" href="#id177" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>The <a class="reference internal" href="#sampling"><span class="std std-numref">Fig. 77</span></a> as above.
The texture object is not bound directly into the shader (where the actual
sampling takes place). Instead, it is bound to a ‘texture unit’ whose index
is passed to the shader. So the shader reaches the texture object by going
through the texture unit. There are usually multiple texture units available
and the exact number depends on the capability of your graphic card <a class="footnote-reference brackets" href="#textureobject" id="id76" role="doc-noteref"><span class="fn-bracket">[</span>60<span class="fn-bracket">]</span></a>.
A texture unit, also called a texture mapping unit (TMU) or a texture processing
unit (TPU), is a hardware component in a GPU that does sampling operation.
The argument sampler in texture function as above is sampler_2d index from
‘teuxture unit’ for texture object <a class="footnote-reference brackets" href="#textureobject" id="id77" role="doc-noteref"><span class="fn-bracket">[</span>60<span class="fn-bracket">]</span></a>.</p>
<p>‘sampler uniform variable’:</p>
<p>There is a group of special uniform variables for that, according to the texture
target: ‘sampler1D’, ‘sampler2D’, ‘sampler3D’, ‘samplerCube’, etc.
You can create as many ‘sampler uniform variables’ as you want and assign the
value of a texture unit to each one from the application.
Whenever you call a sampling function on a ‘sampler uniform variable’ the
corresponding texture unit (and texture object) will be used <a class="footnote-reference brackets" href="#textureobject" id="id78" role="doc-noteref"><span class="fn-bracket">[</span>60<span class="fn-bracket">]</span></a>.</p>
<figure class="align-center" id="id178">
<span id="sampling-binding"></span><img alt="_images/sampling_diagram_binding.png" src="_images/sampling_diagram_binding.png" />
<figcaption>
<p><span class="caption-number">Fig. 78 </span><span class="caption-text">Binding sampler variables <a class="footnote-reference brackets" href="#tpu" id="id79" role="doc-noteref"><span class="fn-bracket">[</span>61<span class="fn-bracket">]</span></a>.</span><a class="headerlink" href="#id178" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>As <a class="reference internal" href="#sampling-binding"><span class="std std-numref">Fig. 78</span></a>, the Java api
gl.bindTexture binding ‘Texture Object’ to ‘Texture Unit’.
The gl.getUniformLocation and gl.uniform1i associate ‘Texture Unit’ to
‘sampler uniform variables’.</p>
<p>gl.uniform1i(xLoc, 1): where 1 is
‘Texture Unit 1’, 2 is ‘Texture Unit 2’, …, etc <a class="footnote-reference brackets" href="#tpu" id="id80" role="doc-noteref"><span class="fn-bracket">[</span>61<span class="fn-bracket">]</span></a>.</p>
<p>The following figure depicts how driver read metadata from compiled glsl obj,
OpenGL api associate ‘Sample Variable’ and gpu executing texture instruction.</p>
<figure class="align-center" id="id179">
<span id="driversamplertable"></span><img alt="_images/driverSamplerTable.png" src="_images/driverSamplerTable.png" />
<figcaption>
<p><span class="caption-number">Fig. 79 </span><span class="caption-text">Associating Sampler Variables and gpu executing texture instruction</span><a class="headerlink" href="#id179" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>Explaining the detail steps for figure above as the following.</p>
<p>1. In order to let the ‘texture unit’ binding by driver, frontend compiler must
pass the metadata of ‘sampler uniform variable’ (sampler_2d_var in this example)
<a class="footnote-reference brackets" href="#samplervar" id="id81" role="doc-noteref"><span class="fn-bracket">[</span>64<span class="fn-bracket">]</span></a> to backend, and backend must
allocate the metadata of ‘sampler uniform variable’ in the compiled
binary file <a class="footnote-reference brackets" href="#metadata" id="id82" role="doc-noteref"><span class="fn-bracket">[</span>62<span class="fn-bracket">]</span></a>.</p>
<p>2. After gpu driver executing glsl on-line compiling,
driver read this metadata from compiled binary file and maintain a
table of {name, type, location} for each ‘sampler uniform variable’.
Driver also fill this information to Texture Desciptor in GPU’s memory.</p>
<ol class="arabic simple" start="3">
<li><p>Api,</p></li>
</ol>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">xLoc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gl</span><span class="p">.</span><span class="n">getUniformLocation</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;x&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// prog: glsl program, xLoc</span>
</pre></div>
</div>
<p>will get the location from the table for ‘sampler uniform variable’ x that
driver created.</p>
<p>SAMPLER_2D: is integer value for Sampler2D type.</p>
<ol class="arabic simple" start="4">
<li><p>Api,</p></li>
</ol>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">gl</span><span class="p">.</span><span class="n">uniform1i</span><span class="p">(</span><span class="w"> </span><span class="n">xLoc</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>will binding xLoc of ‘sampler uniform variable’ x to
‘Texture Unit 1’ by writing 1 to the glsl binary metadata location of
‘sampler uniform variable’ x as follows,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">{xLoc, 1} : 1 is &#39;Texture Unit 1&#39;, xLoc is the location(memory address) of &#39;sampler uniform variable&#39; x</span>
</pre></div>
</div>
<p>This api will set the texture descriptors in gpu with this {xLoc, 1}
information.
Next, driver set the index or memory address of gpu texture descriptors to
variable .tex_a of memory address. For example as diagram, driver set k to
.tex_a.</p>
<ol class="arabic simple" start="5">
<li></li>
</ol>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">// gpu machine code</span>
<span class="go">load $1, tex_a;</span>
<span class="go">sample2d_inst $1, $2, $3 // $1: tex_a, $2: %uv_2d, $3: %bias</span>

<span class="go">.tex_a // Driver set the index of gpu descriptor regsters here at step 4</span>
</pre></div>
</div>
<p>When executing the texture instructions from glsl binary file on gpu, the
corresponding ‘Texture Unit 1’ on gpu will being executed through texture
descriptor in gpu’s memory because .tex_a: {xLoc, 1}. Driver may set
texture descriptor in gpu’s texture desciptors if gpu provides specific
texture descriptors in architecture <a class="footnote-reference brackets" href="#descriptorreg" id="id83" role="doc-noteref"><span class="fn-bracket">[</span>65<span class="fn-bracket">]</span></a>.</p>
<p>For instance, Nvidia texture instruction as follow,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">// the content of tex_a bound to texture unit as step 5 above</span>
<span class="go">tex.3d.v4.s32.s32  {r1,r2,r3,r4}, [tex_a, {f1,f2,f3,f4}];</span>

<span class="go">.tex_a</span>
</pre></div>
</div>
<p>The content of tex_a bound to texture unit set by driver as the end of step 4.
The pixel of coordinates (x,y,z) is given by (f1,f2,f3) user input.
The f4 is skipped for 3D texture.</p>
<p>Above tex.3d texture instruction load the calculated color of pixel (x,y,z) from
texture image into GPRs (r1,r2,r3,r4)=(R,G,B,A).
And fragment shader can re-calculate the color of this pixel with the color of
this pixel at texture image <a class="footnote-reference brackets" href="#ptxtex" id="id84" role="doc-noteref"><span class="fn-bracket">[</span>63<span class="fn-bracket">]</span></a>.</p>
<p>If it is 1d texture instruction, the tex.1d as follows,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">tex.1d.v4.s32.f32  {r1,r2,r3,r4}, [tex_a, {f1}];</span>
</pre></div>
</div>
<p>Since ‘Texture Unit’ is limited hardware accelerator on gpu, OpenGL
providing api to user program for binding ‘Texture Unit’ to ‘Sampler Variables’.
As a result, user program is allowed doing load balance in using ‘Texture Unit’
through OpenGL api without recompiling glsl.
Fast texture sampling is one of the key requirements for good GPU performance
<a class="footnote-reference brackets" href="#tpu" id="id85" role="doc-noteref"><span class="fn-bracket">[</span>61<span class="fn-bracket">]</span></a>.</p>
<p>In addition to api for binding texture, OpenGL provides glTexParameteri api to
do Texture Wrapping <a class="footnote-reference brackets" href="#texturewrapper" id="id86" role="doc-noteref"><span class="fn-bracket">[</span>66<span class="fn-bracket">]</span></a>.
Furthmore the texture instruction for some gpu may including S# T# values in operands.
Same with associating ‘Sampler Variables’ to ‘Texture Unit’, S# and T# are
location of memory associated to Texture Wrapping descriptor registers allowing
user program to change Wrapping option without re-compiling glsl.</p>
<p>Even glsl frontend compiler always expanding function call into inline function
as well as llvm intrinsic extended function providing an easy way to do code
generation through llvm td (Target Description) file written,
GPU backend compiler is still a little complex than CPU backend.
(But when considering the effort in frontend compier such as clang, or other
toolchain such
as linker and gdb/lldb, of course, CPU compiler is not easier than
GPU compiler.)</p>
<p>Here is the software stack of 3D graphic system for OpenGL in linux <a class="footnote-reference brackets" href="#mesawiki" id="id87" role="doc-noteref"><span class="fn-bracket">[</span>11<span class="fn-bracket">]</span></a>.
And mesa open source website is here <a class="footnote-reference brackets" href="#mesa" id="id88" role="doc-noteref"><span class="fn-bracket">[</span>67<span class="fn-bracket">]</span></a>.</p>
</section>
</section>
<section id="gpu-architecture">
<h2><a class="toc-backref" href="#id214" role="doc-backlink">GPU Architecture</a><a class="headerlink" href="#gpu-architecture" title="Permalink to this heading">¶</a></h2>
<figure class="align-center" id="id180">
<span id="gpu-terms"></span><a class="reference internal image-reference" href="_images/gpu-terms.png"><img alt="_images/gpu-terms.png" src="_images/gpu-terms.png" style="width: 621.0px; height: 721.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 80 </span><span class="caption-text">Terms in Nvidia’s gpu (figure from book <a class="footnote-reference brackets" href="#quantitative-gpu-terms" id="id89" role="doc-noteref"><span class="fn-bracket">[</span>84<span class="fn-bracket">]</span></a>)</span><a class="headerlink" href="#id180" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<section id="simt">
<h3><a class="toc-backref" href="#id215" role="doc-backlink">SIMT</a><a class="headerlink" href="#simt" title="Permalink to this heading">¶</a></h3>
<p>Single instruction, multiple threads (SIMT) is an execution model used in
parallel computing where single instruction, multiple data (SIMD) is combined
with multithreading <a class="footnote-reference brackets" href="#simt-wiki" id="id90" role="doc-noteref"><span class="fn-bracket">[</span>68<span class="fn-bracket">]</span></a>.</p>
<p>The leading GPU architecture of Nvidia’s gpu is as the following
figures.</p>
<figure class="align-center" id="id181">
<span id="threadslanes"></span><a class="reference internal image-reference" href="_images/threads-lanes.png"><img alt="_images/threads-lanes.png" src="_images/threads-lanes.png" style="width: 606.0px; height: 556.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 81 </span><span class="caption-text">Threads and lanes in gpu (figure from book <a class="footnote-reference brackets" href="#quantitative-threads-lanes" id="id91" role="doc-noteref"><span class="fn-bracket">[</span>73<span class="fn-bracket">]</span></a>)</span><a class="headerlink" href="#id181" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A SIMD Thread executed by SIMD Processor, a.k.a. SM, has 16 Lanes.</p>
</div>
<figure class="align-center" id="id182">
<span id="sm"></span><a class="reference internal image-reference" href="_images/sm.png"><img alt="_images/sm.png" src="_images/sm.png" style="width: 438.0px; height: 673.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 82 </span><span class="caption-text">Streaming Multiprocessor SM has two -16-way SIMD units and four special
function units <a class="footnote-reference brackets" href="#cuda-sm" id="id92" role="doc-noteref"><span class="fn-bracket">[</span>70<span class="fn-bracket">]</span></a>. SM has L1 and Read Only Cache (Uniform Cache)
GTX480 has 48 SMs. <strong>ALUs run at twice the clock rate of rest of chip. So each
decoded instruction runs on 32 pieces of data on the 16 ALUs over two ALU
clocks</strong> <a class="footnote-reference brackets" href="#chime" id="id93" role="doc-noteref"><span class="fn-bracket">[</span>71<span class="fn-bracket">]</span></a>.</span><a class="headerlink" href="#id182" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id183">
<span id="sm2"></span><a class="reference internal image-reference" href="_images/sm2.png"><img alt="_images/sm2.png" src="_images/sm2.png" style="width: 468.0px; height: 603.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 83 </span><span class="caption-text">Multithreaded SIMD Processor (Streaming Multiprocessor SM) figure from book
<a class="footnote-reference brackets" href="#quantitative-gpu-sm" id="id94" role="doc-noteref"><span class="fn-bracket">[</span>74<span class="fn-bracket">]</span></a></span><a class="headerlink" href="#id183" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A SIMD Thread executed by SIMD Processor, a.k.a. SM, processes 32
elements.
Number of registers in a Thread Block =
16 (SM) * 32 (Cuda Thread) * 64 (TLR, Thread Level Register) = 32768
Register file.
Fermi has a mode bit that offers the choice of using 64 KB of SRAM as
a 16 KB L1 cache with 48 KB of Local Memory or as a 48 KB L1 cache
with 16 KB of Local Memory <a class="footnote-reference brackets" href="#quantitative-gpu-l1" id="id95" role="doc-noteref"><span class="fn-bracket">[</span>85<span class="fn-bracket">]</span></a>.</p>
</div>
<figure class="align-center" id="id184">
<span id="threadblock"></span><a class="reference internal image-reference" href="_images/threadblock.jpg"><img alt="_images/threadblock.jpg" src="_images/threadblock.jpg" style="width: 596.0px; height: 295.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 84 </span><span class="caption-text">SM select Thread Blocks to run</span><a class="headerlink" href="#id184" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<ul class="simple">
<li><p>Two level of scheduler.</p>
<ul>
<li><p>Level 1: Thread Block Scheduler:
Whenever an SM executes a thread block, all the threads inside the
thread block are executed at the same time.
When any of thread in Warp not ready for operands data dependence, context
switching between Warps.
When switching away from a particular warp, all the data of that warp remains
in the register file so that it can be quickly resumed when its operands
become ready <a class="footnote-reference brackets" href="#wiki-tbcp" id="id96" role="doc-noteref"><span class="fn-bracket">[</span>91<span class="fn-bracket">]</span></a>.</p></li>
</ul>
</li>
<li><p>Level 2: Warp Scheduler:
Cuda Threads in the same Warp.</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Invoke MATMUL with 256 threads per Thread Block</span>
<span class="n">__host__</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">nblocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">255</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">512</span><span class="p">;</span><span class="w"></span>
<span class="n">matmul</span><span class="o">&lt;&lt;&lt;</span><span class="n">nblocks</span><span class="p">,</span><span class="w"> </span><span class="mi">255</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">);</span><span class="w"></span>
<span class="c1">// MATMUL in CUDA</span>
<span class="n">__device__</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">matmul</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">C</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="o">*</span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<figure class="align-center" id="id185">
<span id="grid"></span><a class="reference internal image-reference" href="_images/grid.png"><img alt="_images/grid.png" src="_images/grid.png" style="width: 558.0px; height: 694.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 85 </span><span class="caption-text">Mapping 8192 elements of matmul for Nvidia’s GPU (figure from book
<a class="footnote-reference brackets" href="#quantitative-grid" id="id97" role="doc-noteref"><span class="fn-bracket">[</span>69<span class="fn-bracket">]</span></a>). SIMT: 16 SIMD Threads in 1 Thread Block.</span><a class="headerlink" href="#id185" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id186">
<span id="gpu-mem"></span><a class="reference internal image-reference" href="_images/memory.png"><img alt="_images/memory.png" src="_images/memory.png" style="width: 339.5px; height: 316.5px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 86 </span><span class="caption-text">GPU memory (figure from book <a class="footnote-reference brackets" href="#quantitative-gpu-mem" id="id98" role="doc-noteref"><span class="fn-bracket">[</span>75<span class="fn-bracket">]</span></a>)</span><a class="headerlink" href="#id186" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>Summarize as table below.</p>
<table class="docutils align-default" id="id187">
<caption><span class="caption-number">Table 44 </span><span class="caption-text">More Descriptive Name for Cuda term in Fermi GPU.</span><a class="headerlink" href="#id187" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 19%" />
<col style="width: 19%" />
<col style="width: 13%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>More Desciptive Name</p></th>
<th class="head"><p>Cuda term</p></th>
<th class="head"><p>Structure</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Grid</p></td>
<td><p>Grid</p></td>
<td></td>
<td><p>Grid is Vectorizable Loop as <a class="reference internal" href="#gpu-terms"><span class="std std-numref">Fig. 80</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p>Thread Block</p></td>
<td><p>Thread Block / GPU Core</p></td>
<td><p>Each Grid has 16 Thread Block.</p></td>
<td><p>Each Thread Block is assigned 512 elements of the vectors to
work on.
SIMD Processors are full processors with separate PCs and are programmed using
threads <a class="footnote-reference brackets" href="#quantitative-gpu-threadblock" id="id99" role="doc-noteref"><span class="fn-bracket">[</span>87<span class="fn-bracket">]</span></a>.
As <a class="reference internal" href="#grid"><span class="std std-numref">Fig. 85</span></a>, it assigns 16 Thread Block to 16 SIMD Processors.
CPU Core is the processor which include multi-threads. A thread of CPU is
execution unit with its own PC (Program Counter).
Similarly, Once a thread block is launched on a multiprocessor (SM), all of its warps are resident until their execution finishes. Thus a new block is not launched on an SM until there is sufficient number of free registers for all warps of the new block, and until there is enough free shared memory for the new block.
As this concept, GPU
Core is the SIMD Processor includes several SIMD Thread (Warp). Each Warp
has its PC <a class="footnote-reference brackets" href="#wiki-tbcp" id="id100" role="doc-noteref"><span class="fn-bracket">[</span>91<span class="fn-bracket">]</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p>SIMD Thread (run by SIMD Processor)</p></td>
<td><p>Warp (run by Streaming Multiprocessor, SM)</p></td>
<td><p>Each SIMD Processor has 16 SIMD Threads.</p></td>
<td><p>Each SIMD Processor has Memory:Local Memory as <a class="reference internal" href="#gpu-mem"><span class="std std-numref">Fig. 86</span></a>. Local
Memory is shared by the SIMD Lanes within a multithreaded SIMD Processor,
but this memory is not shared between multithreaded SIMD Processors.
Warp has it’s own PC and may map to
one whole function or part of function. Compiler and run time may assign
them to the same Warp or different Warps <a class="footnote-reference brackets" href="#quantitative-gpu-warp" id="id101" role="doc-noteref"><span class="fn-bracket">[</span>92<span class="fn-bracket">]</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p>SIMD Lane</p></td>
<td><p>Cuda Thread</p></td>
<td><p>Each SIMD Thread has 16 Lanes..</p></td>
<td><p>A vertical cut of a thread of SIMD instructions corresponding to
one element executed by one SIMD Lane. It is a vector instruction with
processing 16-elements. SIMD Lane registers: each Lane has its TLR
(Thread Level Registers) which is allocated from Register file (32768 x
32-bit) by SM as <a class="reference internal" href="#sm"><span class="std std-numref">Fig. 82</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p>Chime</p></td>
<td><p>Chime</p></td>
<td><p>Each SIMD Lane has 2 chimes.</p></td>
<td><p>One clock rate of rest of chip executes 2 data elements on two Cuda-core
as <a class="reference internal" href="#sm"><span class="std std-numref">Fig. 82</span></a>.
Vector length is 32 (32 elements). SIMD Lanes is 16. Chime is 2.
This ALU clock cycles, also known as “ping pong” cycles.
As <a class="reference internal" href="#grid"><span class="std std-numref">Fig. 85</span></a> for the later Fermi-generation GPUs.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="vertex-unit">
<h3><a class="toc-backref" href="#id216" role="doc-backlink">Vertex unit</a><a class="headerlink" href="#vertex-unit" title="Permalink to this heading">¶</a></h3>
<section id="var-unit">
<h4><a class="toc-backref" href="#id217" role="doc-backlink">VAR unit</a><a class="headerlink" href="#var-unit" title="Permalink to this heading">¶</a></h4>
<p>VAR Variable Rate Shading Unit <a class="footnote-reference brackets" href="#var" id="id102" role="doc-noteref"><span class="fn-bracket">[</span>88<span class="fn-bracket">]</span></a>.</p>
</section>
</section>
<section id="texture-unit">
<h3><a class="toc-backref" href="#id218" role="doc-backlink">Texture unit</a><a class="headerlink" href="#texture-unit" title="Permalink to this heading">¶</a></h3>
<p>As depicted in <a class="reference external" href="http://jonathan2251.github.io/lbd/gpu.html#opengl-shader-compiler">section OpenGL Shader Compiler</a>.</p>
</section>
<section id="speedup-features">
<h3><a class="toc-backref" href="#id219" role="doc-backlink">Speedup Features</a><a class="headerlink" href="#speedup-features" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>Gather-scatter data transfer: HW support sparse vector access is called
gather-scatter. The VMIPS instructions are LVI (load vector indexed or gather)
and SVI (store vector indexed or scatter) <a class="footnote-reference brackets" href="#quantitative-gpu-gs" id="id103" role="doc-noteref"><span class="fn-bracket">[</span>89<span class="fn-bracket">]</span></a>.</p></li>
<li><p>Address Coalescing: GPU provides this feature explained as follows,</p>
<ul>
<li><p>Note that unlike vector architectures, GPUs don’t have separate instructions
for sequential data transfers, strided data transfers, and gather-scatter
data transfers. All data transfers are gather-scatter! To regain the
efficiency of sequential (unit-stride) data transfers, GPUs include special
Address Coalescing hardware to recognize when the SIMD Lanes within a thread of
SIMD instructions are col- lectively issuing sequential addresses
<a class="footnote-reference brackets" href="#quantitative-gpu-ac" id="id104" role="doc-noteref"><span class="fn-bracket">[</span>90<span class="fn-bracket">]</span></a>..</p></li>
</ul>
</li>
</ul>
</section>
<section id="buffers">
<h3><a class="toc-backref" href="#id220" role="doc-backlink">Buffers</a><a class="headerlink" href="#buffers" title="Permalink to this heading">¶</a></h3>
<p>In addition to texture units and instructions, GPU provides different Buffers
to speedup OpenGL pipeline rendering <a class="footnote-reference brackets" href="#buffers-redbook" id="id105" role="doc-noteref"><span class="fn-bracket">[</span>42<span class="fn-bracket">]</span></a>.</p>
<ul>
<li><p>Color buffer</p>
<p>They contain the RGB or sRGB color data and may also contain alpha values for
each pixel in the framebuffer. There may be multiple color buffers in a
framebuffer.
You’ve already used double buffering for animation. Double buffering is done
by making the main color buffer have two parts: a front buffer that’s displayed
in your window; and a back buffer, which is where you render the new image
<a class="footnote-reference brackets" href="#redbook-p155" id="id106" role="doc-noteref"><span class="fn-bracket">[</span>76<span class="fn-bracket">]</span></a>.</p>
</li>
<li><p>Depth buffer (Z buffer)</p>
<p>Depth is measured in terms of distance to the eye, so pixels with larger
depth-buffer values are overwritten by pixels with smaller values
<a class="footnote-reference brackets" href="#redbook-p156" id="id107" role="doc-noteref"><span class="fn-bracket">[</span>77<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#z-buffer-wiki" id="id108" role="doc-noteref"><span class="fn-bracket">[</span>79<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#depthstencils-ogl" id="id109" role="doc-noteref"><span class="fn-bracket">[</span>80<span class="fn-bracket">]</span></a>.</p>
</li>
<li><p>Stencil Buffer</p>
<p>In the simplest case, the stencil buffer is used to limit the area of
rendering (stenciling) <a class="footnote-reference brackets" href="#stencils-buffer-wiki" id="id110" role="doc-noteref"><span class="fn-bracket">[</span>81<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#depthstencils-ogl" id="id111" role="doc-noteref"><span class="fn-bracket">[</span>80<span class="fn-bracket">]</span></a>.</p>
</li>
<li><p>Frame Buffer</p>
<p>OpenGL offers: the color, depth and stencil buffers.
This combination of buffers is known as the default framebuffer and as you’ve
seen, a framebuffer is an area in memory that can be rendered to
<a class="footnote-reference brackets" href="#framebuffers-ogl" id="id112" role="doc-noteref"><span class="fn-bracket">[</span>82<span class="fn-bracket">]</span></a>.</p>
</li>
</ul>
</section>
</section>
<section id="general-purpose-gpu">
<h2><a class="toc-backref" href="#id221" role="doc-backlink">General purpose GPU</a><a class="headerlink" href="#general-purpose-gpu" title="Permalink to this heading">¶</a></h2>
<p>Since GLSL shaders provide a general way for writing C code in them, if applying
a software frame work instead of OpenGL api, then the system can run some data
parallel computation on GPU for speeding up and even get CPU and GPU executing
simultaneously. Furthmore, any language that allows the code running on the CPU to poll
a GPU shader for return values, can create a GPGPU framework <a class="footnote-reference brackets" href="#gpgpuwiki" id="id113" role="doc-noteref"><span class="fn-bracket">[</span>83<span class="fn-bracket">]</span></a>.</p>
<section id="mapping-data-in-gpu">
<h3><a class="toc-backref" href="#id222" role="doc-backlink">Mapping data in GPU</a><a class="headerlink" href="#mapping-data-in-gpu" title="Permalink to this heading">¶</a></h3>
<p>As previous section GPU, the subset of y[]=a*x[]+y[] array-calculation as follows,</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>// Invoke DAXPY with 256 threads per Thread Block
__host__
int nblocks = (n+255) / 256;
daxpy&lt;&lt;&lt;nblocks, 256&gt;&gt;&gt;(n, 2.0, x, y);
// DAXPY in CUDA
__device__
void daxpy(int n, double a, double *x, double *y) {
  int i = blockIdx.x*blockDim.x + threadIdx.x;
  if (i &lt; n) y[i] = a*x[i] + y[i];
}
</pre></div>
</div>
<ul class="simple">
<li><p>name&lt;&lt;&lt;dimGrid, dimBlock&gt;&gt;&gt;(… parameter list …):</p>
<ul>
<li><p>dimGrid: Number of Blocks in Grid</p></li>
<li><p>dimBlock: 256 Threads in Block</p></li>
</ul>
</li>
</ul>
<p class="rubric">Assembly code of PTX (from page 300 of Quantitative book)</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>// code to set VLR, Vector Length Register, to (n % 256)
//   ...
//
shl.u32 R8, blockIdx, 9       ; Thread Block ID * Block size (512)
add.u32 R8, R8, threadIdx     ; R8 = i = my CUDA Thread ID
shl.u32 R8, R8, 3             ; byte offset
setp.neq.s32 P1, RD8, RD3     ; RD3 = n, P1 is predicate register 1
ld.global.f64 RD0, [X+R8]     ; RD0 = X[i]
ld.global.f64 RD2, [Y+R8]     ; RD2 = Y[i]
mul.f64 RD0, RD0, RD4         ; Product in RD0 = RD0 * RD4 (scalar a)
add.f64 RD0, RD0, RD2         ; SuminRD0 = RD0 + RD2 (Y[i])
st.global.f64 [Y+R8], RD0     ; Y[i] = sum (X[i]*a + Y[i])
</pre></div>
</div>
<ul class="simple">
<li><p>Need to set VLR if PTX has this instruction. Otherwise, set lane-mask in
the similar way of the code below.</p></li>
</ul>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>__device__
void lane-mask-ex( double *X, double *Y, double *Z) {
  if (X[i] != 0)
    X[i] = X[i] – Y[i];
  else X[i] = Z[i];
}
</pre></div>
</div>
<p class="rubric">Assembly code of Vector Processor</p>
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span><span class="nf">LV</span><span class="w"> </span><span class="no">V1</span><span class="p">,</span><span class="no">Rx</span><span class="w">         </span><span class="c1">;load vector X into V1</span>
<span class="nf">LV</span><span class="w"> </span><span class="no">V2</span><span class="p">,</span><span class="no">Ry</span><span class="w">         </span><span class="c1">;load vector Y</span>
<span class="nf">L.D</span><span class="w"> </span><span class="no">F0</span><span class="p">,</span><span class="mi">#0</span><span class="w">        </span><span class="c1">;load FP zero into F0</span>
<span class="nf">SNEVS.D</span><span class="w"> </span><span class="no">V1</span><span class="p">,</span><span class="no">F0</span><span class="w">    </span><span class="c1">;sets VM(i) to 1 if V1(i)!=F0</span>
<span class="nf">SUBVV.D</span><span class="w"> </span><span class="no">V1</span><span class="p">,</span><span class="no">V1</span><span class="p">,</span><span class="no">V2</span><span class="w"> </span><span class="c1">;subtract under vector mask</span>
<span class="nf">SV</span><span class="w"> </span><span class="no">V1</span><span class="p">,</span><span class="no">Rx</span><span class="w">         </span><span class="c1">;store the result in X</span>
</pre></div>
</div>
<p class="rubric">Assembly code of PTX (modified code from refering page 208 - 302 of
Quantitative book)</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>ld.global.f64 RD0, [X+R9]     ; RD0 = X[i]
setp.neq.s32 P1, RD0, #0      ; P1 is predicate register 1
@!P1, bra ELSE1, *Push        ; Push old mask, set new mask bits
                              ; if P1 false, go to ELSE1
ld.global.f64 RD2, [Y+R8]     ; RD2 = Y[i]
sub.f64 RD0, RD0, RD2         ; Difference in RD0
st.global.f64 [X+R8], RD0     ; X[i]=RD0
ELSE1:
ld.global.f64 RD0, [Z+R8]     ; RD0 = Z[i]
st.global.f64 [X+R8], RD0     ; X[i] = RD0
ENDIF1:
ret, *Pop                     ; pop to restore old mask
</pre></div>
</div>
<ul class="simple">
<li><p>For Lane Mask, refer to <a class="footnote-reference brackets" href="#vmr" id="id114" role="doc-noteref"><span class="fn-bracket">[</span>94<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#quantitative-gpu-asm-daxpy" id="id115" role="doc-noteref"><span class="fn-bracket">[</span>95<span class="fn-bracket">]</span></a>.</p></li>
</ul>
<p>The following table explains how the elemements of saxpy() maps to lane of SIMD
Thread(Warp) of Thread Block(Core) of Grid.</p>
<table class="docutils align-default" id="id188">
<caption><span class="caption-number">Table 45 </span><span class="caption-text">Mapping saxpy code to <a class="reference internal" href="#grid"><span class="std std-numref">Fig. 85</span></a>.</span><a class="headerlink" href="#id188" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 10%" />
<col style="width: 21%" />
<col style="width: 69%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>saxpy(()</p></th>
<th class="head"><p>Instance in <a class="reference internal" href="#grid"><span class="std std-numref">Fig. 85</span></a></p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>blockDim.x</p></td>
<td><p>The index of Thread Block</p></td>
<td><p>blockDim: in this example configured as <a class="reference internal" href="#grid"><span class="std std-numref">Fig. 85</span></a> is 16(Thread Blocks) * 16(SIDM Threads) = 256</p></td>
</tr>
<tr class="row-odd"><td><p>blockIdx.x</p></td>
<td><p>The index of SIMD Thread</p></td>
<td><p>blockIdx: the index of Thread Block within the Grid</p></td>
</tr>
<tr class="row-even"><td><p>threadIdx.x</p></td>
<td><p>The index of elements</p></td>
<td><p>threadIdx: the index of the SIMD Thread within its Thread Block</p></td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><p>With Fermi, each 32-wide thread of SIMD instructions is mapped to 16 physical
SIMD Lanes, so each SIMD instruction in a thread of SIMD instructions takes
two clock cycles to complete.</p></li>
<li><p>You could say that it has 16 lanes, the vector length would be 32, and the
chime is 2 clock cycles.</p></li>
<li><p>The mape of y[0..31] = a * x[0..31] * y[0..31] to &lt;Core, Warp, Cuda Thread&gt;
of GPU as the following table. x[0..31] map to 32 Cuda Threads; two Cuda
Thread map to one SIMD lane.</p></li>
</ul>
<table class="docutils align-default" id="id189">
<caption><span class="caption-number">Table 46 </span><span class="caption-text">Map (Core,Warp) to saxpy</span><a class="headerlink" href="#id189" title="Permalink to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><ul class="simple">
<li></li>
</ul>
</th>
<th class="head"><p>Warp-0</p></th>
<th class="head"><p>Warp-1</p></th>
<th class="head"><p>…</p></th>
<th class="head"><p>Warp-15</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Core-0</p></td>
<td><p>y[0..31] = a * x[0..31] * y[0..31]</p></td>
<td><p>y[32..63] = a * x[32..63] + y[32..63]</p></td>
<td><p>…</p></td>
<td><p>y[480..511] = a * x[480..511] + y[480..511]</p></td>
</tr>
<tr class="row-odd"><td><p>…</p></td>
<td><p>…</p></td>
<td><p>…</p></td>
<td><p>…</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-even"><td><p>Core-15</p></td>
<td><p>y[7680..7711] = a * …</p></td>
<td><p>…</p></td>
<td><p>…</p></td>
<td><p>y[8160..8191] = a * x[8160..8191] + y[8160..8191]</p></td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><p>Each Cuda Thread run GPU function-code saxpy. Fermi has Register file (32768 x
32-bit).
As <a class="reference internal" href="#sm"><span class="std std-numref">Fig. 82</span></a>, Number of registers in a Thread Block = 16 (SM) * 32 (Cuda
Thread) * 64 (TLR, Thread Level Register) = 32768 x 32-bit (Register file).</p></li>
<li><p>When mapping to the fragments/pixels in graphic GPU, x[0..15] corresponding to
a two dimensions of tile of fragments/pixels at pixel[0..3][0..3] since image
uses tile base for grouping closest color together.</p></li>
</ul>
</section>
<section id="work-between-cpu-and-gpu-in-cuda">
<h3><a class="toc-backref" href="#id223" role="doc-backlink">Work between CPU and GPU in Cuda</a><a class="headerlink" href="#work-between-cpu-and-gpu-in-cuda" title="Permalink to this heading">¶</a></h3>
<p>Above daxpy() GPU code did not mention the host (CPU) side of code for triggering
GPU’s function.
The following is host (CPU) side of a CUDA example to call saxpy on GPU <a class="footnote-reference brackets" href="#cudaex" id="id116" role="doc-noteref"><span class="fn-bracket">[</span>86<span class="fn-bracket">]</span></a>
as follows,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="n">__global__</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">saxpy</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="o">*</span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">d_x</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span><span class="w"> </span><span class="n">cudaMemcpyHostToDevice</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">d_y</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span><span class="w"> </span><span class="n">cudaMemcpyHostToDevice</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="n">saxpy</span><span class="o">&lt;&lt;&lt;</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">255</span><span class="p">)</span><span class="o">/</span><span class="mi">256</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="p">,</span><span class="w"> </span><span class="n">d_x</span><span class="p">,</span><span class="w"> </span><span class="n">d_y</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">d_y</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span><span class="w"> </span><span class="n">cudaMemcpyDeviceToHost</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The main() run on CPU while the saxpy() run on GPU.
CPU copy the data from x and y to the corresponding device arrays d_x and d_y
using cudaMemcpy.
The saxpy kernel is launched by the statement:
saxpy&lt;&lt;&lt;(N+255)/256, 256&gt;&gt;&gt;(N, 2.0, d_x, d_y);
In this case we launch the kernel with thread blocks containing 512 elements,
and use integer arithmetic to determine the number of thread blocks required to
process all N elements of the arrays ((N+255)/256)
Through cudaMemcpyHostToDevice and cudaMemcpyDeviceToHost, CPU can pass data in
x and y arrays to GPU and get result from GPU to y array.
Since both of these memory transfers trigger the DMA functions without CPU operation,
it may speed up by running both CPU/GPU with their data in their own cache
repectively.
After DMA memcpy from cpu’s memory to gpu’s, gpu operates the whole loop of matrix
operation for “y[] = a*x[]+y[];”
instructions with one Grid.</p>
<p>GPU persues throughput from SIMD application. Can hide cache-miss latence from
SMT. As result GPU may hasn’t L2 and L3 like CPU for each core since GPU is highly
latency-tolerant multithreading for data parallel application <a class="footnote-reference brackets" href="#gpu-latency-tolerant" id="id117" role="doc-noteref"><span class="fn-bracket">[</span>96<span class="fn-bracket">]</span></a>.
DMA memcpy map the data in cpu memory to each l1 cache of core on gpu memory.
Many gpu provides operations scatter and gather to access DRAM data for stream
processing <a class="footnote-reference brackets" href="#quantitative-gpu-sparse-matrix" id="id118" role="doc-noteref"><span class="fn-bracket">[</span>97<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#gpgpuwiki" id="id119" role="doc-noteref"><span class="fn-bracket">[</span>83<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#shadingl1" id="id120" role="doc-noteref"><span class="fn-bracket">[</span>98<span class="fn-bracket">]</span></a>.</p>
<p>When the GPU function is dense computation in array such as MPEG4 encoder or
deep learning for tuning weights, it may get much speed up <a class="footnote-reference brackets" href="#mpeg4speedup" id="id121" role="doc-noteref"><span class="fn-bracket">[</span>99<span class="fn-bracket">]</span></a>.
However when GPU function is matrix addition and CPU will idle for waiting
GPU’s result. It may slow down than doing matrix addition by CPU only.
Arithmetic intensity is defined as the number of operations performed per word of
memory transferred. It is important for GPGPU applications to have high arithmetic
intensity else the memory access latency will limit computational speedup
<a class="footnote-reference brackets" href="#gpgpuwiki" id="id122" role="doc-noteref"><span class="fn-bracket">[</span>83<span class="fn-bracket">]</span></a>.</p>
<p>Wiki here <a class="footnote-reference brackets" href="#gpuspeedup" id="id123" role="doc-noteref"><span class="fn-bracket">[</span>100<span class="fn-bracket">]</span></a> includes speedup applications for gpu as follows:</p>
<p>General Purpose Computing on GPU, has found its way into fields as diverse as
machine learning, oil exploration, scientific image processing, linear algebra,
statistics, 3D reconstruction and even stock options pricing determination.
In addition, section “GPU accelerated video decoding and encoding” for video
compressing <a class="footnote-reference brackets" href="#gpuspeedup" id="id124" role="doc-noteref"><span class="fn-bracket">[</span>100<span class="fn-bracket">]</span></a> gives the more applications for GPU acceleration.</p>
<table class="docutils align-default" id="id190">
<caption><span class="caption-number">Table 47 </span><span class="caption-text">The differences for speedup in architecture of CPU and GPU</span><a class="headerlink" href="#id190" title="Permalink to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Item</p></th>
<th class="head"><p>CPU</p></th>
<th class="head"><p>GPU</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Application</p></td>
<td><p>Non-data parallel</p></td>
<td><p>Data parallel</p></td>
</tr>
<tr class="row-odd"><td><p>Architecture</p></td>
<td><p>SISD, small vector (eg.4*32bits)</p></td>
<td><p>Large SIMD (eg.16*32bits)</p></td>
</tr>
<tr class="row-even"><td><p>Cache</p></td>
<td><p>Smaller and faster</p></td>
<td><p>Larger and slower (ref. The following Note)</p></td>
</tr>
<tr class="row-odd"><td><p>ILP</p></td>
<td><p>Pipeline</p></td>
<td><p>Pipeline</p></td>
</tr>
<tr class="row-even"><td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>Superscalar, SMT</p></td>
<td><p>SIMT</p></td>
</tr>
<tr class="row-odd"><td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>Super-pipeline</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>Core</p></td>
<td><p>Smaller threads for SMT (2 or 4)</p></td>
<td><p>Larger threads (16 or 32)</p></td>
</tr>
<tr class="row-odd"><td><p>Branch</p></td>
<td><p>Conditional-instructions</p></td>
<td><p>Mask &amp; conditional-instructions</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>GPU-Cache</strong></p>
<p>In theory for data parallel application in GPU’s SMT, GPU can schedule more
threads and pursues throughput rather speedup for one single thread as SISD in
CPU. However in reality, GPU provides small L1 cache like CPU’s and fill the
cache-miss with scheduline another thread. So, GPU may has no L2 and L3 while
CPU has deep level of caches.</p>
</div>
</section>
<section id="volta-cuda-thread-simd-lane-with-pc-program-couner-and-call-stack">
<h3><a class="toc-backref" href="#id224" role="doc-backlink">Volta (Cuda thread/SIMD lane with PC, Program Couner and Call Stack)</a><a class="headerlink" href="#volta-cuda-thread-simd-lane-with-pc-program-couner-and-call-stack" title="Permalink to this heading">¶</a></h3>
<p>One way the compiler handles this is by keeping executing
instructions in order and if some threads don’t have to execute certain instructions it switches off those threads and turns them
on their relevant instructions and switches off the other threads, this process is called masking.</p>
<figure class="align-center" id="id191">
<span id="pre-volta-1"></span><a class="reference internal image-reference" href="_images/pre-volta-1.png"><img alt="_images/pre-volta-1.png" src="_images/pre-volta-1.png" style="width: 1004.0px; height: 456.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 87 </span><span class="caption-text">SIMT Warp Execution Model of Pascal and Earlier GPUs <a class="footnote-reference brackets" href="#volta" id="id125" role="doc-noteref"><span class="fn-bracket">[</span>93<span class="fn-bracket">]</span></a></span><a class="headerlink" href="#id191" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id192">
<span id="volta-1"></span><a class="reference internal image-reference" href="_images/volta-1.png"><img alt="_images/volta-1.png" src="_images/volta-1.png" style="width: 679.0px; height: 408.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 88 </span><span class="caption-text">Volta Warp with Per-Thread Program Counter and Call Stack <a class="footnote-reference brackets" href="#volta" id="id126" role="doc-noteref"><span class="fn-bracket">[</span>93<span class="fn-bracket">]</span></a></span><a class="headerlink" href="#id192" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<ul class="simple">
<li><p>After Volta GPU of Nvidia, each thread in Warp has it’s own PC as
<a class="reference internal" href="#volta-1"><span class="std std-numref">Fig. 88</span></a>.</p></li>
</ul>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>//
__device__ void insert_after(Node *a, Node *b)
{
  Node *c;
  lock(a); lock(a-&gt;next);
  ...
  unlock(c); unlock(a);
}
</pre></div>
</div>
<ul>
<li><p>Volta’s independent thread scheduling allows the GPU to yield execution of
any thread, either to make better use of execution resources or to allow
one thread to wait for data to be produced by another.
As above example <a class="footnote-reference brackets" href="#volta" id="id127" role="doc-noteref"><span class="fn-bracket">[</span>93<span class="fn-bracket">]</span></a>, each thread can progress with it’s own PC. So,
the different threads in the same Warp can run insert_ater() function
in dependently without waiting lock().</p></li>
<li><p>Provide both thread in group efficency and independently thread progression.</p>
<p>Beside each thread in same Warp can progress independently as above,
To maximize parallel efficiency, Volta includes a schedule optimizer which
determines how to group active threads from the same warp together into SIMT
units. This retains the high throughput of SIMT execution as in prior NVIDIA
GPUs, but with much more flexibility: threads can now diverge and reconverge
at sub-warp granularity, while the convergence optimizer in Volta will still
group together threads which are executing the same code and run them in
parallel for maximum efficiency.
In Cuda Applications, this feature provides more parallel
opportunities with __syncwarp() to user programmers as <a class="reference internal" href="#volta-2"><span class="std std-numref">Fig. 89</span></a>.</p>
</li>
</ul>
<figure class="align-center" id="id193">
<span id="volta-2"></span><a class="reference internal image-reference" href="_images/volta-2.png"><img alt="_images/volta-2.png" src="_images/volta-2.png" style="width: 738.0px; height: 306.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 89 </span><span class="caption-text">Programs use Explicit Synchronization to Reconverge Threads in a Warp <a class="footnote-reference brackets" href="#volta" id="id128" role="doc-noteref"><span class="fn-bracket">[</span>93<span class="fn-bracket">]</span></a></span><a class="headerlink" href="#id193" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
</section>
</section>
<section id="opencl-vulkan-and-spir-v">
<h2><a class="toc-backref" href="#id225" role="doc-backlink">OpenCL, Vulkan and spir-v</a><a class="headerlink" href="#opencl-vulkan-and-spir-v" title="Permalink to this heading">¶</a></h2>
<figure class="align-default" id="id194">
<span id="spirv"></span><div class="graphviz"><img src="_images/graphviz-edc6470393ed392952140c66f53f8481bfcdd4a5.png" alt="digraph G {
  rankdir=LR;

  compound=true;
  node [shape=record];
  SW_LAYER [label=&quot;{ GLSL | OpenCL } | SPIR-V | GPU machine code&quot;];
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 90 </span><span class="caption-text">OpenCL and GLSL(OpenGL)</span><a class="headerlink" href="#id194" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<table class="docutils align-default" id="id195">
<caption><span class="caption-number">Table 48 </span><span class="caption-text">OpenCL and OpenGL SW system</span><a class="headerlink" href="#id195" title="Permalink to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Name of SW</p></th>
<th class="head"><p>GPU language</p></th>
<th class="head"><p>Level of GPU language</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>OpenCL</p></td>
<td><p>OpenCL</p></td>
<td><p>C99 dialect (with C pointer, …)</p></td>
</tr>
<tr class="row-odd"><td><p>OpenGL</p></td>
<td><p>GLSL</p></td>
<td><p>C-like (no C pointer, …)</p></td>
</tr>
<tr class="row-even"><td><p>Vulkan</p></td>
<td><p>SPIR-V</p></td>
<td><p>IR</p></td>
</tr>
</tbody>
</table>
<figure class="align-center" id="id196">
<span id="opencl-to-spirv"></span><a class="reference internal image-reference" href="_images/opencl-to-spirv-offine-compilation.png"><img alt="_images/opencl-to-spirv-offine-compilation.png" src="_images/opencl-to-spirv-offine-compilation.png" style="width: 713.6px; height: 284.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 91 </span><span class="caption-text">Offline Compilation of OpenCL Kernels into SPIR-V Using Open Source Tooling <a class="footnote-reference brackets" href="#id154" id="id129" role="doc-noteref"><span class="fn-bracket">[</span>102<span class="fn-bracket">]</span></a></span><a class="headerlink" href="#id196" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<ul class="simple">
<li><p>clang: Compile OpenCL to spirv for runtime+driver. Or compile OpenCL to llvm, then
“SPIR-V LLVM Translator” translate llvm to spirv for runtime+driver.</p></li>
<li><p>clspv: Compile OpenCL to spirv for tuntime</p></li>
</ul>
<figure class="align-default" id="id197">
<span id="glsl-spirv"></span><div class="graphviz"><img src="_images/graphviz-785ee4017c1cd0e2868d2fbcd362763707b203b7.png" alt="digraph G {
  rankdir=LR;

  node [shape=record];

  glslang [style=filled,fillcolor=green];
  spirv_cross [label=&quot;spirv-cross&quot;,style=filled,fillcolor=green];
  glsl -&gt; glslang -&gt; spirv;
  glsl -&gt; spirv_cross -&gt; spirv [dir=&quot;back&quot;];
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 92 </span><span class="caption-text">Convertion between glsl and spirv</span><a class="headerlink" href="#id197" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<ul>
<li><p>Comparsion for OpenCL and OpenGL’s compute shader.</p>
<ul>
<li><p>Same:</p>
<p>Both are for General Computing of GPU.</p>
</li>
<li><p>Difference:</p>
<p>OpenCL include GPU and other accelerate device/processor.
OpenCL is C language on Device and C++ on Host based on OpenCL runtime.
Compute shader is GLSL shader language run on OpenGL graphic enviroment and
integrate and access data of OpenGL API easily <a class="footnote-reference brackets" href="#diff-compute-shader-opencl" id="id130" role="doc-noteref"><span class="fn-bracket">[</span>101<span class="fn-bracket">]</span></a>.</p>
</li>
</ul>
</li>
<li><p>OpenGL/GLSL vs Vulkan/spir-v.</p>
<ul class="simple">
<li><p>High level of API and shader: OpenGL, GLSL.</p></li>
<li><p>Low level of API and shader: Vulkan, spir-v.</p></li>
</ul>
</li>
</ul>
<p>Though OpenGL api existed in higher level with many advantages from sections
above, sometimes it cannot compete in efficience with direct3D providing
lower levels api for operating memory by user program <a class="footnote-reference brackets" href="#vulkanapiwiki" id="id131" role="doc-noteref"><span class="fn-bracket">[</span>103<span class="fn-bracket">]</span></a>.
Vulkan api is lower level’s C/C++ api to fill the gap allowing user program to
do these things in OpenGL to compete against Microsoft direct3D.
Here is an example <a class="footnote-reference brackets" href="#vulkanex" id="id132" role="doc-noteref"><span class="fn-bracket">[</span>104<span class="fn-bracket">]</span></a>. Meanwhile glsl is C-like language. The vulkan
infrastructure provides tool, glslangValidator <a class="footnote-reference brackets" href="#spirvtoolchain" id="id133" role="doc-noteref"><span class="fn-bracket">[</span>105<span class="fn-bracket">]</span></a>, to compile
glsl into an Intermediate Representation
Form (IR) called spir-v off-line.
As a result, it saves part of compilation time from glsl to gpu instructions
on-line
since spir-v is an IR of level closing to llvm IR <a class="footnote-reference brackets" href="#spirvwiki" id="id134" role="doc-noteref"><span class="fn-bracket">[</span>106<span class="fn-bracket">]</span></a>.
In addition, vulkan api reduces gpu drivers efforts in optimization and code
generation <a class="footnote-reference brackets" href="#vulkanapiwiki" id="id135" role="doc-noteref"><span class="fn-bracket">[</span>103<span class="fn-bracket">]</span></a>. These standards provide user programmer option to
using vulkan/spir-v instead of OpenGL/glsl, and allow them pre-compiling glsl
into spir-v off-line to saving part of on-line compilation time.</p>
<p>With vulkan and spir-v standard, the gpu can be used in OpenCL for Parallel
Programming of Heterogeneous Systems <a class="footnote-reference brackets" href="#opencl" id="id136" role="doc-noteref"><span class="fn-bracket">[</span>107<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#computekernelwiki" id="id137" role="doc-noteref"><span class="fn-bracket">[</span>108<span class="fn-bracket">]</span></a>.
Similar with Cuda, a OpenCL example for fast Fourier transform (FFT) is here
<a class="footnote-reference brackets" href="#openclexfft" id="id138" role="doc-noteref"><span class="fn-bracket">[</span>109<span class="fn-bracket">]</span></a>.
Once OpenCL grows into a popular standard when more computer languages or
framework supporting OpenCL language, GPU will take more jobs from CPU
<a class="footnote-reference brackets" href="#opencl-wiki-supported-lang" id="id139" role="doc-noteref"><span class="fn-bracket">[</span>110<span class="fn-bracket">]</span></a>.</p>
<p>Most GPUs have 16 or 32 lanes in a SIMD processor (Warp), vulkan provides
Subgroup operations to data parallel programming on lanes of SIMD processor
<a class="footnote-reference brackets" href="#vulkan-subgroup" id="id140" role="doc-noteref"><span class="fn-bracket">[</span>111<span class="fn-bracket">]</span></a>.</p>
<p>Subgroup operations provide a fast way for moving data between lanes intra Warp.
Assuming each Warp has eight lanes.
The following table lists result of reduce, inclusive and exclusive operations.</p>
<table class="docutils align-default" id="id198">
<caption><span class="caption-number">Table 49 </span><span class="caption-text">Lists each lane’s value after <strong>Reduce</strong>, <strong>Inclusive</strong> and
<strong>Exclusive</strong> operations repectively</span><a class="headerlink" href="#id198" title="Permalink to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Lane</p></th>
<th class="head"><p>0</p></th>
<th class="head"><p>1</p></th>
<th class="head"><p>2</p></th>
<th class="head"><p>3</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Initial value</p></td>
<td><p>a</p></td>
<td><p>b</p></td>
<td><p>c</p></td>
<td><p>d</p></td>
</tr>
<tr class="row-odd"><td><p>Reduce</p></td>
<td><p>OP(abcd)</p></td>
<td><p>OP(abcd)</p></td>
<td><p>OP(abcd)</p></td>
<td><p>OP(abcd)</p></td>
</tr>
<tr class="row-even"><td><p>Inclusive</p></td>
<td><p>OP(a)</p></td>
<td><p>OP(ab)</p></td>
<td><p>OP(abc)</p></td>
<td><p>OP(abcd)</p></td>
</tr>
<tr class="row-odd"><td><p>Exclusive</p></td>
<td><p>not define</p></td>
<td><p>OP(a)</p></td>
<td><p>OP(ab)</p></td>
<td><p>OP(abc)</p></td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><p>Reduce: e.g. subgroupAdd. Inclusive: e.g. subgroupInclusiveAdd. Exclusive:
e.g. subgroupExclusiveAdd.</p></li>
<li><p>For examples:</p>
<ul>
<li><p>ADD operation: OP(abcd) = a+b+c+d.</p></li>
<li><p>MAX operation: OP(abc) = MAX(a,b,c).</p></li>
</ul>
</li>
<li><p>When lane i is inactive, it is value is none.</p>
<ul>
<li><p>For instance of lane 0 is inactive, then MUL operation: OP(abcd) = b*c*d.</p></li>
</ul>
</li>
</ul>
<p>The following is a code example.</p>
<p class="rubric">An example of subgroup operations in glsl for vulkan</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">vec4</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec4</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">gl_SubgroupInvocationID</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">16u</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">subgroupAdd</span><span class="p">(</span><span class="n">in</span><span class="p">[</span><span class="n">gl_SubgroupInvocationID</span><span class="p">]);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">subgroupInclusiveMul</span><span class="p">(</span><span class="n">in</span><span class="p">[</span><span class="n">gl_SubgroupInvocationID</span><span class="p">]);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">subgroupMemoryBarrier</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p>Nvidia’s GPU provides __syncwarp() for subgroupMemoryBarrier() or compiler to
sync for the lanes in the same Warp.</p></li>
</ul>
<p>In order to let lanes in the same SIMD processor work efficently, data unifomity
analysis will provide many optimization opporturnities in register allocation,
transformation and code generation <a class="footnote-reference brackets" href="#llvm-uniformity" id="id141" role="doc-noteref"><span class="fn-bracket">[</span>112<span class="fn-bracket">]</span></a>.</p>
<p>Now, you find llvm IR expanding from cpu to gpu becoming influentially more and
more. And actually, llvm IR expanding from version 3.1 util now as I can feel.</p>
</section>
<section id="accelerate-ml-dl-on-opencl-sycl">
<h2><a class="toc-backref" href="#id226" role="doc-backlink">Accelerate ML/DL on OpenCL/SYCL</a><a class="headerlink" href="#accelerate-ml-dl-on-opencl-sycl" title="Permalink to this heading">¶</a></h2>
<figure class="align-center" id="id199">
<span id="opengl-ml-graph"></span><a class="reference internal image-reference" href="_images/opencl_ml_graph.png"><img alt="_images/opencl_ml_graph.png" src="_images/opencl_ml_graph.png" style="width: 918.0px; height: 325.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 93 </span><span class="caption-text">Implement ML graph scheduler both on compiler and runtime</span><a class="headerlink" href="#id199" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>As <a class="reference internal" href="#opengl-ml-graph"><span class="std std-numref">Fig. 93</span></a>, the Device of GPU or CPU+NPU is able to run the
whole ML graph.
However if the Device has NPU only, then the CPU operation such as Avg-Pool
has to run on Host side which add communication cost between Host and Device.</p>
<p>Like OpenGL’s shader, the “kernel” function may be compiled on-line or off-line
and sending to GPU as programmable functions.</p>
<p>In order to run ML (Machine Learning) efficiently, all platforms for ML on
GPU/NPU implement scheduling SW both on graph compiler and runtime.
<strong>If OpenCL can extend to support ML graph, then graph compiler such as TVM or
Runtime from Open Source have chance to leverage the effort of scheduling SW from
programmers</strong> <a class="footnote-reference brackets" href="#paper-graph-on-opencl" id="id142" role="doc-noteref"><span class="fn-bracket">[</span>113<span class="fn-bracket">]</span></a>. Cuda graph is an idea  like this
<a class="footnote-reference brackets" href="#cuda-graph-blog" id="id143" role="doc-noteref"><span class="fn-bracket">[</span>114<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#cuda-graph-pytorch" id="id144" role="doc-noteref"><span class="fn-bracket">[</span>115<span class="fn-bracket">]</span></a> .</p>
<ul class="simple">
<li><p>SYCL: Using C++ templates to optimize and genertate code for OpenCL and Cuda.
Provides a consistent language, APIs, and ecosystem in which to write and tune
code for different accelerator architecture, CPUs, GPUs, and FPGAs <a class="footnote-reference brackets" href="#sycl" id="id145" role="doc-noteref"><span class="fn-bracket">[</span>116<span class="fn-bracket">]</span></a>.</p>
<ul>
<li><p>SYCL uses generic programming with templates and generic lambda functions to
enable higher-level application software to be cleanly coded with optimized
acceleration of kernel code across an extensive range of acceleration backend
APIs, such as OpenCL and CUDA <a class="footnote-reference brackets" href="#sycl-cuda" id="id146" role="doc-noteref"><span class="fn-bracket">[</span>117<span class="fn-bracket">]</span></a>.</p></li>
</ul>
</li>
</ul>
<figure class="align-center" id="id200">
<span id="sycl-role"></span><a class="reference internal image-reference" href="_images/sycl.png"><img alt="_images/sycl.png" src="_images/sycl.png" style="width: 1158.0px; height: 448.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 94 </span><span class="caption-text">SYCL = C++ template and compiler for Data Parallel Applications on AI on CPUs,
GPUs and HPGAs.</span><a class="headerlink" href="#id200" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<ul>
<li><p>DPC++ (OneDPC) compiler: Based on SYCL, DPC++ can compile DPC++ language for
CPU host and GPU device. DPC++ (Data Parallel C++) is a language from Intel and
maybe accepted by C++ which GPU side (Kernal code) is C++ without exception
handler <a class="footnote-reference brackets" href="#dpcpp" id="id147" role="doc-noteref"><span class="fn-bracket">[</span>118<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#dpcpp-book" id="id148" role="doc-noteref"><span class="fn-bracket">[</span>119<span class="fn-bracket">]</span></a>.</p>
<ul>
<li><p>Features of Kernel Code:</p>
<ul>
<li><p>Not supported:</p>
<p>Dynamic polymorphism, dynamic memory allocations (therefore no object
management using new or delete operators), static variables, function
pointers, runtime type information (RTTI), and <strong>exception handling</strong>.
No virtual member functions, and no variadic functions, are allowed to
be called from kernel code. Recursion is not allowed within kernel code.</p>
</li>
<li><p>Supported:</p>
<p>Lambdas, operator overloading, templates, classes, and static polymorphism
<a class="footnote-reference brackets" href="#dpcpp-features" id="id149" role="doc-noteref"><span class="fn-bracket">[</span>120<span class="fn-bracket">]</span></a>.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</section>
<section id="open-sources">
<h2><a class="toc-backref" href="#id227" role="doc-backlink">Open Sources</a><a class="headerlink" href="#open-sources" title="Permalink to this heading">¶</a></h2>
<ul class="simple">
<li><p><a class="reference external" href="https://registry.khronos.org/OpenGL-Refpages/">https://registry.khronos.org/OpenGL-Refpages/</a></p></li>
<li><p><a class="reference external" href="https://www.mesa3d.org">https://www.mesa3d.org</a></p></li>
<li><p><a class="reference external" href="https://www.opengl.org/sdk/">https://www.opengl.org/sdk/</a>, <a class="reference external" href="https://www.opengl.org/sdk/libs/">https://www.opengl.org/sdk/libs/</a></p></li>
</ul>
<aside class="footnote brackets" id="cg-basictheory" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id1">1</a>,<a role="doc-backlink" href="#id20">2</a>,<a role="doc-backlink" href="#id28">3</a>,<a role="doc-backlink" href="#id29">4</a>)</span>
<p><a class="reference external" href="https://www3.ntu.edu.sg/home/ehchua/programming/opengl/CG_BasicsTheory.html">https://www3.ntu.edu.sg/home/ehchua/programming/opengl/CG_BasicsTheory.html</a></p>
</aside>
<aside class="footnote brackets" id="polygon" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id2">1</a>,<a role="doc-backlink" href="#id3">2</a>)</span>
<p><a class="reference external" href="https://www.quora.com/Which-one-is-better-for-3D-modeling-Quads-or-Tris">https://www.quora.com/Which-one-is-better-for-3D-modeling-Quads-or-Tris</a></p>
</aside>
<aside class="footnote brackets" id="shading" role="note">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id4">1</a>,<a role="doc-backlink" href="#id67">2</a>)</span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Shading">https://en.wikipedia.org/wiki/Shading</a></p>
</aside>
<aside class="footnote brackets" id="texturemapping" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">4</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Texture_mapping">https://en.wikipedia.org/wiki/Texture_mapping</a></p>
</aside>
<aside class="footnote brackets" id="animation1" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">5</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.youtube.com/watch?v=f3Cr8Yx3GGA">https://www.youtube.com/watch?v=f3Cr8Yx3GGA</a></p>
</aside>
<aside class="footnote brackets" id="joglwiki" role="note">
<span class="label"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id7">1</a>,<a role="doc-backlink" href="#id16">2</a>)</span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Java_OpenGL">https://en.wikipedia.org/wiki/Java_OpenGL</a></p>
</aside>
<aside class="footnote brackets" id="dfmt" role="note">
<span class="label"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id8">1</a>,<a role="doc-backlink" href="#id9">2</a>,<a role="doc-backlink" href="#id10">3</a>)</span>
<p><a class="reference external" href="https://all3dp.com/3d-file-format-3d-files-3d-printer-3d-cad-vrml-stl-obj/">https://all3dp.com/3d-file-format-3d-files-3d-printer-3d-cad-vrml-stl-obj/</a></p>
</aside>
<aside class="footnote brackets" id="wiki-gpu" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id11">8</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Graphics_processing_unit">https://en.wikipedia.org/wiki/Graphics_processing_unit</a></p>
</aside>
<aside class="footnote brackets" id="ogl-cpu-gpu" role="note">
<span class="label"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id12">1</a>,<a role="doc-backlink" href="#id155">2</a>)</span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Vulkan">https://en.wikipedia.org/wiki/Vulkan</a></p>
</aside>
<aside class="footnote brackets" id="cpu-gpu-role" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id13">10</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://stackoverflow.com/questions/47426655/cpu-and-gpu-in-3d-game-whos-doing-what">https://stackoverflow.com/questions/47426655/cpu-and-gpu-in-3d-game-whos-doing-what</a></p>
</aside>
<aside class="footnote brackets" id="mesawiki" role="note">
<span class="label"><span class="fn-bracket">[</span>11<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id14">1</a>,<a role="doc-backlink" href="#id87">2</a>)</span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Mesa_(computer_graphics">https://en.wikipedia.org/wiki/Mesa_(computer_graphics</a>)</p>
</aside>
<aside class="footnote brackets" id="csf" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id15">12</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://developer.arm.com/documentation/102813/0107/GPU-activity">https://developer.arm.com/documentation/102813/0107/GPU-activity</a></p>
</aside>
<aside class="footnote brackets" id="libclc" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id17">13</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://libclc.llvm.org">https://libclc.llvm.org</a></p>
</aside>
<aside class="footnote brackets" id="vbo" role="note">
<span class="label"><span class="fn-bracket">[</span>14<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id18">1</a>,<a role="doc-backlink" href="#id39">2</a>)</span>
<p><a class="reference external" href="http://www.songho.ca/opengl/gl_vbo.html">http://www.songho.ca/opengl/gl_vbo.html</a></p>
</aside>
<aside class="footnote brackets" id="classorvbo" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id19">15</a><span class="fn-bracket">]</span></span>
<p>If your models will be rigid, meaning you will not change each vertex individually, and you will render many frames with the same model, you will achieve the best performance not by storing the models in your class, but in vertex buffer objects (VBOs) <a class="reference external" href="https://gamedev.stackexchange.com/questions/19560/what-is-the-best-way-to-store-meshes-or-3d-models-in-a-class">https://gamedev.stackexchange.com/questions/19560/what-is-the-best-way-to-store-meshes-or-3d-models-in-a-class</a></p>
</aside>
<aside class="footnote brackets" id="g-sync" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id21">16</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.avadirect.com/blog/frame-rate-fps-vs-hz-refresh-rate/">https://www.avadirect.com/blog/frame-rate-fps-vs-hz-refresh-rate/</a></p>
</aside>
<aside class="footnote brackets" id="additive-colors-wiki" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id22">17</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/RGB_color_model">https://en.wikipedia.org/wiki/RGB_color_model</a></p>
</aside>
<aside class="footnote brackets" id="additive-colors-ytube" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id23">18</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.youtube.com/watch?v=kEnz_3miiAc">https://www.youtube.com/watch?v=kEnz_3miiAc</a></p>
</aside>
<aside class="footnote brackets" id="additive-colors-shade" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id24">19</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.tiktok.com/&#64;tonesterpaints/video/7059565281227853102">https://www.tiktok.com/&#64;tonesterpaints/video/7059565281227853102</a></p>
</aside>
<aside class="footnote brackets" id="wiki-transformation" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id25">20</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Transformation_matrix">https://en.wikipedia.org/wiki/Transformation_matrix</a></p>
</aside>
<aside class="footnote brackets" id="wiki-rotation" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id26">21</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Rotation_matrix">https://en.wikipedia.org/wiki/Rotation_matrix</a></p>
</aside>
<aside class="footnote brackets" id="wiki-quaternion" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id27">22</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Quaternion">https://en.wikipedia.org/wiki/Quaternion</a></p>
</aside>
<aside class="footnote brackets" id="wiki-prospective-projection" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id30">23</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/3D_projection#Perspective_projection">https://en.wikipedia.org/wiki/3D_projection#Perspective_projection</a></p>
</aside>
<aside class="footnote brackets" id="cross-product-wiki" role="note">
<span class="label"><span class="fn-bracket">[</span>24<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id31">1</a>,<a role="doc-backlink" href="#id36">2</a>)</span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Cross_product">https://en.wikipedia.org/wiki/Cross_product</a></p>
</aside>
<aside class="footnote brackets" id="cross-product-2d-proof" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id32">25</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.xarg.org/book/linear-algebra/2d-perp-product/">https://www.xarg.org/book/linear-algebra/2d-perp-product/</a></p>
</aside>
<aside class="footnote brackets" id="cross-product-2d-proof2" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id33">26</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.nagwa.com/en/explainers/175169159270/">https://www.nagwa.com/en/explainers/175169159270/</a></p>
</aside>
<aside class="footnote brackets" id="cgpap" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id34">27</a><span class="fn-bracket">]</span></span>
<p>Figure 7.19 of Book: Computer graphics principles and practice 3rd edition</p>
</aside>
<aside class="footnote brackets" id="wiki-point-in-polygon" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id35">28</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Point_in_polygon">https://en.wikipedia.org/wiki/Point_in_polygon</a></p>
</aside>
<aside class="footnote brackets" id="ogl-point-outwards" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id37">29</a><span class="fn-bracket">]</span></span>
<p>Normals are used to differentiate the front- and back-face, and for other processing such as lighting. Right-hand rule (or counter-clockwise) is used in OpenGL. The normal is pointing outwards, indicating the outer surface (or front-face). <a class="reference external" href="https://www3.ntu.edu.sg/home/ehchua/programming/opengl/CG_BasicsTheory.html">https://www3.ntu.edu.sg/home/ehchua/programming/opengl/CG_BasicsTheory.html</a></p>
</aside>
<aside class="footnote brackets" id="point-in-3d-object" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id38">30</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://stackoverflow.com/questions/63557043/how-to-determine-whether-a-point-is-inside-or-outside-a-3d-model-computationally">https://stackoverflow.com/questions/63557043/how-to-determine-whether-a-point-is-inside-or-outside-a-3d-model-computationally</a></p>
</aside>
<aside class="footnote brackets" id="ogl-frontface" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id40">31</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFrontFace.xhtml">https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFrontFace.xhtml</a></p>
</aside>
<aside class="footnote brackets" id="scene-graph-wiki" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id41">32</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Scene_graph">https://en.wikipedia.org/wiki/Scene_graph</a></p>
</aside>
<aside class="footnote brackets" id="drendering-wiki" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id54">33</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/3D_rendering">https://en.wikipedia.org/wiki/3D_rendering</a></p>
</aside>
<aside class="footnote brackets" id="rendering" role="note">
<span class="label"><span class="fn-bracket">[</span>34<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id55">1</a>,<a role="doc-backlink" href="#id58">2</a>)</span>
<p><a class="reference external" href="https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview">https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview</a></p>
</aside>
<aside class="footnote brackets" id="ts-tu30" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id60">35</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://ogldev.org/www/tutorial30/tutorial30.html">https://ogldev.org/www/tutorial30/tutorial30.html</a></p>
</aside>
<aside class="footnote brackets" id="danimation" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id62">36</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://tw.video.search.yahoo.com/search/video?fr=yfp-search-sb&amp;p=2d+animation#id=12&amp;vid=46be09edf57b960ae79e9cd077eea1ea&amp;action=view">https://tw.video.search.yahoo.com/search/video?fr=yfp-search-sb&amp;p=2d+animation#id=12&amp;vid=46be09edf57b960ae79e9cd077eea1ea&amp;action=view</a></p>
</aside>
<aside class="footnote brackets" id="redbook" role="note">
<span class="label"><span class="fn-bracket">[</span>37<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id42">1</a>,<a role="doc-backlink" href="#id56">2</a>,<a role="doc-backlink" href="#id57">3</a>,<a role="doc-backlink" href="#id59">4</a>,<a role="doc-backlink" href="#id61">5</a>,<a role="doc-backlink" href="#id150">6</a>,<a role="doc-backlink" href="#id151">7</a>,<a role="doc-backlink" href="#id152">8</a>,<a role="doc-backlink" href="#id153">9</a>)</span>
<p><a class="reference external" href="http://www.opengl-redbook.com">http://www.opengl-redbook.com</a></p>
</aside>
<aside class="footnote brackets" id="redbook-examples" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id43">38</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://github.com/openglredbook/examples">https://github.com/openglredbook/examples</a></p>
</aside>
<aside class="footnote brackets" id="vao-vbo-binding" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id44">39</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://stackoverflow.com/questions/21652546/what-is-the-role-of-glbindvertexarrays-vs-glbindbuffer-and-what-is-their-relatio">https://stackoverflow.com/questions/21652546/what-is-the-role-of-glbindvertexarrays-vs-glbindbuffer-and-what-is-their-relatio</a></p>
</aside>
<aside class="footnote brackets" id="ogl-vavb" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id45">40</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindVertexBuffer.xhtml">https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindVertexBuffer.xhtml</a></p>
</aside>
<aside class="footnote brackets" id="ogl-bluebook-p152" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id46">41</a><span class="fn-bracket">]</span></span>
<p>Page 152 of Blue book: OpenGL SuperBible 7th Edition.</p>
</aside>
<aside class="footnote brackets" id="buffers-redbook" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id105">42</a><span class="fn-bracket">]</span></span>
<p>Page 155 - 185 of book “OpenGL Programming Guide 9th Edition” <a class="footnote-reference brackets" href="#redbook" id="id150" role="doc-noteref"><span class="fn-bracket">[</span>37<span class="fn-bracket">]</span></a>.</p>
</aside>
<aside class="footnote brackets" id="monstar-lab-opengl" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id52">43</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://engineering.monstar-lab.com/en/post/2022/03/01/Introduction-To-GPUs-With-OpenGL/">https://engineering.monstar-lab.com/en/post/2022/03/01/Introduction-To-GPUs-With-OpenGL/</a></p>
</aside>
<aside class="footnote brackets" id="glumpy-shaders" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id53">44</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://glumpy.github.io/modern-gl.html">https://glumpy.github.io/modern-gl.html</a></p>
</aside>
<aside class="footnote brackets" id="ogl-qualifier" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id48">45</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.khronos.org/opengl/wiki/Type_Qualifier_(GLSL">https://www.khronos.org/opengl/wiki/Type_Qualifier_(GLSL</a>)</p>
</aside>
<aside class="footnote brackets" id="ogl-qualifier-deprecate" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id49">46</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.khronos.org/opengl/wiki/Type_Qualifier_(GLSL">https://www.khronos.org/opengl/wiki/Type_Qualifier_(GLSL</a>)#Removed_qualifiers</p>
</aside>
<aside class="footnote brackets" id="github-attr-varying-depr" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id50">47</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://github.com/vispy/vispy/issues/242">https://github.com/vispy/vispy/issues/242</a></p>
</aside>
<aside class="footnote brackets" id="ogl-layout-q" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id51">48</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.khronos.org/opengl/wiki/Layout_Qualifier_(GLSL">https://www.khronos.org/opengl/wiki/Layout_Qualifier_(GLSL</a>)</p>
</aside>
<aside class="footnote brackets" id="fragmentshader-reason" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id63">49</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://community.khronos.org/t/pixel-vs-fragment-shader/52838">https://community.khronos.org/t/pixel-vs-fragment-shader/52838</a></p>
</aside>
<aside class="footnote brackets" id="shaderswiki" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id64">50</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.m.wikipedia.org/wiki/OpenGL_Shading_Language">https://en.m.wikipedia.org/wiki/OpenGL_Shading_Language</a></p>
</aside>
<aside class="footnote brackets" id="shadersex" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id65">51</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://learnopengl.com/Getting-started/Shaders">https://learnopengl.com/Getting-started/Shaders</a></p>
</aside>
<aside class="footnote brackets" id="glsleffect" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id66">52</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.youtube.com/watch?v=LyoSSoYyfVU">https://www.youtube.com/watch?v=LyoSSoYyfVU</a> at 5:25 from beginning: combine different textures.</p>
</aside>
<aside class="footnote brackets" id="smoothshadingex" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id68">53</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://github.com/ruange/Gouraud-Shading-and-Phong-Shading">https://github.com/ruange/Gouraud-Shading-and-Phong-Shading</a></p>
</aside>
<aside class="footnote brackets" id="on-line" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id69">54</a><span class="fn-bracket">]</span></span>
<p>Compiler and interpreter: (<a class="reference external" href="https://www.guru99.com/difference-compiler-vs-interpreter.html">https://www.guru99.com/difference-compiler-vs-interpreter.html</a>). AOT compiler: compiles before running; JIT compiler: compiles while running; interpreter: runs (reference <a class="reference external" href="https://softwareengineering.stackexchange.com/questions/246094/understanding-the-differences-traditional-interpreter-jit-compiler-jit-interp">https://softwareengineering.stackexchange.com/questions/246094/understanding-the-differences-traditional-interpreter-jit-compiler-jit-interp</a>). Both online and offline compiler are AOT compiler. User call OpenGL api to run their program and the driver call call online compiler to compile user’s shaders without user compiling their shader before running their program. When user run a CPU program of C language, he must compile C program before running the program. This is offline compiler.</p>
</aside>
<aside class="footnote brackets" id="onlinecompile" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id70">55</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://community.khronos.org/t/offline-glsl-compilation/61784">https://community.khronos.org/t/offline-glsl-compilation/61784</a></p>
</aside>
<aside class="footnote brackets" id="openglspec" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id71">56</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.khronos.org/registry/OpenGL-Refpages/">https://www.khronos.org/registry/OpenGL-Refpages/</a></p>
</aside>
<aside class="footnote brackets" id="opengleswiki" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id72">57</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/OpenGL_ES">https://en.wikipedia.org/wiki/OpenGL_ES</a></p>
</aside>
<aside class="footnote brackets" id="textureapi" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id73">58</a><span class="fn-bracket">]</span></span>
<p>All the api listed in section 8.9 of <a class="reference external" href="https://www.khronos.org/registry/OpenGL/specs/es/3.2/GLSL_ES_Specification_3.20.html#texture-functions">https://www.khronos.org/registry/OpenGL/specs/es/3.2/GLSL_ES_Specification_3.20.html#texture-functions</a></p>
</aside>
<aside class="footnote brackets" id="intrinsiccpu0" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id74">59</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://jonathan2251.github.io/lbd/funccall.html#add-specific-backend-intrinsic-function">http://jonathan2251.github.io/lbd/funccall.html#add-specific-backend-intrinsic-function</a></p>
</aside>
<aside class="footnote brackets" id="textureobject" role="note">
<span class="label"><span class="fn-bracket">[</span>60<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id75">1</a>,<a role="doc-backlink" href="#id76">2</a>,<a role="doc-backlink" href="#id77">3</a>,<a role="doc-backlink" href="#id78">4</a>)</span>
<p><a class="reference external" href="http://ogldev.atspace.co.uk/www/tutorial16/tutorial16.html">http://ogldev.atspace.co.uk/www/tutorial16/tutorial16.html</a></p>
</aside>
<aside class="footnote brackets" id="tpu" role="note">
<span class="label"><span class="fn-bracket">[</span>61<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id79">1</a>,<a role="doc-backlink" href="#id80">2</a>,<a role="doc-backlink" href="#id85">3</a>)</span>
<p><a class="reference external" href="http://math.hws.edu/graphicsbook/c6/s4.html">http://math.hws.edu/graphicsbook/c6/s4.html</a></p>
</aside>
<aside class="footnote brackets" id="metadata" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id82">62</a><span class="fn-bracket">]</span></span>
<p>This can be done by llvm metadata. <a class="reference external" href="http://llvm.org/docs/LangRef.html#namedmetadatastructure">http://llvm.org/docs/LangRef.html#namedmetadatastructure</a> <a class="reference external" href="http://llvm.org/docs/LangRef.html#metadata">http://llvm.org/docs/LangRef.html#metadata</a></p>
</aside>
<aside class="footnote brackets" id="ptxtex" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id84">63</a><span class="fn-bracket">]</span></span>
<p>page 84: tex instruction, p24: texture memory <a class="reference external" href="https://www.nvidia.com/content/CUDA-ptx_isa_1.4.pdf">https://www.nvidia.com/content/CUDA-ptx_isa_1.4.pdf</a></p>
</aside>
<aside class="footnote brackets" id="samplervar" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id81">64</a><span class="fn-bracket">]</span></span>
<p>The type of ‘sampler uniform variable’ called “sampler variables”. <a class="reference external" href="http://math.hws.edu/graphicsbook/c6/s4.html">http://math.hws.edu/graphicsbook/c6/s4.html</a></p>
</aside>
<aside class="footnote brackets" id="descriptorreg" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id83">65</a><span class="fn-bracket">]</span></span>
<p>When performing a texture fetch, the addresses to read pixel data from are computed by reading the GPRs that hold the texture descriptor and the GPRs that hold the texture coordinates. It’s mostly just general purpose memory fetching. <a class="reference external" href="https://www.gamedev.net/forums/topic/681503-texture-units/">https://www.gamedev.net/forums/topic/681503-texture-units/</a></p>
</aside>
<aside class="footnote brackets" id="texturewrapper" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id86">66</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://learnopengl.com/Getting-started/Textures">https://learnopengl.com/Getting-started/Textures</a></p>
</aside>
<aside class="footnote brackets" id="mesa" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id88">67</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.mesa3d.org/">https://www.mesa3d.org/</a></p>
</aside>
<aside class="footnote brackets" id="simt-wiki" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id90">68</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Single_instruction,_multiple_threads">https://en.wikipedia.org/wiki/Single_instruction,_multiple_threads</a></p>
</aside>
<aside class="footnote brackets" id="quantitative-grid" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id97">69</a><span class="fn-bracket">]</span></span>
<p>Book Figure 4.13 of Computer Architecture: A Quantitative Approach 5th edition (The
Morgan Kaufmann Series in Computer Architecture and Design)</p>
</aside>
<aside class="footnote brackets" id="cuda-sm" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id92">70</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.tomshardware.com/reviews/geforce-gtx-480,2585-18.html">https://www.tomshardware.com/reviews/geforce-gtx-480,2585-18.html</a></p>
</aside>
<aside class="footnote brackets" id="chime" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id93">71</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.cs.cmu.edu/afs/cs/academic/class/15418-s12/www/lectures/02_multicore.pdf">https://www.cs.cmu.edu/afs/cs/academic/class/15418-s12/www/lectures/02_multicore.pdf</a></p>
</aside>
<aside class="footnote brackets" id="quantitative-simd-processors" role="note">
<span class="label"><span class="fn-bracket">[</span>72<span class="fn-bracket">]</span></span>
<p>Book Figure 4.15 of Computer Architecture: A Quantitative Approach 5th edition (The
Morgan Kaufmann Series in Computer Architecture and Design)</p>
</aside>
<aside class="footnote brackets" id="quantitative-threads-lanes" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id91">73</a><span class="fn-bracket">]</span></span>
<p>The SIMD Thread Scheduler includes a scoreboard that lets it know which threads of SIMD instructions are ready to run, and then it sends them off to a dispatch unit to be run on the multithreaded SIMD Processor. It is identical to a hardware thread scheduler in a traditional multithreaded processor (see Chapter 3), just that it is scheduling threads of SIMD instructions. Thus, GPU hardware has two levels of hardware schedulers: (1) the Thread Block Scheduler that assigns Thread Blocks (bodies of vectorized loops) to multi- threaded SIMD Processors, which ensures that thread blocks are assigned to the processors whose local memories have the corresponding data, and (2) the SIMD Thread Scheduler within a SIMD Processor, which schedules when threads of SIMD instructions should run.
Book Figure 4.14 of Computer Architecture: A Quantitative Approach 5th edition (The
Morgan Kaufmann Series in Computer Architecture and Design)</p>
</aside>
<aside class="footnote brackets" id="quantitative-gpu-sm" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id94">74</a><span class="fn-bracket">]</span></span>
<p>Book Figure 4.20 of Computer Architecture: A Quantitative Approach 5th edition (The
Morgan Kaufmann Series in Computer Architecture and Design)</p>
</aside>
<aside class="footnote brackets" id="quantitative-gpu-mem" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id98">75</a><span class="fn-bracket">]</span></span>
<p>Book Figure 4.17 of Computer Architecture: A Quantitative Approach 5th edition (The
Morgan Kaufmann Series in Computer Architecture and Design)</p>
</aside>
<aside class="footnote brackets" id="redbook-p155" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id106">76</a><span class="fn-bracket">]</span></span>
<p>Page 155 of book “OpenGL Programming Guide 9th Edition” <a class="footnote-reference brackets" href="#redbook" id="id151" role="doc-noteref"><span class="fn-bracket">[</span>37<span class="fn-bracket">]</span></a>.</p>
</aside>
<aside class="footnote brackets" id="redbook-p156" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id107">77</a><span class="fn-bracket">]</span></span>
<p>Page 156 of book “OpenGL Programming Guide 9th Edition” <a class="footnote-reference brackets" href="#redbook" id="id152" role="doc-noteref"><span class="fn-bracket">[</span>37<span class="fn-bracket">]</span></a>.</p>
</aside>
<aside class="footnote brackets" id="redbook-colorbuffer" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id47">78</a><span class="fn-bracket">]</span></span>
<p>Section of Color Buffer, page 222-223 of book “OpenGL Programming Guide 9th Edition” <a class="footnote-reference brackets" href="#redbook" id="id153" role="doc-noteref"><span class="fn-bracket">[</span>37<span class="fn-bracket">]</span></a>.</p>
</aside>
<aside class="footnote brackets" id="z-buffer-wiki" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id108">79</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Z-buffering">https://en.wikipedia.org/wiki/Z-buffering</a></p>
</aside>
<aside class="footnote brackets" id="depthstencils-ogl" role="note">
<span class="label"><span class="fn-bracket">[</span>80<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id109">1</a>,<a role="doc-backlink" href="#id111">2</a>)</span>
<p><a class="reference external" href="https://open.gl/depthstencils">https://open.gl/depthstencils</a></p>
</aside>
<aside class="footnote brackets" id="stencils-buffer-wiki" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id110">81</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Stencil_buffer">https://en.wikipedia.org/wiki/Stencil_buffer</a></p>
</aside>
<aside class="footnote brackets" id="framebuffers-ogl" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id112">82</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://open.gl/framebuffers">https://open.gl/framebuffers</a></p>
</aside>
<aside class="footnote brackets" id="gpgpuwiki" role="note">
<span class="label"><span class="fn-bracket">[</span>83<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id113">1</a>,<a role="doc-backlink" href="#id119">2</a>,<a role="doc-backlink" href="#id122">3</a>)</span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/General-purpose_computing_on_graphics_processing_units">https://en.wikipedia.org/wiki/General-purpose_computing_on_graphics_processing_units</a></p>
</aside>
<aside class="footnote brackets" id="quantitative-gpu-terms" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id89">84</a><span class="fn-bracket">]</span></span>
<p>Book Figure 4.12 of Computer Architecture: A Quantitative Approach 5th edition (The
Morgan Kaufmann Series in Computer Architecture and Design)</p>
</aside>
<aside class="footnote brackets" id="quantitative-gpu-l1" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id95">85</a><span class="fn-bracket">]</span></span>
<p>Page 306 of Computer Architecture: A Quantitative Approach 5th edition (The
Morgan Kaufmann Series in Computer Architecture and Design)</p>
</aside>
<aside class="footnote brackets" id="cudaex" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id116">86</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://devblogs.nvidia.com/easy-introduction-cuda-c-and-c/">https://devblogs.nvidia.com/easy-introduction-cuda-c-and-c/</a></p>
</aside>
<aside class="footnote brackets" id="quantitative-gpu-threadblock" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id99">87</a><span class="fn-bracket">]</span></span>
<p>search these words from section 4.4 of A Quantitative Approach 5th edition (The
Morgan Kaufmann Series in Computer Architecture and Design)</p>
</aside>
<aside class="footnote brackets" id="var" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id102">88</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://developer.nvidia.com/vrworks/graphics/variablerateshading">https://developer.nvidia.com/vrworks/graphics/variablerateshading</a></p>
</aside>
<aside class="footnote brackets" id="quantitative-gpu-gs" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id103">89</a><span class="fn-bracket">]</span></span>
<p>Page 280 of Computer Architecture: A Quantitative Approach 5th edition (The
Morgan Kaufmann Series in Computer Architecture and Design)</p>
</aside>
<aside class="footnote brackets" id="quantitative-gpu-ac" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id104">90</a><span class="fn-bracket">]</span></span>
<p>Page 300 of Computer Architecture: A Quantitative Approach 5th edition (The
Morgan Kaufmann Series in Computer Architecture and Design)</p>
</aside>
<aside class="footnote brackets" id="wiki-tbcp" role="note">
<span class="label"><span class="fn-bracket">[</span>91<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id96">1</a>,<a role="doc-backlink" href="#id100">2</a>)</span>
<p><cite>https://en.wikipedia.org/wiki/Thread_block_(CUDA_programming)</cite></p>
</aside>
<aside class="footnote brackets" id="quantitative-gpu-warp" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id101">92</a><span class="fn-bracket">]</span></span>
<p>Book Figure 4.14 and 4.24 of Computer Architecture: A Quantitative Approach 5th edition (The
Morgan Kaufmann Series in Computer Architecture and Design)</p>
</aside>
<aside class="footnote brackets" id="volta" role="note">
<span class="label"><span class="fn-bracket">[</span>93<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id125">1</a>,<a role="doc-backlink" href="#id126">2</a>,<a role="doc-backlink" href="#id127">3</a>,<a role="doc-backlink" href="#id128">4</a>)</span>
<p>See the same Figures from <a class="reference external" href="https://images.nvidia.com/content/volta-architecture/pdf/volta-architecture-whitepaper.pdf">https://images.nvidia.com/content/volta-architecture/pdf/volta-architecture-whitepaper.pdf</a></p>
</aside>
<aside class="footnote brackets" id="vmr" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id114">94</a><span class="fn-bracket">]</span></span>
<p>subsection Vector Mask Registers: Handling IF Statements in Vector Loops of Computer Architecture: A Quantitative Approach 5th edition (The
Morgan Kaufmann Series in Computer Architecture and Design)</p>
</aside>
<aside class="footnote brackets" id="quantitative-gpu-asm-daxpy" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id115">95</a><span class="fn-bracket">]</span></span>
<p>Code written by refering page 208 - 302 of Computer Architecture: A Quantitative Approach 5th edition (The
Morgan Kaufmann Series in Computer Architecture and Design)</p>
</aside>
<aside class="footnote brackets" id="gpu-latency-tolerant" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id117">96</a><span class="fn-bracket">]</span></span>
<p>From section 2.3.2 of book “Heterogeneous Computing with OpenCL 2.0” 3rd edition. <a class="reference external" href="https://dahlan.unimal.ac.id/files/ebooks2/2015%203rd%20Heterogeneous%20Computing%20with%20OpenCL%202.0.pdf">https://dahlan.unimal.ac.id/files/ebooks2/2015%203rd%20Heterogeneous%20Computing%20with%20OpenCL%202.0.pdf</a> as follows, “These tasks and the pixels they process are highly parallel, which gives a substan- tial amount of independent work to process for devices with multiple cores and highly latency-tolerant multithreading.”</p>
</aside>
<aside class="footnote brackets" id="quantitative-gpu-sparse-matrix" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id118">97</a><span class="fn-bracket">]</span></span>
<p>Reference “Gather-Scatter: Handling Sparse Matrices in Vector Architectures”: section 4.2 Vector Architecture of A Quantitative Approach 5th edition (The
Morgan Kaufmann Series in Computer Architecture and Design)</p>
</aside>
<aside class="footnote brackets" id="shadingl1" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id120">98</a><span class="fn-bracket">]</span></span>
<p>The whole chip shares a single L2 cache, but the different units will have individual L1 caches. <a class="reference external" href="https://computergraphics.stackexchange.com/questions/355/how-does-texture-cache-work-considering-multiple-shader-units">https://computergraphics.stackexchange.com/questions/355/how-does-texture-cache-work-considering-multiple-shader-units</a></p>
</aside>
<aside class="footnote brackets" id="mpeg4speedup" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id121">99</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.manchestervideo.com/2016/06/11/speed-h-264-encoding-budget-gpu/">https://www.manchestervideo.com/2016/06/11/speed-h-264-encoding-budget-gpu/</a></p>
</aside>
<aside class="footnote brackets" id="gpuspeedup" role="note">
<span class="label"><span class="fn-bracket">[</span>100<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id123">1</a>,<a role="doc-backlink" href="#id124">2</a>)</span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Graphics_processing_unit">https://en.wikipedia.org/wiki/Graphics_processing_unit</a></p>
</aside>
<aside class="footnote brackets" id="diff-compute-shader-opencl" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id130">101</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://stackoverflow.com/questions/15868498/what-is-the-difference-between-opencl-and-opengls-compute-shader">https://stackoverflow.com/questions/15868498/what-is-the-difference-between-opencl-and-opengls-compute-shader</a></p>
</aside>
<aside class="footnote brackets" id="id154" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id129">102</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.khronos.org/blog/offline-compilation-of-opencl-kernels-into-spir-v-using-open-source-tooling">https://www.khronos.org/blog/offline-compilation-of-opencl-kernels-into-spir-v-using-open-source-tooling</a></p>
</aside>
<aside class="footnote brackets" id="vulkanapiwiki" role="note">
<span class="label"><span class="fn-bracket">[</span>103<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id131">1</a>,<a role="doc-backlink" href="#id135">2</a>)</span>
<p>Vulkan offers lower overhead, more direct control over the GPU, and lower CPU usage… By allowing shader pre-compilation, application initialization speed is improved… A Vulkan driver only needs to do GPU specific optimization and code generation, resulting in easier driver maintenance… <a class="footnote-reference brackets" href="#ogl-cpu-gpu" id="id155" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a> <a class="reference external" href="https://en.wikipedia.org/wiki/Vulkan#OpenGL_vs._Vulkan">https://en.wikipedia.org/wiki/Vulkan#OpenGL_vs._Vulkan</a></p>
</aside>
<aside class="footnote brackets" id="vulkanex" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id132">104</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://github.com/SaschaWillems/Vulkan/blob/master/examples/triangle/triangle.cpp">https://github.com/SaschaWillems/Vulkan/blob/master/examples/triangle/triangle.cpp</a></p>
</aside>
<aside class="footnote brackets" id="spirvtoolchain" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id133">105</a><span class="fn-bracket">]</span></span>
<p>glslangValidator is the tool used to compile GLSL shaders into SPIR-V, Vulkan’s shader format. <a class="reference external" href="https://vulkan.lunarg.com/doc/sdk/latest/windows/spirv_toolchain.html">https://vulkan.lunarg.com/doc/sdk/latest/windows/spirv_toolchain.html</a></p>
</aside>
<aside class="footnote brackets" id="spirvwiki" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id134">106</a><span class="fn-bracket">]</span></span>
<p>SPIR 2.0: LLVM IR version 3.4. SPIR-V 1.X: 100% Khronos defined Round-trip lossless conversion to llvm.  <a class="reference external" href="https://en.wikipedia.org/wiki/Standard_Portable_Intermediate_Representation">https://en.wikipedia.org/wiki/Standard_Portable_Intermediate_Representation</a></p>
</aside>
<aside class="footnote brackets" id="opencl" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id136">107</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.khronos.org/opencl/">https://www.khronos.org/opencl/</a></p>
</aside>
<aside class="footnote brackets" id="computekernelwiki" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id137">108</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Compute_kernel">https://en.wikipedia.org/wiki/Compute_kernel</a></p>
</aside>
<aside class="footnote brackets" id="openclexfft" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id138">109</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/OpenCL">https://en.wikipedia.org/wiki/OpenCL</a></p>
</aside>
<aside class="footnote brackets" id="opencl-wiki-supported-lang" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id139">110</a><span class="fn-bracket">]</span></span>
<p>The OpenCL standard defines host APIs for C and C++; third-party APIs exist for other programming languages and platforms such as Python,[15] Java, Perl[15] and .NET.[11]:15 <a class="reference external" href="https://en.wikipedia.org/wiki/OpenCL">https://en.wikipedia.org/wiki/OpenCL</a></p>
</aside>
<aside class="footnote brackets" id="vulkan-subgroup" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id140">111</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.khronos.org/blog/vulkan-subgroup-tutorial">https://www.khronos.org/blog/vulkan-subgroup-tutorial</a></p>
</aside>
<aside class="footnote brackets" id="llvm-uniformity" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id141">112</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://llvm.org/docs/ConvergenceAndUniformity.html">https://llvm.org/docs/ConvergenceAndUniformity.html</a></p>
</aside>
<aside class="footnote brackets" id="paper-graph-on-opencl" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id142">113</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://easychair.org/publications/preprint/GjhX">https://easychair.org/publications/preprint/GjhX</a></p>
</aside>
<aside class="footnote brackets" id="cuda-graph-blog" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id143">114</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://developer.nvidia.com/blog/cuda-graphs/">https://developer.nvidia.com/blog/cuda-graphs/</a></p>
</aside>
<aside class="footnote brackets" id="cuda-graph-pytorch" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id144">115</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://pytorch.org/blog/accelerating-pytorch-with-cuda-graphs/">https://pytorch.org/blog/accelerating-pytorch-with-cuda-graphs/</a></p>
</aside>
<aside class="footnote brackets" id="sycl" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id145">116</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.khronos.org/sycl/">https://www.khronos.org/sycl/</a></p>
</aside>
<aside class="footnote brackets" id="sycl-cuda" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id146">117</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://github.com/codeplaysoftware/sycl-for-cuda/blob/cuda/sycl/doc/GetStartedWithSYCLCompiler.md">https://github.com/codeplaysoftware/sycl-for-cuda/blob/cuda/sycl/doc/GetStartedWithSYCLCompiler.md</a></p>
</aside>
<aside class="footnote brackets" id="dpcpp" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id147">118</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.intel.com/content/www/us/en/developer/tools/oneapi/dpc-compiler.html#gs.cxolyy">https://www.intel.com/content/www/us/en/developer/tools/oneapi/dpc-compiler.html#gs.cxolyy</a></p>
</aside>
<aside class="footnote brackets" id="dpcpp-book" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id148">119</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://link.springer.com/book/10.1007/978-1-4842-5574-2">https://link.springer.com/book/10.1007/978-1-4842-5574-2</a></p>
</aside>
<aside class="footnote brackets" id="dpcpp-features" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id149">120</a><span class="fn-bracket">]</span></span>
<p>Page 14 of DPC++ book.</p>
</aside>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="verilog.html">Verify backend on Verilog simulator</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="install.html">Appendix A: Getting Started: Installing LLVM and the Cpu0 example code</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Chen Chung-Shu.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.0.2.
    </div>
  </body>
</html>