
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>C++ support &#8212; Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Verify backend on Verilog simulator" href="verilog.html" />
    <link rel="prev" title="Assembler" href="asm.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</span></a></h1>
        <h2 class="heading"><span>C++ support</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="asm.html">Assembler</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="verilog.html">Verify backend on Verilog simulator</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="c-support">
<span id="sec-c"></span><h1>C++ support<a class="headerlink" href="#c-support" title="Permalink to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#exception-handling" id="id26">Exception Handling</a></p></li>
<li><p><a class="reference internal" href="#thread-variable" id="id27">Thread variable</a></p></li>
<li><p><a class="reference internal" href="#c-memory-order" id="id28">C++ Memory Order </a></p>
<ul>
<li><p><a class="reference internal" href="#background" id="id29">Background</a></p>
<ul>
<li><p><a class="reference internal" href="#the-problem-before-c-11" id="id30">The Problem Before C++11</a></p></li>
<li><p><a class="reference internal" href="#c-11-memory-model-solution" id="id31">C++11 Memory Model Solution</a></p></li>
<li><p><a class="reference internal" href="#key-memory-order-introductions" id="id32">Key Memory Order Introductions</a></p></li>
<li><p><a class="reference internal" href="#conclusion" id="id33">Conclusion</a></p></li>
<li><p><a class="reference internal" href="#example-usage-in-code" id="id34">Example Usage in Code</a></p></li>
<li><p><a class="reference internal" href="#id10" id="id35">Conclusion</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#example-code-for-producer-consumer" id="id36">Example code for producer-consumer</a></p></li>
<li><p><a class="reference internal" href="#comparison-of-producer-consumer-with-busy-waiting" id="id37">Comparison of Producer-Consumer with Busy Waiting</a></p>
<ul>
<li><p><a class="reference internal" href="#linux-api-with-busy-waiting-using-std-atomic" id="id38">1. Linux API with Busy Waiting (Using <cite>std::atomic</cite>)</a></p></li>
<li><p><a class="reference internal" href="#mips-atomic-and-sync-instructions-ll-sc-sync" id="id39">2. MIPS Atomic and Sync Instructions (<cite>ll</cite>, <cite>sc</cite>, <cite>sync</cite>)</a></p></li>
<li><p><a class="reference internal" href="#c-memory-order-lock-free-busy-waiting" id="id40">3. C++ Memory Order (Lock-Free, Busy-Waiting)</a></p></li>
<li><p><a class="reference internal" href="#comparison-table" id="id41">Comparison Table</a></p></li>
<li><p><a class="reference internal" href="#id11" id="id42">Conclusion</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#cpu0-implementation-for-memory-order" id="id43">Cpu0 implementation for memory-order</a></p></li>
</ul>
</nav>
<p>This chapter supports some C++ compiler features.</p>
<section id="exception-handling">
<h2><a class="toc-backref" href="#id26" role="doc-backlink">Exception Handling</a><a class="headerlink" href="#exception-handling" title="Permalink to this heading">¶</a></h2>
<p>Chapter11_2 can be built and run using the C++ polymorphism example code in
<code class="docutils literal notranslate"><span class="pre">ch12_inherit.cpp</span></code> as follows:</p>
<p class="rubric">lbdex/input/ch12_inherit.cpp</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">...</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">CPolygon</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// _ZTVN10__cxxabiv117__class_type_infoE for parent class</span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="cp">#ifdef COUT_TEST</span>
<span class="w"> </span><span class="c1">// generate IR nvoke, landing, resume and unreachable on iMac</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">area</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="cp">#else</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">area</span><span class="p">());</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="p">};</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
</pre></div>
</div>
<p>If you use <code class="docutils literal notranslate"><span class="pre">cout</span></code> instead of <code class="docutils literal notranslate"><span class="pre">printf</span></code> in <code class="docutils literal notranslate"><span class="pre">ch12_inherit.cpp</span></code>, it will not
generate exception handling IR on Linux. However, it will generate exception
handling IRs such as <code class="docutils literal notranslate"><span class="pre">invoke</span></code>, <code class="docutils literal notranslate"><span class="pre">landingpad</span></code>, <code class="docutils literal notranslate"><span class="pre">resume</span></code>, and
<code class="docutils literal notranslate"><span class="pre">unreachable</span></code> on iMac.</p>
<p>The example code <code class="docutils literal notranslate"><span class="pre">ch12_eh.cpp</span></code>, which includes <strong>try</strong> and <strong>catch</strong>
exception handling, will generate these exception-related IRs on both iMac
and Linux.</p>
<p class="rubric">lbdex/input/ch12_eh.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Ex1</span> <span class="p">{};</span>
<span class="n">void</span> <span class="n">throw_exception</span><span class="p">(</span><span class="nb">int</span> <span class="n">a</span><span class="p">,</span> <span class="nb">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Ex1</span> <span class="n">ex1</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">throw</span> <span class="n">ex1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">test_try_catch</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="n">throw_exception</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">catch</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>clang -c ch12_eh.cpp -emit-llvm
<span class="go">-o ch12_eh.bc</span>
<span class="gp">JonathantekiiMac:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llvm-dis ch12_eh.bc -o -</span>
</pre></div>
</div>
<p class="rubric">../lbdex/output/ch12_eh.ll</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="p">...</span><span class="w"></span>
<span class="k">define</span><span class="w"> </span><span class="k">dso_local</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@_Z14test_try_catchv</span><span class="p">()</span><span class="w"> </span><span class="vg">#0</span><span class="w"> </span><span class="k">personality</span><span class="w"> </span><span class="kt">i8</span><span class="p">*</span><span class="w"> </span><span class="k">bitcast</span><span class="w"> </span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="p">(...</span><span class="w"></span>
<span class="p">)*</span><span class="w"> </span><span class="vg">@__gxx_personality_v0</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="kt">i8</span><span class="p">*)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="nl">entry:</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="k">invoke</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@_Z15throw_exceptionii</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="k">signext</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="k">signext</span><span class="w"> </span><span class="m">1</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">to</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%invoke.cont</span><span class="w"> </span><span class="k">unwind</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%lpad</span><span class="w"></span>

<span class="nl">invoke.cont:</span><span class="w">                                      </span><span class="c">; preds = %entry</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%try.cont</span><span class="w"></span>

<span class="nl">lpad:</span><span class="w">                                             </span><span class="c">; preds = %entry</span>
<span class="w">  </span><span class="nv nv-Anonymous">%0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">landingpad</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">i8</span><span class="p">*,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">          </span><span class="k">catch</span><span class="w"> </span><span class="kt">i8</span><span class="p">*</span><span class="w"> </span><span class="k">null</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llc -march=cpu0 -relocation-model=static -filetype=asm ch12_eh.bc -o -</span>
<span class="go">        .section .mdebug.abi32</span>
<span class="go">        .previous</span>
<span class="go">        .file &quot;ch12_eh.bc&quot;</span>
<span class="go">llc: /Users/Jonathan/llvm/test/llvm/lib/CodeGen/LiveVariables.cpp:133: void llvm::</span>
<span class="go">LiveVariables::HandleVirtRegUse(unsigned int, llvm::MachineBasicBlock *, llvm</span>
<span class="go">::MachineInstr *): Assertion `MRI-&gt;getVRegDef(reg) &amp;&amp; &quot;Register use before</span>
<span class="go">def!&quot;&#39; failed.</span>
</pre></div>
</div>
<p>A description of the C++ exception table formats can be found here
<a class="footnote-reference brackets" href="#itanium-exception" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>.</p>
<p>For details about the LLVM IR used in exception handling, please refer to
<a class="footnote-reference brackets" href="#exception" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>.</p>
<p>Chapter12_1 supports the LLVM IRs that correspond to the C++ <strong>try</strong> and
<strong>catch</strong> keywords. It can compile <code class="docutils literal notranslate"><span class="pre">ch12_eh.bc</span></code> as follows:</p>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0ISelLowering.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="o">///</span> <span class="n">If</span> <span class="n">a</span> <span class="n">physical</span> <span class="n">register</span><span class="p">,</span> <span class="n">this</span> <span class="n">returns</span> <span class="n">the</span> <span class="n">register</span> <span class="n">that</span> <span class="n">receives</span> <span class="n">the</span>
    <span class="o">///</span> <span class="n">exception</span> <span class="n">address</span> <span class="n">on</span> <span class="n">entry</span> <span class="n">to</span> <span class="n">an</span> <span class="n">EH</span> <span class="n">pad</span><span class="o">.</span>
    <span class="n">Register</span>
    <span class="n">getExceptionPointerRegister</span><span class="p">(</span><span class="n">const</span> <span class="n">Constant</span> <span class="o">*</span><span class="n">PersonalityFn</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">A0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="o">///</span> <span class="n">If</span> <span class="n">a</span> <span class="n">physical</span> <span class="n">register</span><span class="p">,</span> <span class="n">this</span> <span class="n">returns</span> <span class="n">the</span> <span class="n">register</span> <span class="n">that</span> <span class="n">receives</span> <span class="n">the</span>
    <span class="o">///</span> <span class="n">exception</span> <span class="n">typeid</span> <span class="n">on</span> <span class="n">entry</span> <span class="n">to</span> <span class="n">a</span> <span class="n">landing</span> <span class="n">pad</span><span class="o">.</span>
    <span class="n">Register</span>
    <span class="n">getExceptionSelectorRegister</span><span class="p">(</span><span class="n">const</span> <span class="n">Constant</span> <span class="o">*</span><span class="n">PersonalityFn</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">A1</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llc -march=cpu0 -relocation-model=static -filetype=asm ch12_eh.bc -o -</span>
</pre></div>
</div>
<p class="rubric">../lbdex/output/ch12_eh.cpu0.s</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>  .type  _Z14test_try_catchv,@function
  .ent  _Z14test_try_catchv             # @_Z14test_try_catchv
_Z14test_try_catchv:
  ...
$tmp0:
  addiu  $4, $zero, 2
  addiu  $5, $zero, 1
  jsub  _Z15throw_exceptionii
  nop
$tmp1:
# %bb.1:                                # %invoke.cont
  jmp  $BB1_4
$BB1_2:                                 # %lpad
$tmp2:
  st  $4, 16($fp)
  st  $5, 12($fp)
# %bb.3:                                # %catch
  ld  $4, 16($fp)
  jsub  __cxa_begin_catch
  nop
  addiu  $2, $zero, 1
  st  $2, 20($fp)
  jsub  __cxa_end_catch
  nop
  jmp  $BB1_5
$BB1_4:                                 # %try.cont
  addiu  $2, $zero, 0
  st  $2, 20($fp)
$BB1_5:                                 # %return
  ld  $2, 20($fp)
  ...
</pre></div>
</div>
</section>
<section id="thread-variable">
<h2><a class="toc-backref" href="#id27" role="doc-backlink">Thread variable</a><a class="headerlink" href="#thread-variable" title="Permalink to this heading">¶</a></h2>
<p>C++ support thread variable as the following file ch12_thread_var.cpp.</p>
<p class="rubric">lbdex/input/ch12_thread_var.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">__thread</span> <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">thread_local</span> <span class="nb">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">//</span> <span class="n">need</span> <span class="n">option</span> <span class="o">-</span><span class="n">std</span><span class="o">=</span><span class="n">c</span><span class="o">++</span><span class="mi">11</span>
<span class="nb">int</span> <span class="n">test_thread_var</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">test_thread_var_2</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

</pre></div>
</div>
<p>While a global variable is a single instance shared by all threads in a process,
a thread-local variable has a separate instance for each thread in the process.
The same thread accesses the same instance of the thread-local variable, while
different threads have their own instances with the same variable name
<a class="footnote-reference brackets" href="#thread-wiki" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>.</p>
<p>To support thread-local variables, symbols such as <strong>tlsgd</strong>, <strong>tlsldm</strong>,
<strong>dtp_hi</strong>, <strong>dtp_lo</strong>, <strong>gottp</strong>, <strong>tp_hi</strong>, and <strong>tp_lo</strong> must be handled in
both <cite>evaluateRelocExpr()</cite> of <cite>Cpu0AsmParser.cpp</cite> and <cite>printImpl()</cite> of
<cite>Cpu0MCExpr.cpp</cite>.</p>
<p>Most of these symbols are used for relocation record handling,
because the actual thread-local storage is created by the OS or language
runtime that supports multi-threaded programming.</p>
<p class="rubric">lbdex/chapters/Chapter12_1/MCTargetDesc/Cpu0AsmBackend.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">MCFixupKindInfo</span> <span class="o">&amp;</span><span class="n">Cpu0AsmBackend</span><span class="p">::</span>
<span class="n">getFixupKindInfo</span><span class="p">(</span><span class="n">MCFixupKind</span> <span class="n">Kind</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="n">unsigned</span> <span class="n">JSUBReloRec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">HasLLD</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">JSUBReloRec</span> <span class="o">=</span> <span class="n">MCFixupKindInfo</span><span class="p">::</span><span class="n">FKF_IsPCRel</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="n">JSUBReloRec</span> <span class="o">=</span> <span class="n">MCFixupKindInfo</span><span class="p">::</span><span class="n">FKF_IsPCRel</span> <span class="o">|</span> <span class="n">MCFixupKindInfo</span><span class="p">::</span><span class="n">FKF_Constant</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">const</span> <span class="n">static</span> <span class="n">MCFixupKindInfo</span> <span class="n">Infos</span><span class="p">[</span><span class="n">Cpu0</span><span class="p">::</span><span class="n">NumTargetFixupKinds</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="o">//</span> <span class="n">This</span> <span class="n">table</span> <span class="o">*</span><span class="n">must</span><span class="o">*</span> <span class="n">be</span> <span class="ow">in</span> <span class="n">same</span> <span class="n">the</span> <span class="n">order</span> <span class="n">of</span> <span class="n">fixup_</span><span class="o">*</span> <span class="n">kinds</span> <span class="ow">in</span>
    <span class="o">//</span> <span class="n">Cpu0FixupKinds</span><span class="o">.</span><span class="n">h</span><span class="o">.</span>
    <span class="o">//</span>
    <span class="o">//</span> <span class="n">name</span>                        <span class="n">offset</span>  <span class="n">bits</span>  <span class="n">flags</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="p">{</span> <span class="s2">&quot;fixup_Cpu0_TLSGD&quot;</span><span class="p">,</span>          <span class="mi">0</span><span class="p">,</span>     <span class="mi">16</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s2">&quot;fixup_Cpu0_GOTTP&quot;</span><span class="p">,</span>          <span class="mi">0</span><span class="p">,</span>     <span class="mi">16</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s2">&quot;fixup_Cpu0_TP_HI&quot;</span><span class="p">,</span>          <span class="mi">0</span><span class="p">,</span>     <span class="mi">16</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s2">&quot;fixup_Cpu0_TP_LO&quot;</span><span class="p">,</span>          <span class="mi">0</span><span class="p">,</span>     <span class="mi">16</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s2">&quot;fixup_Cpu0_TLSLDM&quot;</span><span class="p">,</span>         <span class="mi">0</span><span class="p">,</span>     <span class="mi">16</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s2">&quot;fixup_Cpu0_DTP_HI&quot;</span><span class="p">,</span>         <span class="mi">0</span><span class="p">,</span>     <span class="mi">16</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s2">&quot;fixup_Cpu0_DTP_LO&quot;</span><span class="p">,</span>         <span class="mi">0</span><span class="p">,</span>     <span class="mi">16</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/MCTargetDesc/Cpu0BaseInfo.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">namespace</span> <span class="n">Cpu0II</span> <span class="p">{</span>
  <span class="o">///</span> <span class="n">Target</span> <span class="n">Operand</span> <span class="n">Flag</span> <span class="n">enum</span><span class="o">.</span>
  <span class="n">enum</span> <span class="n">TOF</span> <span class="p">{</span>
    <span class="o">//===------------------------------------------------------------------===//</span>
    <span class="o">//</span> <span class="n">Cpu0</span> <span class="n">Specific</span> <span class="n">MachineOperand</span> <span class="n">flags</span><span class="o">.</span>

</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="o">///</span> <span class="n">MO_TLSGD</span> <span class="o">-</span> <span class="n">Represents</span> <span class="n">the</span> <span class="n">offset</span> <span class="n">into</span> <span class="n">the</span> <span class="k">global</span> <span class="n">offset</span> <span class="n">table</span> <span class="n">at</span> <span class="n">which</span>
    <span class="o">//</span> <span class="n">the</span> <span class="n">module</span> <span class="n">ID</span> <span class="ow">and</span> <span class="n">TSL</span> <span class="n">block</span> <span class="n">offset</span> <span class="n">reside</span> <span class="n">during</span> <span class="n">execution</span> <span class="p">(</span><span class="n">General</span>
    <span class="o">//</span> <span class="n">Dynamic</span> <span class="n">TLS</span><span class="p">)</span><span class="o">.</span>
    <span class="n">MO_TLSGD</span><span class="p">,</span>

    <span class="o">///</span> <span class="n">MO_TLSLDM</span> <span class="o">-</span> <span class="n">Represents</span> <span class="n">the</span> <span class="n">offset</span> <span class="n">into</span> <span class="n">the</span> <span class="k">global</span> <span class="n">offset</span> <span class="n">table</span> <span class="n">at</span> <span class="n">which</span>
    <span class="o">//</span> <span class="n">the</span> <span class="n">module</span> <span class="n">ID</span> <span class="ow">and</span> <span class="n">TSL</span> <span class="n">block</span> <span class="n">offset</span> <span class="n">reside</span> <span class="n">during</span> <span class="n">execution</span> <span class="p">(</span><span class="n">Local</span>
    <span class="o">//</span> <span class="n">Dynamic</span> <span class="n">TLS</span><span class="p">)</span><span class="o">.</span>
    <span class="n">MO_TLSLDM</span><span class="p">,</span>
    <span class="n">MO_DTP_HI</span><span class="p">,</span>
    <span class="n">MO_DTP_LO</span><span class="p">,</span>

    <span class="o">///</span> <span class="n">MO_GOTTPREL</span> <span class="o">-</span> <span class="n">Represents</span> <span class="n">the</span> <span class="n">offset</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">thread</span> <span class="n">pointer</span> <span class="p">(</span><span class="n">Initial</span>
    <span class="o">//</span> <span class="n">Exec</span> <span class="n">TLS</span><span class="p">)</span><span class="o">.</span>
    <span class="n">MO_GOTTPREL</span><span class="p">,</span>

    <span class="o">///</span> <span class="n">MO_TPREL_HI</span><span class="o">/</span><span class="n">LO</span> <span class="o">-</span> <span class="n">Represents</span> <span class="n">the</span> <span class="n">hi</span> <span class="ow">and</span> <span class="n">low</span> <span class="n">part</span> <span class="n">of</span> <span class="n">the</span> <span class="n">offset</span> <span class="kn">from</span>
    <span class="o">//</span> <span class="n">the</span> <span class="n">thread</span> <span class="n">pointer</span> <span class="p">(</span><span class="n">Local</span> <span class="n">Exec</span> <span class="n">TLS</span><span class="p">)</span><span class="o">.</span>
    <span class="n">MO_TP_HI</span><span class="p">,</span>
    <span class="n">MO_TP_LO</span><span class="p">,</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/MCTargetDesc/Cpu0ELFObjectWriter.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">unsigned</span> <span class="n">Cpu0ELFObjectWriter</span><span class="p">::</span><span class="n">getRelocType</span><span class="p">(</span><span class="n">MCContext</span> <span class="o">&amp;</span><span class="n">Ctx</span><span class="p">,</span>
                                           <span class="n">const</span> <span class="n">MCValue</span> <span class="o">&amp;</span><span class="n">Target</span><span class="p">,</span>
                                           <span class="n">const</span> <span class="n">MCFixup</span> <span class="o">&amp;</span><span class="n">Fixup</span><span class="p">,</span>
                                           <span class="nb">bool</span> <span class="n">IsPCRel</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="o">//</span> <span class="n">determine</span> <span class="n">the</span> <span class="nb">type</span> <span class="n">of</span> <span class="n">the</span> <span class="n">relocation</span>
  <span class="n">unsigned</span> <span class="n">Type</span> <span class="o">=</span> <span class="p">(</span><span class="n">unsigned</span><span class="p">)</span><span class="n">ELF</span><span class="p">::</span><span class="n">R_CPU0_NONE</span><span class="p">;</span>
  <span class="n">unsigned</span> <span class="n">Kind</span> <span class="o">=</span> <span class="p">(</span><span class="n">unsigned</span><span class="p">)</span><span class="n">Fixup</span><span class="o">.</span><span class="n">getKind</span><span class="p">();</span>

  <span class="n">switch</span> <span class="p">(</span><span class="n">Kind</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">case</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_TLSGD</span><span class="p">:</span>
    <span class="n">Type</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">::</span><span class="n">R_CPU0_TLS_GD</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_GOTTPREL</span><span class="p">:</span>
    <span class="n">Type</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">::</span><span class="n">R_CPU0_TLS_GOTTPREL</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/MCTargetDesc/Cpu0FixupKinds.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">enum</span> <span class="n">Fixups</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="o">//</span> <span class="n">resulting</span> <span class="ow">in</span> <span class="o">-</span> <span class="n">R_CPU0_TLS_GD</span><span class="o">.</span>
    <span class="n">fixup_Cpu0_TLSGD</span><span class="p">,</span>

    <span class="o">//</span> <span class="n">resulting</span> <span class="ow">in</span> <span class="o">-</span> <span class="n">R_CPU0_TLS_GOTTPREL</span><span class="o">.</span>
    <span class="n">fixup_Cpu0_GOTTPREL</span><span class="p">,</span>

    <span class="o">//</span> <span class="n">resulting</span> <span class="ow">in</span> <span class="o">-</span> <span class="n">R_CPU0_TLS_TPREL_HI16</span><span class="o">.</span>
    <span class="n">fixup_Cpu0_TP_HI</span><span class="p">,</span>

    <span class="o">//</span> <span class="n">resulting</span> <span class="ow">in</span> <span class="o">-</span> <span class="n">R_CPU0_TLS_TPREL_LO16</span><span class="o">.</span>
    <span class="n">fixup_Cpu0_TP_LO</span><span class="p">,</span>

    <span class="o">//</span> <span class="n">resulting</span> <span class="ow">in</span> <span class="o">-</span> <span class="n">R_CPU0_TLS_LDM</span><span class="o">.</span>
    <span class="n">fixup_Cpu0_TLSLDM</span><span class="p">,</span>

    <span class="o">//</span> <span class="n">resulting</span> <span class="ow">in</span> <span class="o">-</span> <span class="n">R_CPU0_TLS_DTP_HI16</span><span class="o">.</span>
    <span class="n">fixup_Cpu0_DTP_HI</span><span class="p">,</span>

    <span class="o">//</span> <span class="n">resulting</span> <span class="ow">in</span> <span class="o">-</span> <span class="n">R_CPU0_TLS_DTP_LO16</span><span class="o">.</span>
    <span class="n">fixup_Cpu0_DTP_LO</span><span class="p">,</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/MCTargetDesc/Cpu0MCCodeEmitter.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">unsigned</span> <span class="n">Cpu0MCCodeEmitter</span><span class="p">::</span>
<span class="n">getExprOpValue</span><span class="p">(</span><span class="n">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">Expr</span><span class="p">,</span><span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCFixup</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Fixups</span><span class="p">,</span>
               <span class="n">const</span> <span class="n">MCSubtargetInfo</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="k">case</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_TLSGD</span><span class="p">:</span>
      <span class="n">FixupKind</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_TLSGD</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_TLSLDM</span><span class="p">:</span>
      <span class="n">FixupKind</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_TLSLDM</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_DTP_HI</span><span class="p">:</span>
      <span class="n">FixupKind</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_DTP_HI</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_DTP_LO</span><span class="p">:</span>
      <span class="n">FixupKind</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_DTP_LO</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_GOTTPREL</span><span class="p">:</span>
      <span class="n">FixupKind</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_GOTTPREL</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_TP_HI</span><span class="p">:</span>
      <span class="n">FixupKind</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_TP_HI</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_TP_LO</span><span class="p">:</span>
      <span class="n">FixupKind</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_TP_LO</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0InstrInfo.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">TlsGd</span> <span class="n">node</span> <span class="ow">is</span> <span class="n">used</span> <span class="n">to</span> <span class="n">handle</span> <span class="n">General</span> <span class="n">Dynamic</span> <span class="n">TLS</span>
<span class="k">def</span> <span class="nf">Cpu0TlsGd</span> <span class="p">:</span> <span class="n">SDNode</span><span class="o">&lt;</span><span class="s2">&quot;Cpu0ISD::TlsGd&quot;</span><span class="p">,</span> <span class="n">SDTIntUnaryOp</span><span class="o">&gt;</span><span class="p">;</span>

<span class="o">//</span> <span class="n">TpHi</span> <span class="ow">and</span> <span class="n">TpLo</span> <span class="n">nodes</span> <span class="n">are</span> <span class="n">used</span> <span class="n">to</span> <span class="n">handle</span> <span class="n">Local</span> <span class="n">Exec</span> <span class="n">TLS</span>
<span class="k">def</span> <span class="nf">Cpu0TpHi</span>  <span class="p">:</span> <span class="n">SDNode</span><span class="o">&lt;</span><span class="s2">&quot;Cpu0ISD::TpHi&quot;</span><span class="p">,</span> <span class="n">SDTIntUnaryOp</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">Cpu0TpLo</span>  <span class="p">:</span> <span class="n">SDNode</span><span class="o">&lt;</span><span class="s2">&quot;Cpu0ISD::TpLo&quot;</span><span class="p">,</span> <span class="n">SDTIntUnaryOp</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>let Predicates = [Ch12_1] in {
def : Pat&lt;(Cpu0Hi tglobaltlsaddr:$in), (LUi tglobaltlsaddr:$in)&gt;;
}
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>let Predicates = [Ch12_1] in {
def : Pat&lt;(Cpu0Lo tglobaltlsaddr:$in), (ORi ZERO, tglobaltlsaddr:$in)&gt;;
}
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>let Predicates = [Ch12_1] in {
def : Pat&lt;(add CPURegs:$hi, (Cpu0Lo tglobaltlsaddr:$lo)),
              (ORi CPURegs:$hi, tglobaltlsaddr:$lo)&gt;;
}
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ch12_1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">{</span>
<span class="k">def</span> <span class="p">:</span> <span class="n">WrapperPat</span><span class="o">&lt;</span><span class="n">tglobaltlsaddr</span><span class="p">,</span> <span class="n">ORi</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0SelLowering.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="n">const</span> <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">,</span>
                                       <span class="n">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span>
    <span class="p">:</span> <span class="n">TargetLowering</span><span class="p">(</span><span class="n">TM</span><span class="p">),</span> <span class="n">Subtarget</span><span class="p">(</span><span class="n">STI</span><span class="p">),</span> <span class="n">ABI</span><span class="p">(</span><span class="n">TM</span><span class="o">.</span><span class="n">getABI</span><span class="p">())</span> <span class="p">{</span>

</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">GlobalTLSAddress</span><span class="p">,</span>   <span class="n">MVT</span><span class="p">::</span><span class="n">i32</span><span class="p">,</span>   <span class="n">Custom</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="p">::</span>
<span class="n">LowerOperation</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span>
<span class="p">{</span>
  <span class="n">switch</span> <span class="p">(</span><span class="n">Op</span><span class="o">.</span><span class="n">getOpcode</span><span class="p">())</span>
  <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">case</span> <span class="n">ISD</span><span class="p">::</span><span class="n">GlobalTLSAddress</span><span class="p">:</span>   <span class="k">return</span> <span class="n">lowerGlobalTLSAddress</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>SDValue Cpu0TargetLowering::
lowerGlobalTLSAddress(SDValue Op, SelectionDAG &amp;DAG) const
{
  // If the relocation model is PIC, use the General Dynamic TLS Model or
  // Local Dynamic TLS model, otherwise use the Initial Exec or
  // Local Exec TLS Model.

  GlobalAddressSDNode *GA = cast&lt;GlobalAddressSDNode&gt;(Op);
  if (DAG.getTarget().Options.EmulatedTLS)
    return LowerToTLSEmulatedModel(GA, DAG);

  SDLoc DL(GA);
  const GlobalValue *GV = GA-&gt;getGlobal();
  EVT PtrVT = getPointerTy(DAG.getDataLayout());

  TLSModel::Model model = getTargetMachine().getTLSModel(GV);

  if (model == TLSModel::GeneralDynamic || model == TLSModel::LocalDynamic) {
    // General Dynamic and Local Dynamic TLS Model.
    unsigned Flag = (model == TLSModel::LocalDynamic) ? Cpu0II::MO_TLSLDM
                                                      : Cpu0II::MO_TLSGD;

    SDValue TGA = DAG.getTargetGlobalAddress(GV, DL, PtrVT, 0, Flag);
    SDValue Argument = DAG.getNode(Cpu0ISD::Wrapper, DL, PtrVT,
                                   getGlobalReg(DAG, PtrVT), TGA);
    unsigned PtrSize = PtrVT.getSizeInBits();
    IntegerType *PtrTy = Type::getIntNTy(*DAG.getContext(), PtrSize);

    SDValue TlsGetAddr = DAG.getExternalSymbol(&quot;__tls_get_addr&quot;, PtrVT);

    ArgListTy Args;
    ArgListEntry Entry;
    Entry.Node = Argument;
    Entry.Ty = PtrTy;
    Args.push_back(Entry);

    TargetLowering::CallLoweringInfo CLI(DAG);
    CLI.setDebugLoc(DL).setChain(DAG.getEntryNode())
      .setCallee(CallingConv::C, PtrTy, TlsGetAddr, std::move(Args));
    std::pair&lt;SDValue, SDValue&gt; CallResult = LowerCallTo(CLI);

    SDValue Ret = CallResult.first;

    if (model != TLSModel::LocalDynamic)
      return Ret;

    SDValue TGAHi = DAG.getTargetGlobalAddress(GV, DL, PtrVT, 0,
                                               Cpu0II::MO_DTP_HI);
    SDValue Hi = DAG.getNode(Cpu0ISD::Hi, DL, PtrVT, TGAHi);
    SDValue TGALo = DAG.getTargetGlobalAddress(GV, DL, PtrVT, 0,
                                               Cpu0II::MO_DTP_LO);
    SDValue Lo = DAG.getNode(Cpu0ISD::Lo, DL, PtrVT, TGALo);
    SDValue Add = DAG.getNode(ISD::ADD, DL, PtrVT, Hi, Ret);
    return DAG.getNode(ISD::ADD, DL, PtrVT, Add, Lo);
  }

  SDValue Offset;
  if (model == TLSModel::InitialExec) {
    // Initial Exec TLS Model
    SDValue TGA = DAG.getTargetGlobalAddress(GV, DL, PtrVT, 0,
                                             Cpu0II::MO_GOTTPREL);
    TGA = DAG.getNode(Cpu0ISD::Wrapper, DL, PtrVT, getGlobalReg(DAG, PtrVT),
                      TGA);
    Offset =
        DAG.getLoad(PtrVT, DL, DAG.getEntryNode(), TGA, MachinePointerInfo());
  } else {
    // Local Exec TLS Model
    assert(model == TLSModel::LocalExec);
    SDValue TGAHi = DAG.getTargetGlobalAddress(GV, DL, PtrVT, 0,
                                               Cpu0II::MO_TP_HI);
    SDValue TGALo = DAG.getTargetGlobalAddress(GV, DL, PtrVT, 0,
                                               Cpu0II::MO_TP_LO);
    SDValue Hi = DAG.getNode(Cpu0ISD::Hi, DL, PtrVT, TGAHi);
    SDValue Lo = DAG.getNode(Cpu0ISD::Lo, DL, PtrVT, TGALo);
    Offset = DAG.getNode(ISD::ADD, DL, PtrVT, Hi, Lo);
  }
  return Offset;
}
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0ISelLowering.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">SDValue</span> <span class="n">lowerGlobalTLSAddress</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0MCInstLower.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MCOperand</span> <span class="n">Cpu0MCInstLower</span><span class="p">::</span><span class="n">LowerSymbolOperand</span><span class="p">(</span><span class="n">const</span> <span class="n">MachineOperand</span> <span class="o">&amp;</span><span class="n">MO</span><span class="p">,</span>
                                              <span class="n">MachineOperandType</span> <span class="n">MOTy</span><span class="p">,</span>
                                              <span class="n">unsigned</span> <span class="n">Offset</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VariantKind</span> <span class="n">Kind</span> <span class="o">=</span> <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VK_None</span><span class="p">;</span>
  <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">Cpu0ExprKind</span> <span class="n">TargetKind</span> <span class="o">=</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_None</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">MCSymbol</span> <span class="o">*</span><span class="n">Symbol</span><span class="p">;</span>

  <span class="n">switch</span><span class="p">(</span><span class="n">MO</span><span class="o">.</span><span class="n">getTargetFlags</span><span class="p">())</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">case</span> <span class="n">Cpu0II</span><span class="p">::</span><span class="n">MO_TLSGD</span><span class="p">:</span>
    <span class="n">TargetKind</span> <span class="o">=</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_TLSGD</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0II</span><span class="p">::</span><span class="n">MO_TLSLDM</span><span class="p">:</span>
    <span class="n">TargetKind</span> <span class="o">=</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_TLSLDM</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0II</span><span class="p">::</span><span class="n">MO_DTP_HI</span><span class="p">:</span>
    <span class="n">TargetKind</span> <span class="o">=</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_DTP_HI</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0II</span><span class="p">::</span><span class="n">MO_DTP_LO</span><span class="p">:</span>
    <span class="n">TargetKind</span> <span class="o">=</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_DTP_LO</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0II</span><span class="p">::</span><span class="n">MO_GOTTPREL</span><span class="p">:</span>
    <span class="n">TargetKind</span> <span class="o">=</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_GOTTPREL</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0II</span><span class="p">::</span><span class="n">MO_TP_HI</span><span class="p">:</span>
    <span class="n">TargetKind</span> <span class="o">=</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_TP_HI</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0II</span><span class="p">::</span><span class="n">MO_TP_LO</span><span class="p">:</span>
    <span class="n">TargetKind</span> <span class="o">=</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_TP_LO</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>clang -target mips-unknown-linux-gnu -c
<span class="go">ch12_thread_var.cpp -emit-llvm -std=c++11 -o ch12_thread_var.bc</span>
<span class="gp">JonathantekiiMac:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llvm-dis ch12_thread_var.bc -o -</span>
</pre></div>
</div>
<p class="rubric">../lbdex/output/ch12_thread_var.ll</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="p">...</span><span class="w"></span>
<span class="vg">@a</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">dso_local</span><span class="w"> </span><span class="k">thread_local</span><span class="w"> </span><span class="k">global</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span><span class="w"></span>
<span class="vg">@b</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">dso_local</span><span class="w"> </span><span class="k">thread_local</span><span class="w"> </span><span class="k">global</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span><span class="w"></span>

<span class="c">; Function Attrs: noinline nounwind optnone mustprogress</span>
<span class="k">define</span><span class="w"> </span><span class="k">dso_local</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@_Z15test_thread_varv</span><span class="p">()</span><span class="w"> </span><span class="vg">#0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="nl">entry:</span><span class="w"></span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="vg">@a</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span><span class="w"></span>
<span class="w">  </span><span class="nv nv-Anonymous">%0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="vg">@a</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span><span class="w"></span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv nv-Anonymous">%0</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c">; Function Attrs: noinline nounwind optnone mustprogress</span>
<span class="k">define</span><span class="w"> </span><span class="k">dso_local</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@_Z17test_thread_var_2v</span><span class="p">()</span><span class="w"> </span><span class="vg">#0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="nl">entry:</span><span class="w"></span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="vg">@b</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span><span class="w"></span>
<span class="w">  </span><span class="nv nv-Anonymous">%0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="vg">@b</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span><span class="w"></span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv nv-Anonymous">%0</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llc -march=cpu0 -relocation-model=pic -filetype=asm ch12_thread_var.bc</span>
<span class="go">-o ch12_thread_var.cpu0.pic.s</span>
<span class="gp">JonathantekiiMac:input Jonathan$ </span>cat ch12_thread_var.cpu0.pic.s
</pre></div>
</div>
<p class="rubric">../lbdex/output/ch12_thread_var.cpu0.pic.s</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>...
  .ent  _Z15test_thread_varv            # @_Z15test_thread_varv
_Z15test_thread_varv:
  ...
  ori  $4, $gp, %tlsldm(a)
  ld  $t9, %call16(__tls_get_addr)($gp)
  jalr  $t9
  nop
  ld  $gp, 8($fp)
  lui  $3, %dtp_hi(a)
  addu  $2, $3, $2
  ori  $2, $2, %dtp_lo(a)
  ...
</pre></div>
</div>
<p>In PIC (Position-Independent Code) mode, the <cite>__thread</cite> variable is accessed by
calling the function <cite>__tls_get_addr</cite> with the address of the thread-local
variable as an argument.</p>
<p>For C++11 <cite>thread_local</cite> variables, the compiler generates a call to the function
<cite>_ZTW1b</cite>, which internally calls <cite>__tls_get_addr</cite> to retrieve the address of the
<cite>thread_local</cite> variable.</p>
<p>In static mode, thread-local variables are accessed directly by loading their
addresses using machine instructions. For example, variables <cite>a</cite> and <cite>b</cite> are
accessed through direct address calculation instructions.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llc -march=cpu0 -relocation-model=static -filetype=asm</span>
<span class="go">ch12_thread_var.bc -o ch12_thread_var.cpu0.static.s</span>
<span class="gp">JonathantekiiMac:input Jonathan$ </span>cat ch12_thread_var.cpu0.static.s
</pre></div>
</div>
<p class="rubric">../lbdex/output/ch12_thread_var.cpu0.static.s</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>...
lui  $2, %tp_hi(a)
ori  $2, $2, %tp_lo(a)
...
lui  $2, %tp_hi(b)
ori  $2, $2, %tp_lo(b)
...
</pre></div>
</div>
<p>While MIPS uses the <cite>rdhwr</cite> instruction to access thread-local variables, Cpu0
accesses thread-local variables without introducing any new instructions.</p>
<p>Thread-local variables in Cpu0 are stored in a dedicated thread-local memory
region, which is accessed through <cite>%tp_hi</cite> and <cite>%tp_lo</cite>. This memory section is
protected by the kernel, meaning it can only be accessed in kernel mode.</p>
<p>As a result, user-mode programs cannot access this memory region, leaving no room
for potential exploits or malicious programs to interfere with thread-local
storage.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llc -march=mips -relocation-model=static -filetype=asm</span>
<span class="go">ch12_thread_var.bc -o -</span>
<span class="go">  ...</span>
<span class="go">  lui $1, %tprel_hi(a)</span>
<span class="go">  ori $1, $1, %tprel_lo(a)</span>
<span class="go">  .set  push</span>
<span class="go">  .set  mips32r2</span>
<span class="go">  rdhwr $3, $29</span>
<span class="go">  .set  pop</span>
<span class="go">  addu  $1, $3, $1</span>
<span class="go">  addiu $2, $zero, 2</span>
<span class="go">  sw  $2, 0($1)</span>
<span class="go">  addiu $2, $zero, 2</span>
<span class="go">  ...</span>
</pre></div>
</div>
<p>In static mode, the thread variable is similar to global variable.
In general, they are same in IRs, DAGs and machine code translation.
List them in the following tables.
You can check them with debug option enabled.</p>
<p>In static mode, the thread variable behaves similarly to a global variable.
In general, they are the same in terms of LLVM IR, DAG, and machine code
translation.</p>
<p>You can refer to the following tables for a detailed comparison.</p>
<p>To observe this in action, compile and check with debug options enabled.</p>
<table class="docutils align-default" id="id18">
<caption><span class="caption-number">Table 39 </span><span class="caption-text">The DAGs of thread varaible of static mode</span><a class="headerlink" href="#id18" title="Permalink to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>stage</p></th>
<th class="head"><p>DAG</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>IR</p></td>
<td><p>load i32* &#64;a, align 4;</p></td>
</tr>
<tr class="row-odd"><td><p>Legalized selection DAG</p></td>
<td><p>(add Cpu0ISD::Hi Cpu0ISD::Lo);</p></td>
</tr>
<tr class="row-even"><td><p>Instruction Selection</p></td>
<td><p>ori $2, $zero, %tp_lo(a);</p></td>
</tr>
<tr class="row-odd"><td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>lui $3, %tp_hi(a);</p></td>
</tr>
<tr class="row-even"><td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>addu  $3, $3, $2;</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="id19">
<caption><span class="caption-number">Table 40 </span><span class="caption-text">The DAGs of local_thread varaible of static mode</span><a class="headerlink" href="#id19" title="Permalink to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>stage</p></th>
<th class="head"><p>DAG</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>IR</p></td>
<td><p>ret i32* &#64;b;</p></td>
</tr>
<tr class="row-odd"><td><p>Legalized selection DAG</p></td>
<td><p>%0=(add Cpu0ISD::Hi Cpu0ISD::Lo);…</p></td>
</tr>
<tr class="row-even"><td><p>Instruction Selection</p></td>
<td><p>ori $2, $zero, %tp_lo(a);</p></td>
</tr>
<tr class="row-odd"><td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>lui $3, %tp_hi(a);</p></td>
</tr>
<tr class="row-even"><td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>addu  $3, $3, $2;</p></td>
</tr>
</tbody>
</table>
</section>
<section id="c-memory-order">
<h2><a class="toc-backref" href="#id28" role="doc-backlink">C++ Memory Order <a class="footnote-reference brackets" href="#cpp-mem-order" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a></a><a class="headerlink" href="#c-memory-order" title="Permalink to this heading">¶</a></h2>
<section id="background">
<h3><a class="toc-backref" href="#id29" role="doc-backlink">Background</a><a class="headerlink" href="#background" title="Permalink to this heading">¶</a></h3>
<p>Before <strong>C++11</strong>, multi-threaded programming relied on <strong>mutexes, volatile
variables, and platform-specific atomic operations</strong>, leading to inefficiencies
and undefined behavior.</p>
<p>For RISC CPU, <strong>only load/store instruction have accessed memory.</strong>
Atomic instructions are memory access instructions to provide memory consistence
for multi-cores.</p>
<p>CPU has atomic operations (compare-and-swap <a class="footnote-reference brackets" href="#cas-wiki" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a> or ll/sc instruction)
and BARRIER or
SYNC instructions to support memory order. <strong>However no C++ statements tell
compiler to controll the ordering for load/store instructions.</strong></p>
<p>To solve this, <strong>C++11 introduced memory orderings in `std::atomic`</strong> to give
programmers <strong>fine-grained control</strong> over synchronization.</p>
<p>Before <strong>C++11</strong>, multi-threaded programming relied on <strong>mutexes, volatile
variables, and platform-specific atomic operations</strong>, which often led to
inefficiencies and undefined behavior.</p>
<p>For RISC CPUs, <strong>only load/store instructions access memory.</strong> Atomic
instructions ensure memory consistency across multiple cores.</p>
<p>CPUs provide atomic operations such as <strong>compare-and-swap</strong> <a class="footnote-reference brackets" href="#cas-wiki" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a> or
<strong>ll/sc (load-linked/store-conditional)</strong>, along with <strong>BARRIER</strong> or <strong>SYNC</strong>
instructions to enforce memory ordering. However, <strong>C++03 did not have a language
feature to tell the compiler how to control memory order for load/store
instructions.</strong></p>
<p>To address this, <strong>C++11 introduced memory orderings via `std::atomic`</strong>, giving
programmers <strong>fine-grained control</strong> over synchronization and memory consistency.</p>
<section id="the-problem-before-c-11">
<h4><a class="toc-backref" href="#id30" role="doc-backlink">The Problem Before C++11</a><a class="headerlink" href="#the-problem-before-c-11" title="Permalink to this heading">¶</a></h4>
<ol class="arabic simple">
<li><p><strong>Unspecified Behavior in Multi-threading</strong></p>
<ul class="simple">
<li><p>The C++98/03 standard had <strong>no formal memory model</strong>.</p></li>
<li><p>Compilers <strong>optimized code aggressively</strong>, leading to race conditions.</p></li>
<li><p>Without a memory model, a compiler may not apply such optimizations to
multi-threaded programs at all, or it may apply optimizations that are
incompatible with multi-threading, leading to bugs <a class="footnote-reference brackets" href="#atomic-wiki" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a>.</p></li>
</ul>
</li>
<li><p><strong>Reliance on Volatile and Platform-specific Primitives</strong></p>
<ul class="simple">
<li><p><cite>volatile</cite> <strong>did not</strong> prevent reordering by the compiler.</p></li>
<li><p>Programmers had to use <strong>OS-specific APIs (e.g., `pthread_mutex`)</strong>
<a class="footnote-reference brackets" href="#atomic-stackoverflow" id="id8" role="doc-noteref"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></a>.</p></li>
</ul>
</li>
<li><p><strong>Inefficient Synchronization Mechanisms</strong></p>
<ul class="simple">
<li><p>Mutexes ensured correctness but <strong>caused performance overhead</strong>.</p></li>
<li><p><strong>Spin-locks wasted CPU cycles</strong> due to busy-waiting.</p></li>
</ul>
</li>
</ol>
</section>
<section id="c-11-memory-model-solution">
<h4><a class="toc-backref" href="#id31" role="doc-backlink">C++11 Memory Model Solution</a><a class="headerlink" href="#c-11-memory-model-solution" title="Permalink to this heading">¶</a></h4>
<p>C++11 introduced <strong>a well-defined memory model</strong> and <strong>atomic operations</strong> with
<strong>memory orderings</strong>, allowing programmers to control hardware-level
optimizations.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Feature</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
<th class="head"><p><strong>Benefit</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><cite>std::atomic</cite></p></td>
<td><p>Provides lock-free atomic variables</p></td>
<td><p>Faster than mutexes</p></td>
</tr>
<tr class="row-odd"><td><p>Memory Orderings (<cite>std::memory_order</cite>)</p></td>
<td><p>Controls instruction reordering</p></td>
<td><p>Fine-grained optimization</p></td>
</tr>
<tr class="row-even"><td><p>Sequential Consistency (<cite>memory_order_seq_cst</cite>)</p></td>
<td><p>Strongest ordering, default behavior</p></td>
<td><p>Prevents race conditions</p></td>
</tr>
<tr class="row-odd"><td><p>Acquire-Release (<cite>memory_order_acquire/release</cite>)</p></td>
<td><p>Synchronization without mutexes</p></td>
<td><p>Efficient producer-consumer</p></td>
</tr>
<tr class="row-even"><td><p>Relaxed Ordering (<cite>memory_order_relaxed</cite>)</p></td>
<td><p>Allows reordering for performance</p></td>
<td><p>Best for atomic counters</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="id20">
<caption><span class="caption-number">Table 41 </span><span class="caption-text">C++ memory order</span><a class="headerlink" href="#id20" title="Permalink to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p><strong>Memory Order</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
<th class="head"><p><strong>Use Cases</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><cite>memory_order_relaxed</cite></p></td>
<td><p>No ordering guarantees; only atomicity.</p></td>
<td><p>Non-dependent atomic counters, statistics.</p></td>
</tr>
<tr class="row-odd"><td><p><cite>memory_order_consume</cite></p></td>
<td><p>Data-dependent ordering (deprecated in practice).</p></td>
<td><p>Rarely used; intended for pointer chains.</p></td>
</tr>
<tr class="row-even"><td><p><cite>memory_order_acquire</cite></p></td>
<td><p>Ensures preceding reads/writes are visible.</p></td>
<td><p>Locks, consumer threads.</p></td>
</tr>
<tr class="row-odd"><td><p><cite>memory_order_release</cite></p></td>
<td><p>Ensures following reads/writes are visible.</p></td>
<td><p>Locks, producer threads.</p></td>
</tr>
<tr class="row-even"><td><p><cite>memory_order_acq_rel</cite></p></td>
<td><p>Combines acquire + release.</p></td>
<td><p>Read-modify-write operations, synchronization.</p></td>
</tr>
<tr class="row-odd"><td><p><cite>memory_order_seq_cst</cite></p></td>
<td><p>Strongest ordering; global sequential consistency.</p></td>
<td><p>Default behavior, safest but can be slow.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="key-memory-order-introductions">
<h4><a class="toc-backref" href="#id32" role="doc-backlink">Key Memory Order Introductions</a><a class="headerlink" href="#key-memory-order-introductions" title="Permalink to this heading">¶</a></h4>
<ol class="arabic simple">
<li><p><strong>Sequential Consistency (`memory_order_seq_cst`)</strong></p>
<ul class="simple">
<li><p><strong>Prevents reordering globally.</strong></p></li>
<li><p><strong>Ensures</strong> all threads observe operations in the same order.</p></li>
<li><p><strong>Default behavior</strong> of <cite>std::atomic</cite>.</p></li>
<li><p>Provides <strong>global order of operations</strong>, preventing out-of-order execution.</p></li>
<li><p>The safest but can cause <strong>performance overhead</strong>.</p></li>
</ul>
</li>
<li><p><strong>Acquire-Release (`memory_order_acquire/release`)</strong></p>
<ul class="simple">
<li><p><strong>Efficient alternative to mutexes.</strong></p></li>
<li><p><cite>acquire</cite>: Ensures earlier loads are visible.</p></li>
<li><p><cite>release</cite>: Ensures later stores are visible.</p></li>
<li><p>Used in <strong>lock-free producer-consumer models</strong> <a class="footnote-reference brackets" href="#lf-wiki" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a>.</p></li>
</ul>
</li>
<li><p><strong>Relaxed Ordering (`memory_order_relaxed`)</strong></p>
<ul class="simple">
<li><p>Allows <strong>maximum performance</strong> without ordering constraints.</p></li>
<li><p>Best for <strong>counters and statistics</strong> that don’t need synchronization.</p></li>
<li><p>Example: <strong>Atomic counters</strong> that don’t require ordering.</p></li>
</ul>
</li>
<li><p><strong>`memory_order_acq_rel`</strong></p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Used in <strong>atomic read-modify-write operations</strong> like <cite>fetch_add</cite>.</p></li>
<li><p>Ensures proper ordering in concurrent updates.</p></li>
</ul>
</div></blockquote>
</section>
<section id="conclusion">
<h4><a class="toc-backref" href="#id33" role="doc-backlink">Conclusion</a><a class="headerlink" href="#conclusion" title="Permalink to this heading">¶</a></h4>
<ul class="simple">
<li><p><strong>C++11 introduced memory order to define a consistent multi-threaded model.</strong></p></li>
<li><p><strong>It prevents race conditions while optimizing performance.</strong></p></li>
<li><p><strong>Use relaxed ordering for performance, acquire-release for synchronization,
and sequential consistency for safety.</strong></p></li>
</ul>
</section>
<section id="example-usage-in-code">
<h4><a class="toc-backref" href="#id34" role="doc-backlink">Example Usage in Code</a><a class="headerlink" href="#example-usage-in-code" title="Permalink to this heading">¶</a></h4>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">counter</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">producer</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">counter</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">consumer</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">counter</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>Ensures `consumer()` sees the updated value from `producer()` safely.</strong></p></li>
<li><p>Avoids <strong>race conditions</strong> without unnecessary locking.</p></li>
</ul>
</section>
<section id="id10">
<h4><a class="toc-backref" href="#id35" role="doc-backlink">Conclusion</a><a class="headerlink" href="#id10" title="Permalink to this heading">¶</a></h4>
<ul class="simple">
<li><p>Use <strong>`memory_order_relaxed`</strong> for <strong>performance</strong> when ordering is
unnecessary.</p></li>
<li><p>Use <strong>`memory_order_acquire/release`</strong> for <strong>synchronization</strong> between
threads.</p></li>
<li><p>Use <strong>`memory_order_seq_cst`</strong> when you need <strong>global ordering but at a
performance cost</strong>.</p></li>
</ul>
</section>
</section>
<section id="example-code-for-producer-consumer">
<h3><a class="toc-backref" href="#id36" role="doc-backlink">Example code for producer-consumer</a><a class="headerlink" href="#example-code-for-producer-consumer" title="Permalink to this heading">¶</a></h3>
<p>Example code of C++ code for producer-consumer as follows,</p>
<p class="rubric">References/c++/mem-order-ex1.cpp (C++ code of memory order for
producer-consumer)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;atomic&gt;

std::atomic&lt;int&gt; data(0);
std::atomic&lt;bool&gt; ready(false);

void producer() {
    data.store(42, std::memory_order_relaxed); // Store value
    ready.store(true, std::memory_order_release); // Release signal
}

void consumer() {
    while (!ready.load(std::memory_order_acquire)); // Wait for ready signal

    // Ensure that this print sees the correct value of `data`
    std::cout &lt;&lt; &quot;Data: &quot; &lt;&lt; data.load(std::memory_order_relaxed) &lt;&lt; std::endl;
}

int main() {
    std::thread t1(producer);
    std::thread t2(consumer);

    t1.join();
    t2.join();

    return 0;
}

</pre></div>
</div>
<p>Explaining as <a class="reference internal" href="#mem-o-hw"><span class="std std-numref">Fig. 57</span></a> and follows,</p>
<figure class="align-default" id="id21">
<span id="mem-o-hw"></span><div class="graphviz"><img src="_images/graphviz-95e351b5cf89d1a459cfaadd204004716c249546.png" alt="digraph MemoryOrderAcquireCache {
    rankdir=TB;
    node [shape=box, fontname=&quot;Helvetica&quot;];

    // Main memory
    MainMemory [label=&quot;Main Memory&quot;, shape=cylinder, style=filled, fillcolor=lightgray];

    // CPU caches
    subgraph cluster_cache1 {
        label=&quot;CPU Core 1 Cache (Thread 1 - Producer)&quot;;
        style=dashed;
        Cache1_Data [label=&quot;data=42 (Stale?)&quot;];
        Cache1_Ready [label=&quot;ready=true&quot;];
    }

    subgraph cluster_cache2 {
        label=&quot;CPU Core 2 Cache (Thread 2 - Consumer)&quot;;
        style=dashed;
        Cache2_Data [label=&quot;data=?&quot;];
        Cache2_Ready [label=&quot;ready=false&quot;];
    }

    // Threads
    Thread1 [label=&quot;Thread 1 (Producer)&quot;];
    Thread2 [label=&quot;Thread 2 (Consumer)&quot;];

    // Memory operations in Thread 1 (Producer)
    Thread1 -&gt; Cache1_Data [label=&quot;data.store(42, relaxed)&quot;];
    Thread1 -&gt; Cache1_Ready [label=&quot;ready.store(true, release)&quot;];
    
    // Memory propagation
    Cache1_Ready -&gt; MainMemory [label=&quot;ready=true propagated&quot;, color=red];
    MainMemory -&gt; Cache2_Ready [label=&quot;Consumer sees ready=true (Acquire)&quot;, color=red];

    // Memory operations in Thread 2 (Consumer)
    Thread2 -&gt; Cache2_Ready [label=&quot;while (!ready.load(acquire));&quot;];
    Cache2_Ready -&gt; Cache2_Data [label=&quot;data.load(relaxed)&quot;, color=blue];

    // Synchronization path
    Cache1_Ready -&gt; Cache2_Ready [label=&quot;Acquire-Release Sync&quot;, style=dashed, color=purple];
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 57 </span><span class="caption-text">Diagram for mem-order-ex1.cpp</span><a class="headerlink" href="#id21" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>Diagram Explanation:</p>
<ul class="simple">
<li><p><strong>CPU Core 1 (Thread 1 - Producer)</strong></p>
<ul>
<li><p>Writes 42 to data with memory_order_relaxed (not immediately visible).</p></li>
<li><p>Writes true to ready with memory_order_release, ensuring prior stores are
visible before this write.</p></li>
</ul>
</li>
<li><p><strong>Main Memory</strong></p>
<ul>
<li><p>ready=true propagates to main memory, making it visible to all cores.</p></li>
</ul>
</li>
<li><p><strong>CPU Core 2 (Thread 2 - Consumer)</strong></p>
<ul>
<li><p>Waits until ready=true with memory_order_acquire, ensuring visibility of all
previous writes.</p></li>
<li><p>After acquiring ready, loads data, which is now guaranteed to be 42.</p></li>
</ul>
</li>
</ul>
</section>
<section id="comparison-of-producer-consumer-with-busy-waiting">
<h3><a class="toc-backref" href="#id37" role="doc-backlink">Comparison of Producer-Consumer with Busy Waiting</a><a class="headerlink" href="#comparison-of-producer-consumer-with-busy-waiting" title="Permalink to this heading">¶</a></h3>
<p>This section compares different <strong>lock-free</strong> implementations of the
producer-consumer, <strong>SPSC (Single-Producer, Single-Consumer)</strong> problem
using a <strong>busy-waiting</strong> algorithm in the following approaches:</p>
<ol class="arabic simple">
<li><p><strong>Linux API with busy-waiting</strong> (using <cite>std::atomic</cite>)</p></li>
<li><p><strong>MIPS atomic and sync instructions</strong> (using <cite>ll</cite>, <cite>sc</cite>, <cite>sync</cite>)</p></li>
<li><p><strong>C++ memory order</strong> (lock-free, busy-waiting)</p></li>
</ol>
<p>Each approach avoids locks (<strong>lock-free</strong>) but relies on busy-waiting, which
affects performance.</p>
<section id="linux-api-with-busy-waiting-using-std-atomic">
<h4><a class="toc-backref" href="#id38" role="doc-backlink">1. Linux API with Busy Waiting (Using <cite>std::atomic</cite>)</a><a class="headerlink" href="#linux-api-with-busy-waiting-using-std-atomic" title="Permalink to this heading">¶</a></h4>
<p>This implementation uses <cite>std::atomic&lt;int&gt;</cite> for atomic operations and a circular
buffer for data exchange. It relies on busy-waiting when the buffer is full or empty.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;array&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;atomic&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;thread&gt;</span><span class="cp"></span>

<span class="k">constexpr</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="o">&gt;</span><span class="w"> </span><span class="n">buffer</span><span class="p">;</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">head</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tail</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="kt">bool</span><span class="w"> </span><span class="nf">enqueue</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">item</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">current_tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tail</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">next_tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">current_tail</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">next_tail</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">head</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">))</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// Busy-wait</span>

<span class="w">    </span><span class="n">buffer</span><span class="p">[</span><span class="n">current_tail</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">item</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">tail</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">next_tail</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">bool</span><span class="w"> </span><span class="nf">dequeue</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">item</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">current_head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">current_head</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tail</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">))</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// Busy-wait</span>

<span class="w">    </span><span class="n">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buffer</span><span class="p">[</span><span class="n">current_head</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">head</span><span class="p">.</span><span class="n">store</span><span class="p">((</span><span class="n">current_head</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">producer</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">enqueue</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Produced: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">consumer</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">item</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">dequeue</span><span class="p">(</span><span class="n">item</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Consumed: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="w"> </span><span class="n">prod</span><span class="p">(</span><span class="n">producer</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="w"> </span><span class="n">cons</span><span class="p">(</span><span class="n">consumer</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">prod</span><span class="p">.</span><span class="n">join</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">cons</span><span class="p">.</span><span class="n">join</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="mips-atomic-and-sync-instructions-ll-sc-sync">
<h4><a class="toc-backref" href="#id39" role="doc-backlink">2. MIPS Atomic and Sync Instructions (<cite>ll</cite>, <cite>sc</cite>, <cite>sync</cite>)</a><a class="headerlink" href="#mips-atomic-and-sync-instructions-ll-sc-sync" title="Permalink to this heading">¶</a></h4>
<p>This implementation uses MIPS low-level atomic instructions (<cite>ll</cite>, <cite>sc</cite>, <cite>sync</cite>).
It ensures atomicity using <cite>ll/sc</cite> and relies on busy-waiting.</p>
<div class="highlight-nasm notranslate"><div class="highlight"><pre><span></span><span class="nf">.data</span><span class="w"></span>
<span class="nl">buffer:</span><span class="w"> </span><span class="nf">.space</span><span class="w"> </span><span class="mi">4</span><span class="w">     </span><span class="c1"># Shared buffer (1 item)</span><span class="w"></span>
<span class="nl">flag:</span><span class="w">   </span><span class="nf">.word</span><span class="w"> </span><span class="mi">0</span><span class="w">      </span><span class="c1"># 0 = empty, 1 = full</span><span class="w"></span>

<span class="nf">.text</span><span class="w"></span>
<span class="nf">.globl</span><span class="w"> </span><span class="nv">producer</span><span class="p">,</span><span class="w"> </span><span class="nv">consumer</span><span class="w"></span>

<span class="nl">producer:</span><span class="w"></span>
<span class="w">    </span><span class="nf">li</span><span class="w"> </span><span class="kc">$</span><span class="nv">t0</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="w">       </span><span class="c1"># Produce 10 items</span><span class="w"></span>
<span class="nl">produce_loop:</span><span class="w"></span>
<span class="w">    </span><span class="nf">bgtz</span><span class="w"> </span><span class="kc">$</span><span class="nv">t0</span><span class="p">,</span><span class="w"> </span><span class="nv">produce_item</span><span class="w"></span>
<span class="w">    </span><span class="nf">j</span><span class="w"> </span><span class="nv">end</span><span class="w"></span>

<span class="nl">produce_item:</span><span class="w"></span>
<span class="w">    </span><span class="c1"># Busy-wait until buffer is empty</span><span class="w"></span>
<span class="nl">wait_empty:</span><span class="w"></span>
<span class="w">    </span><span class="nf">ll</span><span class="w"> </span><span class="kc">$</span><span class="nv">t1</span><span class="p">,</span><span class="w"> </span><span class="nv">flag</span><span class="w"></span>
<span class="w">    </span><span class="nf">bne</span><span class="w"> </span><span class="kc">$</span><span class="nv">t1</span><span class="p">,</span><span class="w"> </span><span class="kc">$</span><span class="nv">zero</span><span class="p">,</span><span class="w"> </span><span class="nv">wait_empty</span><span class="w"></span>

<span class="w">    </span><span class="nf">li</span><span class="w"> </span><span class="kc">$</span><span class="nv">t2</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">    </span><span class="nf">sc</span><span class="w"> </span><span class="kc">$</span><span class="nv">t2</span><span class="p">,</span><span class="w"> </span><span class="nv">flag</span><span class="w"></span>
<span class="w">    </span><span class="nf">beqz</span><span class="w"> </span><span class="kc">$</span><span class="nv">t2</span><span class="p">,</span><span class="w"> </span><span class="nv">wait_empty</span><span class="w">  </span><span class="c1"># Retry if store failed</span><span class="w"></span>

<span class="w">    </span><span class="nf">li</span><span class="w"> </span><span class="kc">$</span><span class="nv">t3</span><span class="p">,</span><span class="w"> </span><span class="mi">42</span><span class="w"></span>
<span class="w">    </span><span class="nf">sw</span><span class="w"> </span><span class="kc">$</span><span class="nv">t3</span><span class="p">,</span><span class="w"> </span><span class="nv">buffer</span><span class="w"></span>

<span class="w">    </span><span class="nf">sync</span><span class="w"></span>

<span class="w">    </span><span class="nf">sub</span><span class="w"> </span><span class="kc">$</span><span class="nv">t0</span><span class="p">,</span><span class="w"> </span><span class="kc">$</span><span class="nv">t0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">    </span><span class="nf">j</span><span class="w"> </span><span class="nv">produce_loop</span><span class="w"></span>

<span class="nl">end:</span><span class="w"></span>
<span class="w">    </span><span class="nf">jr</span><span class="w"> </span><span class="kc">$</span><span class="nv">ra</span><span class="w"></span>

<span class="nl">consumer:</span><span class="w"></span>
<span class="w">    </span><span class="nf">li</span><span class="w"> </span><span class="kc">$</span><span class="nv">t0</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="w"></span>
<span class="nl">consume_loop:</span><span class="w"></span>
<span class="w">    </span><span class="nf">bgtz</span><span class="w"> </span><span class="kc">$</span><span class="nv">t0</span><span class="p">,</span><span class="w"> </span><span class="nv">consume_item</span><span class="w"></span>
<span class="w">    </span><span class="nf">j</span><span class="w"> </span><span class="nv">end</span><span class="w"></span>

<span class="nl">consume_item:</span><span class="w"></span>
<span class="w">    </span><span class="c1"># Busy-wait until buffer is full</span><span class="w"></span>
<span class="nl">wait_full:</span><span class="w"></span>
<span class="w">    </span><span class="nf">ll</span><span class="w"> </span><span class="kc">$</span><span class="nv">t1</span><span class="p">,</span><span class="w"> </span><span class="nv">flag</span><span class="w"></span>
<span class="w">    </span><span class="nf">beqz</span><span class="w"> </span><span class="kc">$</span><span class="nv">t1</span><span class="p">,</span><span class="w"> </span><span class="nv">wait_full</span><span class="w"></span>

<span class="w">    </span><span class="nf">lw</span><span class="w"> </span><span class="kc">$</span><span class="nv">t3</span><span class="p">,</span><span class="w"> </span><span class="nv">buffer</span><span class="w"></span>
<span class="w">    </span><span class="nf">li</span><span class="w"> </span><span class="kc">$</span><span class="nv">t2</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="nf">sc</span><span class="w"> </span><span class="kc">$</span><span class="nv">t2</span><span class="p">,</span><span class="w"> </span><span class="nv">flag</span><span class="w"></span>
<span class="w">    </span><span class="nf">beqz</span><span class="w"> </span><span class="kc">$</span><span class="nv">t2</span><span class="p">,</span><span class="w"> </span><span class="nv">wait_full</span><span class="w"></span>

<span class="w">    </span><span class="nf">sync</span><span class="w"></span>

<span class="w">    </span><span class="nf">sub</span><span class="w"> </span><span class="kc">$</span><span class="nv">t0</span><span class="p">,</span><span class="w"> </span><span class="kc">$</span><span class="nv">t0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">    </span><span class="nf">j</span><span class="w"> </span><span class="nv">consume_loop</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="c-memory-order-lock-free-busy-waiting">
<h4><a class="toc-backref" href="#id40" role="doc-backlink">3. C++ Memory Order (Lock-Free, Busy-Waiting)</a><a class="headerlink" href="#c-memory-order-lock-free-busy-waiting" title="Permalink to this heading">¶</a></h4>
<p>This implementation uses <cite>std::memory_order</cite> for atomic synchronization.
It relies on <strong>lock-free operations</strong> and busy-waiting when the queue is full or empty.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;atomic&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;array&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;thread&gt;</span><span class="cp"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">SIZE</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">LockFreeQueue</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">SIZE</span><span class="o">&gt;</span><span class="w"> </span><span class="n">buffer</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">head</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tail</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span><span class="w"></span>

<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">enqueue</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">item</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="n">current_tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tail</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="n">next_tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">current_tail</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">SIZE</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">next_tail</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">head</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">))</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// Busy-wait</span>

<span class="w">        </span><span class="n">buffer</span><span class="p">[</span><span class="n">current_tail</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">item</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">tail</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">next_tail</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">dequeue</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">item</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="n">current_head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">current_head</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tail</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">))</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// Busy-wait</span>

<span class="w">        </span><span class="n">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buffer</span><span class="p">[</span><span class="n">current_head</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="n">head</span><span class="p">.</span><span class="n">store</span><span class="p">((</span><span class="n">current_head</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="n">LockFreeQueue</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="o">&gt;</span><span class="w"> </span><span class="n">queue</span><span class="p">;</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">producer</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">queue</span><span class="p">.</span><span class="n">enqueue</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Produced: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">consumer</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">item</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">queue</span><span class="p">.</span><span class="n">dequeue</span><span class="p">(</span><span class="n">item</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Consumed: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="w"> </span><span class="n">prod</span><span class="p">(</span><span class="n">producer</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="w"> </span><span class="n">cons</span><span class="p">(</span><span class="n">consumer</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">prod</span><span class="p">.</span><span class="n">join</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">cons</span><span class="p">.</span><span class="n">join</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="comparison-table">
<h4><a class="toc-backref" href="#id41" role="doc-backlink">Comparison Table</a><a class="headerlink" href="#comparison-table" title="Permalink to this heading">¶</a></h4>
<p>The following table summarizes the differences between the three implementations:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Approach</p></th>
<th class="head"><p>Blocking?</p></th>
<th class="head"><p>Busy-Waiting?</p></th>
<th class="head"><p>Performance</p></th>
<th class="head"><p>Scalability</p></th>
<th class="head"><p>Portability</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>Linux API (Busy-Waiting)</strong></p></td>
<td><p>No</p></td>
<td><p>Yes</p></td>
<td><p>Medium</p></td>
<td><p>Medium</p></td>
<td><p>High</p></td>
</tr>
<tr class="row-odd"><td><p><strong>MIPS (`ll`, `sc`, `sync`)</strong></p></td>
<td><p>No</p></td>
<td><p>Yes</p></td>
<td><p>High</p></td>
<td><p>Low</p></td>
<td><p>Low (MIPS Only)</p></td>
</tr>
<tr class="row-even"><td><p><strong>C++ `std::memory_order`</strong></p></td>
<td><p>No</p></td>
<td><p>Yes</p></td>
<td><p>High</p></td>
<td><p>High</p></td>
<td><p>High</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id11">
<h4><a class="toc-backref" href="#id42" role="doc-backlink">Conclusion</a><a class="headerlink" href="#id11" title="Permalink to this heading">¶</a></h4>
<ul class="simple">
<li><p>The <strong>Linux API version</strong> is <strong>portable</strong>, but suffers from <strong>busy-waiting inefficiency</strong>.</p></li>
<li><p>The <strong>MIPS atomic version</strong> is <strong>optimized for MIPS CPUs</strong>, but lacks <strong>portability</strong>.</p></li>
<li><p>The <strong>C++ memory order version</strong> is the best balance between <strong>performance and portability</strong>.</p></li>
</ul>
</section>
</section>
</section>
<section id="cpu0-implementation-for-memory-order">
<h2><a class="toc-backref" href="#id43" role="doc-backlink">Cpu0 implementation for memory-order</a><a class="headerlink" href="#cpu0-implementation-for-memory-order" title="Permalink to this heading">¶</a></h2>
<p>In order to support atomic in C++ and java, llvm provides the atomic IRs and
memory ordering here <a class="footnote-reference brackets" href="#atomics-llvm" id="id12" role="doc-noteref"><span class="fn-bracket">[</span>13<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#llvmlang-ordering" id="id13" role="doc-noteref"><span class="fn-bracket">[</span>14<span class="fn-bracket">]</span></a>.</p>
<p>The chapter 19
of book DPC++ <a class="footnote-reference brackets" href="#dpcpp-memorder" id="id14" role="doc-noteref"><span class="fn-bracket">[</span>15<span class="fn-bracket">]</span></a> explains the memory ordering better and I add
the related code fragment of lbdex/input/atomics.ll to it for explanation as
follows,</p>
<ul class="simple">
<li><p>memory_order::relaxed</p></li>
</ul>
<p>Read and write operations can be re-ordered before or after the operation with
no restrictions. There are no ordering guarantees.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">define i8 @load_i8_unordered(i8* %mem) {</span>
<span class="go">; CHECK-LABEL: load_i8_unordered</span>
<span class="go">; CHECK: ll</span>
<span class="go">; CHECK: sc</span>
<span class="go">; CHECK-NOT: sync</span>
<span class="gp">  %</span><span class="nv">val</span> <span class="o">=</span> load atomic i8, i8* %mem unordered, align <span class="m">1</span>
<span class="go">  ret i8 %val</span>
<span class="go">}</span>
</pre></div>
</div>
<p>No <strong>sync</strong> from CodeGen instructions above.</p>
<ul class="simple">
<li><p>memory_order::acquire</p></li>
</ul>
<p>Read and write operations appearing after the operation in the program must
occur after it (i.e., they cannot be re-ordered before the operation).</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">define i32 @load_i32_acquire(i32* %mem) {</span>
<span class="go">; CHECK-LABEL: load_i32_acquire</span>
<span class="go">; CHECK: ll</span>
<span class="go">; CHECK: sc</span>
<span class="gp">  %</span><span class="nv">val</span> <span class="o">=</span> load atomic i32, i32* %mem acquire, align <span class="m">4</span>
<span class="go">; CHECK: sync</span>
<span class="go">  ret i32 %val</span>
<span class="go">}</span>
</pre></div>
</div>
<p>Sync guarantees “load atomic” complete before the next R/W (Read/Write). All
writes in other threads that release the same atomic variable are visible in the
current thread.</p>
<ul class="simple">
<li><p>memory_order::release</p></li>
</ul>
<p>Read and write operations appearing before the operation in the program must
occur before it (i.e., they cannot be re-ordered after the operation), and
preceding write operations are guaranteed to be visible to other program
instances which have been synchronized by a corresponding acquire operation
(i.e., an atomic operation using the same variable and memory_order::acquire
or a barrier function).</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">define void @store_i32_release(i32* %mem) {</span>
<span class="go">; CHECK-LABEL: store_i32_release</span>
<span class="go">; CHECK: sync</span>
<span class="go">; CHECK: ll</span>
<span class="go">; CHECK: sc</span>
<span class="go">  store atomic i32 42, i32* %mem release, align 4</span>
<span class="go">  ret void</span>
<span class="go">}</span>
</pre></div>
</div>
<p>Sync guarantees preceding R/W complete before “store atomic”. Mips’ ll and sc
guarantee that “store atomic release” is visible to other processors.</p>
<ul class="simple">
<li><p>memory_order::acq_rel</p></li>
</ul>
<p>The operation acts as both an acquire and a release. Read and write operations
cannot be re-ordered around the operation, and preceding writes must be made
visible as previously described for memory_order::release.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">define i32 @cas_strong_i32_acqrel_acquire(i32* %mem) {</span>
<span class="go">; CHECK-LABEL: cas_strong_i32_acqrel_acquire</span>
<span class="go">; CHECK: ll</span>
<span class="go">; CHECK: sc</span>
<span class="gp">  %</span><span class="nv">val</span> <span class="o">=</span> cmpxchg i32* %mem, i32 <span class="m">0</span>, i32 <span class="m">1</span> acq_rel acquire
<span class="go">; CHECK: sync</span>
<span class="gp">  %</span><span class="nv">loaded</span> <span class="o">=</span> extractvalue <span class="o">{</span> i32, i1<span class="o">}</span> %val, <span class="m">0</span>
<span class="go">  ret i32 %loaded</span>
<span class="go">}</span>
</pre></div>
</div>
<p>Sync guarantees preceding R/W complete before “cmpxchg”. Other processors’
preceding write operations are guaranteed to be visible to this
“cmpxchg acquire” (Mips’s ll and sc quarantee it).</p>
<ul class="simple">
<li><p>memory_order::seq_cst</p></li>
</ul>
<p>The operation acts as an acquire, release, or both depending on whether it is
a read, write, or read-modify-write operation, respectively. All operations
with this memory order are observed in a sequentially consistent order.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">define i8 @cas_strong_i8_sc_sc(i8* %mem) {</span>
<span class="go">; CHECK-LABEL: cas_strong_i8_sc_sc</span>
<span class="go">; CHECK: sync</span>
<span class="go">; CHECK: ll</span>
<span class="go">; CHECK: sc</span>
<span class="gp">  %</span><span class="nv">val</span> <span class="o">=</span> cmpxchg i8* %mem, i8 <span class="m">0</span>, i8 <span class="m">1</span> seq_cst seq_cst
<span class="go">; CHECK: sync</span>
<span class="gp">  %</span><span class="nv">loaded</span> <span class="o">=</span> extractvalue <span class="o">{</span> i8, i1<span class="o">}</span> %val, <span class="m">0</span>
<span class="go">  ret i8 %loaded</span>
<span class="go">}</span>
</pre></div>
</div>
<p>First sync guarantees preceding R/W complete before “cmpxchg seq_cst” and
visible to “cmpxchg seq_cst”. For seq_cst, a store performs a release operation.
Which means “cmpxchg seq_cst” are visible to other threads/processors that
acquire the same atomic variable as the memory_order_release definition.
Mips’ ll and sc quarantees this feature of “cmpxchg seq_cst”.
Second Sync guarantees “cmpxchg seq_cst” complete before the next R/W.</p>
<p>There are several restrictions on which memory orders are supported by each
operation. <a class="reference internal" href="#c-f1"><span class="std std-numref">Fig. 58</span></a> (from book Figure 19-10) summarizes which
combinations are valid.</p>
<figure class="align-center" id="id22">
<span id="c-f1"></span><a class="reference internal image-reference" href="_images/Fig-19-10-book-dpc++.png"><img alt="_images/Fig-19-10-book-dpc++.png" src="_images/Fig-19-10-book-dpc++.png" style="width: 633.0px; height: 368.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 58 </span><span class="caption-text">Supporting atomic operations with memory_order</span><a class="headerlink" href="#id22" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>Load operations do not write values to memory and are therefore incompatible
with release semantics. Similarly, store operations do not read values from
memory and are therefore incompatible with acquire semantics. The remaining
read-modify-write atomic operations and fences are compatible with all memory
orderings <a class="footnote-reference brackets" href="#dpcpp-memorder" id="id15" role="doc-noteref"><span class="fn-bracket">[</span>15<span class="fn-bracket">]</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>C++ memory_order_consume</strong></p>
</div>
<figure class="align-center" id="id23">
<span id="c-f2"></span><a class="reference internal image-reference" href="_images/Fig-19-9-book-dpc++.png"><img alt="_images/Fig-19-9-book-dpc++.png" src="_images/Fig-19-9-book-dpc++.png" style="width: 578.0px; height: 594.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 59 </span><span class="caption-text">Comparing standard C++ and SYCL/DPC++ memory models</span><a class="headerlink" href="#id23" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>The C++ memory model additionally includes memory_order::consume, with similar
behavior to memory_order::acquire. however, the C++17 standard discourages its
use, noting that its definition is being revised. its inclusion in dpC++ has
therefore been postponed to a future version.</p>
<p>For a few years now, compilers have treated consume as a synonym for acquire
<a class="footnote-reference brackets" href="#cpp-memorder-consume-as-acquire" id="id16" role="doc-noteref"><span class="fn-bracket">[</span>16<span class="fn-bracket">]</span></a>.</p>
<p>The current expectation is that the replacement facility will rely on core
memory model and atomics definitions very similar to what’s currently there.
Since memory_order_consume does have a profound impact on the memory model,
removing this text would allow drastic simplification, but conversely would
make it very difficult to add anything along the lines of memory_order_consume
back in later, especially if the standard evolves in the meantime, as expected.
Thus we are not proposing to remove the current wording
<a class="footnote-reference brackets" href="#cpp-memorder-consume-remove" id="id17" role="doc-noteref"><span class="fn-bracket">[</span>17<span class="fn-bracket">]</span></a>.</p>
<p>The following test files are extracted from <cite>memory_checks()</cite> in
<cite>clang/test/Sema/atomic-ops.c</cite>. The <cite>__c11_atomic_xxx</cite> built-in functions used
by Clang are defined in <cite>clang/include/clang/Basic/Builtins.def</cite>. Compiling
these files with Clang produces the same results as shown in <a class="reference internal" href="#c-f1"><span class="std std-numref">Fig. 58</span></a>.</p>
<p>Note: Clang compiles <cite>memory_order_consume</cite> to the same result as
<cite>memory_order_acquire</cite>.</p>
<p class="rubric">lbdex/input/ch12_sema_atomic-ops.c</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">clang</span> <span class="o">-</span><span class="n">S</span> <span class="n">ch12_sema_atomic</span><span class="o">-</span><span class="n">ops</span><span class="o">.</span><span class="n">c</span> <span class="o">-</span><span class="n">emit</span><span class="o">-</span><span class="n">llvm</span> <span class="o">-</span><span class="n">o</span> <span class="o">-</span>
<span class="o">//</span> <span class="n">Uses</span> <span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">homebrew</span><span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">llvm</span><span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">clang</span> <span class="ow">in</span> <span class="n">macOS</span><span class="o">.</span>

<span class="c1">#include &lt;stdatomic.h&gt;</span>

<span class="o">//</span> <span class="n">From</span> <span class="n">memory_checks</span><span class="p">()</span> <span class="n">of</span> <span class="n">Sema</span><span class="o">/</span><span class="n">atomic</span><span class="o">-</span><span class="n">ops</span><span class="o">.</span><span class="n">c</span>
<span class="n">void</span> <span class="n">memory_checks</span><span class="p">(</span><span class="n">_Atomic</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span><span class="n">Ap</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="nb">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_load</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_load</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_load</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">memory_order_consume</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_load</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">);</span> <span class="o">//</span> <span class="n">expected</span><span class="o">-</span><span class="n">warning</span> <span class="p">{{</span><span class="n">memory</span> <span class="n">order</span> <span class="n">argument</span> <span class="n">to</span> <span class="n">atomic</span> <span class="n">operation</span> <span class="ow">is</span> <span class="n">invalid</span><span class="p">}}</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_load</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">);</span> <span class="o">//</span> <span class="n">expected</span><span class="o">-</span><span class="n">warning</span> <span class="p">{{</span><span class="n">memory</span> <span class="n">order</span> <span class="n">argument</span> <span class="n">to</span> <span class="n">atomic</span> <span class="n">operation</span> <span class="ow">is</span> <span class="n">invalid</span><span class="p">}}</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_load</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_load</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_load</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="o">//</span> <span class="n">expected</span><span class="o">-</span><span class="n">warning</span> <span class="p">{{</span><span class="n">memory</span> <span class="n">order</span> <span class="n">argument</span> <span class="n">to</span> <span class="n">atomic</span> <span class="n">operation</span> <span class="ow">is</span> <span class="n">invalid</span><span class="p">}}</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_load</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="mi">42</span><span class="p">);</span> <span class="o">//</span> <span class="n">expected</span><span class="o">-</span><span class="n">warning</span> <span class="p">{{</span><span class="n">memory</span> <span class="n">order</span> <span class="n">argument</span> <span class="n">to</span> <span class="n">atomic</span> <span class="n">operation</span> <span class="ow">is</span> <span class="n">invalid</span><span class="p">}}</span>

  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_store</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_store</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">);</span> <span class="o">//</span> <span class="n">expected</span><span class="o">-</span><span class="n">warning</span> <span class="p">{{</span><span class="n">memory</span> <span class="n">order</span> <span class="n">argument</span> <span class="n">to</span> <span class="n">atomic</span> <span class="n">operation</span> <span class="ow">is</span> <span class="n">invalid</span><span class="p">}}</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_store</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_consume</span><span class="p">);</span> <span class="o">//</span> <span class="n">expected</span><span class="o">-</span><span class="n">warning</span> <span class="p">{{</span><span class="n">memory</span> <span class="n">order</span> <span class="n">argument</span> <span class="n">to</span> <span class="n">atomic</span> <span class="n">operation</span> <span class="ow">is</span> <span class="n">invalid</span><span class="p">}}</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_store</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_store</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">);</span> <span class="o">//</span> <span class="n">expected</span><span class="o">-</span><span class="n">warning</span> <span class="p">{{</span><span class="n">memory</span> <span class="n">order</span> <span class="n">argument</span> <span class="n">to</span> <span class="n">atomic</span> <span class="n">operation</span> <span class="ow">is</span> <span class="n">invalid</span><span class="p">}}</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_store</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">);</span>

  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_exchange</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_exchange</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_exchange</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_consume</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_exchange</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_exchange</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_exchange</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">);</span>

  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_compare_exchange_strong</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_compare_exchange_strong</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_compare_exchange_strong</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_consume</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_compare_exchange_strong</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_compare_exchange_strong</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_compare_exchange_strong</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>

  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_compare_exchange_weak</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_compare_exchange_weak</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_compare_exchange_weak</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_consume</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_compare_exchange_weak</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_compare_exchange_weak</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_compare_exchange_weak</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>

  <span class="n">atomic_thread_fence</span><span class="p">(</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="n">atomic_thread_fence</span><span class="p">(</span><span class="n">memory_order_acquire</span><span class="p">);</span>
  <span class="n">atomic_thread_fence</span><span class="p">(</span><span class="n">memory_order_consume</span><span class="p">);</span> <span class="o">//</span> <span class="n">For</span> <span class="n">a</span> <span class="n">few</span> <span class="n">years</span> <span class="n">now</span><span class="p">,</span> <span class="n">compilers</span> <span class="n">have</span> <span class="n">treated</span> <span class="n">consume</span> <span class="k">as</span> <span class="n">a</span> <span class="n">synonym</span> <span class="k">for</span> <span class="n">acquire</span><span class="o">.</span>
  <span class="n">atomic_thread_fence</span><span class="p">(</span><span class="n">memory_order_release</span><span class="p">);</span>
  <span class="n">atomic_thread_fence</span><span class="p">(</span><span class="n">memory_order_acq_rel</span><span class="p">);</span>
  <span class="n">atomic_thread_fence</span><span class="p">(</span><span class="n">memory_order_seq_cst</span><span class="p">);</span>
  <span class="n">atomic_signal_fence</span><span class="p">(</span><span class="n">memory_order_seq_cst</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/input/ch12_sema_atomic-fetch.c</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">clang</span> <span class="o">-</span><span class="n">S</span> <span class="n">ch12_sema_atomic</span><span class="o">-</span><span class="n">fetch</span><span class="o">.</span><span class="n">c</span> <span class="o">-</span><span class="n">emit</span><span class="o">-</span><span class="n">llvm</span> <span class="o">-</span><span class="n">o</span> <span class="o">-</span>
<span class="o">//</span> <span class="n">Uses</span> <span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">homebrew</span><span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">llvm</span><span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">clang</span> <span class="ow">in</span> <span class="n">macOS</span><span class="o">.</span>

<span class="c1">#include &lt;stdatomic.h&gt;</span>

<span class="o">//</span><span class="c1">#define WANT_COMPILE_FAIL</span>

<span class="o">//</span> <span class="n">From</span> <span class="n">__c11_atomic_fetch_xxx</span> <span class="n">of</span> <span class="n">memory_checks</span><span class="p">()</span> <span class="n">of</span> <span class="n">Sema</span><span class="o">/</span><span class="n">atomic</span><span class="o">-</span><span class="n">ops</span><span class="o">.</span><span class="n">c</span>
<span class="n">void</span> <span class="n">memory_checks</span><span class="p">(</span><span class="n">_Atomic</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span><span class="n">Ap</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="nb">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_add</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_add</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_add</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">memory_order_consume</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_add</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_add</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_add</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">);</span>

<span class="c1">#ifdef WANT_COMPILE_FAIL // fail to compile:</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_add</span><span class="p">(</span>
      <span class="p">(</span><span class="n">struct</span> <span class="n">Incomplete</span> <span class="o">*</span> <span class="n">_Atomic</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,</span> <span class="o">//</span> <span class="n">expected</span><span class="o">-</span><span class="n">error</span> <span class="p">{{</span><span class="n">incomplete</span> <span class="nb">type</span> <span class="s1">&#39;struct Incomplete&#39;</span><span class="p">}}</span>
      <span class="mi">1</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">);</span>
<span class="c1">#endif</span>

  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_init</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_init</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_init</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_init</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_init</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_init</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_sub</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_sub</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_sub</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_consume</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_sub</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_sub</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_sub</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">);</span>

  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_and</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_and</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_and</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_consume</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_and</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_and</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_and</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">);</span>

  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_or</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_or</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_or</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_consume</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_or</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_or</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_or</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">);</span>

  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_xor</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_xor</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_xor</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_consume</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_xor</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_xor</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_xor</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">);</span>

  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_nand</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_nand</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_nand</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_consume</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_nand</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_nand</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_nand</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">);</span>

  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_min</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_min</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_min</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_consume</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_min</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_min</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_min</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">);</span>

  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_max</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_max</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_max</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_consume</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_max</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_max</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_max</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<table class="docutils align-default" id="id24">
<caption><span class="caption-number">Table 42 </span><span class="caption-text">Atomic related between clang’s builtin and llvm ir</span><a class="headerlink" href="#id24" title="Permalink to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>clang’s builtin</p></th>
<th class="head"><p>llvm ir</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>__c11_atomic_load</p></td>
<td><p>load atomic</p></td>
</tr>
<tr class="row-odd"><td><p>__c11_atomic_store</p></td>
<td><p>store atomic</p></td>
</tr>
<tr class="row-even"><td><p>__c11_atomic_exchange_xxx</p></td>
<td><p>cmpxchg</p></td>
</tr>
<tr class="row-odd"><td><p>atomic_thread_fence</p></td>
<td><p>fence</p></td>
</tr>
<tr class="row-even"><td><p>__c11_atomic_fetch_xxx</p></td>
<td><p>atomicrmw xxx</p></td>
</tr>
</tbody>
</table>
<p>C++ atomic functions are supported by calling implementation functions from the
C++ standard library. These functions eventually call the <cite>__c11_atomic_xxx</cite>
built-in functions for actual implementation.</p>
<p>Therefore, <cite>__c11_atomic_xxx</cite> functions, listed above, provide a lower-level and
higher-performance interface for C++ programmers. An example is shown below:</p>
<p class="rubric">lbdex/input/ch12_c++_atomics.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">clang</span> <span class="o">-</span><span class="n">S</span> <span class="n">ch12_c</span><span class="o">++</span><span class="n">_atomics</span><span class="o">.</span><span class="n">cpp</span> <span class="o">-</span><span class="n">emit</span><span class="o">-</span><span class="n">llvm</span> <span class="o">-</span><span class="n">o</span> <span class="o">-</span>
<span class="o">//</span> <span class="n">Uses</span> <span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">homebrew</span><span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">llvm</span><span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">clang</span> <span class="ow">in</span> <span class="n">macOS</span><span class="o">.</span>

<span class="c1">#include &lt;atomic&gt;</span>

<span class="n">std</span><span class="p">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="nb">bool</span><span class="o">&gt;</span> <span class="n">winner</span> <span class="p">(</span><span class="n">false</span><span class="p">);</span>

<span class="nb">int</span> <span class="n">test_atomics</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nb">bool</span> <span class="n">res</span> <span class="o">=</span> <span class="n">winner</span><span class="o">.</span><span class="n">exchange</span><span class="p">(</span><span class="n">true</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="n">count</span><span class="o">++</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To support LLVM atomic IR instructions, the following code is added to
Chapter12_1.</p>
<p class="rubric">lbdex/chapters/Chapter12_1/Disassembler/Cpu0Disassembler.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">static</span> <span class="n">DecodeStatus</span> <span class="n">DecodeMem</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span>
                              <span class="n">unsigned</span> <span class="n">Insn</span><span class="p">,</span>
                              <span class="n">uint64_t</span> <span class="n">Address</span><span class="p">,</span>
                              <span class="n">const</span> <span class="n">void</span> <span class="o">*</span><span class="n">Decoder</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">if</span><span class="p">(</span><span class="n">Inst</span><span class="o">.</span><span class="n">getOpcode</span><span class="p">()</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">SC</span><span class="p">){</span>
    <span class="n">Inst</span><span class="o">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="p">::</span><span class="n">createReg</span><span class="p">(</span><span class="n">Reg</span><span class="p">));</span>
  <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0InstrInfo.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">SDT_Sync</span>             <span class="p">:</span> <span class="n">SDTypeProfile</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="n">SDTCisVT</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">i32</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">Cpu0Sync</span> <span class="p">:</span> <span class="n">SDNode</span><span class="o">&lt;</span><span class="s2">&quot;Cpu0ISD::Sync&quot;</span><span class="p">,</span> <span class="n">SDT_Sync</span><span class="p">,</span> <span class="p">[</span><span class="n">SDNPHasChain</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">PtrRC</span> <span class="p">:</span> <span class="n">Operand</span><span class="o">&lt;</span><span class="n">iPTR</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">let</span> <span class="n">MIOperandInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">ops</span> <span class="n">ptr_rc</span><span class="p">);</span>
  <span class="n">let</span> <span class="n">DecoderMethod</span> <span class="o">=</span> <span class="s2">&quot;DecodeCPURegsRegisterClass&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// Atomic instructions with 2 source operands (ATOMIC_SWAP &amp; ATOMIC_LOAD_*).
class Atomic2Ops&lt;PatFrag Op, RegisterClass DRC&gt; :
  PseudoSE&lt;(outs DRC:$dst), (ins PtrRC:$ptr, DRC:$incr),
           [(set DRC:$dst, (Op iPTR:$ptr, DRC:$incr))]&gt;;

// Atomic Compare &amp; Swap.
class AtomicCmpSwap&lt;PatFrag Op, RegisterClass DRC&gt; :
  PseudoSE&lt;(outs DRC:$dst), (ins PtrRC:$ptr, DRC:$cmp, DRC:$swap),
           [(set DRC:$dst, (Op iPTR:$ptr, DRC:$cmp, DRC:$swap))]&gt;;
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>class LLBase&lt;bits&lt;8&gt; Opc, string opstring, RegisterClass RC, Operand Mem&gt; :
  FMem&lt;Opc, (outs RC:$ra), (ins Mem:$addr),
       !strconcat(opstring, &quot;\t$ra, $addr&quot;), [], IILoad&gt; {
  let mayLoad = 1;
}

class SCBase&lt;bits&lt;8&gt; Opc, string opstring, RegisterOperand RO, Operand Mem&gt; :
  FMem&lt;Opc, (outs RO:$dst), (ins RO:$ra, Mem:$addr),
       !strconcat(opstring, &quot;\t$ra, $addr&quot;), [], IIStore&gt; {
  let mayStore = 1;
  let Constraints = &quot;$ra = $dst&quot;;
}
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ch12_1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">{</span>
<span class="n">let</span> <span class="n">usesCustomInserter</span> <span class="o">=</span> <span class="mi">1</span> <span class="ow">in</span> <span class="p">{</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_ADD_I8</span>   <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_add_8</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_ADD_I16</span>  <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_add_16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_ADD_I32</span>  <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_add_32</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_SUB_I8</span>   <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_sub_8</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_SUB_I16</span>  <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_sub_16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_SUB_I32</span>  <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_sub_32</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_AND_I8</span>   <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_and_8</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_AND_I16</span>  <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_and_16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_AND_I32</span>  <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_and_32</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_OR_I8</span>    <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_or_8</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_OR_I16</span>   <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_or_16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_OR_I32</span>   <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_or_32</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_XOR_I8</span>   <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_xor_8</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_XOR_I16</span>  <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_xor_16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_XOR_I32</span>  <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_xor_32</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_NAND_I8</span>  <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_nand_8</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_NAND_I16</span> <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_nand_16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_NAND_I32</span> <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_nand_32</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>

  <span class="k">def</span> <span class="nf">ATOMIC_SWAP_I8</span>       <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_swap_8</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_SWAP_I16</span>      <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_swap_16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_SWAP_I32</span>      <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_swap_32</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>

  <span class="k">def</span> <span class="nf">ATOMIC_CMP_SWAP_I8</span>   <span class="p">:</span> <span class="n">AtomicCmpSwap</span><span class="o">&lt;</span><span class="n">atomic_cmp_swap_8</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_CMP_SWAP_I16</span>  <span class="p">:</span> <span class="n">AtomicCmpSwap</span><span class="o">&lt;</span><span class="n">atomic_cmp_swap_16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_CMP_SWAP_I32</span>  <span class="p">:</span> <span class="n">AtomicCmpSwap</span><span class="o">&lt;</span><span class="n">atomic_cmp_swap_32</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>let Predicates = [Ch12_1] in {
let hasSideEffects = 1 in
def SYNC : Cpu0Inst&lt;(outs), (ins i32imm:$stype), &quot;sync $stype&quot;,
                    [(Cpu0Sync imm:$stype)], NoItinerary, FrmOther&gt;
{
  bits&lt;5&gt; stype;
  let Opcode = 0x60;
  let Inst{25-11} = 0;
  let Inst{10-6} = stype;
  let Inst{5-0} = 0;
}
}
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">///</span> <span class="n">Load</span><span class="o">-</span><span class="n">linked</span><span class="p">,</span> <span class="n">Store</span><span class="o">-</span><span class="n">conditional</span>
<span class="k">def</span> <span class="nf">LL</span>      <span class="p">:</span> <span class="n">LLBase</span><span class="o">&lt;</span><span class="mh">0x61</span><span class="p">,</span> <span class="s2">&quot;ll&quot;</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="n">mem</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">SC</span>      <span class="p">:</span> <span class="n">SCBase</span><span class="o">&lt;</span><span class="mh">0x62</span><span class="p">,</span> <span class="s2">&quot;sc&quot;</span><span class="p">,</span> <span class="n">RegisterOperand</span><span class="o">&lt;</span><span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">mem</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="p">:</span> <span class="n">Cpu0InstAlias</span><span class="o">&lt;</span><span class="s2">&quot;sync&quot;</span><span class="p">,</span>
                    <span class="p">(</span><span class="n">SYNC</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0ISelLowering.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">MachineBasicBlock</span> <span class="o">*</span>
    <span class="n">EmitInstrWithCustomInserter</span><span class="p">(</span><span class="n">MachineInstr</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">,</span>
                                <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">MBB</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">SDValue</span> <span class="n">lowerATOMIC_FENCE</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span><span class="o">&amp;</span> <span class="n">DAG</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="nb">bool</span> <span class="n">shouldInsertFencesForAtomic</span><span class="p">(</span><span class="n">const</span> <span class="n">Instruction</span> <span class="o">*</span><span class="n">I</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="o">///</span> <span class="n">Emit</span> <span class="n">a</span> <span class="n">sign</span><span class="o">-</span><span class="n">extension</span> <span class="n">using</span> <span class="n">shl</span><span class="o">/</span><span class="n">sra</span> <span class="n">appropriately</span><span class="o">.</span>
    <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">emitSignExtendToI32InReg</span><span class="p">(</span><span class="n">MachineInstr</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">,</span>
                                                <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">BB</span><span class="p">,</span>
                                                <span class="n">unsigned</span> <span class="n">Size</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">DstReg</span><span class="p">,</span>
                                                <span class="n">unsigned</span> <span class="n">SrcRec</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
    <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">emitAtomicBinary</span><span class="p">(</span><span class="n">MachineInstr</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">,</span> <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">BB</span><span class="p">,</span>
                    <span class="n">unsigned</span> <span class="n">Size</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">BinOpcode</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">Nand</span> <span class="o">=</span> <span class="n">false</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
    <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">emitAtomicBinaryPartword</span><span class="p">(</span><span class="n">MachineInstr</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">,</span>
                    <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">BB</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">Size</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">BinOpcode</span><span class="p">,</span>
                    <span class="nb">bool</span> <span class="n">Nand</span> <span class="o">=</span> <span class="n">false</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
    <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">emitAtomicCmpSwap</span><span class="p">(</span><span class="n">MachineInstr</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">,</span>
                                  <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">BB</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">Size</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
    <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">emitAtomicCmpSwapPartword</span><span class="p">(</span><span class="n">MachineInstr</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">,</span>
                                  <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">BB</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">Size</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0SelLowering.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">getTargetNodeName</span><span class="p">(</span><span class="n">unsigned</span> <span class="n">Opcode</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">case</span> <span class="n">Cpu0ISD</span><span class="p">::</span><span class="n">Sync</span><span class="p">:</span>              <span class="k">return</span> <span class="s2">&quot;Cpu0ISD::Sync&quot;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="n">const</span> <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">,</span>
                                       <span class="n">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span>
    <span class="p">:</span> <span class="n">TargetLowering</span><span class="p">(</span><span class="n">TM</span><span class="p">),</span> <span class="n">Subtarget</span><span class="p">(</span><span class="n">STI</span><span class="p">),</span> <span class="n">ABI</span><span class="p">(</span><span class="n">TM</span><span class="o">.</span><span class="n">getABI</span><span class="p">())</span> <span class="p">{</span>

</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">ATOMIC_LOAD</span><span class="p">,</span>       <span class="n">MVT</span><span class="p">::</span><span class="n">i32</span><span class="p">,</span>    <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">ATOMIC_LOAD</span><span class="p">,</span>       <span class="n">MVT</span><span class="p">::</span><span class="n">i64</span><span class="p">,</span>    <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">ATOMIC_STORE</span><span class="p">,</span>      <span class="n">MVT</span><span class="p">::</span><span class="n">i32</span><span class="p">,</span>    <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">ATOMIC_STORE</span><span class="p">,</span>      <span class="n">MVT</span><span class="p">::</span><span class="n">i64</span><span class="p">,</span>    <span class="n">Expand</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="p">::</span>
<span class="n">LowerOperation</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span>
<span class="p">{</span>
  <span class="n">switch</span> <span class="p">(</span><span class="n">Op</span><span class="o">.</span><span class="n">getOpcode</span><span class="p">())</span>
  <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">case</span> <span class="n">ISD</span><span class="p">::</span><span class="n">ATOMIC_FENCE</span><span class="p">:</span>       <span class="k">return</span> <span class="n">lowerATOMIC_FENCE</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>MachineBasicBlock *
Cpu0TargetLowering::EmitInstrWithCustomInserter(MachineInstr &amp;MI,
                                                MachineBasicBlock *BB) const {
  switch (MI.getOpcode()) {
  default:
    llvm_unreachable(&quot;Unexpected instr type to insert&quot;);
  case Cpu0::ATOMIC_LOAD_ADD_I8:
    return emitAtomicBinaryPartword(MI, BB, 1, Cpu0::ADDu);
  case Cpu0::ATOMIC_LOAD_ADD_I16:
    return emitAtomicBinaryPartword(MI, BB, 2, Cpu0::ADDu);
  case Cpu0::ATOMIC_LOAD_ADD_I32:
    return emitAtomicBinary(MI, BB, 4, Cpu0::ADDu);

  case Cpu0::ATOMIC_LOAD_AND_I8:
    return emitAtomicBinaryPartword(MI, BB, 1, Cpu0::AND);
  case Cpu0::ATOMIC_LOAD_AND_I16:
    return emitAtomicBinaryPartword(MI, BB, 2, Cpu0::AND);
  case Cpu0::ATOMIC_LOAD_AND_I32:
    return emitAtomicBinary(MI, BB, 4, Cpu0::AND);

  case Cpu0::ATOMIC_LOAD_OR_I8:
    return emitAtomicBinaryPartword(MI, BB, 1, Cpu0::OR);
  case Cpu0::ATOMIC_LOAD_OR_I16:
    return emitAtomicBinaryPartword(MI, BB, 2, Cpu0::OR);
  case Cpu0::ATOMIC_LOAD_OR_I32:
    return emitAtomicBinary(MI, BB, 4, Cpu0::OR);

  case Cpu0::ATOMIC_LOAD_XOR_I8:
    return emitAtomicBinaryPartword(MI, BB, 1, Cpu0::XOR);
  case Cpu0::ATOMIC_LOAD_XOR_I16:
    return emitAtomicBinaryPartword(MI, BB, 2, Cpu0::XOR);
  case Cpu0::ATOMIC_LOAD_XOR_I32:
    return emitAtomicBinary(MI, BB, 4, Cpu0::XOR);

  case Cpu0::ATOMIC_LOAD_NAND_I8:
    return emitAtomicBinaryPartword(MI, BB, 1, 0, true);
  case Cpu0::ATOMIC_LOAD_NAND_I16:
    return emitAtomicBinaryPartword(MI, BB, 2, 0, true);
  case Cpu0::ATOMIC_LOAD_NAND_I32:
    return emitAtomicBinary(MI, BB, 4, 0, true);

  case Cpu0::ATOMIC_LOAD_SUB_I8:
    return emitAtomicBinaryPartword(MI, BB, 1, Cpu0::SUBu);
  case Cpu0::ATOMIC_LOAD_SUB_I16:
    return emitAtomicBinaryPartword(MI, BB, 2, Cpu0::SUBu);
  case Cpu0::ATOMIC_LOAD_SUB_I32:
    return emitAtomicBinary(MI, BB, 4, Cpu0::SUBu);

  case Cpu0::ATOMIC_SWAP_I8:
    return emitAtomicBinaryPartword(MI, BB, 1, 0);
  case Cpu0::ATOMIC_SWAP_I16:
    return emitAtomicBinaryPartword(MI, BB, 2, 0);
  case Cpu0::ATOMIC_SWAP_I32:
    return emitAtomicBinary(MI, BB, 4, 0);

  case Cpu0::ATOMIC_CMP_SWAP_I8:
    return emitAtomicCmpSwapPartword(MI, BB, 1);
  case Cpu0::ATOMIC_CMP_SWAP_I16:
    return emitAtomicCmpSwapPartword(MI, BB, 2);
  case Cpu0::ATOMIC_CMP_SWAP_I32:
    return emitAtomicCmpSwap(MI, BB, 4);
  }
}

// This function also handles Cpu0::ATOMIC_SWAP_I32 (when BinOpcode == 0), and
// Cpu0::ATOMIC_LOAD_NAND_I32 (when Nand == true)
MachineBasicBlock *Cpu0TargetLowering::emitAtomicBinary(
    MachineInstr &amp;MI, MachineBasicBlock *BB, unsigned Size, unsigned BinOpcode,
    bool Nand) const {
  assert((Size == 4) &amp;&amp; &quot;Unsupported size for EmitAtomicBinary.&quot;);

  MachineFunction *MF = BB-&gt;getParent();
  MachineRegisterInfo &amp;RegInfo = MF-&gt;getRegInfo();
  const TargetRegisterClass *RC = getRegClassFor(MVT::getIntegerVT(Size * 8));
  const TargetInstrInfo *TII = Subtarget.getInstrInfo();
  DebugLoc DL = MI.getDebugLoc();
  unsigned LL, SC, AND, XOR, ZERO, BEQ;

  LL = Cpu0::LL;
  SC = Cpu0::SC;
  AND = Cpu0::AND;
  XOR = Cpu0::XOR;
  ZERO = Cpu0::ZERO;
  BEQ = Cpu0::BEQ;

  unsigned OldVal = MI.getOperand(0).getReg();
  unsigned Ptr = MI.getOperand(1).getReg();
  unsigned Incr = MI.getOperand(2).getReg();

  unsigned StoreVal = RegInfo.createVirtualRegister(RC);
  unsigned AndRes = RegInfo.createVirtualRegister(RC);
  unsigned AndRes2 = RegInfo.createVirtualRegister(RC);
  unsigned Success = RegInfo.createVirtualRegister(RC);

  // insert new blocks after the current block
  const BasicBlock *LLVM_BB = BB-&gt;getBasicBlock();
  MachineBasicBlock *loopMBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineBasicBlock *exitMBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineFunction::iterator It = ++BB-&gt;getIterator();
  MF-&gt;insert(It, loopMBB);
  MF-&gt;insert(It, exitMBB);

  // Transfer the remainder of BB and its successor edges to exitMBB.
  exitMBB-&gt;splice(exitMBB-&gt;begin(), BB,
                  std::next(MachineBasicBlock::iterator(MI)), BB-&gt;end());
  exitMBB-&gt;transferSuccessorsAndUpdatePHIs(BB);

  //  thisMBB:
  //    ...
  //    fallthrough --&gt; loopMBB
  BB-&gt;addSuccessor(loopMBB);
  loopMBB-&gt;addSuccessor(loopMBB);
  loopMBB-&gt;addSuccessor(exitMBB);

  //  loopMBB:
  //    ll oldval, 0(ptr)
  //    &lt;binop&gt; storeval, oldval, incr
  //    sc success, storeval, 0(ptr)
  //    beq success, $0, loopMBB
  BB = loopMBB;
  BuildMI(BB, DL, TII-&gt;get(LL), OldVal).addReg(Ptr).addImm(0);
  if (Nand) {
    //  and andres, oldval, incr
    //  xor storeval, $0, andres
    //  xor storeval2, $0, storeval
    BuildMI(BB, DL, TII-&gt;get(AND), AndRes).addReg(OldVal).addReg(Incr);
    BuildMI(BB, DL, TII-&gt;get(XOR), StoreVal).addReg(ZERO).addReg(AndRes);
    BuildMI(BB, DL, TII-&gt;get(XOR), AndRes2).addReg(ZERO).addReg(AndRes);
  } else if (BinOpcode) {
    //  &lt;binop&gt; storeval, oldval, incr
    BuildMI(BB, DL, TII-&gt;get(BinOpcode), StoreVal).addReg(OldVal).addReg(Incr);
  } else {
    StoreVal = Incr;
  }
  BuildMI(BB, DL, TII-&gt;get(SC), Success).addReg(StoreVal).addReg(Ptr).addImm(0);
  BuildMI(BB, DL, TII-&gt;get(BEQ)).addReg(Success).addReg(ZERO).addMBB(loopMBB);

  MI.eraseFromParent(); // The instruction is gone now.

  return exitMBB;
}

MachineBasicBlock *Cpu0TargetLowering::emitSignExtendToI32InReg(
    MachineInstr &amp;MI, MachineBasicBlock *BB, unsigned Size, unsigned DstReg,
    unsigned SrcReg) const {
  const TargetInstrInfo *TII = Subtarget.getInstrInfo();
  DebugLoc DL = MI.getDebugLoc();

  MachineFunction *MF = BB-&gt;getParent();
  MachineRegisterInfo &amp;RegInfo = MF-&gt;getRegInfo();
  const TargetRegisterClass *RC = getRegClassFor(MVT::i32);
  unsigned ScrReg = RegInfo.createVirtualRegister(RC);

  assert(Size &lt; 32);
  int64_t ShiftImm = 32 - (Size * 8);

  BuildMI(BB, DL, TII-&gt;get(Cpu0::SHL), ScrReg).addReg(SrcReg).addImm(ShiftImm);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::SRA), DstReg).addReg(ScrReg).addImm(ShiftImm);

  return BB;
}

MachineBasicBlock *Cpu0TargetLowering::emitAtomicBinaryPartword(
    MachineInstr &amp;MI, MachineBasicBlock *BB, unsigned Size, unsigned BinOpcode,
    bool Nand) const {
  assert((Size == 1 || Size == 2) &amp;&amp;
         &quot;Unsupported size for EmitAtomicBinaryPartial.&quot;);

  MachineFunction *MF = BB-&gt;getParent();
  MachineRegisterInfo &amp;RegInfo = MF-&gt;getRegInfo();
  const TargetRegisterClass *RC = getRegClassFor(MVT::i32);
  const TargetInstrInfo *TII = Subtarget.getInstrInfo();
  DebugLoc DL = MI.getDebugLoc();

  unsigned Dest = MI.getOperand(0).getReg();
  unsigned Ptr = MI.getOperand(1).getReg();
  unsigned Incr = MI.getOperand(2).getReg();

  unsigned AlignedAddr = RegInfo.createVirtualRegister(RC);
  unsigned ShiftAmt = RegInfo.createVirtualRegister(RC);
  unsigned Mask = RegInfo.createVirtualRegister(RC);
  unsigned Mask2 = RegInfo.createVirtualRegister(RC);
  unsigned Mask3 = RegInfo.createVirtualRegister(RC);
  unsigned NewVal = RegInfo.createVirtualRegister(RC);
  unsigned OldVal = RegInfo.createVirtualRegister(RC);
  unsigned Incr2 = RegInfo.createVirtualRegister(RC);
  unsigned MaskLSB2 = RegInfo.createVirtualRegister(RC);
  unsigned PtrLSB2 = RegInfo.createVirtualRegister(RC);
  unsigned MaskUpper = RegInfo.createVirtualRegister(RC);
  unsigned AndRes = RegInfo.createVirtualRegister(RC);
  unsigned BinOpRes = RegInfo.createVirtualRegister(RC);
  unsigned BinOpRes2 = RegInfo.createVirtualRegister(RC);
  unsigned MaskedOldVal0 = RegInfo.createVirtualRegister(RC);
  unsigned StoreVal = RegInfo.createVirtualRegister(RC);
  unsigned MaskedOldVal1 = RegInfo.createVirtualRegister(RC);
  unsigned SrlRes = RegInfo.createVirtualRegister(RC);
  unsigned Success = RegInfo.createVirtualRegister(RC);

  // insert new blocks after the current block
  const BasicBlock *LLVM_BB = BB-&gt;getBasicBlock();
  MachineBasicBlock *loopMBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineBasicBlock *sinkMBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineBasicBlock *exitMBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineFunction::iterator It = ++BB-&gt;getIterator();

  MF-&gt;insert(It, loopMBB);
  MF-&gt;insert(It, sinkMBB);
  MF-&gt;insert(It, exitMBB);

  // Transfer the remainder of BB and its successor edges to exitMBB.
  exitMBB-&gt;splice(exitMBB-&gt;begin(), BB,
                  std::next(MachineBasicBlock::iterator(MI)), BB-&gt;end());
  exitMBB-&gt;transferSuccessorsAndUpdatePHIs(BB);

  BB-&gt;addSuccessor(loopMBB);
  loopMBB-&gt;addSuccessor(loopMBB);
  loopMBB-&gt;addSuccessor(sinkMBB);
  sinkMBB-&gt;addSuccessor(exitMBB);

  //  thisMBB:
  //    addiu   masklsb2,$0,-4                # 0xfffffffc
  //    and     alignedaddr,ptr,masklsb2
  //    andi    ptrlsb2,ptr,3
  //    sll     shiftamt,ptrlsb2,3
  //    ori     maskupper,$0,255               # 0xff
  //    sll     mask,maskupper,shiftamt
  //    xor     mask2,$0,mask
  //    xor     mask3,$0,mask2
  //    sll     incr2,incr,shiftamt

  int64_t MaskImm = (Size == 1) ? 255 : 65535;
  BuildMI(BB, DL, TII-&gt;get(Cpu0::ADDiu), MaskLSB2)
    .addReg(Cpu0::ZERO).addImm(-4);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::AND), AlignedAddr)
    .addReg(Ptr).addReg(MaskLSB2);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::ANDi), PtrLSB2).addReg(Ptr).addImm(3);
  if (Subtarget.isLittle()) {
    BuildMI(BB, DL, TII-&gt;get(Cpu0::SHL), ShiftAmt).addReg(PtrLSB2).addImm(3);
  } else {
    unsigned Off = RegInfo.createVirtualRegister(RC);
    BuildMI(BB, DL, TII-&gt;get(Cpu0::XORi), Off)
      .addReg(PtrLSB2).addImm((Size == 1) ? 3 : 2);
    BuildMI(BB, DL, TII-&gt;get(Cpu0::SHL), ShiftAmt).addReg(Off).addImm(3);
  }
  BuildMI(BB, DL, TII-&gt;get(Cpu0::ORi), MaskUpper)
    .addReg(Cpu0::ZERO).addImm(MaskImm);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::SHLV), Mask)
    .addReg(MaskUpper).addReg(ShiftAmt);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::XOR), Mask2).addReg(Cpu0::ZERO).addReg(Mask);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::XOR), Mask3).addReg(Cpu0::ZERO).addReg(Mask2);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::SHLV), Incr2).addReg(Incr).addReg(ShiftAmt);

  // atomic.load.binop
  // loopMBB:
  //   ll      oldval,0(alignedaddr)
  //   binop   binopres,oldval,incr2
  //   and     newval,binopres,mask
  //   and     maskedoldval0,oldval,mask3
  //   or      storeval,maskedoldval0,newval
  //   sc      success,storeval,0(alignedaddr)
  //   beq     success,$0,loopMBB

  // atomic.swap
  // loopMBB:
  //   ll      oldval,0(alignedaddr)
  //   and     newval,incr2,mask
  //   and     maskedoldval0,oldval,mask3
  //   or      storeval,maskedoldval0,newval
  //   sc      success,storeval,0(alignedaddr)
  //   beq     success,$0,loopMBB

  BB = loopMBB;
  unsigned LL = Cpu0::LL;
  BuildMI(BB, DL, TII-&gt;get(LL), OldVal).addReg(AlignedAddr).addImm(0);
  if (Nand) {
    //  and andres, oldval, incr2
    //  xor binopres,  $0, andres
    //  xor binopres2, $0, binopres
    //  and newval, binopres, mask
    BuildMI(BB, DL, TII-&gt;get(Cpu0::AND), AndRes).addReg(OldVal).addReg(Incr2);
    BuildMI(BB, DL, TII-&gt;get(Cpu0::XOR), BinOpRes)
      .addReg(Cpu0::ZERO).addReg(AndRes);
    BuildMI(BB, DL, TII-&gt;get(Cpu0::XOR), BinOpRes2)
      .addReg(Cpu0::ZERO).addReg(BinOpRes);
    BuildMI(BB, DL, TII-&gt;get(Cpu0::AND), NewVal).addReg(BinOpRes).addReg(Mask);
  } else if (BinOpcode) {
    //  &lt;binop&gt; binopres, oldval, incr2
    //  and newval, binopres, mask
    BuildMI(BB, DL, TII-&gt;get(BinOpcode), BinOpRes).addReg(OldVal).addReg(Incr2);
    BuildMI(BB, DL, TII-&gt;get(Cpu0::AND), NewVal).addReg(BinOpRes).addReg(Mask);
  } else { // atomic.swap
    //  and newval, incr2, mask
    BuildMI(BB, DL, TII-&gt;get(Cpu0::AND), NewVal).addReg(Incr2).addReg(Mask);
  }

  BuildMI(BB, DL, TII-&gt;get(Cpu0::AND), MaskedOldVal0)
    .addReg(OldVal).addReg(Mask2);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::OR), StoreVal)
    .addReg(MaskedOldVal0).addReg(NewVal);
  unsigned SC = Cpu0::SC;
  BuildMI(BB, DL, TII-&gt;get(SC), Success)
    .addReg(StoreVal).addReg(AlignedAddr).addImm(0);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::BEQ))
    .addReg(Success).addReg(Cpu0::ZERO).addMBB(loopMBB);

  //  sinkMBB:
  //    and     maskedoldval1,oldval,mask
  //    srl     srlres,maskedoldval1,shiftamt
  //    sign_extend dest,srlres
  BB = sinkMBB;

  BuildMI(BB, DL, TII-&gt;get(Cpu0::AND), MaskedOldVal1)
    .addReg(OldVal).addReg(Mask);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::SHRV), SrlRes)
      .addReg(MaskedOldVal1).addReg(ShiftAmt);
  BB = emitSignExtendToI32InReg(MI, BB, Size, Dest, SrlRes);

  MI.eraseFromParent(); // The instruction is gone now.

  return exitMBB;
}

MachineBasicBlock * Cpu0TargetLowering::emitAtomicCmpSwap(MachineInstr &amp;MI,
                                                          MachineBasicBlock *BB,
                                                          unsigned Size) const {
  assert((Size == 4) &amp;&amp; &quot;Unsupported size for EmitAtomicCmpSwap.&quot;);

  MachineFunction *MF = BB-&gt;getParent();
  MachineRegisterInfo &amp;RegInfo = MF-&gt;getRegInfo();
  const TargetRegisterClass *RC = getRegClassFor(MVT::getIntegerVT(Size * 8));
  const TargetInstrInfo *TII = Subtarget.getInstrInfo();
  DebugLoc DL = MI.getDebugLoc();
  unsigned LL, SC, ZERO, BNE, BEQ;

  LL = Cpu0::LL;
  SC = Cpu0::SC;
  ZERO = Cpu0::ZERO;
  BNE = Cpu0::BNE;
  BEQ = Cpu0::BEQ;

  unsigned Dest    = MI.getOperand(0).getReg();
  unsigned Ptr     = MI.getOperand(1).getReg();
  unsigned OldVal  = MI.getOperand(2).getReg();
  unsigned NewVal  = MI.getOperand(3).getReg();

  unsigned Success = RegInfo.createVirtualRegister(RC);

  // insert new blocks after the current block
  const BasicBlock *LLVM_BB = BB-&gt;getBasicBlock();
  MachineBasicBlock *loop1MBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineBasicBlock *loop2MBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineBasicBlock *exitMBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineFunction::iterator It = ++BB-&gt;getIterator();

  MF-&gt;insert(It, loop1MBB);
  MF-&gt;insert(It, loop2MBB);
  MF-&gt;insert(It, exitMBB);

  // Transfer the remainder of BB and its successor edges to exitMBB.
  exitMBB-&gt;splice(exitMBB-&gt;begin(), BB,
                  std::next(MachineBasicBlock::iterator(MI)), BB-&gt;end());
  exitMBB-&gt;transferSuccessorsAndUpdatePHIs(BB);

  //  thisMBB:
  //    ...
  //    fallthrough --&gt; loop1MBB
  BB-&gt;addSuccessor(loop1MBB);
  loop1MBB-&gt;addSuccessor(exitMBB);
  loop1MBB-&gt;addSuccessor(loop2MBB);
  loop2MBB-&gt;addSuccessor(loop1MBB);
  loop2MBB-&gt;addSuccessor(exitMBB);

  // loop1MBB:
  //   ll dest, 0(ptr)
  //   bne dest, oldval, exitMBB
  BB = loop1MBB;
  BuildMI(BB, DL, TII-&gt;get(LL), Dest).addReg(Ptr).addImm(0);
  BuildMI(BB, DL, TII-&gt;get(BNE))
    .addReg(Dest).addReg(OldVal).addMBB(exitMBB);

  // loop2MBB:
  //   sc success, newval, 0(ptr)
  //   beq success, $0, loop1MBB
  BB = loop2MBB;
  BuildMI(BB, DL, TII-&gt;get(SC), Success)
    .addReg(NewVal).addReg(Ptr).addImm(0);
  BuildMI(BB, DL, TII-&gt;get(BEQ))
    .addReg(Success).addReg(ZERO).addMBB(loop1MBB);

  MI.eraseFromParent(); // The instruction is gone now.

  return exitMBB;
}

MachineBasicBlock *
Cpu0TargetLowering::emitAtomicCmpSwapPartword(MachineInstr &amp;MI,
                                              MachineBasicBlock *BB,
                                              unsigned Size) const {
  assert((Size == 1 || Size == 2) &amp;&amp;
      &quot;Unsupported size for EmitAtomicCmpSwapPartial.&quot;);

  MachineFunction *MF = BB-&gt;getParent();
  MachineRegisterInfo &amp;RegInfo = MF-&gt;getRegInfo();
  const TargetRegisterClass *RC = getRegClassFor(MVT::i32);
  const TargetInstrInfo *TII = Subtarget.getInstrInfo();
  DebugLoc DL = MI.getDebugLoc();

  unsigned Dest    = MI.getOperand(0).getReg();
  unsigned Ptr     = MI.getOperand(1).getReg();
  unsigned CmpVal  = MI.getOperand(2).getReg();
  unsigned NewVal  = MI.getOperand(3).getReg();

  unsigned AlignedAddr = RegInfo.createVirtualRegister(RC);
  unsigned ShiftAmt = RegInfo.createVirtualRegister(RC);
  unsigned Mask = RegInfo.createVirtualRegister(RC);
  unsigned Mask2 = RegInfo.createVirtualRegister(RC);
  unsigned Mask3 = RegInfo.createVirtualRegister(RC);
  unsigned ShiftedCmpVal = RegInfo.createVirtualRegister(RC);
  unsigned OldVal = RegInfo.createVirtualRegister(RC);
  unsigned MaskedOldVal0 = RegInfo.createVirtualRegister(RC);
  unsigned ShiftedNewVal = RegInfo.createVirtualRegister(RC);
  unsigned MaskLSB2 = RegInfo.createVirtualRegister(RC);
  unsigned PtrLSB2 = RegInfo.createVirtualRegister(RC);
  unsigned MaskUpper = RegInfo.createVirtualRegister(RC);
  unsigned MaskedCmpVal = RegInfo.createVirtualRegister(RC);
  unsigned MaskedNewVal = RegInfo.createVirtualRegister(RC);
  unsigned MaskedOldVal1 = RegInfo.createVirtualRegister(RC);
  unsigned StoreVal = RegInfo.createVirtualRegister(RC);
  unsigned SrlRes = RegInfo.createVirtualRegister(RC);
  unsigned Success = RegInfo.createVirtualRegister(RC);

  // insert new blocks after the current block
  const BasicBlock *LLVM_BB = BB-&gt;getBasicBlock();
  MachineBasicBlock *loop1MBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineBasicBlock *loop2MBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineBasicBlock *sinkMBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineBasicBlock *exitMBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineFunction::iterator It = ++BB-&gt;getIterator();

  MF-&gt;insert(It, loop1MBB);
  MF-&gt;insert(It, loop2MBB);
  MF-&gt;insert(It, sinkMBB);
  MF-&gt;insert(It, exitMBB);

  // Transfer the remainder of BB and its successor edges to exitMBB.
  exitMBB-&gt;splice(exitMBB-&gt;begin(), BB,
                  std::next(MachineBasicBlock::iterator(MI)), BB-&gt;end());
  exitMBB-&gt;transferSuccessorsAndUpdatePHIs(BB);

  BB-&gt;addSuccessor(loop1MBB);
  loop1MBB-&gt;addSuccessor(sinkMBB);
  loop1MBB-&gt;addSuccessor(loop2MBB);
  loop2MBB-&gt;addSuccessor(loop1MBB);
  loop2MBB-&gt;addSuccessor(sinkMBB);
  sinkMBB-&gt;addSuccessor(exitMBB);

  // FIXME: computation of newval2 can be moved to loop2MBB.
  //  thisMBB:
  //    addiu   masklsb2,$0,-4                # 0xfffffffc
  //    and     alignedaddr,ptr,masklsb2
  //    andi    ptrlsb2,ptr,3
  //    shl     shiftamt,ptrlsb2,3
  //    ori     maskupper,$0,255               # 0xff
  //    shl     mask,maskupper,shiftamt
  //    xor     mask2,$0,mask
  //    xor     mask3,$0,mask2
  //    andi    maskedcmpval,cmpval,255
  //    shl     shiftedcmpval,maskedcmpval,shiftamt
  //    andi    maskednewval,newval,255
  //    shl     shiftednewval,maskednewval,shiftamt
  int64_t MaskImm = (Size == 1) ? 255 : 65535;
  BuildMI(BB, DL, TII-&gt;get(Cpu0::ADDiu), MaskLSB2)
    .addReg(Cpu0::ZERO).addImm(-4);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::AND), AlignedAddr)
    .addReg(Ptr).addReg(MaskLSB2);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::ANDi), PtrLSB2).addReg(Ptr).addImm(3);
  if (Subtarget.isLittle()) {
    BuildMI(BB, DL, TII-&gt;get(Cpu0::SHL), ShiftAmt).addReg(PtrLSB2).addImm(3);
  } else {
    unsigned Off = RegInfo.createVirtualRegister(RC);
    BuildMI(BB, DL, TII-&gt;get(Cpu0::XORi), Off)
      .addReg(PtrLSB2).addImm((Size == 1) ? 3 : 2);
    BuildMI(BB, DL, TII-&gt;get(Cpu0::SHL), ShiftAmt).addReg(Off).addImm(3);
  }
  BuildMI(BB, DL, TII-&gt;get(Cpu0::ORi), MaskUpper)
    .addReg(Cpu0::ZERO).addImm(MaskImm);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::SHLV), Mask)
    .addReg(MaskUpper).addReg(ShiftAmt);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::XOR), Mask2).addReg(Cpu0::ZERO).addReg(Mask);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::XOR), Mask3).addReg(Cpu0::ZERO).addReg(Mask2);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::ANDi), MaskedCmpVal)
    .addReg(CmpVal).addImm(MaskImm);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::SHLV), ShiftedCmpVal)
    .addReg(MaskedCmpVal).addReg(ShiftAmt);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::ANDi), MaskedNewVal)
    .addReg(NewVal).addImm(MaskImm);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::SHLV), ShiftedNewVal)
    .addReg(MaskedNewVal).addReg(ShiftAmt);

  //  loop1MBB:
  //    ll      oldval,0(alginedaddr)
  //    and     maskedoldval0,oldval,mask
  //    bne     maskedoldval0,shiftedcmpval,sinkMBB
  BB = loop1MBB;
  unsigned LL = Cpu0::LL;
  BuildMI(BB, DL, TII-&gt;get(LL), OldVal).addReg(AlignedAddr).addImm(0);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::AND), MaskedOldVal0)
    .addReg(OldVal).addReg(Mask);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::BNE))
    .addReg(MaskedOldVal0).addReg(ShiftedCmpVal).addMBB(sinkMBB);

  //  loop2MBB:
  //    and     maskedoldval1,oldval,mask3
  //    or      storeval,maskedoldval1,shiftednewval
  //    sc      success,storeval,0(alignedaddr)
  //    beq     success,$0,loop1MBB
  BB = loop2MBB;
  BuildMI(BB, DL, TII-&gt;get(Cpu0::AND), MaskedOldVal1)
    .addReg(OldVal).addReg(Mask3);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::OR), StoreVal)
    .addReg(MaskedOldVal1).addReg(ShiftedNewVal);
  unsigned SC = Cpu0::SC;
  BuildMI(BB, DL, TII-&gt;get(SC), Success)
      .addReg(StoreVal).addReg(AlignedAddr).addImm(0);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::BEQ))
      .addReg(Success).addReg(Cpu0::ZERO).addMBB(loop1MBB);

  //  sinkMBB:
  //    srl     srlres,maskedoldval0,shiftamt
  //    sign_extend dest,srlres
  BB = sinkMBB;

  BuildMI(BB, DL, TII-&gt;get(Cpu0::SHRV), SrlRes)
      .addReg(MaskedOldVal0).addReg(ShiftAmt);
  BB = emitSignExtendToI32InReg(MI, BB, Size, Dest, SrlRes);

  MI.eraseFromParent();   // The instruction is gone now.

  return exitMBB;
}
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">lowerATOMIC_FENCE</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span>
                                              <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="o">//</span> <span class="n">FIXME</span><span class="p">:</span> <span class="n">Need</span> <span class="n">pseudo</span><span class="o">-</span><span class="n">fence</span> <span class="k">for</span> <span class="s1">&#39;singlethread&#39;</span> <span class="n">fences</span>
  <span class="o">//</span> <span class="n">FIXME</span><span class="p">:</span> <span class="n">Set</span> <span class="n">SType</span> <span class="k">for</span> <span class="n">weaker</span> <span class="n">fences</span> <span class="n">where</span> <span class="n">supported</span><span class="o">/</span><span class="n">appropriate</span><span class="o">.</span>
  <span class="n">unsigned</span> <span class="n">SType</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">(</span><span class="n">Op</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">Cpu0ISD</span><span class="p">::</span><span class="n">Sync</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">MVT</span><span class="p">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Op</span><span class="o">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                     <span class="n">DAG</span><span class="o">.</span><span class="n">getConstant</span><span class="p">(</span><span class="n">SType</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">MVT</span><span class="p">::</span><span class="n">i32</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0RegisterInfo.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="o">///</span> <span class="n">Code</span> <span class="n">Generation</span> <span class="n">virtual</span> <span class="n">methods</span><span class="o">...</span>
  <span class="n">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span><span class="n">getPointerRegClass</span><span class="p">(</span><span class="n">const</span> <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                                <span class="n">unsigned</span> <span class="n">Kind</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0RegisterInfo.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span>
<span class="n">Cpu0RegisterInfo</span><span class="p">::</span><span class="n">getPointerRegClass</span><span class="p">(</span><span class="n">const</span> <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                     <span class="n">unsigned</span> <span class="n">Kind</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="n">Cpu0</span><span class="p">::</span><span class="n">CPURegsRegClass</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0SEISelLowering.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Cpu0SETargetLowering</span><span class="p">::</span><span class="n">Cpu0SETargetLowering</span><span class="p">(</span><span class="n">const</span> <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">,</span>
                                           <span class="n">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span>
    <span class="p">:</span> <span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="n">TM</span><span class="p">,</span> <span class="n">STI</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">ATOMIC_FENCE</span><span class="p">,</span>       <span class="n">MVT</span><span class="p">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Custom</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0TargetMachine.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">///</span> <span class="n">Cpu0</span> <span class="n">Code</span> <span class="n">Generator</span> <span class="n">Pass</span> <span class="n">Configuration</span> <span class="n">Options</span><span class="o">.</span>
<span class="k">class</span> <span class="nc">Cpu0PassConfig</span> <span class="p">:</span> <span class="n">public</span> <span class="n">TargetPassConfig</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">void</span> <span class="n">addIRPasses</span><span class="p">()</span> <span class="n">override</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">Cpu0PassConfig</span><span class="p">::</span><span class="n">addIRPasses</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">TargetPassConfig</span><span class="p">::</span><span class="n">addIRPasses</span><span class="p">();</span>
  <span class="n">addPass</span><span class="p">(</span><span class="n">createAtomicExpandPass</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Since the <cite>SC</cite> instruction uses <cite>RegisterOperand</cite> type in <cite>Cpu0InstrInfo.td</cite> and
<cite>SC</cite> uses the <cite>FMem</cite> node whose <cite>DecoderMethod</cite> is <cite>DecodeMem</cite>, the
<cite>DecodeMem()</cite> function in <cite>Cpu0Disassembler.cpp</cite> needs to be modified
accordingly.</p>
<p>The atomic node defined in <cite>let usesCustomInserter = 1 in</cite> within
<cite>Cpu0InstrInfo.td</cite> tells LLVM to call <cite>EmitInstrWithCustomInserter()</cite> in
<cite>Cpu0ISelLowering.cpp</cite> after the Instruction Selection stage, specifically in
the <cite>Cpu0TargetLowering::EmitInstrWithCustomInserter()</cite> function invoked during
the <cite>ExpandISelPseudos::runOnMachineFunction()</cite> phase.</p>
<p>For example, the declaration
<cite>def ATOMIC_LOAD_ADD_I8 : Atomic2Ops&lt;atomic_load_add_8, CPURegs&gt;;</cite>
will trigger a call to <cite>EmitInstrWithCustomInserter()</cite> with the machine
instruction opcode <cite>ATOMIC_LOAD_ADD_I8</cite> when the IR <cite>load atomic i8*</cite> is
encountered.</p>
<p>The call to <cite>setInsertFencesForAtomic(true);</cite> in <cite>Cpu0ISelLowering.cpp</cite> will
trigger the <cite>addIRPasses()</cite> function in <cite>Cpu0TargetMachine.cpp</cite>, which in turn
invokes <cite>createAtomicExpandPass()</cite> to create the LLVM IR <cite>ATOMIC_FENCE</cite>.</p>
<p>Later, <cite>lowerATOMIC_FENCE()</cite> in <cite>Cpu0ISelLowering.cpp</cite> will emit a
<cite>Cpu0ISD::Sync</cite> when it sees an <cite>ATOMIC_FENCE</cite> IR, because of the statement
<cite>setOperationAction(ISD::ATOMIC_FENCE, MVT::Other, Custom);</cite> in
<cite>Cpu0SEISelLowering.cpp</cite>.</p>
<p>Finally, the pattern defined in <cite>Cpu0InstrInfo.td</cite> will translate the DAG node
into the actual <cite>sync</cite> instruction via <cite>def SYNC</cite> and its alias <cite>SYNC 0</cite>.</p>
<p>This part of the Cpu0 backend code is similar to Mips, except that Cpu0 does
not include the <cite>nor</cite> instruction.</p>
<p>Below is a table listing the atomic IRs, their corresponding DAG nodes, and
machine opcodes.</p>
<table class="docutils align-default" id="id25">
<caption><span class="caption-number">Table 43 </span><span class="caption-text">The atomic related IRs, their corresponding DAGs and Opcode of Cpu0ISelLowering.cpp</span><a class="headerlink" href="#id25" title="Permalink to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>IR</p></th>
<th class="head"><p>DAG</p></th>
<th class="head"><p>Opcode</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>load atomic</p></td>
<td><p>AtomicLoad</p></td>
<td><p>ATOMIC_CMP_SWAP_XXX</p></td>
</tr>
<tr class="row-odd"><td><p>store atomic</p></td>
<td><p>AtomicStore</p></td>
<td><p>ATOMIC_SWAP_XXX</p></td>
</tr>
<tr class="row-even"><td><p>atomicrmw add</p></td>
<td><p>AtomicLoadAdd</p></td>
<td><p>ATOMIC_LOAD_ADD_XXX</p></td>
</tr>
<tr class="row-odd"><td><p>atomicrmw sub</p></td>
<td><p>AtomicLoadSub</p></td>
<td><p>ATOMIC_LOAD_SUB_XXX</p></td>
</tr>
<tr class="row-even"><td><p>atomicrmw xor</p></td>
<td><p>AtomicLoadXor</p></td>
<td><p>ATOMIC_LOAD_XOR_XXX</p></td>
</tr>
<tr class="row-odd"><td><p>atomicrmw and</p></td>
<td><p>AtomicLoadAnd</p></td>
<td><p>ATOMIC_LOAD_AND_XXX</p></td>
</tr>
<tr class="row-even"><td><p>atomicrmw nand</p></td>
<td><p>AtomicLoadNand</p></td>
<td><p>ATOMIC_LOAD_NAND_XXX</p></td>
</tr>
<tr class="row-odd"><td><p>atomicrmw or</p></td>
<td><p>AtomicLoadOr</p></td>
<td><p>ATOMIC_LOAD_OR_XXX</p></td>
</tr>
<tr class="row-even"><td><p>cmpxchg</p></td>
<td><p>AtomicCmpSwapWithSuccess</p></td>
<td><p>ATOMIC_CMP_SWAP_XXX</p></td>
</tr>
<tr class="row-odd"><td><p>atomicrmw xchg</p></td>
<td><p>AtomicLoadSwap</p></td>
<td><p>ATOMIC_SWAP_XXX</p></td>
</tr>
</tbody>
</table>
<p>The input files <cite>atomics.ll</cite> and <cite>atomics-fences.ll</cite> include tests for LLVM
atomic IRs.</p>
<p>The C++ source files <cite>ch12_atomics.cpp</cite> and <cite>ch12_atomics-fences.cpp</cite> are used
to generate the corresponding LLVM atomic IRs. To compile these files, use the
following <cite>clang++</cite> options:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">clang</span><span class="o">++</span> <span class="o">-</span><span class="n">pthread</span> <span class="o">-</span><span class="n">std</span><span class="o">=</span><span class="n">c</span><span class="o">++</span><span class="mi">11</span>
</pre></div>
</div>
<aside class="footnote brackets" id="exception" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">1</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://llvm.org/docs/ExceptionHandling.html">http://llvm.org/docs/ExceptionHandling.html</a></p>
</aside>
<aside class="footnote brackets" id="itanium-exception" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">2</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://itanium-cxx-abi.github.io/cxx-abi/exceptions.pdf">http://itanium-cxx-abi.github.io/cxx-abi/exceptions.pdf</a></p>
</aside>
<aside class="footnote brackets" id="thread-wiki" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">3</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://en.wikipedia.org/wiki/Thread-local_storage">http://en.wikipedia.org/wiki/Thread-local_storage</a></p>
</aside>
<aside class="footnote brackets" id="cpp-atomic" role="note">
<span class="label"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://cplusplus.com/reference/atomic/">https://cplusplus.com/reference/atomic/</a></p>
</aside>
<aside class="footnote brackets" id="cpp-mem-order" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">5</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.cppreference.com/w/cpp/atomic/memory_order">https://en.cppreference.com/w/cpp/atomic/memory_order</a></p>
</aside>
<aside class="footnote brackets" id="cas-wiki" role="note">
<span class="label"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id5">1</a>,<a role="doc-backlink" href="#id6">2</a>)</span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Compare-and-swap">https://en.wikipedia.org/wiki/Compare-and-swap</a></p>
</aside>
<aside class="footnote brackets" id="atomic-wiki" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">7</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Memory_model_%28programming%29">https://en.wikipedia.org/wiki/Memory_model_%28programming%29</a></p>
</aside>
<aside class="footnote brackets" id="atomic-stackoverflow" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id8">8</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://stackoverflow.com/questions/6319146/c11-introduced-a-standardized-memory-model-what-does-it-mean-and-how-is-it-g">http://stackoverflow.com/questions/6319146/c11-introduced-a-standardized-memory-model-what-does-it-mean-and-how-is-it-g</a></p>
</aside>
<aside class="footnote brackets" id="lf-wiki" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id9">9</a><span class="fn-bracket">]</span></span>
<p>An algorithm is wait-free if every operation has a bound on the
number of steps the algorithm will take before the operation completes. In
other words, wait-free algorithm has no starvation. Lock-freedom allows
individual threads to starve but guarantees system-wide throughput. An
algorithm is lock-free if, when the program threads are run for a
sufficiently long time, at least one of the threads makes progress (for
some sensible definition of progress). All wait-free algorithms are lock-free.
In particular, if one thread is suspended, then a lock-free algorithm guarantees
that the remaining threads can still make progress. Hence, if two threads can
contend for the same mutex lock or spinlock, then the algorithm is not lock-free.
(If we suspend one thread that holds the lock, then the second thread will block.)
<a class="reference external" href="https://en.wikipedia.org/wiki/Non-blocking_algorithm">https://en.wikipedia.org/wiki/Non-blocking_algorithm</a></p>
</aside>
<aside class="footnote brackets" id="ll-wiki" role="note">
<span class="label"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Load-link/store-conditional">https://en.wikipedia.org/wiki/Load-link/store-conditional</a></p>
</aside>
<aside class="footnote brackets" id="mb-wiki" role="note">
<span class="label"><span class="fn-bracket">[</span>11<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Memory_barrier">https://en.wikipedia.org/wiki/Memory_barrier</a></p>
</aside>
<aside class="footnote brackets" id="mips-sync" role="note">
<span class="label"><span class="fn-bracket">[</span>12<span class="fn-bracket">]</span></span>
<p>From page A-158, it is same with ARM’s barrier that all instructions before SYNC are completed before issuing the instructions after SYNC. Page 167 (A-155) of <a class="reference external" href="https://www.cs.cmu.edu/afs/cs/academic/class/15740-f97/public/doc/mips-isa.pdf">https://www.cs.cmu.edu/afs/cs/academic/class/15740-f97/public/doc/mips-isa.pdf</a></p>
</aside>
<aside class="footnote brackets" id="atomics-llvm" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id12">13</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://llvm.org/docs/Atomics.html">http://llvm.org/docs/Atomics.html</a></p>
</aside>
<aside class="footnote brackets" id="llvmlang-ordering" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id13">14</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://llvm.org/docs/LangRef.html#ordering">http://llvm.org/docs/LangRef.html#ordering</a></p>
</aside>
<aside class="footnote brackets" id="dpcpp-memorder" role="note">
<span class="label"><span class="fn-bracket">[</span>15<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id14">1</a>,<a role="doc-backlink" href="#id15">2</a>)</span>
<p>Section “The memory_order Enumeration Class” which include figure 19-10 of book <a class="reference external" href="https://link.springer.com/book/10.1007/978-1-4842-5574-2">https://link.springer.com/book/10.1007/978-1-4842-5574-2</a></p>
</aside>
<aside class="footnote brackets" id="cpp-memorder-consume-as-acquire" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id16">16</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://stackoverflow.com/questions/65336409/what-does-memory-order-consume-really-do">https://stackoverflow.com/questions/65336409/what-does-memory-order-consume-really-do</a></p>
</aside>
<aside class="footnote brackets" id="cpp-memorder-consume-remove" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id17">17</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0371r1.html">https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0371r1.html</a></p>
</aside>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="asm.html">Assembler</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="verilog.html">Verify backend on Verilog simulator</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Chen Chung-Shu.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.0.2.
    </div>
  </body>
</html>