<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>C++ support &mdash; Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '3.7.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="top" title="Tutorial: Creating an LLVM Backend for the Cpu0 Architecture" href="index.html" />
    <link rel="next" title="Verify backend on Verilog simulator" href="verilog.html" />
    <link rel="prev" title="Assembler" href="asm.html" /> 
  </head>
  <body role="document">
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</span></a></h1>
        <h2 class="heading"><span>C++ support</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="asm.html">Assembler</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="verilog.html">Verify backend on Verilog simulator</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="c-support">
<span id="sec-c"></span><h1>C++ support<a class="headerlink" href="#c-support" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#exception-handle" id="id11">Exception handle</a></li>
<li><a class="reference internal" href="#thread-variable" id="id12">Thread variable</a></li>
<li><a class="reference internal" href="#atomic" id="id13">Atomic</a></li>
</ul>
</div>
<p>This chapter supports C++ compiler features.</p>
<div class="section" id="exception-handle">
<h2><a class="toc-backref" href="#id11">Exception handle</a><a class="headerlink" href="#exception-handle" title="Permalink to this headline">¶</a></h2>
<p>The Chapter11_2 can be built and run with the C++ polymorphism example code of
ch12_inherit.cpp as follows,</p>
<p class="rubric">lbdex/input/ch12_inherit.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1">#ifdef COUT_TEST</span>
<span class="c1">#include &lt;iostream&gt;</span>
<span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="c1">#endif</span>

<span class="n">extern</span> <span class="s2">&quot;C&quot;</span> <span class="nb">int</span> <span class="n">printf</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="nb">format</span><span class="p">,</span> <span class="o">...</span><span class="p">);</span>
<span class="n">extern</span> <span class="s2">&quot;C&quot;</span> <span class="nb">int</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">char</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="nb">format</span><span class="p">,</span> <span class="o">...</span><span class="p">);</span>

<span class="k">class</span> <span class="nc">CPolygon</span> <span class="p">{</span> <span class="o">//</span> <span class="n">_ZTVN10__cxxabiv117__class_type_infoE</span> <span class="k">for</span> <span class="n">parent</span> <span class="k">class</span>
  <span class="nc">protected</span><span class="p">:</span>
    <span class="nb">int</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">;</span>
  <span class="n">public</span><span class="p">:</span>
    <span class="n">void</span> <span class="n">set_values</span> <span class="p">(</span><span class="nb">int</span> <span class="n">a</span><span class="p">,</span> <span class="nb">int</span> <span class="n">b</span><span class="p">)</span>
    <span class="p">{</span> <span class="n">width</span><span class="o">=</span><span class="n">a</span><span class="p">;</span> <span class="n">height</span><span class="o">=</span><span class="n">b</span><span class="p">;</span> <span class="p">}</span>
<span class="o">//</span>    <span class="n">virtual</span> <span class="nb">int</span> <span class="n">area</span> <span class="p">(</span><span class="n">void</span><span class="p">)</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="o">//</span> <span class="n">__cxa_pure_virtual</span>
    <span class="n">virtual</span> <span class="nb">int</span> <span class="n">area</span> <span class="p">(</span><span class="n">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;};</span>
    <span class="n">void</span> <span class="n">printarea</span> <span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="c1">#ifdef COUT_TEST</span>
 <span class="o">//</span> <span class="n">generate</span> <span class="n">IR</span> <span class="n">nvoke</span><span class="p">,</span> <span class="n">landing</span><span class="p">,</span> <span class="n">resume</span> <span class="ow">and</span> <span class="n">unreachable</span> <span class="n">on</span> <span class="n">iMac</span>
    <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">area</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="c1">#else</span>
    <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">area</span><span class="p">());</span> <span class="p">}</span>
<span class="c1">#endif</span>
  <span class="p">};</span>

<span class="o">//</span> <span class="n">_ZTVN10__cxxabiv120__si_class_type_infoE</span> <span class="k">for</span> <span class="n">derived</span> <span class="k">class</span>
<span class="nc">class</span> <span class="n">CRectangle</span><span class="p">:</span> <span class="n">public</span> <span class="n">CPolygon</span> <span class="p">{</span>
  <span class="n">public</span><span class="p">:</span>
    <span class="nb">int</span> <span class="n">area</span> <span class="p">(</span><span class="n">void</span><span class="p">)</span>
    <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">width</span> <span class="o">*</span> <span class="n">height</span><span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">CTriangle</span><span class="p">:</span> <span class="n">public</span> <span class="n">CPolygon</span> <span class="p">{</span>
  <span class="n">public</span><span class="p">:</span>
    <span class="nb">int</span> <span class="n">area</span> <span class="p">(</span><span class="n">void</span><span class="p">)</span>
    <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">width</span> <span class="o">*</span> <span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">CAngle</span><span class="p">:</span> <span class="n">public</span> <span class="n">CPolygon</span> <span class="p">{</span>
  <span class="n">public</span><span class="p">:</span>
    <span class="nb">int</span> <span class="n">area</span> <span class="p">(</span><span class="n">void</span><span class="p">)</span>
    <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">width</span> <span class="o">*</span> <span class="n">height</span> <span class="o">/</span> <span class="mi">4</span><span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>
<span class="c1">#if 0</span>
<span class="nb">int</span> <span class="n">test_cpp_polymorphism</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">CPolygon</span> <span class="o">*</span> <span class="n">ppoly1</span> <span class="o">=</span> <span class="n">new</span> <span class="n">CRectangle</span><span class="p">;</span>	<span class="o">//</span> <span class="n">_Znwm</span>
  <span class="n">CPolygon</span> <span class="o">*</span> <span class="n">ppoly2</span> <span class="o">=</span> <span class="n">new</span> <span class="n">CTriangle</span><span class="p">;</span>
  <span class="n">ppoly1</span><span class="o">-&gt;</span><span class="n">set_values</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>
  <span class="n">ppoly2</span><span class="o">-&gt;</span><span class="n">set_values</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>
  <span class="n">ppoly1</span><span class="o">-&gt;</span><span class="n">printarea</span><span class="p">();</span>
  <span class="n">ppoly2</span><span class="o">-&gt;</span><span class="n">printarea</span><span class="p">();</span>
  <span class="n">delete</span> <span class="n">ppoly1</span><span class="p">;</span>	<span class="o">//</span> <span class="n">_ZdlPv</span>
  <span class="n">delete</span> <span class="n">ppoly2</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">#else</span>
<span class="nb">int</span> <span class="n">test_cpp_polymorphism</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">CRectangle</span> <span class="n">poly1</span><span class="p">;</span>
  <span class="n">CTriangle</span> <span class="n">poly2</span><span class="p">;</span>
  <span class="n">CAngle</span> <span class="n">poly3</span><span class="p">;</span>
  
  <span class="n">CPolygon</span> <span class="o">*</span> <span class="n">ppoly1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">poly1</span><span class="p">;</span>
  <span class="n">CPolygon</span> <span class="o">*</span> <span class="n">ppoly2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">poly2</span><span class="p">;</span>
  <span class="n">CPolygon</span> <span class="o">*</span> <span class="n">ppoly3</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">poly3</span><span class="p">;</span>
  
  <span class="n">ppoly1</span><span class="o">-&gt;</span><span class="n">set_values</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>
  <span class="n">ppoly2</span><span class="o">-&gt;</span><span class="n">set_values</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>
  <span class="n">ppoly3</span><span class="o">-&gt;</span><span class="n">set_values</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>
  <span class="n">ppoly1</span><span class="o">-&gt;</span><span class="n">printarea</span><span class="p">();</span>
  <span class="n">ppoly2</span><span class="o">-&gt;</span><span class="n">printarea</span><span class="p">();</span>
  <span class="n">ppoly3</span><span class="o">-&gt;</span><span class="n">printarea</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ppoly1</span><span class="o">-&gt;</span><span class="n">area</span><span class="p">()</span> <span class="o">==</span> <span class="mi">20</span> <span class="o">&amp;&amp;</span> <span class="n">ppoly2</span><span class="o">-&gt;</span><span class="n">area</span><span class="p">()</span> <span class="o">==</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">ppoly3</span><span class="o">-&gt;</span><span class="n">area</span><span class="p">()</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">#endif</span>

</pre></div>
</div>
<p>If using cout instead of printf in ch12_inherit.cpp on Linux won&#8217;t generate exception
handler IRs.
But on iMac, ch12_inherit.cpp will generate invoke, landing, resume and unreachable
exception handler IRs.
Example code, ch12_eh.cpp, which supports <strong>try</strong> and <strong>catch</strong> exception handler
as the following will generate these exception handler IRs both on iMac and Linux.</p>
<p class="rubric">lbdex/input/ch12_eh.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Ex1</span> <span class="p">{};</span>
<span class="n">void</span> <span class="n">throw_exception</span><span class="p">(</span><span class="nb">int</span> <span class="n">a</span><span class="p">,</span> <span class="nb">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Ex1</span> <span class="n">ex1</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">throw</span> <span class="n">ex1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">test_try_catch</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="n">throw_exception</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">catch</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre><span></span>JonathantekiiMac:input Jonathan$ clang -c ch12_eh.cpp -emit-llvm
-o ch12_eh.bc
JonathantekiiMac:input Jonathan$ /Users/Jonathan/llvm/test/cmake_debug_build/
Debug/bin/llvm-dis ch12_eh.bc -o -
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>; ModuleID = &#39;ch12_eh.bc&#39;
target datalayout = &quot;E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64&quot;
target triple = &quot;mips-unknown-linux-gnu&quot;

%class.Ex1 = type { i8 }

$_ZTS3Ex1 = comdat any

$_ZTI3Ex1 = comdat any

@_ZTVN10__cxxabiv117__class_type_infoE = external global i8*
@_ZTS3Ex1 = linkonce_odr constant [5 x i8] c&quot;3Ex1\00&quot;, comdat
@_ZTI3Ex1 = linkonce_odr constant { i8*, i8* } { i8* bitcast (i8** getelementptr
 inbounds (i8*, i8** @_ZTVN10__cxxabiv117__class_type_infoE, i32 2) to i8*), i8*
 getelementptr inbounds ([5 x i8], [5 x i8]* @_ZTS3Ex1, i32 0, i32 0) }, comdat

define void @_Z15throw_exceptionii(i32 signext %a, i32 signext %b) #0 {
  %1 = alloca i32, align 4
  %2 = alloca i32, align 4
  %ex1 = alloca %class.Ex1, align 1
  store i32 %a, i32* %1, align 4
  store i32 %b, i32* %2, align 4
  %3 = load i32, i32* %1, align 4
  %4 = load i32, i32* %2, align 4
  %5 = icmp sgt i32 %3, %4
  br i1 %5, label %6, label %9

; &lt;label&gt;:6                                       ; preds = %0
  %7 = call i8* @__cxa_allocate_exception(i32 1) #1
  %8 = bitcast i8* %7 to %class.Ex1*
  call void @__cxa_throw(i8* %7, i8* bitcast ({ i8*, i8* }* @_ZTI3Ex1 to i8*), i
8* null) #2
  unreachable

; &lt;label&gt;:9                                       ; preds = %0
  ret void
}

declare i8* @__cxa_allocate_exception(i32)

declare void @__cxa_throw(i8*, i8*, i8*)

define i32 @_Z14test_try_catchv() #0 personality i8* bitcast (i32 (...)* @__gxx_
personality_v0 to i8*) {
  %1 = alloca i32, align 4
  %2 = alloca i8*
  %3 = alloca i32
  %4 = alloca i32
  invoke void @_Z15throw_exceptionii(i32 signext 2, i32 signext 1)
          to label %5 unwind label %6

; &lt;label&gt;:5                                       ; preds = %0
  br label %13

; &lt;label&gt;:6                                       ; preds = %0
  %7 = landingpad { i8*, i32 }
          catch i8* null
  %8 = extractvalue { i8*, i32 } %7, 0
  store i8* %8, i8** %2
  %9 = extractvalue { i8*, i32 } %7, 1
  store i32 %9, i32* %3
  br label %10

; &lt;label&gt;:10                                      ; preds = %6
  %11 = load i8*, i8** %2
  %12 = call i8* @__cxa_begin_catch(i8* %11) #1
  store i32 1, i32* %1
  store i32 1, i32* %4
  call void @__cxa_end_catch()
  br label %14

; &lt;label&gt;:13                                      ; preds = %5
  store i32 0, i32* %1
  br label %14

; &lt;label&gt;:14                                      ; preds = %13, %10
  %15 = load i32, i32* %1
  ret i32 %15
}

declare i32 @__gxx_personality_v0(...)

declare i8* @__cxa_begin_catch(i8*)

declare void @__cxa_end_catch()

attributes #0 = { &quot;less-precise-fpmad&quot;=&quot;false&quot; &quot;no-frame-pointer-elim&quot;=&quot;true&quot; &quot;n
o-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;=&quot;false&quot; &quot;no-nans-fp-math&quot;=&quot;fals
e&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;target-cpu&quot;=&quot;mips32r2&quot; &quot;target-features&quot;=&quot;
+mips32r2&quot; &quot;unsafe-fp-math&quot;=&quot;false&quot; &quot;use-soft-float&quot;=&quot;false&quot; }
attributes #1 = { nounwind }
attributes #2 = { noreturn }

!llvm.ident = !{!0}

!0 = !{!&quot;Apple LLVM version 7.0.0 (clang-700.1.76)&quot;}
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre><span></span>JonathantekiiMac:input Jonathan$ /Users/Jonathan/llvm/test/cmake_debug_build/
Debug/bin/llc -march=cpu0 -relocation-model=static -filetype=asm ch12_eh.bc -o -
        .section .mdebug.abi32
        .previous
        .file &quot;ch12_eh.bc&quot;
llc: /Users/Jonathan/llvm/test/src/lib/CodeGen/LiveVariables.cpp:133: void llvm::
LiveVariables::HandleVirtRegUse(unsigned int, llvm::MachineBasicBlock *, llvm
::MachineInstr *): Assertion `MRI-&gt;getVRegDef(reg) &amp;&amp; &quot;Register use before
def!&quot;&#39; failed.
</pre></div>
</div>
<p>About the IRs of LLVM exception handling, please reference here <a class="footnote-reference" href="#exception" id="id1">[1]</a>.
Chapter12_1 supports the llvm IRs of corresponding <strong>try</strong> and <strong>catch</strong>
exception C++ keywords. It can compile ch12_eh.bc as follows,</p>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0ISelLowering.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="n">const</span> <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">,</span>
                                       <span class="n">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span>
    <span class="p">:</span> <span class="n">TargetLowering</span><span class="p">(</span><span class="n">TM</span><span class="p">),</span> <span class="n">Subtarget</span><span class="p">(</span><span class="n">STI</span><span class="p">),</span> <span class="n">ABI</span><span class="p">(</span><span class="n">TM</span><span class="o">.</span><span class="n">getABI</span><span class="p">())</span> <span class="p">{</span>

</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="n">setExceptionPointerRegister</span><span class="p">(</span><span class="n">Cpu0</span><span class="p">::</span><span class="n">A0</span><span class="p">);</span>
  <span class="n">setExceptionSelectorRegister</span><span class="p">(</span><span class="n">Cpu0</span><span class="p">::</span><span class="n">A1</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre><span></span>JonathantekiiMac:input Jonathan$ /Users/Jonathan/llvm/test/cmake_debug_build/
Debug/bin/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>static -filetype<span class="o">=</span>asm ch12_eh.bc -o -
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  .text
  .section .mdebug.abiO32
  .previous
  .file  &quot;ch12_eh.bc&quot;
  .globl  _Z15throw_exceptionii
  .align  2
  .type  _Z15throw_exceptionii,@function
  .ent  _Z15throw_exceptionii   # @_Z15throw_exceptionii
_Z15throw_exceptionii:
  .cfi_startproc
  .frame  $fp,40,$lr
  .mask   0x00005000,-4
  .set  noreorder
  .set  nomacro
# BB#0:
  addiu  $sp, $sp, -40
$tmp0:
  .cfi_def_cfa_offset 40
  st  $lr, 36($sp)            # 4-byte Folded Spill
  st  $fp, 32($sp)            # 4-byte Folded Spill
$tmp1:
  .cfi_offset 14, -4
$tmp2:
  .cfi_offset 12, -8
  move   $fp, $sp
$tmp3:
  .cfi_def_cfa_register 12
  st  $4, 28($fp)
  st  $5, 24($fp)
  ld  $2, 28($fp)
  cmp  $sw, $2, $5
  jle  $sw, $BB0_2
  nop
  jmp  $BB0_1
  nop
$BB0_2:
  move   $sp, $fp
  ld  $fp, 32($sp)            # 4-byte Folded Reload
  ld  $lr, 36($sp)            # 4-byte Folded Reload
  addiu  $sp, $sp, 40
  ret  $lr
  nop
$BB0_1:
  addiu  $4, $zero, 1
  jsub  __cxa_allocate_exception
  nop
  addiu  $3, $zero, 0
  st  $3, 8($sp)
  lui  $3, %hi(_ZTI3Ex1)
  ori  $5, $3, %lo(_ZTI3Ex1)
  addu  $4, $zero, $2
  jsub  __cxa_throw
  nop
  .set  macro
  .set  reorder
  .end  _Z15throw_exceptionii
$func_end0:
  .size  _Z15throw_exceptionii, ($func_end0)-_Z15throw_exceptionii
  .cfi_endproc

  .globl  _Z14test_try_catchv
  .align  2
  .type  _Z14test_try_catchv,@function
  .ent  _Z14test_try_catchv     # @_Z14test_try_catchv
_Z14test_try_catchv:
$tmp7:
$func_begin0 = ($tmp7)
  .cfi_startproc
  .cfi_personality 0, __gxx_personality_v0
  .cfi_lsda 0, $exception0
  .frame  $fp,40,$lr
  .mask   0x00005200,-4
  .set  noreorder
  .set  nomacro
# BB#0:
  addiu  $sp, $sp, -40
$tmp8:
  .cfi_def_cfa_offset 40
  st  $lr, 36($sp)            # 4-byte Folded Spill
  st  $fp, 32($sp)            # 4-byte Folded Spill
  st  $9, 28($sp)             # 4-byte Folded Spill
$tmp9:
  .cfi_offset 14, -4
$tmp10:
  .cfi_offset 12, -8
$tmp11:
  .cfi_offset 9, -12
  move   $fp, $sp
$tmp12:
  .cfi_def_cfa_register 12
$tmp4:
  addiu  $4, $zero, 2
  addiu  $9, $zero, 1
  addu  $5, $zero, $9
  jsub  _Z15throw_exceptionii
  nop
$tmp5:
# BB#2:
  addiu  $2, $zero, 0
  st  $2, 24($fp)
$BB1_3:
  ld  $2, 24($fp)
  move   $sp, $fp
  ld  $9, 28($sp)             # 4-byte Folded Reload
  ld  $fp, 32($sp)            # 4-byte Folded Reload
  ld  $lr, 36($sp)            # 4-byte Folded Reload
  addiu  $sp, $sp, 40
  ret  $lr
  nop
$BB1_1:
$tmp6:
  st  $4, 20($fp)
  st  $5, 16($fp)
  ld  $4, 20($fp)
  jsub  __cxa_begin_catch
  nop
  st  $9, 24($fp)
  st  $9, 12($fp)
  jsub  __cxa_end_catch
  nop
  jmp  $BB1_3
  nop
  .set  macro
  .set  reorder
  .end  _Z14test_try_catchv
$func_end1:
  .size  _Z14test_try_catchv, ($func_end1)-_Z14test_try_catchv
  .cfi_endproc
  .section  .gcc_except_table,&quot;a&quot;,@progbits
  .align  2
GCC_except_table1:
$exception0:
  .byte  255                     # @LPStart Encoding = omit
  .byte  0                       # @TType Encoding = absptr
  .asciz  &quot;\242\200\200&quot;          # @TType base offset
  .byte  3                       # Call site Encoding = udata4
  .byte  26                      # Call site table length
  .4byte  ($tmp4)-($func_begin0)  # &gt;&gt; Call Site 1 &lt;&lt;
  .4byte  ($tmp5)-($tmp4)         #   Call between $tmp4 and $tmp5
  .4byte  ($tmp6)-($func_begin0)  #     jumps to $tmp6
  .byte  1                       #   On action: 1
  .4byte  ($tmp5)-($func_begin0)  # &gt;&gt; Call Site 2 &lt;&lt;
  .4byte  ($func_end1)-($tmp5)    #   Call between $tmp5 and $func_end1
  .4byte  0                       #     has no landing pad
  .byte  0                       #   On action: cleanup
  .byte  1                       # &gt;&gt; Action Record 1 &lt;&lt;
                                        #   Catch TypeInfo 1
  .byte  0                       #   No further actions
                                        # &gt;&gt; Catch TypeInfos &lt;&lt;
  .4byte  0                       # TypeInfo 1
  .align  2

  .type  _ZTS3Ex1,@object        # @_ZTS3Ex1
  .section  .rodata._ZTS3Ex1,&quot;aG&quot;,@progbits,_ZTS3Ex1,comdat
  .weak  _ZTS3Ex1
  .align  2
_ZTS3Ex1:
  .asciz  &quot;3Ex1&quot;
  .size  _ZTS3Ex1, 5

  .type  _ZTI3Ex1,@object        # @_ZTI3Ex1
  .section  .rodata._ZTI3Ex1,&quot;aG&quot;,@progbits,_ZTI3Ex1,comdat
  .weak  _ZTI3Ex1
  .align  3
_ZTI3Ex1:
  .4byte  _ZTVN10__cxxabiv117__class_type_infoE+8
  .4byte  _ZTS3Ex1
  .size  _ZTI3Ex1, 8


  .ident  &quot;Apple LLVM version 7.0.0 (clang-700.1.76)&quot;
  .section  &quot;.note.GNU-stack&quot;,&quot;&quot;,@progbits
</pre></div>
</div>
</div>
<div class="section" id="thread-variable">
<h2><a class="toc-backref" href="#id12">Thread variable</a><a class="headerlink" href="#thread-variable" title="Permalink to this headline">¶</a></h2>
<p>C++ include the thread variable as the following file ch12_thread_var.cpp.</p>
<p class="rubric">lbdex/input/ch12_thread_var.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">__thread</span> <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">thread_local</span> <span class="nb">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">//</span> <span class="n">need</span> <span class="n">option</span> <span class="o">-</span><span class="n">std</span><span class="o">=</span><span class="n">c</span><span class="o">++</span><span class="mi">11</span>
<span class="nb">int</span> <span class="n">test_thread_var</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">test_thread_var_2</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

</pre></div>
</div>
<p>While global variable is a single instance shared by all threads in a process,
thread variable has different instances for each different thread in a process.
The same thread share the thread variable but different threads have their own
thread variable with the same name <a class="footnote-reference" href="#thread-wiki" id="id2">[2]</a>.</p>
<p>To support thread variable, the following code added to Chapter12_1.
Most of them are for relocation record handle and display since the thread
variable created by OS or language library which support multi-threads
programming.</p>
<p class="rubric">lbdex/chapters/Chapter12_1/AsmParser/Cpu0AsmParser.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VariantKind</span> <span class="n">Cpu0AsmParser</span><span class="p">::</span><span class="n">getVariantKind</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">Symbol</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>    <span class="o">.</span><span class="n">Case</span><span class="p">(</span><span class="s2">&quot;tlsgd&quot;</span><span class="p">,</span>       <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VK_Cpu0_TLSGD</span><span class="p">)</span>
    <span class="o">.</span><span class="n">Case</span><span class="p">(</span><span class="s2">&quot;tlsldm&quot;</span><span class="p">,</span>      <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VK_Cpu0_TLSLDM</span><span class="p">)</span>
    <span class="o">.</span><span class="n">Case</span><span class="p">(</span><span class="s2">&quot;dtp_hi&quot;</span><span class="p">,</span>      <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VK_Cpu0_DTP_HI</span><span class="p">)</span>
    <span class="o">.</span><span class="n">Case</span><span class="p">(</span><span class="s2">&quot;dtp_lo&quot;</span><span class="p">,</span>      <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VK_Cpu0_DTP_LO</span><span class="p">)</span>
    <span class="o">.</span><span class="n">Case</span><span class="p">(</span><span class="s2">&quot;gottp&quot;</span><span class="p">,</span>       <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VK_Cpu0_GOTTPREL</span><span class="p">)</span>
    <span class="o">.</span><span class="n">Case</span><span class="p">(</span><span class="s2">&quot;tp_hi&quot;</span><span class="p">,</span>       <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VK_Cpu0_TP_HI</span><span class="p">)</span>
    <span class="o">.</span><span class="n">Case</span><span class="p">(</span><span class="s2">&quot;tp_lo&quot;</span><span class="p">,</span>       <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VK_Cpu0_TP_LO</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/InstPrinter/Cpu0InstPrinter.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">static</span> <span class="n">void</span> <span class="n">printExpr</span><span class="p">(</span><span class="n">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">Expr</span><span class="p">,</span> <span class="n">const</span> <span class="n">MCAsmInfo</span> <span class="o">*</span><span class="n">MAI</span><span class="p">,</span>
                      <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">OS</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="n">case</span> <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VK_Cpu0_TLSGD</span><span class="p">:</span>     <span class="n">OS</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;%tlsgd(&quot;</span><span class="p">;</span>  <span class="k">break</span><span class="p">;</span>
  <span class="n">case</span> <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VK_Cpu0_TLSLDM</span><span class="p">:</span>    <span class="n">OS</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;%tlsldm(&quot;</span><span class="p">;</span>  <span class="k">break</span><span class="p">;</span>
  <span class="n">case</span> <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VK_Cpu0_DTP_HI</span><span class="p">:</span>    <span class="n">OS</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2">tp_hi(&quot;</span><span class="p">;</span>  <span class="k">break</span><span class="p">;</span>
  <span class="n">case</span> <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VK_Cpu0_DTP_LO</span><span class="p">:</span>    <span class="n">OS</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2">tp_lo(&quot;</span><span class="p">;</span>  <span class="k">break</span><span class="p">;</span>
  <span class="n">case</span> <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VK_Cpu0_GOTTPREL</span><span class="p">:</span>  <span class="n">OS</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;</span><span class="si">%g</span><span class="s2">ottprel(&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
  <span class="n">case</span> <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VK_Cpu0_TP_HI</span><span class="p">:</span>     <span class="n">OS</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;%tp_hi(&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
  <span class="n">case</span> <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VK_Cpu0_TP_LO</span><span class="p">:</span>     <span class="n">OS</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;%tp_lo(&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/MCTargetDesc/Cpu0AsmBackend.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">MCFixupKindInfo</span> <span class="o">&amp;</span><span class="n">Cpu0AsmBackend</span><span class="p">::</span>
<span class="n">getFixupKindInfo</span><span class="p">(</span><span class="n">MCFixupKind</span> <span class="n">Kind</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="n">const</span> <span class="n">static</span> <span class="n">MCFixupKindInfo</span> <span class="n">Infos</span><span class="p">[</span><span class="n">Cpu0</span><span class="p">::</span><span class="n">NumTargetFixupKinds</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="o">//</span> <span class="n">This</span> <span class="n">table</span> <span class="o">*</span><span class="n">must</span><span class="o">*</span> <span class="n">be</span> <span class="ow">in</span> <span class="n">same</span> <span class="n">the</span> <span class="n">order</span> <span class="n">of</span> <span class="n">fixup_</span><span class="o">*</span> <span class="n">kinds</span> <span class="ow">in</span>
    <span class="o">//</span> <span class="n">Cpu0FixupKinds</span><span class="o">.</span><span class="n">h</span><span class="o">.</span>
    <span class="o">//</span>
    <span class="o">//</span> <span class="n">name</span>                        <span class="n">offset</span>  <span class="n">bits</span>  <span class="n">flags</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>    <span class="p">{</span> <span class="s2">&quot;fixup_Cpu0_TLSGD&quot;</span><span class="p">,</span>          <span class="mi">0</span><span class="p">,</span>     <span class="mi">16</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s2">&quot;fixup_Cpu0_GOTTP&quot;</span><span class="p">,</span>          <span class="mi">0</span><span class="p">,</span>     <span class="mi">16</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s2">&quot;fixup_Cpu0_TP_HI&quot;</span><span class="p">,</span>          <span class="mi">0</span><span class="p">,</span>     <span class="mi">16</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s2">&quot;fixup_Cpu0_TP_LO&quot;</span><span class="p">,</span>          <span class="mi">0</span><span class="p">,</span>     <span class="mi">16</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s2">&quot;fixup_Cpu0_TLSLDM&quot;</span><span class="p">,</span>         <span class="mi">0</span><span class="p">,</span>     <span class="mi">16</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s2">&quot;fixup_Cpu0_DTP_HI&quot;</span><span class="p">,</span>         <span class="mi">0</span><span class="p">,</span>     <span class="mi">16</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s2">&quot;fixup_Cpu0_DTP_LO&quot;</span><span class="p">,</span>         <span class="mi">0</span><span class="p">,</span>     <span class="mi">16</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>    <span class="p">...</span>
  <span class="p">};</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/MCTargetDesc/Cpu0BaseInfo.h</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">namespace</span> <span class="n">Cpu0II</span> <span class="p">{</span>
  <span class="o">///</span> <span class="n">Target</span> <span class="n">Operand</span> <span class="n">Flag</span> <span class="n">enum</span><span class="o">.</span>
  <span class="n">enum</span> <span class="n">TOF</span> <span class="p">{</span>
    <span class="o">//===------------------------------------------------------------------===//</span>
    <span class="o">//</span> <span class="n">Cpu0</span> <span class="n">Specific</span> <span class="n">MachineOperand</span> <span class="n">flags</span><span class="o">.</span>

</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>    <span class="o">///</span> <span class="n">MO_TLSGD</span> <span class="o">-</span> <span class="n">Represents</span> <span class="n">the</span> <span class="n">offset</span> <span class="n">into</span> <span class="n">the</span> <span class="k">global</span> <span class="n">offset</span> <span class="n">table</span> <span class="n">at</span> <span class="n">which</span>
    <span class="o">//</span> <span class="n">the</span> <span class="n">module</span> <span class="n">ID</span> <span class="ow">and</span> <span class="n">TSL</span> <span class="n">block</span> <span class="n">offset</span> <span class="n">reside</span> <span class="n">during</span> <span class="n">execution</span> <span class="p">(</span><span class="n">General</span>
    <span class="o">//</span> <span class="n">Dynamic</span> <span class="n">TLS</span><span class="p">)</span><span class="o">.</span>
    <span class="n">MO_TLSGD</span><span class="p">,</span>

    <span class="o">///</span> <span class="n">MO_TLSLDM</span> <span class="o">-</span> <span class="n">Represents</span> <span class="n">the</span> <span class="n">offset</span> <span class="n">into</span> <span class="n">the</span> <span class="k">global</span> <span class="n">offset</span> <span class="n">table</span> <span class="n">at</span> <span class="n">which</span>
    <span class="o">//</span> <span class="n">the</span> <span class="n">module</span> <span class="n">ID</span> <span class="ow">and</span> <span class="n">TSL</span> <span class="n">block</span> <span class="n">offset</span> <span class="n">reside</span> <span class="n">during</span> <span class="n">execution</span> <span class="p">(</span><span class="n">Local</span>
    <span class="o">//</span> <span class="n">Dynamic</span> <span class="n">TLS</span><span class="p">)</span><span class="o">.</span>
    <span class="n">MO_TLSLDM</span><span class="p">,</span>
    <span class="n">MO_DTP_HI</span><span class="p">,</span>
    <span class="n">MO_DTP_LO</span><span class="p">,</span>

    <span class="o">///</span> <span class="n">MO_GOTTPREL</span> <span class="o">-</span> <span class="n">Represents</span> <span class="n">the</span> <span class="n">offset</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">thread</span> <span class="n">pointer</span> <span class="p">(</span><span class="n">Initial</span>
    <span class="o">//</span> <span class="n">Exec</span> <span class="n">TLS</span><span class="p">)</span><span class="o">.</span>
    <span class="n">MO_GOTTPREL</span><span class="p">,</span>

    <span class="o">///</span> <span class="n">MO_TPREL_HI</span><span class="o">/</span><span class="n">LO</span> <span class="o">-</span> <span class="n">Represents</span> <span class="n">the</span> <span class="n">hi</span> <span class="ow">and</span> <span class="n">low</span> <span class="n">part</span> <span class="n">of</span> <span class="n">the</span> <span class="n">offset</span> <span class="kn">from</span>
    <span class="o">//</span> <span class="n">the</span> <span class="n">thread</span> <span class="n">pointer</span> <span class="p">(</span><span class="n">Local</span> <span class="n">Exec</span> <span class="n">TLS</span><span class="p">)</span><span class="o">.</span>
    <span class="n">MO_TP_HI</span><span class="p">,</span>
    <span class="n">MO_TP_LO</span><span class="p">,</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>    <span class="p">...</span>
  <span class="p">};</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/MCTargetDesc/Cpu0ELFObjectWriter.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">unsigned</span> <span class="n">Cpu0ELFObjectWriter</span><span class="p">::</span><span class="n">GetRelocType</span><span class="p">(</span><span class="n">const</span> <span class="n">MCValue</span> <span class="o">&amp;</span><span class="n">Target</span><span class="p">,</span>
                                           <span class="n">const</span> <span class="n">MCFixup</span> <span class="o">&amp;</span><span class="n">Fixup</span><span class="p">,</span>
                                           <span class="nb">bool</span> <span class="n">IsPCRel</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="o">//</span> <span class="n">determine</span> <span class="n">the</span> <span class="nb">type</span> <span class="n">of</span> <span class="n">the</span> <span class="n">relocation</span>
  <span class="n">unsigned</span> <span class="n">Type</span> <span class="o">=</span> <span class="p">(</span><span class="n">unsigned</span><span class="p">)</span><span class="n">ELF</span><span class="p">::</span><span class="n">R_CPU0_NONE</span><span class="p">;</span>
  <span class="n">unsigned</span> <span class="n">Kind</span> <span class="o">=</span> <span class="p">(</span><span class="n">unsigned</span><span class="p">)</span><span class="n">Fixup</span><span class="o">.</span><span class="n">getKind</span><span class="p">();</span>

  <span class="n">switch</span> <span class="p">(</span><span class="n">Kind</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="n">case</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_TLSGD</span><span class="p">:</span>
    <span class="n">Type</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">::</span><span class="n">R_CPU0_TLS_GD</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="n">case</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_GOTTPREL</span><span class="p">:</span>
    <span class="n">Type</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">::</span><span class="n">R_CPU0_TLS_GOTTPREL</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/MCTargetDesc/Cpu0FixupKinds.h</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="n">enum</span> <span class="n">Fixups</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>    <span class="o">//</span> <span class="n">resulting</span> <span class="ow">in</span> <span class="o">-</span> <span class="n">R_CPU0_TLS_GD</span><span class="o">.</span>
    <span class="n">fixup_Cpu0_TLSGD</span><span class="p">,</span>

    <span class="o">//</span> <span class="n">resulting</span> <span class="ow">in</span> <span class="o">-</span> <span class="n">R_CPU0_TLS_GOTTPREL</span><span class="o">.</span>
    <span class="n">fixup_Cpu0_GOTTPREL</span><span class="p">,</span>

    <span class="o">//</span> <span class="n">resulting</span> <span class="ow">in</span> <span class="o">-</span> <span class="n">R_CPU0_TLS_TPREL_HI16</span><span class="o">.</span>
    <span class="n">fixup_Cpu0_TP_HI</span><span class="p">,</span>

    <span class="o">//</span> <span class="n">resulting</span> <span class="ow">in</span> <span class="o">-</span> <span class="n">R_CPU0_TLS_TPREL_LO16</span><span class="o">.</span>
    <span class="n">fixup_Cpu0_TP_LO</span><span class="p">,</span>

    <span class="o">//</span> <span class="n">resulting</span> <span class="ow">in</span> <span class="o">-</span> <span class="n">R_CPU0_TLS_LDM</span><span class="o">.</span>
    <span class="n">fixup_Cpu0_TLSLDM</span><span class="p">,</span>

    <span class="o">//</span> <span class="n">resulting</span> <span class="ow">in</span> <span class="o">-</span> <span class="n">R_CPU0_TLS_DTP_HI16</span><span class="o">.</span>
    <span class="n">fixup_Cpu0_DTP_HI</span><span class="p">,</span>

    <span class="o">//</span> <span class="n">resulting</span> <span class="ow">in</span> <span class="o">-</span> <span class="n">R_CPU0_TLS_DTP_LO16</span><span class="o">.</span>
    <span class="n">fixup_Cpu0_DTP_LO</span><span class="p">,</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/MCTargetDesc/Cpu0MCCodeEmitter.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">unsigned</span> <span class="n">Cpu0MCCodeEmitter</span><span class="p">::</span>
<span class="n">getExprOpValue</span><span class="p">(</span><span class="n">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">Expr</span><span class="p">,</span><span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCFixup</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Fixups</span><span class="p">,</span>
               <span class="n">const</span> <span class="n">MCSubtargetInfo</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>    <span class="n">case</span> <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VK_Cpu0_TLSGD</span><span class="p">:</span>
      <span class="n">FixupKind</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_TLSGD</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="n">case</span> <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VK_Cpu0_TLSLDM</span><span class="p">:</span>
      <span class="n">FixupKind</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_TLSLDM</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="n">case</span> <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VK_Cpu0_DTP_HI</span><span class="p">:</span>
      <span class="n">FixupKind</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_DTP_HI</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="n">case</span> <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VK_Cpu0_DTP_LO</span><span class="p">:</span>
      <span class="n">FixupKind</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_DTP_LO</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="n">case</span> <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VK_Cpu0_GOTTPREL</span><span class="p">:</span>
      <span class="n">FixupKind</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_GOTTPREL</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="n">case</span> <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VK_Cpu0_TP_HI</span><span class="p">:</span>
      <span class="n">FixupKind</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_TP_HI</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="n">case</span> <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VK_Cpu0_TP_LO</span><span class="p">:</span>
      <span class="n">FixupKind</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_TP_LO</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0InstrInfo.td</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">TlsGd</span> <span class="n">node</span> <span class="ow">is</span> <span class="n">used</span> <span class="n">to</span> <span class="n">handle</span> <span class="n">General</span> <span class="n">Dynamic</span> <span class="n">TLS</span>
<span class="k">def</span> <span class="nf">Cpu0TlsGd</span> <span class="p">:</span> <span class="n">SDNode</span><span class="o">&lt;</span><span class="s2">&quot;Cpu0ISD::TlsGd&quot;</span><span class="p">,</span> <span class="n">SDTIntUnaryOp</span><span class="o">&gt;</span><span class="p">;</span>

<span class="o">//</span> <span class="n">TpHi</span> <span class="ow">and</span> <span class="n">TpLo</span> <span class="n">nodes</span> <span class="n">are</span> <span class="n">used</span> <span class="n">to</span> <span class="n">handle</span> <span class="n">Local</span> <span class="n">Exec</span> <span class="n">TLS</span>
<span class="k">def</span> <span class="nf">Cpu0TpHi</span>  <span class="p">:</span> <span class="n">SDNode</span><span class="o">&lt;</span><span class="s2">&quot;Cpu0ISD::TpHi&quot;</span><span class="p">,</span> <span class="n">SDTIntUnaryOp</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">Cpu0TpLo</span>  <span class="p">:</span> <span class="n">SDNode</span><span class="o">&lt;</span><span class="s2">&quot;Cpu0ISD::TpLo&quot;</span><span class="p">,</span> <span class="n">SDTIntUnaryOp</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>let Predicates = [Ch12_1] in {
def : Pat&lt;(Cpu0Hi tglobaltlsaddr:$in), (LUi tglobaltlsaddr:$in)&gt;;
}
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>let Predicates = [Ch12_1] in {
def : Pat&lt;(Cpu0Lo tglobaltlsaddr:$in), (ORi ZERO, tglobaltlsaddr:$in)&gt;;
}
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>let Predicates = [Ch12_1] in {
def : Pat&lt;(add CPURegs:$hi, (Cpu0Lo tglobaltlsaddr:$lo)),
              (ORi CPURegs:$hi, tglobaltlsaddr:$lo)&gt;;
}
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>let Predicates = [Ch12_1] in {
def : WrapperPat&lt;tglobaltlsaddr, ORi, CPURegs&gt;;
}
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0SelLowering.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="n">const</span> <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">,</span>
                                       <span class="n">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span>
    <span class="p">:</span> <span class="n">TargetLowering</span><span class="p">(</span><span class="n">TM</span><span class="p">),</span> <span class="n">Subtarget</span><span class="p">(</span><span class="n">STI</span><span class="p">),</span> <span class="n">ABI</span><span class="p">(</span><span class="n">TM</span><span class="o">.</span><span class="n">getABI</span><span class="p">())</span> <span class="p">{</span>

</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">GlobalTLSAddress</span><span class="p">,</span>   <span class="n">MVT</span><span class="p">::</span><span class="n">i32</span><span class="p">,</span>   <span class="n">Custom</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="p">::</span>
<span class="n">LowerOperation</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span>
<span class="p">{</span>
  <span class="n">switch</span> <span class="p">(</span><span class="n">Op</span><span class="o">.</span><span class="n">getOpcode</span><span class="p">())</span>
  <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="n">case</span> <span class="n">ISD</span><span class="p">::</span><span class="n">GlobalTLSAddress</span><span class="p">:</span>   <span class="k">return</span> <span class="n">lowerGlobalTLSAddress</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>    <span class="p">...</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>SDValue Cpu0TargetLowering::
lowerGlobalTLSAddress(SDValue Op, SelectionDAG &amp;DAG) const
{
  // If the relocation model is PIC, use the General Dynamic TLS Model or
  // Local Dynamic TLS model, otherwise use the Initial Exec or
  // Local Exec TLS Model.

  GlobalAddressSDNode *GA = cast&lt;GlobalAddressSDNode&gt;(Op);
  SDLoc DL(GA);
  const GlobalValue *GV = GA-&gt;getGlobal();
  EVT PtrVT = getPointerTy(DAG.getDataLayout());

  TLSModel::Model model = getTargetMachine().getTLSModel(GV);

  if (model == TLSModel::GeneralDynamic || model == TLSModel::LocalDynamic) {
    // General Dynamic and Local Dynamic TLS Model.
    unsigned Flag = (model == TLSModel::LocalDynamic) ? Cpu0II::MO_TLSLDM
                                                      : Cpu0II::MO_TLSGD;

    SDValue TGA = DAG.getTargetGlobalAddress(GV, DL, PtrVT, 0, Flag);
    SDValue Argument = DAG.getNode(Cpu0ISD::Wrapper, DL, PtrVT,
                                   getGlobalReg(DAG, PtrVT), TGA);
    unsigned PtrSize = PtrVT.getSizeInBits();
    IntegerType *PtrTy = Type::getIntNTy(*DAG.getContext(), PtrSize);

    SDValue TlsGetAddr = DAG.getExternalSymbol(&quot;__tls_get_addr&quot;, PtrVT);

    ArgListTy Args;
    ArgListEntry Entry;
    Entry.Node = Argument;
    Entry.Ty = PtrTy;
    Args.push_back(Entry);

    TargetLowering::CallLoweringInfo CLI(DAG);
    CLI.setDebugLoc(DL).setChain(DAG.getEntryNode())
      .setCallee(CallingConv::C, PtrTy, TlsGetAddr, std::move(Args), 0);
    std::pair&lt;SDValue, SDValue&gt; CallResult = LowerCallTo(CLI);

    SDValue Ret = CallResult.first;

    if (model != TLSModel::LocalDynamic)
      return Ret;

    SDValue TGAHi = DAG.getTargetGlobalAddress(GV, DL, PtrVT, 0,
                                               Cpu0II::MO_DTP_HI);
    SDValue Hi = DAG.getNode(Cpu0ISD::Hi, DL, PtrVT, TGAHi);
    SDValue TGALo = DAG.getTargetGlobalAddress(GV, DL, PtrVT, 0,
                                               Cpu0II::MO_DTP_LO);
    SDValue Lo = DAG.getNode(Cpu0ISD::Lo, DL, PtrVT, TGALo);
    SDValue Add = DAG.getNode(ISD::ADD, DL, PtrVT, Hi, Ret);
    return DAG.getNode(ISD::ADD, DL, PtrVT, Add, Lo);
  }

  SDValue Offset;
  if (model == TLSModel::InitialExec) {
    // Initial Exec TLS Model
    SDValue TGA = DAG.getTargetGlobalAddress(GV, DL, PtrVT, 0,
                                             Cpu0II::MO_GOTTPREL);
    TGA = DAG.getNode(Cpu0ISD::Wrapper, DL, PtrVT, getGlobalReg(DAG, PtrVT),
                      TGA);
    Offset = DAG.getLoad(PtrVT, DL,
                         DAG.getEntryNode(), TGA, MachinePointerInfo(),
                         false, false, false, 0);
  } else {
    // Local Exec TLS Model
    assert(model == TLSModel::LocalExec);
    SDValue TGAHi = DAG.getTargetGlobalAddress(GV, DL, PtrVT, 0,
                                               Cpu0II::MO_TP_HI);
    SDValue TGALo = DAG.getTargetGlobalAddress(GV, DL, PtrVT, 0,
                                               Cpu0II::MO_TP_LO);
    SDValue Hi = DAG.getNode(Cpu0ISD::Hi, DL, PtrVT, TGAHi);
    SDValue Lo = DAG.getNode(Cpu0ISD::Lo, DL, PtrVT, TGALo);
    Offset = DAG.getNode(ISD::ADD, DL, PtrVT, Hi, Lo);
  }
  return Offset;
}
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0SelLowering.h</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>    <span class="n">MachineBasicBlock</span> <span class="o">*</span>
    <span class="n">EmitInstrWithCustomInserter</span><span class="p">(</span><span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span>
                                <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">MBB</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0MCInstLower.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MCOperand</span> <span class="n">Cpu0MCInstLower</span><span class="p">::</span><span class="n">LowerSymbolOperand</span><span class="p">(</span><span class="n">const</span> <span class="n">MachineOperand</span> <span class="o">&amp;</span><span class="n">MO</span><span class="p">,</span>
                                              <span class="n">MachineOperandType</span> <span class="n">MOTy</span><span class="p">,</span>
                                              <span class="n">unsigned</span> <span class="n">Offset</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VariantKind</span> <span class="n">Kind</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">MCSymbol</span> <span class="o">*</span><span class="n">Symbol</span><span class="p">;</span>

  <span class="n">switch</span><span class="p">(</span><span class="n">MO</span><span class="o">.</span><span class="n">getTargetFlags</span><span class="p">())</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="n">case</span> <span class="n">Cpu0II</span><span class="p">::</span><span class="n">MO_TLSGD</span><span class="p">:</span>     <span class="n">Kind</span> <span class="o">=</span> <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VK_Cpu0_TLSGD</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
  <span class="n">case</span> <span class="n">Cpu0II</span><span class="p">::</span><span class="n">MO_TLSLDM</span><span class="p">:</span>    <span class="n">Kind</span> <span class="o">=</span> <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VK_Cpu0_TLSLDM</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
  <span class="n">case</span> <span class="n">Cpu0II</span><span class="p">::</span><span class="n">MO_DTP_HI</span><span class="p">:</span>    <span class="n">Kind</span> <span class="o">=</span> <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VK_Cpu0_DTP_HI</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
  <span class="n">case</span> <span class="n">Cpu0II</span><span class="p">::</span><span class="n">MO_DTP_LO</span><span class="p">:</span>    <span class="n">Kind</span> <span class="o">=</span> <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VK_Cpu0_DTP_LO</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
  <span class="n">case</span> <span class="n">Cpu0II</span><span class="p">::</span><span class="n">MO_GOTTPREL</span><span class="p">:</span>  <span class="n">Kind</span> <span class="o">=</span> <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VK_Cpu0_GOTTPREL</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
  <span class="n">case</span> <span class="n">Cpu0II</span><span class="p">::</span><span class="n">MO_TP_HI</span><span class="p">:</span>     <span class="n">Kind</span> <span class="o">=</span> <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VK_Cpu0_TP_HI</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
  <span class="n">case</span> <span class="n">Cpu0II</span><span class="p">::</span><span class="n">MO_TP_LO</span><span class="p">:</span>     <span class="n">Kind</span> <span class="o">=</span> <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VK_Cpu0_TP_LO</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="p">...</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre><span></span>JonathantekiiMac:input Jonathan$ clang -target mips-unknown-linux-gnu -c
ch12_thread_var.cpp -emit-llvm -std<span class="o">=</span>c++11 -o ch12_thread_var.bc
JonathantekiiMac:input Jonathan$ /Users/Jonathan/llvm/test/cmake_debug_build/
Debug/bin/llvm-dis ch12_thread_var.bc -o -
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>; ModuleID = &#39;ch12_thread_var.bc&#39;
target datalayout = &quot;E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64&quot;
target triple = &quot;mips-unknown-linux-gnu&quot;

@a = thread_local global i32 0, align 4
@b = thread_local global i32 0, align 4

; Function Attrs: nounwind
define i32 @_Z15test_thread_varv() #0 {
  store i32 2, i32* @a, align 4
  %1 = load i32, i32* @a, align 4
  ret i32 %1
}

define i32 @_Z17test_thread_var_2v() #1 {
  %1 = call i32* @_ZTW1b()
  store i32 3, i32* %1, align 4
  %2 = call i32* @_ZTW1b()
  %3 = load i32, i32* %2, align 4
  ret i32 %3
}

define weak_odr hidden i32* @_ZTW1b() {
  ret i32* @b
}

attributes #0 = { nounwind &quot;less-precise-fpmad&quot;=&quot;false&quot; &quot;no-frame-pointer-elim&quot;=
&quot;true&quot; &quot;no-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;=&quot;false&quot; &quot;no-nans-fp-ma
th&quot;=&quot;false&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;target-cpu&quot;=&quot;mips32r2&quot; &quot;target-fe
atures&quot;=&quot;+mips32r2&quot; &quot;unsafe-fp-math&quot;=&quot;false&quot; &quot;use-soft-float&quot;=&quot;false&quot; }
attributes #1 = { &quot;less-precise-fpmad&quot;=&quot;false&quot; &quot;no-frame-pointer-elim&quot;=&quot;true&quot; &quot;n
o-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;=&quot;false&quot; &quot;no-nans-fp-math&quot;=&quot;fals
e&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;target-cpu&quot;=&quot;mips32r2&quot; &quot;target-features&quot;=&quot;
+mips32r2&quot; &quot;unsafe-fp-math&quot;=&quot;false&quot; &quot;use-soft-float&quot;=&quot;false&quot; }

!llvm.ident = !{!0}

!0 = !{!&quot;Apple LLVM version 7.0.0 (clang-700.1.76)&quot;}
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre><span></span>JonathantekiiMac:input Jonathan$ /Users/Jonathan/llvm/test/cmake_debug_build/
Debug/bin/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch12_thread_var.bc
-o -
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  .text
  .section .mdebug.abiO32
  .previous
  .file  &quot;ch12_thread_var.bc&quot;
  .globl  _Z15test_thread_varv
  .align  2
  .type  _Z15test_thread_varv,@function
  .ent  _Z15test_thread_varv    # @_Z15test_thread_varv
_Z15test_thread_varv:
  .frame  $fp,16,$lr
  .mask   0x00005000,-4
  .set  noreorder
  .cpload  $t9
  .set  nomacro
# BB#0:
  addiu  $sp, $sp, -16
  st  $lr, 12($sp)            # 4-byte Folded Spill
  st  $fp, 8($sp)             # 4-byte Folded Spill
  move   $fp, $sp
  .cprestore  8
  ld  $t9, %call16(__tls_get_addr)($gp)
  ori  $4, $gp, %tlsgd(a)
  jalr  $t9
  nop
  ld  $gp, 8($fp)
  addiu  $3, $zero, 2
  st  $3, 0($2)
  addu  $2, $zero, $3
  move   $sp, $fp
  ld  $fp, 8($sp)             # 4-byte Folded Reload
  ld  $lr, 12($sp)            # 4-byte Folded Reload
  addiu  $sp, $sp, 16
  ret  $lr
  nop
  .set  macro
  .set  reorder
  .end  _Z15test_thread_varv
$func_end0:
  .size  _Z15test_thread_varv, ($func_end0)-_Z15test_thread_varv

  .globl  _Z17test_thread_var_2v
  .align  2
  .type  _Z17test_thread_var_2v,@function
  .ent  _Z17test_thread_var_2v  # @_Z17test_thread_var_2v
_Z17test_thread_var_2v:
  .cfi_startproc
  .frame  $fp,16,$lr
  .mask   0x00005000,-4
  .set  noreorder
  .cpload  $t9
  .set  nomacro
# BB#0:
  addiu  $sp, $sp, -16
$tmp0:
  .cfi_def_cfa_offset 16
  st  $lr, 12($sp)            # 4-byte Folded Spill
  st  $fp, 8($sp)             # 4-byte Folded Spill
$tmp1:
  .cfi_offset 14, -4
$tmp2:
  .cfi_offset 12, -8
  move   $fp, $sp
$tmp3:
  .cfi_def_cfa_register 12
  .cprestore  8
  ld  $t9, %call16(_ZTW1b)($gp)
  jalr  $t9
  nop
  ld  $gp, 8($fp)
  addiu  $3, $zero, 3
  st  $3, 0($2)
  ld  $t9, %call16(_ZTW1b)($gp)
  jalr  $t9
  nop
  ld  $gp, 8($fp)
  ld  $2, 0($2)
  move   $sp, $fp
  ld  $fp, 8($sp)             # 4-byte Folded Reload
  ld  $lr, 12($sp)            # 4-byte Folded Reload
  addiu  $sp, $sp, 16
  ret  $lr
  nop
  .set  macro
  .set  reorder
  .end  _Z17test_thread_var_2v
$func_end1:
  .size  _Z17test_thread_var_2v, ($func_end1)-_Z17test_thread_var_2v
  .cfi_endproc

  .hidden  _ZTW1b
  .weak  _ZTW1b
  .align  2
  .type  _ZTW1b,@function
  .ent  _ZTW1b                  # @_ZTW1b
_ZTW1b:
  .cfi_startproc
  .frame  $sp,16,$lr
  .mask   0x00004000,-4
  .set  noreorder
  .cpload  $t9
  .set  nomacro
# BB#0:
  addiu  $sp, $sp, -16
$tmp4:
  .cfi_def_cfa_offset 16
  st  $lr, 12($sp)            # 4-byte Folded Spill
$tmp5:
  .cfi_offset 14, -4
  .cprestore  8
  ld  $t9, %call16(__tls_get_addr)($gp)
  ori  $4, $gp, %tlsgd(b)
  jalr  $t9
  nop
  ld  $gp, 8($sp)
  ld  $lr, 12($sp)            # 4-byte Folded Reload
  addiu  $sp, $sp, 16
  ret  $lr
  nop
  .set  macro
  .set  reorder
  .end  _ZTW1b
$func_end2:
  .size  _ZTW1b, ($func_end2)-_ZTW1b
  .cfi_endproc

  .type  a,@object               # @a
  .section  .tbss,&quot;awT&quot;,@nobits
  .globl  a
  .align  2
a:
  .4byte  0                       # 0x0
  .size  a, 4

  .type  b,@object               # @b
  .globl  b
  .align  2
b:
  .4byte  0                       # 0x0
  .size  b, 4


  .ident  &quot;Apple LLVM version 7.0.0 (clang-700.1.76)&quot;
  .section  &quot;.note.GNU-stack&quot;,&quot;&quot;,@progbits
</pre></div>
</div>
<p>In pic mode, the __thread variable access by call function __tls_get_addr with
the address of thread variable.
The c++11 standard thread_local variable is accessed by call function _ZTW1b
which call the function __tls_get_addr too to get the thread_local variable
address.
In static mode, the thread variable is accessed by machine instructions as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>JonathantekiiMac:input Jonathan$ /Users/Jonathan/llvm/test/cmake_debug_build/
Debug/bin/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>static -filetype<span class="o">=</span>asm
ch12_thread_var.bc -o -
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  .text
  .section .mdebug.abiO32
  .previous
  .file  &quot;ch12_thread_var.bc&quot;
  .globl  _Z15test_thread_varv
  .align  2
  .type  _Z15test_thread_varv,@function
  .ent  _Z15test_thread_varv    # @_Z15test_thread_varv
_Z15test_thread_varv:
  .frame  $fp,8,$lr
  .mask   0x00001000,-4
  .set  noreorder
  .set  nomacro
# BB#0:
  addiu  $sp, $sp, -8
  st  $fp, 4($sp)             # 4-byte Folded Spill
  move   $fp, $sp
  lui  $2, %tp_hi(a)
  ori  $3, $2, %tp_lo(a)
  addiu  $2, $zero, 2
  st  $2, 0($3)
  move   $sp, $fp
  ld  $fp, 4($sp)             # 4-byte Folded Reload
  addiu  $sp, $sp, 8
  ret  $lr
  nop
  .set  macro
  .set  reorder
  .end  _Z15test_thread_varv
$func_end0:
  .size  _Z15test_thread_varv, ($func_end0)-_Z15test_thread_varv

  .globl  _Z17test_thread_var_2v
  .align  2
  .type  _Z17test_thread_var_2v,@function
  .ent  _Z17test_thread_var_2v  # @_Z17test_thread_var_2v
_Z17test_thread_var_2v:
  .cfi_startproc
  .frame  $fp,16,$lr
  .mask   0x00005000,-4
  .set  noreorder
  .set  nomacro
# BB#0:
  addiu  $sp, $sp, -16
$tmp0:
  .cfi_def_cfa_offset 16
  st  $lr, 12($sp)            # 4-byte Folded Spill
  st  $fp, 8($sp)             # 4-byte Folded Spill
$tmp1:
  .cfi_offset 14, -4
$tmp2:
  .cfi_offset 12, -8
  move   $fp, $sp
$tmp3:
  .cfi_def_cfa_register 12
  jsub  _ZTW1b
  nop
  addiu  $3, $zero, 3
  st  $3, 0($2)
  jsub  _ZTW1b
  nop
  ld  $2, 0($2)
  move   $sp, $fp
  ld  $fp, 8($sp)             # 4-byte Folded Reload
  ld  $lr, 12($sp)            # 4-byte Folded Reload
  addiu  $sp, $sp, 16
  ret  $lr
  nop
  .set  macro
  .set  reorder
  .end  _Z17test_thread_var_2v
$func_end1:
  .size  _Z17test_thread_var_2v, ($func_end1)-_Z17test_thread_var_2v
  .cfi_endproc

  .hidden  _ZTW1b
  .weak  _ZTW1b
  .align  2
  .type  _ZTW1b,@function
  .ent  _ZTW1b                  # @_ZTW1b
_ZTW1b:
  .cfi_startproc
  .frame  $sp,0,$lr
  .mask   0x00000000,0
  .set  noreorder
  .set  nomacro
# BB#0:
  lui  $2, %tp_hi(b)
  ori  $2, $2, %tp_lo(b)
  ret  $lr
  nop
  .set  macro
  .set  reorder
  .end  _ZTW1b
$func_end2:
  .size  _ZTW1b, ($func_end2)-_ZTW1b
  .cfi_endproc

  .type  a,@object               # @a
  .section  .tbss,&quot;awT&quot;,@nobits
  .globl  a
  .align  2
a:
  .4byte  0                       # 0x0
  .size  a, 4

  .type  b,@object               # @b
  .globl  b
  .align  2
b:
  .4byte  0                       # 0x0
  .size  b, 4


  .ident  &quot;Apple LLVM version 7.0.0 (clang-700.1.76)&quot;
  .section  &quot;.note.GNU-stack&quot;,&quot;&quot;,@progbits
</pre></div>
</div>
<p>While Mips uses rdhwr instruction to access thread varaible as below,
Cpu0 access thread varaible without inventing any new instruction.
The thread variables are keeped in thread varaible memory location which
accessed through %tp_hi and %tp_lo. Furthermore, this section of memory is
protected through kernel mode program.
As a result, the user mode program cannot access this area of memory and
no space to breathe for hack program.</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>JonathantekiiMac:input Jonathan$ /Users/Jonathan/llvm/test/cmake_debug_build/
Debug/bin/llc -march<span class="o">=</span>mips -relocation-model<span class="o">=</span>static -filetype<span class="o">=</span>asm
ch12_thread_var.bc -o -
  ...
  lui <span class="nv">$1</span>, %tprel_hi<span class="o">(</span>a<span class="o">)</span>
  ori <span class="nv">$1</span>, <span class="nv">$1</span>, %tprel_lo<span class="o">(</span>a<span class="o">)</span>
  .set  push
  .set  mips32r2
  rdhwr <span class="nv">$3</span>, <span class="nv">$29</span>
  .set  pop
  addu  <span class="nv">$1</span>, <span class="nv">$3</span>, <span class="nv">$1</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 2
  sw  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$1</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 2
  ...
</pre></div>
</div>
<p>In static mode, the thread variable is similar to global variable.
In general, they are same in IRs, DAGs and machine code translation.
List them in the following tables.
You can check them with debug option enabled.</p>
<table border="1" class="docutils" id="id8">
<caption><span class="caption-number">Table 32 </span><span class="caption-text">The DAGs of thread varaible of static mode</span><a class="headerlink" href="#id8" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="46%" />
<col width="54%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">stage</th>
<th class="head">DAG</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>IR</td>
<td>load i32* &#64;a, align 4;</td>
</tr>
<tr class="row-odd"><td>Legalized selection DAG</td>
<td>(add Cpu0ISD::Hi Cpu0ISD::Lo);</td>
</tr>
<tr class="row-even"><td>Instruction Selection</td>
<td>ori $2, $zero, %tp_lo(a);</td>
</tr>
<tr class="row-odd"><td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>lui $3, %tp_hi(a);</td>
</tr>
<tr class="row-even"><td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>addu  $3, $3, $2;</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils" id="id9">
<caption><span class="caption-number">Table 33 </span><span class="caption-text">The DAGs of local_thread varaible of static mode</span><a class="headerlink" href="#id9" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="42%" />
<col width="58%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">stage</th>
<th class="head">DAG</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>IR</td>
<td>ret i32* &#64;b;</td>
</tr>
<tr class="row-odd"><td>Legalized selection DAG</td>
<td>%0=(add Cpu0ISD::Hi Cpu0ISD::Lo);...</td>
</tr>
<tr class="row-even"><td>Instruction Selection</td>
<td>ori $2, $zero, %tp_lo(a);</td>
</tr>
<tr class="row-odd"><td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>lui $3, %tp_hi(a);</td>
</tr>
<tr class="row-even"><td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>addu  $3, $3, $2;</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="atomic">
<h2><a class="toc-backref" href="#id13">Atomic</a><a class="headerlink" href="#atomic" title="Permalink to this headline">¶</a></h2>
<p>In tradition, C uses different API which provided by OS or library to support
multi-thread programming. For example, posix thread API on unix/linux, MS
windows API, ..., etc. In order to achieve synchronization to solve race
condition between threads, OS provide their own lock or semaphore functions to
programmer. But this solution is OS dependent.
After c++11, programmer can use atomic to program and run the code
on every different platform since the thread and atomic are part of c++ standard.
Beside of portability, the other important benifit is the compiler can generate
high performance code by the target hardware instruction rather than couting on
lock() function only <a class="footnote-reference" href="#atomic-wiki" id="id3">[3]</a> <a class="footnote-reference" href="#atomic-stackoverflow" id="id4">[4]</a>
<a class="footnote-reference" href="#atomic-herbsutter" id="id5">[5]</a>.</p>
<p>In order to support atomic in C++ and java, llvm provides the atomic IRs here
<a class="footnote-reference" href="#atomics-llvm" id="id6">[6]</a> <a class="footnote-reference" href="#llvmlang-ordering" id="id7">[7]</a>.</p>
<p>To support llvm atomic IRs, the following code added to Chapter12_1.</p>
<p class="rubric">lbdex/chapters/Chapter12_1/AsmParser/Cpu0AsmParser.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VariantKind</span> <span class="n">Cpu0AsmParser</span><span class="p">::</span><span class="n">getVariantKind</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">Symbol</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>    <span class="o">.</span><span class="n">Case</span><span class="p">(</span><span class="s2">&quot;tlsgd&quot;</span><span class="p">,</span>       <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VK_Cpu0_TLSGD</span><span class="p">)</span>
    <span class="o">.</span><span class="n">Case</span><span class="p">(</span><span class="s2">&quot;tlsldm&quot;</span><span class="p">,</span>      <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VK_Cpu0_TLSLDM</span><span class="p">)</span>
    <span class="o">.</span><span class="n">Case</span><span class="p">(</span><span class="s2">&quot;dtp_hi&quot;</span><span class="p">,</span>      <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VK_Cpu0_DTP_HI</span><span class="p">)</span>
    <span class="o">.</span><span class="n">Case</span><span class="p">(</span><span class="s2">&quot;dtp_lo&quot;</span><span class="p">,</span>      <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VK_Cpu0_DTP_LO</span><span class="p">)</span>
    <span class="o">.</span><span class="n">Case</span><span class="p">(</span><span class="s2">&quot;gottp&quot;</span><span class="p">,</span>       <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VK_Cpu0_GOTTPREL</span><span class="p">)</span>
    <span class="o">.</span><span class="n">Case</span><span class="p">(</span><span class="s2">&quot;tp_hi&quot;</span><span class="p">,</span>       <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VK_Cpu0_TP_HI</span><span class="p">)</span>
    <span class="o">.</span><span class="n">Case</span><span class="p">(</span><span class="s2">&quot;tp_lo&quot;</span><span class="p">,</span>       <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VK_Cpu0_TP_LO</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Disassembler/Cpu0Disassembler.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">static</span> <span class="n">DecodeStatus</span> <span class="n">DecodeMem</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span>
                              <span class="n">unsigned</span> <span class="n">Insn</span><span class="p">,</span>
                              <span class="n">uint64_t</span> <span class="n">Address</span><span class="p">,</span>
                              <span class="n">const</span> <span class="n">void</span> <span class="o">*</span><span class="n">Decoder</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="k">if</span><span class="p">(</span><span class="n">Inst</span><span class="o">.</span><span class="n">getOpcode</span><span class="p">()</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">SC</span><span class="p">){</span>
    <span class="n">Inst</span><span class="o">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="p">::</span><span class="n">createReg</span><span class="p">(</span><span class="n">Reg</span><span class="p">));</span>
  <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0InstrInfo.td</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">SDT_Sync</span>             <span class="p">:</span> <span class="n">SDTypeProfile</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="n">SDTCisVT</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">i32</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">Cpu0Sync</span> <span class="p">:</span> <span class="n">SDNode</span><span class="o">&lt;</span><span class="s2">&quot;Cpu0ISD::Sync&quot;</span><span class="p">,</span> <span class="n">SDT_Sync</span><span class="p">,</span> <span class="p">[</span><span class="n">SDNPHasChain</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">PtrRC</span> <span class="p">:</span> <span class="n">Operand</span><span class="o">&lt;</span><span class="n">iPTR</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">let</span> <span class="n">MIOperandInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">ops</span> <span class="n">ptr_rc</span><span class="p">);</span>
  <span class="n">let</span> <span class="n">DecoderMethod</span> <span class="o">=</span> <span class="s2">&quot;DecodeCPURegsRegisterClass&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>// Atomic instructions with 2 source operands (ATOMIC_SWAP &amp; ATOMIC_LOAD_*).
class Atomic2Ops&lt;PatFrag Op, RegisterClass DRC&gt; :
  PseudoSE&lt;(outs DRC:$dst), (ins PtrRC:$ptr, DRC:$incr),
           [(set DRC:$dst, (Op iPTR:$ptr, DRC:$incr))]&gt;;

// Atomic Compare &amp; Swap.
class AtomicCmpSwap&lt;PatFrag Op, RegisterClass DRC&gt; :
  PseudoSE&lt;(outs DRC:$dst), (ins PtrRC:$ptr, DRC:$cmp, DRC:$swap),
           [(set DRC:$dst, (Op iPTR:$ptr, DRC:$cmp, DRC:$swap))]&gt;;
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>class LLBase&lt;bits&lt;8&gt; Opc, string opstring, RegisterClass RC, Operand Mem&gt; :
  FMem&lt;Opc, (outs RC:$ra), (ins Mem:$addr),
       !strconcat(opstring, &quot;\t$ra, $addr&quot;), [], IILoad&gt; {
  let mayLoad = 1;
}

class SCBase&lt;bits&lt;8&gt; Opc, string opstring, RegisterOperand RO, Operand Mem&gt; :
  FMem&lt;Opc, (outs RO:$dst), (ins RO:$ra, Mem:$addr),
       !strconcat(opstring, &quot;\t$ra, $addr&quot;), [], IIStore&gt; {
  let mayStore = 1;
  let Constraints = &quot;$ra = $dst&quot;;
}
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ch12_1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">{</span>
<span class="n">let</span> <span class="n">usesCustomInserter</span> <span class="o">=</span> <span class="mi">1</span> <span class="ow">in</span> <span class="p">{</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_ADD_I8</span>   <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_add_8</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_ADD_I16</span>  <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_add_16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_ADD_I32</span>  <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_add_32</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_SUB_I8</span>   <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_sub_8</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_SUB_I16</span>  <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_sub_16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_SUB_I32</span>  <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_sub_32</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_AND_I8</span>   <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_and_8</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_AND_I16</span>  <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_and_16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_AND_I32</span>  <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_and_32</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_OR_I8</span>    <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_or_8</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_OR_I16</span>   <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_or_16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_OR_I32</span>   <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_or_32</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_XOR_I8</span>   <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_xor_8</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_XOR_I16</span>  <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_xor_16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_XOR_I32</span>  <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_xor_32</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_NAND_I8</span>  <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_nand_8</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_NAND_I16</span> <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_nand_16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_NAND_I32</span> <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_nand_32</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>

  <span class="k">def</span> <span class="nf">ATOMIC_SWAP_I8</span>       <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_swap_8</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_SWAP_I16</span>      <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_swap_16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_SWAP_I32</span>      <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_swap_32</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>

  <span class="k">def</span> <span class="nf">ATOMIC_CMP_SWAP_I8</span>   <span class="p">:</span> <span class="n">AtomicCmpSwap</span><span class="o">&lt;</span><span class="n">atomic_cmp_swap_8</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_CMP_SWAP_I16</span>  <span class="p">:</span> <span class="n">AtomicCmpSwap</span><span class="o">&lt;</span><span class="n">atomic_cmp_swap_16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_CMP_SWAP_I32</span>  <span class="p">:</span> <span class="n">AtomicCmpSwap</span><span class="o">&lt;</span><span class="n">atomic_cmp_swap_32</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>let Predicates = [Ch12_1] in {
let hasSideEffects = 1 in
def SYNC : Cpu0Inst&lt;(outs), (ins i32imm:$stype), &quot;sync $stype&quot;,
                    [(Cpu0Sync imm:$stype)], NoItinerary, FrmOther&gt;
{
  bits&lt;5&gt; stype;
  let Opcode = 0x60;
  let Inst{25-11} = 0;
  let Inst{10-6} = stype;
  let Inst{5-0} = 0;
}
}
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">///</span> <span class="n">Load</span><span class="o">-</span><span class="n">linked</span><span class="p">,</span> <span class="n">Store</span><span class="o">-</span><span class="n">conditional</span>
<span class="k">def</span> <span class="nf">LL</span>      <span class="p">:</span> <span class="n">LLBase</span><span class="o">&lt;</span><span class="mh">0x61</span><span class="p">,</span> <span class="s2">&quot;ll&quot;</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="n">mem</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">SC</span>      <span class="p">:</span> <span class="n">SCBase</span><span class="o">&lt;</span><span class="mh">0x62</span><span class="p">,</span> <span class="s2">&quot;sc&quot;</span><span class="p">,</span> <span class="n">RegisterOperand</span><span class="o">&lt;</span><span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">mem</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>def : Cpu0InstAlias&lt;&quot;sync&quot;,
                    (SYNC 0), 1&gt;;
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0SelLowering.h</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>    <span class="n">MachineBasicBlock</span> <span class="o">*</span>
    <span class="n">EmitInstrWithCustomInserter</span><span class="p">(</span><span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span>
                                <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">MBB</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>    <span class="n">SDValue</span> <span class="n">lowerATOMIC_FENCE</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span><span class="o">&amp;</span> <span class="n">DAG</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>    <span class="o">///</span> <span class="n">Emit</span> <span class="n">a</span> <span class="n">sign</span><span class="o">-</span><span class="n">extension</span> <span class="n">using</span> <span class="n">shl</span><span class="o">/</span><span class="n">sra</span> <span class="n">appropriately</span><span class="o">.</span>
    <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">emitSignExtendToI32InReg</span><span class="p">(</span><span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span>
                                                <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">BB</span><span class="p">,</span>
                                                <span class="n">unsigned</span> <span class="n">Size</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">DstReg</span><span class="p">,</span>
                                                <span class="n">unsigned</span> <span class="n">SrcRec</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
    <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">emitAtomicBinary</span><span class="p">(</span><span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">BB</span><span class="p">,</span>
                    <span class="n">unsigned</span> <span class="n">Size</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">BinOpcode</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">Nand</span> <span class="o">=</span> <span class="n">false</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
    <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">emitAtomicBinaryPartword</span><span class="p">(</span><span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span>
                    <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">BB</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">Size</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">BinOpcode</span><span class="p">,</span>
                    <span class="nb">bool</span> <span class="n">Nand</span> <span class="o">=</span> <span class="n">false</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
    <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">emitAtomicCmpSwap</span><span class="p">(</span><span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span>
                                  <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">BB</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">Size</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
    <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">emitAtomicCmpSwapPartword</span><span class="p">(</span><span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span>
                                  <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">BB</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">Size</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0SelLowering.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">getTargetNodeName</span><span class="p">(</span><span class="n">unsigned</span> <span class="n">Opcode</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="n">case</span> <span class="n">Cpu0ISD</span><span class="p">::</span><span class="n">Sync</span><span class="p">:</span>              <span class="k">return</span> <span class="s2">&quot;Cpu0ISD::Sync&quot;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="n">const</span> <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">,</span>
                                       <span class="n">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span>
    <span class="p">:</span> <span class="n">TargetLowering</span><span class="p">(</span><span class="n">TM</span><span class="p">),</span> <span class="n">Subtarget</span><span class="p">(</span><span class="n">STI</span><span class="p">),</span> <span class="n">ABI</span><span class="p">(</span><span class="n">TM</span><span class="o">.</span><span class="n">getABI</span><span class="p">())</span> <span class="p">{</span>

</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">ATOMIC_LOAD</span><span class="p">,</span>       <span class="n">MVT</span><span class="p">::</span><span class="n">i32</span><span class="p">,</span>    <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">ATOMIC_LOAD</span><span class="p">,</span>       <span class="n">MVT</span><span class="p">::</span><span class="n">i64</span><span class="p">,</span>    <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">ATOMIC_STORE</span><span class="p">,</span>      <span class="n">MVT</span><span class="p">::</span><span class="n">i32</span><span class="p">,</span>    <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">ATOMIC_STORE</span><span class="p">,</span>      <span class="n">MVT</span><span class="p">::</span><span class="n">i64</span><span class="p">,</span>    <span class="n">Expand</span><span class="p">);</span>

  <span class="n">setInsertFencesForAtomic</span><span class="p">(</span><span class="n">true</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="p">::</span>
<span class="n">LowerOperation</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span>
<span class="p">{</span>
  <span class="n">switch</span> <span class="p">(</span><span class="n">Op</span><span class="o">.</span><span class="n">getOpcode</span><span class="p">())</span>
  <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="n">case</span> <span class="n">ISD</span><span class="p">::</span><span class="n">ATOMIC_FENCE</span><span class="p">:</span>       <span class="k">return</span> <span class="n">lowerATOMIC_FENCE</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>MachineBasicBlock *
Cpu0TargetLowering::EmitInstrWithCustomInserter(MachineInstr *MI,
                                                MachineBasicBlock *BB) const {
  switch (MI-&gt;getOpcode()) {
  default:
    llvm_unreachable(&quot;Unexpected instr type to insert&quot;);
  case Cpu0::ATOMIC_LOAD_ADD_I8:
    return emitAtomicBinaryPartword(MI, BB, 1, Cpu0::ADDu);
  case Cpu0::ATOMIC_LOAD_ADD_I16:
    return emitAtomicBinaryPartword(MI, BB, 2, Cpu0::ADDu);
  case Cpu0::ATOMIC_LOAD_ADD_I32:
    return emitAtomicBinary(MI, BB, 4, Cpu0::ADDu);

  case Cpu0::ATOMIC_LOAD_AND_I8:
    return emitAtomicBinaryPartword(MI, BB, 1, Cpu0::AND);
  case Cpu0::ATOMIC_LOAD_AND_I16:
    return emitAtomicBinaryPartword(MI, BB, 2, Cpu0::AND);
  case Cpu0::ATOMIC_LOAD_AND_I32:
    return emitAtomicBinary(MI, BB, 4, Cpu0::AND);

  case Cpu0::ATOMIC_LOAD_OR_I8:
    return emitAtomicBinaryPartword(MI, BB, 1, Cpu0::OR);
  case Cpu0::ATOMIC_LOAD_OR_I16:
    return emitAtomicBinaryPartword(MI, BB, 2, Cpu0::OR);
  case Cpu0::ATOMIC_LOAD_OR_I32:
    return emitAtomicBinary(MI, BB, 4, Cpu0::OR);

  case Cpu0::ATOMIC_LOAD_XOR_I8:
    return emitAtomicBinaryPartword(MI, BB, 1, Cpu0::XOR);
  case Cpu0::ATOMIC_LOAD_XOR_I16:
    return emitAtomicBinaryPartword(MI, BB, 2, Cpu0::XOR);
  case Cpu0::ATOMIC_LOAD_XOR_I32:
    return emitAtomicBinary(MI, BB, 4, Cpu0::XOR);

  case Cpu0::ATOMIC_LOAD_NAND_I8:
    return emitAtomicBinaryPartword(MI, BB, 1, 0, true);
  case Cpu0::ATOMIC_LOAD_NAND_I16:
    return emitAtomicBinaryPartword(MI, BB, 2, 0, true);
  case Cpu0::ATOMIC_LOAD_NAND_I32:
    return emitAtomicBinary(MI, BB, 4, 0, true);

  case Cpu0::ATOMIC_LOAD_SUB_I8:
    return emitAtomicBinaryPartword(MI, BB, 1, Cpu0::SUBu);
  case Cpu0::ATOMIC_LOAD_SUB_I16:
    return emitAtomicBinaryPartword(MI, BB, 2, Cpu0::SUBu);
  case Cpu0::ATOMIC_LOAD_SUB_I32:
    return emitAtomicBinary(MI, BB, 4, Cpu0::SUBu);

  case Cpu0::ATOMIC_SWAP_I8:
    return emitAtomicBinaryPartword(MI, BB, 1, 0);
  case Cpu0::ATOMIC_SWAP_I16:
    return emitAtomicBinaryPartword(MI, BB, 2, 0);
  case Cpu0::ATOMIC_SWAP_I32:
    return emitAtomicBinary(MI, BB, 4, 0);

  case Cpu0::ATOMIC_CMP_SWAP_I8:
    return emitAtomicCmpSwapPartword(MI, BB, 1);
  case Cpu0::ATOMIC_CMP_SWAP_I16:
    return emitAtomicCmpSwapPartword(MI, BB, 2);
  case Cpu0::ATOMIC_CMP_SWAP_I32:
    return emitAtomicCmpSwap(MI, BB, 4);
  }
}

// This function also handles Cpu0::ATOMIC_SWAP_I32 (when BinOpcode == 0), and
// Cpu0::ATOMIC_LOAD_NAND_I32 (when Nand == true)
MachineBasicBlock *
Cpu0TargetLowering::emitAtomicBinary(MachineInstr *MI, MachineBasicBlock *BB,
                                     unsigned Size, unsigned BinOpcode,
                                     bool Nand) const {
  assert((Size == 4) &amp;&amp; &quot;Unsupported size for EmitAtomicBinary.&quot;);

  MachineFunction *MF = BB-&gt;getParent();
  MachineRegisterInfo &amp;RegInfo = MF-&gt;getRegInfo();
  const TargetRegisterClass *RC = getRegClassFor(MVT::getIntegerVT(Size * 8));
  const TargetInstrInfo *TII = Subtarget.getInstrInfo();
  DebugLoc DL = MI-&gt;getDebugLoc();
  unsigned LL, SC, AND, XOR, ZERO, BEQ;

  LL = Cpu0::LL;
  SC = Cpu0::SC;
  AND = Cpu0::AND;
  XOR = Cpu0::XOR;
  ZERO = Cpu0::ZERO;
  BEQ = Cpu0::BEQ;

  unsigned OldVal = MI-&gt;getOperand(0).getReg();
  unsigned Ptr = MI-&gt;getOperand(1).getReg();
  unsigned Incr = MI-&gt;getOperand(2).getReg();

  unsigned StoreVal = RegInfo.createVirtualRegister(RC);
  unsigned AndRes = RegInfo.createVirtualRegister(RC);
  unsigned AndRes2 = RegInfo.createVirtualRegister(RC);
  unsigned Success = RegInfo.createVirtualRegister(RC);

  // insert new blocks after the current block
  const BasicBlock *LLVM_BB = BB-&gt;getBasicBlock();
  MachineBasicBlock *loopMBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineBasicBlock *exitMBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineFunction::iterator It = BB;
  ++It;
  MF-&gt;insert(It, loopMBB);
  MF-&gt;insert(It, exitMBB);

  // Transfer the remainder of BB and its successor edges to exitMBB.
  exitMBB-&gt;splice(exitMBB-&gt;begin(), BB,
                  std::next(MachineBasicBlock::iterator(MI)), BB-&gt;end());
  exitMBB-&gt;transferSuccessorsAndUpdatePHIs(BB);

  //  thisMBB:
  //    ...
  //    fallthrough --&gt; loopMBB
  BB-&gt;addSuccessor(loopMBB);
  loopMBB-&gt;addSuccessor(loopMBB);
  loopMBB-&gt;addSuccessor(exitMBB);

  //  loopMBB:
  //    ll oldval, 0(ptr)
  //    &lt;binop&gt; storeval, oldval, incr
  //    sc success, storeval, 0(ptr)
  //    beq success, $0, loopMBB
  BB = loopMBB;
  BuildMI(BB, DL, TII-&gt;get(LL), OldVal).addReg(Ptr).addImm(0);
  if (Nand) {
    //  and andres, oldval, incr
    //  xor storeval, $0, andres
    //  xor storeval2, $0, storeval
    BuildMI(BB, DL, TII-&gt;get(AND), AndRes).addReg(OldVal).addReg(Incr);
    BuildMI(BB, DL, TII-&gt;get(XOR), StoreVal).addReg(ZERO).addReg(AndRes);
    BuildMI(BB, DL, TII-&gt;get(XOR), AndRes2).addReg(ZERO).addReg(AndRes);
  } else if (BinOpcode) {
    //  &lt;binop&gt; storeval, oldval, incr
    BuildMI(BB, DL, TII-&gt;get(BinOpcode), StoreVal).addReg(OldVal).addReg(Incr);
  } else {
    StoreVal = Incr;
  }
  BuildMI(BB, DL, TII-&gt;get(SC), Success).addReg(StoreVal).addReg(Ptr).addImm(0);
  BuildMI(BB, DL, TII-&gt;get(BEQ)).addReg(Success).addReg(ZERO).addMBB(loopMBB);

  MI-&gt;eraseFromParent(); // The instruction is gone now.

  return exitMBB;
}

MachineBasicBlock *Cpu0TargetLowering::emitSignExtendToI32InReg(
    MachineInstr *MI, MachineBasicBlock *BB, unsigned Size, unsigned DstReg,
    unsigned SrcReg) const {
  const TargetInstrInfo *TII = Subtarget.getInstrInfo();
  DebugLoc DL = MI-&gt;getDebugLoc();

  MachineFunction *MF = BB-&gt;getParent();
  MachineRegisterInfo &amp;RegInfo = MF-&gt;getRegInfo();
  const TargetRegisterClass *RC = getRegClassFor(MVT::i32);
  unsigned ScrReg = RegInfo.createVirtualRegister(RC);

  assert(Size &lt; 32);
  int64_t ShiftImm = 32 - (Size * 8);

  BuildMI(BB, DL, TII-&gt;get(Cpu0::SHL), ScrReg).addReg(SrcReg).addImm(ShiftImm);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::SRA), DstReg).addReg(ScrReg).addImm(ShiftImm);

  return BB;
}

MachineBasicBlock *Cpu0TargetLowering::emitAtomicBinaryPartword(
    MachineInstr *MI, MachineBasicBlock *BB, unsigned Size, unsigned BinOpcode,
    bool Nand) const {
  assert((Size == 1 || Size == 2) &amp;&amp;
         &quot;Unsupported size for EmitAtomicBinaryPartial.&quot;);

  MachineFunction *MF = BB-&gt;getParent();
  MachineRegisterInfo &amp;RegInfo = MF-&gt;getRegInfo();
  const TargetRegisterClass *RC = getRegClassFor(MVT::i32);
  const TargetInstrInfo *TII = Subtarget.getInstrInfo();
  DebugLoc DL = MI-&gt;getDebugLoc();

  unsigned Dest = MI-&gt;getOperand(0).getReg();
  unsigned Ptr = MI-&gt;getOperand(1).getReg();
  unsigned Incr = MI-&gt;getOperand(2).getReg();

  unsigned AlignedAddr = RegInfo.createVirtualRegister(RC);
  unsigned ShiftAmt = RegInfo.createVirtualRegister(RC);
  unsigned Mask = RegInfo.createVirtualRegister(RC);
  unsigned Mask2 = RegInfo.createVirtualRegister(RC);
  unsigned Mask3 = RegInfo.createVirtualRegister(RC);
  unsigned NewVal = RegInfo.createVirtualRegister(RC);
  unsigned OldVal = RegInfo.createVirtualRegister(RC);
  unsigned Incr2 = RegInfo.createVirtualRegister(RC);
  unsigned MaskLSB2 = RegInfo.createVirtualRegister(RC);
  unsigned PtrLSB2 = RegInfo.createVirtualRegister(RC);
  unsigned MaskUpper = RegInfo.createVirtualRegister(RC);
  unsigned AndRes = RegInfo.createVirtualRegister(RC);
  unsigned BinOpRes = RegInfo.createVirtualRegister(RC);
  unsigned BinOpRes2 = RegInfo.createVirtualRegister(RC);
  unsigned MaskedOldVal0 = RegInfo.createVirtualRegister(RC);
  unsigned StoreVal = RegInfo.createVirtualRegister(RC);
  unsigned MaskedOldVal1 = RegInfo.createVirtualRegister(RC);
  unsigned SrlRes = RegInfo.createVirtualRegister(RC);
  unsigned Success = RegInfo.createVirtualRegister(RC);

  // insert new blocks after the current block
  const BasicBlock *LLVM_BB = BB-&gt;getBasicBlock();
  MachineBasicBlock *loopMBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineBasicBlock *sinkMBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineBasicBlock *exitMBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineFunction::iterator It = BB;
  ++It;
  MF-&gt;insert(It, loopMBB);
  MF-&gt;insert(It, sinkMBB);
  MF-&gt;insert(It, exitMBB);

  // Transfer the remainder of BB and its successor edges to exitMBB.
  exitMBB-&gt;splice(exitMBB-&gt;begin(), BB,
                  std::next(MachineBasicBlock::iterator(MI)), BB-&gt;end());
  exitMBB-&gt;transferSuccessorsAndUpdatePHIs(BB);

  BB-&gt;addSuccessor(loopMBB);
  loopMBB-&gt;addSuccessor(loopMBB);
  loopMBB-&gt;addSuccessor(sinkMBB);
  sinkMBB-&gt;addSuccessor(exitMBB);

  //  thisMBB:
  //    addiu   masklsb2,$0,-4                # 0xfffffffc
  //    and     alignedaddr,ptr,masklsb2
  //    andi    ptrlsb2,ptr,3
  //    sll     shiftamt,ptrlsb2,3
  //    ori     maskupper,$0,255               # 0xff
  //    sll     mask,maskupper,shiftamt
  //    xor     mask2,$0,mask
  //    xor     mask3,$0,mask2
  //    sll     incr2,incr,shiftamt

  int64_t MaskImm = (Size == 1) ? 255 : 65535;
  BuildMI(BB, DL, TII-&gt;get(Cpu0::ADDiu), MaskLSB2)
    .addReg(Cpu0::ZERO).addImm(-4);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::AND), AlignedAddr)
    .addReg(Ptr).addReg(MaskLSB2);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::ANDi), PtrLSB2).addReg(Ptr).addImm(3);
  if (Subtarget.isLittle()) {
    BuildMI(BB, DL, TII-&gt;get(Cpu0::SHL), ShiftAmt).addReg(PtrLSB2).addImm(3);
  } else {
    unsigned Off = RegInfo.createVirtualRegister(RC);
    BuildMI(BB, DL, TII-&gt;get(Cpu0::XORi), Off)
      .addReg(PtrLSB2).addImm((Size == 1) ? 3 : 2);
    BuildMI(BB, DL, TII-&gt;get(Cpu0::SHL), ShiftAmt).addReg(Off).addImm(3);
  }
  BuildMI(BB, DL, TII-&gt;get(Cpu0::ORi), MaskUpper)
    .addReg(Cpu0::ZERO).addImm(MaskImm);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::SHLV), Mask)
    .addReg(MaskUpper).addReg(ShiftAmt);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::XOR), Mask2).addReg(Cpu0::ZERO).addReg(Mask);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::XOR), Mask3).addReg(Cpu0::ZERO).addReg(Mask2);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::SHLV), Incr2).addReg(Incr).addReg(ShiftAmt);

  // atomic.load.binop
  // loopMBB:
  //   ll      oldval,0(alignedaddr)
  //   binop   binopres,oldval,incr2
  //   and     newval,binopres,mask
  //   and     maskedoldval0,oldval,mask3
  //   or      storeval,maskedoldval0,newval
  //   sc      success,storeval,0(alignedaddr)
  //   beq     success,$0,loopMBB

  // atomic.swap
  // loopMBB:
  //   ll      oldval,0(alignedaddr)
  //   and     newval,incr2,mask
  //   and     maskedoldval0,oldval,mask3
  //   or      storeval,maskedoldval0,newval
  //   sc      success,storeval,0(alignedaddr)
  //   beq     success,$0,loopMBB

  BB = loopMBB;
  unsigned LL = Cpu0::LL;
  BuildMI(BB, DL, TII-&gt;get(LL), OldVal).addReg(AlignedAddr).addImm(0);
  if (Nand) {
    //  and andres, oldval, incr2
    //  xor binopres,  $0, andres
    //  xor binopres2, $0, binopres
    //  and newval, binopres, mask
    BuildMI(BB, DL, TII-&gt;get(Cpu0::AND), AndRes).addReg(OldVal).addReg(Incr2);
    BuildMI(BB, DL, TII-&gt;get(Cpu0::XOR), BinOpRes)
      .addReg(Cpu0::ZERO).addReg(AndRes);
    BuildMI(BB, DL, TII-&gt;get(Cpu0::XOR), BinOpRes2)
      .addReg(Cpu0::ZERO).addReg(BinOpRes);
    BuildMI(BB, DL, TII-&gt;get(Cpu0::AND), NewVal).addReg(BinOpRes).addReg(Mask);
  } else if (BinOpcode) {
    //  &lt;binop&gt; binopres, oldval, incr2
    //  and newval, binopres, mask
    BuildMI(BB, DL, TII-&gt;get(BinOpcode), BinOpRes).addReg(OldVal).addReg(Incr2);
    BuildMI(BB, DL, TII-&gt;get(Cpu0::AND), NewVal).addReg(BinOpRes).addReg(Mask);
  } else { // atomic.swap
    //  and newval, incr2, mask
    BuildMI(BB, DL, TII-&gt;get(Cpu0::AND), NewVal).addReg(Incr2).addReg(Mask);
  }

  BuildMI(BB, DL, TII-&gt;get(Cpu0::AND), MaskedOldVal0)
    .addReg(OldVal).addReg(Mask2);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::OR), StoreVal)
    .addReg(MaskedOldVal0).addReg(NewVal);
  unsigned SC = Cpu0::SC;
  BuildMI(BB, DL, TII-&gt;get(SC), Success)
    .addReg(StoreVal).addReg(AlignedAddr).addImm(0);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::BEQ))
    .addReg(Success).addReg(Cpu0::ZERO).addMBB(loopMBB);

  //  sinkMBB:
  //    and     maskedoldval1,oldval,mask
  //    srl     srlres,maskedoldval1,shiftamt
  //    sign_extend dest,srlres
  BB = sinkMBB;

  BuildMI(BB, DL, TII-&gt;get(Cpu0::AND), MaskedOldVal1)
    .addReg(OldVal).addReg(Mask);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::SHRV), SrlRes)
      .addReg(MaskedOldVal1).addReg(ShiftAmt);
  BB = emitSignExtendToI32InReg(MI, BB, Size, Dest, SrlRes);

  MI-&gt;eraseFromParent(); // The instruction is gone now.

  return exitMBB;
}

MachineBasicBlock * Cpu0TargetLowering::emitAtomicCmpSwap(MachineInstr *MI,
                                                          MachineBasicBlock *BB,
                                                          unsigned Size) const {
  assert((Size == 4) &amp;&amp; &quot;Unsupported size for EmitAtomicCmpSwap.&quot;);

  MachineFunction *MF = BB-&gt;getParent();
  MachineRegisterInfo &amp;RegInfo = MF-&gt;getRegInfo();
  const TargetRegisterClass *RC = getRegClassFor(MVT::getIntegerVT(Size * 8));
  const TargetInstrInfo *TII = Subtarget.getInstrInfo();
  DebugLoc DL = MI-&gt;getDebugLoc();
  unsigned LL, SC, ZERO, BNE, BEQ;

  LL = Cpu0::LL;
  SC = Cpu0::SC;
  ZERO = Cpu0::ZERO;
  BNE = Cpu0::BNE;
  BEQ = Cpu0::BEQ;

  unsigned Dest    = MI-&gt;getOperand(0).getReg();
  unsigned Ptr     = MI-&gt;getOperand(1).getReg();
  unsigned OldVal  = MI-&gt;getOperand(2).getReg();
  unsigned NewVal  = MI-&gt;getOperand(3).getReg();

  unsigned Success = RegInfo.createVirtualRegister(RC);

  // insert new blocks after the current block
  const BasicBlock *LLVM_BB = BB-&gt;getBasicBlock();
  MachineBasicBlock *loop1MBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineBasicBlock *loop2MBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineBasicBlock *exitMBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineFunction::iterator It = BB;
  ++It;
  MF-&gt;insert(It, loop1MBB);
  MF-&gt;insert(It, loop2MBB);
  MF-&gt;insert(It, exitMBB);

  // Transfer the remainder of BB and its successor edges to exitMBB.
  exitMBB-&gt;splice(exitMBB-&gt;begin(), BB,
                  std::next(MachineBasicBlock::iterator(MI)), BB-&gt;end());
  exitMBB-&gt;transferSuccessorsAndUpdatePHIs(BB);

  //  thisMBB:
  //    ...
  //    fallthrough --&gt; loop1MBB
  BB-&gt;addSuccessor(loop1MBB);
  loop1MBB-&gt;addSuccessor(exitMBB);
  loop1MBB-&gt;addSuccessor(loop2MBB);
  loop2MBB-&gt;addSuccessor(loop1MBB);
  loop2MBB-&gt;addSuccessor(exitMBB);

  // loop1MBB:
  //   ll dest, 0(ptr)
  //   bne dest, oldval, exitMBB
  BB = loop1MBB;
  BuildMI(BB, DL, TII-&gt;get(LL), Dest).addReg(Ptr).addImm(0);
  BuildMI(BB, DL, TII-&gt;get(BNE))
    .addReg(Dest).addReg(OldVal).addMBB(exitMBB);

  // loop2MBB:
  //   sc success, newval, 0(ptr)
  //   beq success, $0, loop1MBB
  BB = loop2MBB;
  BuildMI(BB, DL, TII-&gt;get(SC), Success)
    .addReg(NewVal).addReg(Ptr).addImm(0);
  BuildMI(BB, DL, TII-&gt;get(BEQ))
    .addReg(Success).addReg(ZERO).addMBB(loop1MBB);

  MI-&gt;eraseFromParent(); // The instruction is gone now.

  return exitMBB;
}

MachineBasicBlock *
Cpu0TargetLowering::emitAtomicCmpSwapPartword(MachineInstr *MI,
                                              MachineBasicBlock *BB,
                                              unsigned Size) const {
  assert((Size == 1 || Size == 2) &amp;&amp;
      &quot;Unsupported size for EmitAtomicCmpSwapPartial.&quot;);

  MachineFunction *MF = BB-&gt;getParent();
  MachineRegisterInfo &amp;RegInfo = MF-&gt;getRegInfo();
  const TargetRegisterClass *RC = getRegClassFor(MVT::i32);
  const TargetInstrInfo *TII = Subtarget.getInstrInfo();
  DebugLoc DL = MI-&gt;getDebugLoc();

  unsigned Dest    = MI-&gt;getOperand(0).getReg();
  unsigned Ptr     = MI-&gt;getOperand(1).getReg();
  unsigned CmpVal  = MI-&gt;getOperand(2).getReg();
  unsigned NewVal  = MI-&gt;getOperand(3).getReg();

  unsigned AlignedAddr = RegInfo.createVirtualRegister(RC);
  unsigned ShiftAmt = RegInfo.createVirtualRegister(RC);
  unsigned Mask = RegInfo.createVirtualRegister(RC);
  unsigned Mask2 = RegInfo.createVirtualRegister(RC);
  unsigned Mask3 = RegInfo.createVirtualRegister(RC);
  unsigned ShiftedCmpVal = RegInfo.createVirtualRegister(RC);
  unsigned OldVal = RegInfo.createVirtualRegister(RC);
  unsigned MaskedOldVal0 = RegInfo.createVirtualRegister(RC);
  unsigned ShiftedNewVal = RegInfo.createVirtualRegister(RC);
  unsigned MaskLSB2 = RegInfo.createVirtualRegister(RC);
  unsigned PtrLSB2 = RegInfo.createVirtualRegister(RC);
  unsigned MaskUpper = RegInfo.createVirtualRegister(RC);
  unsigned MaskedCmpVal = RegInfo.createVirtualRegister(RC);
  unsigned MaskedNewVal = RegInfo.createVirtualRegister(RC);
  unsigned MaskedOldVal1 = RegInfo.createVirtualRegister(RC);
  unsigned StoreVal = RegInfo.createVirtualRegister(RC);
  unsigned SrlRes = RegInfo.createVirtualRegister(RC);
  unsigned Success = RegInfo.createVirtualRegister(RC);

  // insert new blocks after the current block
  const BasicBlock *LLVM_BB = BB-&gt;getBasicBlock();
  MachineBasicBlock *loop1MBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineBasicBlock *loop2MBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineBasicBlock *sinkMBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineBasicBlock *exitMBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineFunction::iterator It = BB;
  ++It;
  MF-&gt;insert(It, loop1MBB);
  MF-&gt;insert(It, loop2MBB);
  MF-&gt;insert(It, sinkMBB);
  MF-&gt;insert(It, exitMBB);

  // Transfer the remainder of BB and its successor edges to exitMBB.
  exitMBB-&gt;splice(exitMBB-&gt;begin(), BB,
                  std::next(MachineBasicBlock::iterator(MI)), BB-&gt;end());
  exitMBB-&gt;transferSuccessorsAndUpdatePHIs(BB);

  BB-&gt;addSuccessor(loop1MBB);
  loop1MBB-&gt;addSuccessor(sinkMBB);
  loop1MBB-&gt;addSuccessor(loop2MBB);
  loop2MBB-&gt;addSuccessor(loop1MBB);
  loop2MBB-&gt;addSuccessor(sinkMBB);
  sinkMBB-&gt;addSuccessor(exitMBB);

  // FIXME: computation of newval2 can be moved to loop2MBB.
  //  thisMBB:
  //    addiu   masklsb2,$0,-4                # 0xfffffffc
  //    and     alignedaddr,ptr,masklsb2
  //    andi    ptrlsb2,ptr,3
  //    shl     shiftamt,ptrlsb2,3
  //    ori     maskupper,$0,255               # 0xff
  //    shl     mask,maskupper,shiftamt
  //    xor     mask2,$0,mask
  //    xor     mask3,$0,mask2
  //    andi    maskedcmpval,cmpval,255
  //    shl     shiftedcmpval,maskedcmpval,shiftamt
  //    andi    maskednewval,newval,255
  //    shl     shiftednewval,maskednewval,shiftamt
  int64_t MaskImm = (Size == 1) ? 255 : 65535;
  BuildMI(BB, DL, TII-&gt;get(Cpu0::ADDiu), MaskLSB2)
    .addReg(Cpu0::ZERO).addImm(-4);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::AND), AlignedAddr)
    .addReg(Ptr).addReg(MaskLSB2);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::ANDi), PtrLSB2).addReg(Ptr).addImm(3);
  if (Subtarget.isLittle()) {
    BuildMI(BB, DL, TII-&gt;get(Cpu0::SHL), ShiftAmt).addReg(PtrLSB2).addImm(3);
  } else {
    unsigned Off = RegInfo.createVirtualRegister(RC);
    BuildMI(BB, DL, TII-&gt;get(Cpu0::XORi), Off)
      .addReg(PtrLSB2).addImm((Size == 1) ? 3 : 2);
    BuildMI(BB, DL, TII-&gt;get(Cpu0::SHL), ShiftAmt).addReg(Off).addImm(3);
  }
  BuildMI(BB, DL, TII-&gt;get(Cpu0::ORi), MaskUpper)
    .addReg(Cpu0::ZERO).addImm(MaskImm);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::SHLV), Mask)
    .addReg(MaskUpper).addReg(ShiftAmt);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::XOR), Mask2).addReg(Cpu0::ZERO).addReg(Mask);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::XOR), Mask3).addReg(Cpu0::ZERO).addReg(Mask2);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::ANDi), MaskedCmpVal)
    .addReg(CmpVal).addImm(MaskImm);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::SHLV), ShiftedCmpVal)
    .addReg(MaskedCmpVal).addReg(ShiftAmt);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::ANDi), MaskedNewVal)
    .addReg(NewVal).addImm(MaskImm);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::SHLV), ShiftedNewVal)
    .addReg(MaskedNewVal).addReg(ShiftAmt);

  //  loop1MBB:
  //    ll      oldval,0(alginedaddr)
  //    and     maskedoldval0,oldval,mask
  //    bne     maskedoldval0,shiftedcmpval,sinkMBB
  BB = loop1MBB;
  unsigned LL = Cpu0::LL;
  BuildMI(BB, DL, TII-&gt;get(LL), OldVal).addReg(AlignedAddr).addImm(0);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::AND), MaskedOldVal0)
    .addReg(OldVal).addReg(Mask);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::BNE))
    .addReg(MaskedOldVal0).addReg(ShiftedCmpVal).addMBB(sinkMBB);

  //  loop2MBB:
  //    and     maskedoldval1,oldval,mask3
  //    or      storeval,maskedoldval1,shiftednewval
  //    sc      success,storeval,0(alignedaddr)
  //    beq     success,$0,loop1MBB
  BB = loop2MBB;
  BuildMI(BB, DL, TII-&gt;get(Cpu0::AND), MaskedOldVal1)
    .addReg(OldVal).addReg(Mask3);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::OR), StoreVal)
    .addReg(MaskedOldVal1).addReg(ShiftedNewVal);
  unsigned SC = Cpu0::SC;
  BuildMI(BB, DL, TII-&gt;get(SC), Success)
      .addReg(StoreVal).addReg(AlignedAddr).addImm(0);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::BEQ))
      .addReg(Success).addReg(Cpu0::ZERO).addMBB(loop1MBB);

  //  sinkMBB:
  //    srl     srlres,maskedoldval0,shiftamt
  //    sign_extend dest,srlres
  BB = sinkMBB;

  BuildMI(BB, DL, TII-&gt;get(Cpu0::SHRV), SrlRes)
      .addReg(MaskedOldVal0).addReg(ShiftAmt);
  BB = emitSignExtendToI32InReg(MI, BB, Size, Dest, SrlRes);

  MI-&gt;eraseFromParent();   // The instruction is gone now.

  return exitMBB;
}
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">lowerATOMIC_FENCE</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span>
                                              <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="o">//</span> <span class="n">FIXME</span><span class="p">:</span> <span class="n">Need</span> <span class="n">pseudo</span><span class="o">-</span><span class="n">fence</span> <span class="k">for</span> <span class="s1">&#39;singlethread&#39;</span> <span class="n">fences</span>
  <span class="o">//</span> <span class="n">FIXME</span><span class="p">:</span> <span class="n">Set</span> <span class="n">SType</span> <span class="k">for</span> <span class="n">weaker</span> <span class="n">fences</span> <span class="n">where</span> <span class="n">supported</span><span class="o">/</span><span class="n">appropriate</span><span class="o">.</span>
  <span class="n">unsigned</span> <span class="n">SType</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">(</span><span class="n">Op</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">Cpu0ISD</span><span class="p">::</span><span class="n">Sync</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">MVT</span><span class="p">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Op</span><span class="o">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                     <span class="n">DAG</span><span class="o">.</span><span class="n">getConstant</span><span class="p">(</span><span class="n">SType</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">MVT</span><span class="p">::</span><span class="n">i32</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0RegisterInfo.h</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="o">///</span> <span class="n">Code</span> <span class="n">Generation</span> <span class="n">virtual</span> <span class="n">methods</span><span class="o">...</span>
  <span class="n">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span><span class="n">getPointerRegClass</span><span class="p">(</span><span class="n">const</span> <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                                <span class="n">unsigned</span> <span class="n">Kind</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0RegisterInfo.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span>
<span class="n">Cpu0RegisterInfo</span><span class="p">::</span><span class="n">getPointerRegClass</span><span class="p">(</span><span class="n">const</span> <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                     <span class="n">unsigned</span> <span class="n">Kind</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="n">Cpu0</span><span class="p">::</span><span class="n">CPURegsRegClass</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0SEISelLowering.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Cpu0SETargetLowering</span><span class="p">::</span><span class="n">Cpu0SETargetLowering</span><span class="p">(</span><span class="n">const</span> <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">,</span>
                                           <span class="n">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span>
    <span class="p">:</span> <span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="n">TM</span><span class="p">,</span> <span class="n">STI</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">ATOMIC_FENCE</span><span class="p">,</span>       <span class="n">MVT</span><span class="p">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Custom</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0TargetMachine.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">///</span> <span class="n">Cpu0</span> <span class="n">Code</span> <span class="n">Generator</span> <span class="n">Pass</span> <span class="n">Configuration</span> <span class="n">Options</span><span class="o">.</span>
<span class="k">class</span> <span class="nc">Cpu0PassConfig</span> <span class="p">:</span> <span class="n">public</span> <span class="n">TargetPassConfig</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="n">void</span> <span class="n">addIRPasses</span><span class="p">()</span> <span class="n">override</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">Cpu0PassConfig</span><span class="p">::</span><span class="n">addIRPasses</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">TargetPassConfig</span><span class="p">::</span><span class="n">addIRPasses</span><span class="p">();</span>
  <span class="n">addPass</span><span class="p">(</span><span class="n">createAtomicExpandPass</span><span class="p">(</span><span class="o">&amp;</span><span class="n">getCpu0TargetMachine</span><span class="p">()));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Since SC instruction uses RegisterOperand type in Cpu0InstrInfo.td and SC uses
FMem node which DecoderMethod is &#8220;DecodeMem&#8221;, the DecodeMem() of
Cpu0Disassembler.cpp need to be changed as above.</p>
<p>The atomic node defined in &#8220;let usesCustomInserter = 1 in&#8221; of Cpu0InstrInfo.td
tells llvm calling EmitInstrWithCustomInserter() of Cpu0ISelLowering.cpp. For
example, &#8220;def ATOMIC_LOAD_ADD_I8 : Atomic2Ops&lt;atomic_load_add_8, CPURegs&gt;;&#8221; will
calling EmitInstrWithCustomInserter() with Machine Instruction Opcode
&#8220;ATOMIC_LOAD_ADD_I8&#8221; when it meets IR &#8220;load atomic i8*&#8221;.</p>
<p>The &#8220;setInsertFencesForAtomic(true);&#8221; in Cpu0ISelLowering.cpp will trigger
addIRPasses() of Cpu0TargetMachine.cpp, then createAtomicExpandPass() in
addIRPasses() will create llvm IR ATOMIC_FENCE. Next, the lowerATOMIC_FENCE()
of Cpu0ISelLowering.cpp will create Cpu0ISD::Sync when it meets IR ATOMIC_FENCE
since &#8220;setOperationAction(ISD::ATOMIC_FENCE, MVT::Other, Custom);&#8221; of
Cpu0SEISelLowering.cpp. Finally the pattern defined in Cpu0InstrInfo.td translate
it into instruction &#8220;sync&#8221; by &#8220;def SYNC&#8221; and alias &#8220;SYNC 0&#8221;.</p>
<p>This part of Cpu0 backend code is same with Mips except Cpu0 has no instruction
&#8220;nor&#8221;.</p>
<p>List the atomic IRs, corresponding DAGs and Opcode as the following table.</p>
<table border="1" class="docutils" id="id10">
<caption><span class="caption-number">Table 34 </span><span class="caption-text">The atomic related IRs, their corresponding DAGs and Opcode of Cpu0ISelLowering.cpp</span><a class="headerlink" href="#id10" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="33%" />
<col width="34%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">IR</th>
<th class="head">DAG</th>
<th class="head">Opcode</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>load atomic</td>
<td>AtomicLoad</td>
<td>ATOMIC_CMP_SWAP_XXX</td>
</tr>
<tr class="row-odd"><td>store atomic</td>
<td>AtomicStore</td>
<td>ATOMIC_SWAP_XXX</td>
</tr>
<tr class="row-even"><td>atomicrmw add</td>
<td>AtomicLoadAdd</td>
<td>ATOMIC_LOAD_ADD_XXX</td>
</tr>
<tr class="row-odd"><td>atomicrmw sub</td>
<td>AtomicLoadSub</td>
<td>ATOMIC_LOAD_SUB_XXX</td>
</tr>
<tr class="row-even"><td>atomicrmw xor</td>
<td>AtomicLoadXor</td>
<td>ATOMIC_LOAD_XOR_XXX</td>
</tr>
<tr class="row-odd"><td>atomicrmw and</td>
<td>AtomicLoadAnd</td>
<td>ATOMIC_LOAD_AND_XXX</td>
</tr>
<tr class="row-even"><td>atomicrmw nand</td>
<td>AtomicLoadNand</td>
<td>ATOMIC_LOAD_NAND_XXX</td>
</tr>
<tr class="row-odd"><td>atomicrmw or</td>
<td>AtomicLoadOr</td>
<td>ATOMIC_LOAD_OR_XXX</td>
</tr>
<tr class="row-even"><td>cmpxchg</td>
<td>AtomicCmpSwapWithSuccess</td>
<td>ATOMIC_CMP_SWAP_XXX</td>
</tr>
<tr class="row-odd"><td>atomicrmw xchg</td>
<td>AtomicLoadSwap</td>
<td>ATOMIC_SWAP_XXX</td>
</tr>
</tbody>
</table>
<p>Input files atomics.ll and atomics-fences.ll include the llvm atomic IRs test.
Input files ch12_atomics.cpp and ch12_atomics-fences.cpp are the C++ source
files for generating llvm atomic IRs. The C++ files need to run with clang
options &#8220;clang++ -pthread -std=c++11&#8221;.</p>
<table class="docutils footnote" frame="void" id="exception" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://llvm.org/docs/ExceptionHandling.html">http://llvm.org/docs/ExceptionHandling.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="thread-wiki" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Thread-local_storage">http://en.wikipedia.org/wiki/Thread-local_storage</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="atomic-wiki" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td><a class="reference external" href="https://en.wikipedia.org/wiki/Memory_model_%28programming%29">https://en.wikipedia.org/wiki/Memory_model_%28programming%29</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="atomic-stackoverflow" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td><a class="reference external" href="http://stackoverflow.com/questions/6319146/c11-introduced-a-standardized-memory-model-what-does-it-mean-and-how-is-it-g">http://stackoverflow.com/questions/6319146/c11-introduced-a-standardized-memory-model-what-does-it-mean-and-how-is-it-g</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="atomic-herbsutter" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td><a class="reference external" href="http://herbsutter.com/2013/02/11/atomic-weapons-the-c-memory-model-and-modern-hardware/">http://herbsutter.com/2013/02/11/atomic-weapons-the-c-memory-model-and-modern-hardware/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="atomics-llvm" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[6]</a></td><td><a class="reference external" href="http://llvm.org/docs/Atomics.html">http://llvm.org/docs/Atomics.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="llvmlang-ordering" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[7]</a></td><td><a class="reference external" href="http://llvm.org/docs/LangRef.html#ordering">http://llvm.org/docs/LangRef.html#ordering</a></td></tr>
</tbody>
</table>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="asm.html">Assembler</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="verilog.html">Verify backend on Verilog simulator</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2016, Chen Chung-Shu.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.4.
    </div>
  </body>
</html>