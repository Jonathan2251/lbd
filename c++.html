
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>C++ support &#8212; Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Verify backend on Verilog simulator" href="verilog.html" />
    <link rel="prev" title="Assembler" href="asm.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</span></a></h1>
        <h2 class="heading"><span>C++ support</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="asm.html">Assembler</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="verilog.html">Verify backend on Verilog simulator</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="c-support">
<span id="sec-c"></span><h1>C++ support<a class="headerlink" href="#c-support" title="Permalink to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#exception-handle" id="id25">Exception handle</a></p></li>
<li><p><a class="reference internal" href="#thread-variable" id="id26">Thread variable</a></p></li>
<li><p><a class="reference internal" href="#atomic" id="id27">Atomic</a></p></li>
</ul>
</nav>
<p>This chapter supports some C++ compiler features.</p>
<section id="exception-handle">
<h2><a class="toc-backref" href="#id25" role="doc-backlink">Exception handle</a><a class="headerlink" href="#exception-handle" title="Permalink to this heading">¶</a></h2>
<p>The Chapter11_2 can be built and run with the C++ polymorphism example code of
ch12_inherit.cpp as follows,</p>
<p class="rubric">lbdex/input/ch12_inherit.cpp</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">...</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">CPolygon</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// _ZTVN10__cxxabiv117__class_type_infoE for parent class</span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="cp">#ifdef COUT_TEST</span>
<span class="w"> </span><span class="c1">// generate IR nvoke, landing, resume and unreachable on iMac</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">area</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="cp">#else</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">area</span><span class="p">());</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="p">};</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
</pre></div>
</div>
<p>If using cout instead of printf in ch12_inherit.cpp, it won’t generate exception
handler IRs on Linux, whereas it will generate invoke, landing, resume
and unreachable exception handler IRs on iMac.
Example code, ch12_eh.cpp, which includes <strong>try</strong> and <strong>catch</strong> exception handler
as the following will generate these exception handler IRs both on iMac and Linux.</p>
<p class="rubric">lbdex/input/ch12_eh.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Ex1</span> <span class="p">{};</span>
<span class="n">void</span> <span class="n">throw_exception</span><span class="p">(</span><span class="nb">int</span> <span class="n">a</span><span class="p">,</span> <span class="nb">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Ex1</span> <span class="n">ex1</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">throw</span> <span class="n">ex1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">test_try_catch</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="n">throw_exception</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">catch</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>clang -c ch12_eh.cpp -emit-llvm
<span class="go">-o ch12_eh.bc</span>
<span class="gp">JonathantekiiMac:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llvm-dis ch12_eh.bc -o -</span>
</pre></div>
</div>
<p class="rubric">../lbdex/output/ch12_eh.ll</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="p">...</span><span class="w"></span>
<span class="k">define</span><span class="w"> </span><span class="k">dso_local</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@_Z14test_try_catchv</span><span class="p">()</span><span class="w"> </span><span class="vg">#0</span><span class="w"> </span><span class="k">personality</span><span class="w"> </span><span class="kt">i8</span><span class="p">*</span><span class="w"> </span><span class="k">bitcast</span><span class="w"> </span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="p">(...</span><span class="w"></span>
<span class="p">)*</span><span class="w"> </span><span class="vg">@__gxx_personality_v0</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="kt">i8</span><span class="p">*)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="nl">entry:</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="k">invoke</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@_Z15throw_exceptionii</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="k">signext</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="k">signext</span><span class="w"> </span><span class="m">1</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">to</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%invoke.cont</span><span class="w"> </span><span class="k">unwind</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%lpad</span><span class="w"></span>

<span class="nl">invoke.cont:</span><span class="w">                                      </span><span class="c">; preds = %entry</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%try.cont</span><span class="w"></span>

<span class="nl">lpad:</span><span class="w">                                             </span><span class="c">; preds = %entry</span>
<span class="w">  </span><span class="nv nv-Anonymous">%0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">landingpad</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">i8</span><span class="p">*,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">          </span><span class="k">catch</span><span class="w"> </span><span class="kt">i8</span><span class="p">*</span><span class="w"> </span><span class="k">null</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llc -march=cpu0 -relocation-model=static -filetype=asm ch12_eh.bc -o -</span>
<span class="go">        .section .mdebug.abi32</span>
<span class="go">        .previous</span>
<span class="go">        .file &quot;ch12_eh.bc&quot;</span>
<span class="go">llc: /Users/Jonathan/llvm/test/llvm/lib/CodeGen/LiveVariables.cpp:133: void llvm::</span>
<span class="go">LiveVariables::HandleVirtRegUse(unsigned int, llvm::MachineBasicBlock *, llvm</span>
<span class="go">::MachineInstr *): Assertion `MRI-&gt;getVRegDef(reg) &amp;&amp; &quot;Register use before</span>
<span class="go">def!&quot;&#39; failed.</span>
</pre></div>
</div>
<p>A description for the C++ exception table formats can be found here
<a class="footnote-reference brackets" href="#itanium-exception" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>.
About the IRs of LLVM exception handling, please reference here <a class="footnote-reference brackets" href="#exception" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>.
Chapter12_1 supports the llvm IRs of corresponding <strong>try</strong> and <strong>catch</strong>
exception C++ keywords. It can compile ch12_eh.bc as follows,</p>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0ISelLowering.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="o">///</span> <span class="n">If</span> <span class="n">a</span> <span class="n">physical</span> <span class="n">register</span><span class="p">,</span> <span class="n">this</span> <span class="n">returns</span> <span class="n">the</span> <span class="n">register</span> <span class="n">that</span> <span class="n">receives</span> <span class="n">the</span>
    <span class="o">///</span> <span class="n">exception</span> <span class="n">address</span> <span class="n">on</span> <span class="n">entry</span> <span class="n">to</span> <span class="n">an</span> <span class="n">EH</span> <span class="n">pad</span><span class="o">.</span>
    <span class="n">Register</span>
    <span class="n">getExceptionPointerRegister</span><span class="p">(</span><span class="n">const</span> <span class="n">Constant</span> <span class="o">*</span><span class="n">PersonalityFn</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">A0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="o">///</span> <span class="n">If</span> <span class="n">a</span> <span class="n">physical</span> <span class="n">register</span><span class="p">,</span> <span class="n">this</span> <span class="n">returns</span> <span class="n">the</span> <span class="n">register</span> <span class="n">that</span> <span class="n">receives</span> <span class="n">the</span>
    <span class="o">///</span> <span class="n">exception</span> <span class="n">typeid</span> <span class="n">on</span> <span class="n">entry</span> <span class="n">to</span> <span class="n">a</span> <span class="n">landing</span> <span class="n">pad</span><span class="o">.</span>
    <span class="n">Register</span>
    <span class="n">getExceptionSelectorRegister</span><span class="p">(</span><span class="n">const</span> <span class="n">Constant</span> <span class="o">*</span><span class="n">PersonalityFn</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">A1</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llc -march=cpu0 -relocation-model=static -filetype=asm ch12_eh.bc -o -</span>
</pre></div>
</div>
<p class="rubric">../lbdex/output/ch12_eh.cpu0.s</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>  .type  _Z14test_try_catchv,@function
  .ent  _Z14test_try_catchv             # @_Z14test_try_catchv
_Z14test_try_catchv:
  ...
$tmp0:
  addiu  $4, $zero, 2
  addiu  $5, $zero, 1
  jsub  _Z15throw_exceptionii
  nop
$tmp1:
# %bb.1:                                # %invoke.cont
  jmp  $BB1_4
$BB1_2:                                 # %lpad
$tmp2:
  st  $4, 16($fp)
  st  $5, 12($fp)
# %bb.3:                                # %catch
  ld  $4, 16($fp)
  jsub  __cxa_begin_catch
  nop
  addiu  $2, $zero, 1
  st  $2, 20($fp)
  jsub  __cxa_end_catch
  nop
  jmp  $BB1_5
$BB1_4:                                 # %try.cont
  addiu  $2, $zero, 0
  st  $2, 20($fp)
$BB1_5:                                 # %return
  ld  $2, 20($fp)
  ...
</pre></div>
</div>
</section>
<section id="thread-variable">
<h2><a class="toc-backref" href="#id26" role="doc-backlink">Thread variable</a><a class="headerlink" href="#thread-variable" title="Permalink to this heading">¶</a></h2>
<p>C++ support thread variable as the following file ch12_thread_var.cpp.</p>
<p class="rubric">lbdex/input/ch12_thread_var.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">__thread</span> <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">thread_local</span> <span class="nb">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">//</span> <span class="n">need</span> <span class="n">option</span> <span class="o">-</span><span class="n">std</span><span class="o">=</span><span class="n">c</span><span class="o">++</span><span class="mi">11</span>
<span class="nb">int</span> <span class="n">test_thread_var</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">test_thread_var_2</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

</pre></div>
</div>
<p>While global variable is a single instance shared by all threads in a process,
thread variable has different instances for each different thread in a process.
The same thread share the thread variable but different threads have their own
thread variable with the same name <a class="footnote-reference brackets" href="#thread-wiki" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>.</p>
<p>To support thread variable, tlsgd, tlsldm, dtp_hi, dtp_lo, gottp, tp_hi and
tp_lo in both evaluateRelocExpr() of Cpu0AsmParser.cpp and printImpl() of
Cpu0MCExpr.cpp are needed, and the following code are required.
Most of them are for relocation record handle and display since the thread
variable created by OS or language library which support multi-threads
programming.</p>
<p class="rubric">lbdex/chapters/Chapter12_1/MCTargetDesc/Cpu0AsmBackend.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">MCFixupKindInfo</span> <span class="o">&amp;</span><span class="n">Cpu0AsmBackend</span><span class="p">::</span>
<span class="n">getFixupKindInfo</span><span class="p">(</span><span class="n">MCFixupKind</span> <span class="n">Kind</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="n">unsigned</span> <span class="n">JSUBReloRec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">HasLLD</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">JSUBReloRec</span> <span class="o">=</span> <span class="n">MCFixupKindInfo</span><span class="p">::</span><span class="n">FKF_IsPCRel</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="n">JSUBReloRec</span> <span class="o">=</span> <span class="n">MCFixupKindInfo</span><span class="p">::</span><span class="n">FKF_IsPCRel</span> <span class="o">|</span> <span class="n">MCFixupKindInfo</span><span class="p">::</span><span class="n">FKF_Constant</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">const</span> <span class="n">static</span> <span class="n">MCFixupKindInfo</span> <span class="n">Infos</span><span class="p">[</span><span class="n">Cpu0</span><span class="p">::</span><span class="n">NumTargetFixupKinds</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="o">//</span> <span class="n">This</span> <span class="n">table</span> <span class="o">*</span><span class="n">must</span><span class="o">*</span> <span class="n">be</span> <span class="ow">in</span> <span class="n">same</span> <span class="n">the</span> <span class="n">order</span> <span class="n">of</span> <span class="n">fixup_</span><span class="o">*</span> <span class="n">kinds</span> <span class="ow">in</span>
    <span class="o">//</span> <span class="n">Cpu0FixupKinds</span><span class="o">.</span><span class="n">h</span><span class="o">.</span>
    <span class="o">//</span>
    <span class="o">//</span> <span class="n">name</span>                        <span class="n">offset</span>  <span class="n">bits</span>  <span class="n">flags</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="p">{</span> <span class="s2">&quot;fixup_Cpu0_TLSGD&quot;</span><span class="p">,</span>          <span class="mi">0</span><span class="p">,</span>     <span class="mi">16</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s2">&quot;fixup_Cpu0_GOTTP&quot;</span><span class="p">,</span>          <span class="mi">0</span><span class="p">,</span>     <span class="mi">16</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s2">&quot;fixup_Cpu0_TP_HI&quot;</span><span class="p">,</span>          <span class="mi">0</span><span class="p">,</span>     <span class="mi">16</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s2">&quot;fixup_Cpu0_TP_LO&quot;</span><span class="p">,</span>          <span class="mi">0</span><span class="p">,</span>     <span class="mi">16</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s2">&quot;fixup_Cpu0_TLSLDM&quot;</span><span class="p">,</span>         <span class="mi">0</span><span class="p">,</span>     <span class="mi">16</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s2">&quot;fixup_Cpu0_DTP_HI&quot;</span><span class="p">,</span>         <span class="mi">0</span><span class="p">,</span>     <span class="mi">16</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s2">&quot;fixup_Cpu0_DTP_LO&quot;</span><span class="p">,</span>         <span class="mi">0</span><span class="p">,</span>     <span class="mi">16</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/MCTargetDesc/Cpu0BaseInfo.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">namespace</span> <span class="n">Cpu0II</span> <span class="p">{</span>
  <span class="o">///</span> <span class="n">Target</span> <span class="n">Operand</span> <span class="n">Flag</span> <span class="n">enum</span><span class="o">.</span>
  <span class="n">enum</span> <span class="n">TOF</span> <span class="p">{</span>
    <span class="o">//===------------------------------------------------------------------===//</span>
    <span class="o">//</span> <span class="n">Cpu0</span> <span class="n">Specific</span> <span class="n">MachineOperand</span> <span class="n">flags</span><span class="o">.</span>

</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="o">///</span> <span class="n">MO_TLSGD</span> <span class="o">-</span> <span class="n">Represents</span> <span class="n">the</span> <span class="n">offset</span> <span class="n">into</span> <span class="n">the</span> <span class="k">global</span> <span class="n">offset</span> <span class="n">table</span> <span class="n">at</span> <span class="n">which</span>
    <span class="o">//</span> <span class="n">the</span> <span class="n">module</span> <span class="n">ID</span> <span class="ow">and</span> <span class="n">TSL</span> <span class="n">block</span> <span class="n">offset</span> <span class="n">reside</span> <span class="n">during</span> <span class="n">execution</span> <span class="p">(</span><span class="n">General</span>
    <span class="o">//</span> <span class="n">Dynamic</span> <span class="n">TLS</span><span class="p">)</span><span class="o">.</span>
    <span class="n">MO_TLSGD</span><span class="p">,</span>

    <span class="o">///</span> <span class="n">MO_TLSLDM</span> <span class="o">-</span> <span class="n">Represents</span> <span class="n">the</span> <span class="n">offset</span> <span class="n">into</span> <span class="n">the</span> <span class="k">global</span> <span class="n">offset</span> <span class="n">table</span> <span class="n">at</span> <span class="n">which</span>
    <span class="o">//</span> <span class="n">the</span> <span class="n">module</span> <span class="n">ID</span> <span class="ow">and</span> <span class="n">TSL</span> <span class="n">block</span> <span class="n">offset</span> <span class="n">reside</span> <span class="n">during</span> <span class="n">execution</span> <span class="p">(</span><span class="n">Local</span>
    <span class="o">//</span> <span class="n">Dynamic</span> <span class="n">TLS</span><span class="p">)</span><span class="o">.</span>
    <span class="n">MO_TLSLDM</span><span class="p">,</span>
    <span class="n">MO_DTP_HI</span><span class="p">,</span>
    <span class="n">MO_DTP_LO</span><span class="p">,</span>

    <span class="o">///</span> <span class="n">MO_GOTTPREL</span> <span class="o">-</span> <span class="n">Represents</span> <span class="n">the</span> <span class="n">offset</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">thread</span> <span class="n">pointer</span> <span class="p">(</span><span class="n">Initial</span>
    <span class="o">//</span> <span class="n">Exec</span> <span class="n">TLS</span><span class="p">)</span><span class="o">.</span>
    <span class="n">MO_GOTTPREL</span><span class="p">,</span>

    <span class="o">///</span> <span class="n">MO_TPREL_HI</span><span class="o">/</span><span class="n">LO</span> <span class="o">-</span> <span class="n">Represents</span> <span class="n">the</span> <span class="n">hi</span> <span class="ow">and</span> <span class="n">low</span> <span class="n">part</span> <span class="n">of</span> <span class="n">the</span> <span class="n">offset</span> <span class="kn">from</span>
    <span class="o">//</span> <span class="n">the</span> <span class="n">thread</span> <span class="n">pointer</span> <span class="p">(</span><span class="n">Local</span> <span class="n">Exec</span> <span class="n">TLS</span><span class="p">)</span><span class="o">.</span>
    <span class="n">MO_TP_HI</span><span class="p">,</span>
    <span class="n">MO_TP_LO</span><span class="p">,</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/MCTargetDesc/Cpu0ELFObjectWriter.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">unsigned</span> <span class="n">Cpu0ELFObjectWriter</span><span class="p">::</span><span class="n">getRelocType</span><span class="p">(</span><span class="n">MCContext</span> <span class="o">&amp;</span><span class="n">Ctx</span><span class="p">,</span>
                                           <span class="n">const</span> <span class="n">MCValue</span> <span class="o">&amp;</span><span class="n">Target</span><span class="p">,</span>
                                           <span class="n">const</span> <span class="n">MCFixup</span> <span class="o">&amp;</span><span class="n">Fixup</span><span class="p">,</span>
                                           <span class="nb">bool</span> <span class="n">IsPCRel</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="o">//</span> <span class="n">determine</span> <span class="n">the</span> <span class="nb">type</span> <span class="n">of</span> <span class="n">the</span> <span class="n">relocation</span>
  <span class="n">unsigned</span> <span class="n">Type</span> <span class="o">=</span> <span class="p">(</span><span class="n">unsigned</span><span class="p">)</span><span class="n">ELF</span><span class="p">::</span><span class="n">R_CPU0_NONE</span><span class="p">;</span>
  <span class="n">unsigned</span> <span class="n">Kind</span> <span class="o">=</span> <span class="p">(</span><span class="n">unsigned</span><span class="p">)</span><span class="n">Fixup</span><span class="o">.</span><span class="n">getKind</span><span class="p">();</span>

  <span class="n">switch</span> <span class="p">(</span><span class="n">Kind</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">case</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_TLSGD</span><span class="p">:</span>
    <span class="n">Type</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">::</span><span class="n">R_CPU0_TLS_GD</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_GOTTPREL</span><span class="p">:</span>
    <span class="n">Type</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">::</span><span class="n">R_CPU0_TLS_GOTTPREL</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/MCTargetDesc/Cpu0FixupKinds.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">enum</span> <span class="n">Fixups</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="o">//</span> <span class="n">resulting</span> <span class="ow">in</span> <span class="o">-</span> <span class="n">R_CPU0_TLS_GD</span><span class="o">.</span>
    <span class="n">fixup_Cpu0_TLSGD</span><span class="p">,</span>

    <span class="o">//</span> <span class="n">resulting</span> <span class="ow">in</span> <span class="o">-</span> <span class="n">R_CPU0_TLS_GOTTPREL</span><span class="o">.</span>
    <span class="n">fixup_Cpu0_GOTTPREL</span><span class="p">,</span>

    <span class="o">//</span> <span class="n">resulting</span> <span class="ow">in</span> <span class="o">-</span> <span class="n">R_CPU0_TLS_TPREL_HI16</span><span class="o">.</span>
    <span class="n">fixup_Cpu0_TP_HI</span><span class="p">,</span>

    <span class="o">//</span> <span class="n">resulting</span> <span class="ow">in</span> <span class="o">-</span> <span class="n">R_CPU0_TLS_TPREL_LO16</span><span class="o">.</span>
    <span class="n">fixup_Cpu0_TP_LO</span><span class="p">,</span>

    <span class="o">//</span> <span class="n">resulting</span> <span class="ow">in</span> <span class="o">-</span> <span class="n">R_CPU0_TLS_LDM</span><span class="o">.</span>
    <span class="n">fixup_Cpu0_TLSLDM</span><span class="p">,</span>

    <span class="o">//</span> <span class="n">resulting</span> <span class="ow">in</span> <span class="o">-</span> <span class="n">R_CPU0_TLS_DTP_HI16</span><span class="o">.</span>
    <span class="n">fixup_Cpu0_DTP_HI</span><span class="p">,</span>

    <span class="o">//</span> <span class="n">resulting</span> <span class="ow">in</span> <span class="o">-</span> <span class="n">R_CPU0_TLS_DTP_LO16</span><span class="o">.</span>
    <span class="n">fixup_Cpu0_DTP_LO</span><span class="p">,</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/MCTargetDesc/Cpu0MCCodeEmitter.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">unsigned</span> <span class="n">Cpu0MCCodeEmitter</span><span class="p">::</span>
<span class="n">getExprOpValue</span><span class="p">(</span><span class="n">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">Expr</span><span class="p">,</span><span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCFixup</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Fixups</span><span class="p">,</span>
               <span class="n">const</span> <span class="n">MCSubtargetInfo</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="k">case</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_TLSGD</span><span class="p">:</span>
      <span class="n">FixupKind</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_TLSGD</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_TLSLDM</span><span class="p">:</span>
      <span class="n">FixupKind</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_TLSLDM</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_DTP_HI</span><span class="p">:</span>
      <span class="n">FixupKind</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_DTP_HI</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_DTP_LO</span><span class="p">:</span>
      <span class="n">FixupKind</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_DTP_LO</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_GOTTPREL</span><span class="p">:</span>
      <span class="n">FixupKind</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_GOTTPREL</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_TP_HI</span><span class="p">:</span>
      <span class="n">FixupKind</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_TP_HI</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_TP_LO</span><span class="p">:</span>
      <span class="n">FixupKind</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_TP_LO</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0InstrInfo.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">TlsGd</span> <span class="n">node</span> <span class="ow">is</span> <span class="n">used</span> <span class="n">to</span> <span class="n">handle</span> <span class="n">General</span> <span class="n">Dynamic</span> <span class="n">TLS</span>
<span class="k">def</span> <span class="nf">Cpu0TlsGd</span> <span class="p">:</span> <span class="n">SDNode</span><span class="o">&lt;</span><span class="s2">&quot;Cpu0ISD::TlsGd&quot;</span><span class="p">,</span> <span class="n">SDTIntUnaryOp</span><span class="o">&gt;</span><span class="p">;</span>

<span class="o">//</span> <span class="n">TpHi</span> <span class="ow">and</span> <span class="n">TpLo</span> <span class="n">nodes</span> <span class="n">are</span> <span class="n">used</span> <span class="n">to</span> <span class="n">handle</span> <span class="n">Local</span> <span class="n">Exec</span> <span class="n">TLS</span>
<span class="k">def</span> <span class="nf">Cpu0TpHi</span>  <span class="p">:</span> <span class="n">SDNode</span><span class="o">&lt;</span><span class="s2">&quot;Cpu0ISD::TpHi&quot;</span><span class="p">,</span> <span class="n">SDTIntUnaryOp</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">Cpu0TpLo</span>  <span class="p">:</span> <span class="n">SDNode</span><span class="o">&lt;</span><span class="s2">&quot;Cpu0ISD::TpLo&quot;</span><span class="p">,</span> <span class="n">SDTIntUnaryOp</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>let Predicates = [Ch12_1] in {
def : Pat&lt;(Cpu0Hi tglobaltlsaddr:$in), (LUi tglobaltlsaddr:$in)&gt;;
}
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>let Predicates = [Ch12_1] in {
def : Pat&lt;(Cpu0Lo tglobaltlsaddr:$in), (ORi ZERO, tglobaltlsaddr:$in)&gt;;
}
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>let Predicates = [Ch12_1] in {
def : Pat&lt;(add CPURegs:$hi, (Cpu0Lo tglobaltlsaddr:$lo)),
              (ORi CPURegs:$hi, tglobaltlsaddr:$lo)&gt;;
}
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ch12_1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">{</span>
<span class="k">def</span> <span class="p">:</span> <span class="n">WrapperPat</span><span class="o">&lt;</span><span class="n">tglobaltlsaddr</span><span class="p">,</span> <span class="n">ORi</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0SelLowering.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="n">const</span> <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">,</span>
                                       <span class="n">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span>
    <span class="p">:</span> <span class="n">TargetLowering</span><span class="p">(</span><span class="n">TM</span><span class="p">),</span> <span class="n">Subtarget</span><span class="p">(</span><span class="n">STI</span><span class="p">),</span> <span class="n">ABI</span><span class="p">(</span><span class="n">TM</span><span class="o">.</span><span class="n">getABI</span><span class="p">())</span> <span class="p">{</span>

</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">GlobalTLSAddress</span><span class="p">,</span>   <span class="n">MVT</span><span class="p">::</span><span class="n">i32</span><span class="p">,</span>   <span class="n">Custom</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="p">::</span>
<span class="n">LowerOperation</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span>
<span class="p">{</span>
  <span class="n">switch</span> <span class="p">(</span><span class="n">Op</span><span class="o">.</span><span class="n">getOpcode</span><span class="p">())</span>
  <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">case</span> <span class="n">ISD</span><span class="p">::</span><span class="n">GlobalTLSAddress</span><span class="p">:</span>   <span class="k">return</span> <span class="n">lowerGlobalTLSAddress</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>SDValue Cpu0TargetLowering::
lowerGlobalTLSAddress(SDValue Op, SelectionDAG &amp;DAG) const
{
  // If the relocation model is PIC, use the General Dynamic TLS Model or
  // Local Dynamic TLS model, otherwise use the Initial Exec or
  // Local Exec TLS Model.

  GlobalAddressSDNode *GA = cast&lt;GlobalAddressSDNode&gt;(Op);
  if (DAG.getTarget().Options.EmulatedTLS)
    return LowerToTLSEmulatedModel(GA, DAG);

  SDLoc DL(GA);
  const GlobalValue *GV = GA-&gt;getGlobal();
  EVT PtrVT = getPointerTy(DAG.getDataLayout());

  TLSModel::Model model = getTargetMachine().getTLSModel(GV);

  if (model == TLSModel::GeneralDynamic || model == TLSModel::LocalDynamic) {
    // General Dynamic and Local Dynamic TLS Model.
    unsigned Flag = (model == TLSModel::LocalDynamic) ? Cpu0II::MO_TLSLDM
                                                      : Cpu0II::MO_TLSGD;

    SDValue TGA = DAG.getTargetGlobalAddress(GV, DL, PtrVT, 0, Flag);
    SDValue Argument = DAG.getNode(Cpu0ISD::Wrapper, DL, PtrVT,
                                   getGlobalReg(DAG, PtrVT), TGA);
    unsigned PtrSize = PtrVT.getSizeInBits();
    IntegerType *PtrTy = Type::getIntNTy(*DAG.getContext(), PtrSize);

    SDValue TlsGetAddr = DAG.getExternalSymbol(&quot;__tls_get_addr&quot;, PtrVT);

    ArgListTy Args;
    ArgListEntry Entry;
    Entry.Node = Argument;
    Entry.Ty = PtrTy;
    Args.push_back(Entry);

    TargetLowering::CallLoweringInfo CLI(DAG);
    CLI.setDebugLoc(DL).setChain(DAG.getEntryNode())
      .setCallee(CallingConv::C, PtrTy, TlsGetAddr, std::move(Args));
    std::pair&lt;SDValue, SDValue&gt; CallResult = LowerCallTo(CLI);

    SDValue Ret = CallResult.first;

    if (model != TLSModel::LocalDynamic)
      return Ret;

    SDValue TGAHi = DAG.getTargetGlobalAddress(GV, DL, PtrVT, 0,
                                               Cpu0II::MO_DTP_HI);
    SDValue Hi = DAG.getNode(Cpu0ISD::Hi, DL, PtrVT, TGAHi);
    SDValue TGALo = DAG.getTargetGlobalAddress(GV, DL, PtrVT, 0,
                                               Cpu0II::MO_DTP_LO);
    SDValue Lo = DAG.getNode(Cpu0ISD::Lo, DL, PtrVT, TGALo);
    SDValue Add = DAG.getNode(ISD::ADD, DL, PtrVT, Hi, Ret);
    return DAG.getNode(ISD::ADD, DL, PtrVT, Add, Lo);
  }

  SDValue Offset;
  if (model == TLSModel::InitialExec) {
    // Initial Exec TLS Model
    SDValue TGA = DAG.getTargetGlobalAddress(GV, DL, PtrVT, 0,
                                             Cpu0II::MO_GOTTPREL);
    TGA = DAG.getNode(Cpu0ISD::Wrapper, DL, PtrVT, getGlobalReg(DAG, PtrVT),
                      TGA);
    Offset =
        DAG.getLoad(PtrVT, DL, DAG.getEntryNode(), TGA, MachinePointerInfo());
  } else {
    // Local Exec TLS Model
    assert(model == TLSModel::LocalExec);
    SDValue TGAHi = DAG.getTargetGlobalAddress(GV, DL, PtrVT, 0,
                                               Cpu0II::MO_TP_HI);
    SDValue TGALo = DAG.getTargetGlobalAddress(GV, DL, PtrVT, 0,
                                               Cpu0II::MO_TP_LO);
    SDValue Hi = DAG.getNode(Cpu0ISD::Hi, DL, PtrVT, TGAHi);
    SDValue Lo = DAG.getNode(Cpu0ISD::Lo, DL, PtrVT, TGALo);
    Offset = DAG.getNode(ISD::ADD, DL, PtrVT, Hi, Lo);
  }
  return Offset;
}
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0ISelLowering.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">SDValue</span> <span class="n">lowerGlobalTLSAddress</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0MCInstLower.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MCOperand</span> <span class="n">Cpu0MCInstLower</span><span class="p">::</span><span class="n">LowerSymbolOperand</span><span class="p">(</span><span class="n">const</span> <span class="n">MachineOperand</span> <span class="o">&amp;</span><span class="n">MO</span><span class="p">,</span>
                                              <span class="n">MachineOperandType</span> <span class="n">MOTy</span><span class="p">,</span>
                                              <span class="n">unsigned</span> <span class="n">Offset</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VariantKind</span> <span class="n">Kind</span> <span class="o">=</span> <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VK_None</span><span class="p">;</span>
  <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">Cpu0ExprKind</span> <span class="n">TargetKind</span> <span class="o">=</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_None</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">MCSymbol</span> <span class="o">*</span><span class="n">Symbol</span><span class="p">;</span>

  <span class="n">switch</span><span class="p">(</span><span class="n">MO</span><span class="o">.</span><span class="n">getTargetFlags</span><span class="p">())</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">case</span> <span class="n">Cpu0II</span><span class="p">::</span><span class="n">MO_TLSGD</span><span class="p">:</span>
    <span class="n">TargetKind</span> <span class="o">=</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_TLSGD</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0II</span><span class="p">::</span><span class="n">MO_TLSLDM</span><span class="p">:</span>
    <span class="n">TargetKind</span> <span class="o">=</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_TLSLDM</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0II</span><span class="p">::</span><span class="n">MO_DTP_HI</span><span class="p">:</span>
    <span class="n">TargetKind</span> <span class="o">=</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_DTP_HI</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0II</span><span class="p">::</span><span class="n">MO_DTP_LO</span><span class="p">:</span>
    <span class="n">TargetKind</span> <span class="o">=</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_DTP_LO</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0II</span><span class="p">::</span><span class="n">MO_GOTTPREL</span><span class="p">:</span>
    <span class="n">TargetKind</span> <span class="o">=</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_GOTTPREL</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0II</span><span class="p">::</span><span class="n">MO_TP_HI</span><span class="p">:</span>
    <span class="n">TargetKind</span> <span class="o">=</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_TP_HI</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0II</span><span class="p">::</span><span class="n">MO_TP_LO</span><span class="p">:</span>
    <span class="n">TargetKind</span> <span class="o">=</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_TP_LO</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>clang -target mips-unknown-linux-gnu -c
<span class="go">ch12_thread_var.cpp -emit-llvm -std=c++11 -o ch12_thread_var.bc</span>
<span class="gp">JonathantekiiMac:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llvm-dis ch12_thread_var.bc -o -</span>
</pre></div>
</div>
<p class="rubric">../lbdex/output/ch12_thread_var.ll</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="p">...</span><span class="w"></span>
<span class="vg">@a</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">dso_local</span><span class="w"> </span><span class="k">thread_local</span><span class="w"> </span><span class="k">global</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span><span class="w"></span>
<span class="vg">@b</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">dso_local</span><span class="w"> </span><span class="k">thread_local</span><span class="w"> </span><span class="k">global</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span><span class="w"></span>

<span class="c">; Function Attrs: noinline nounwind optnone mustprogress</span>
<span class="k">define</span><span class="w"> </span><span class="k">dso_local</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@_Z15test_thread_varv</span><span class="p">()</span><span class="w"> </span><span class="vg">#0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="nl">entry:</span><span class="w"></span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="vg">@a</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span><span class="w"></span>
<span class="w">  </span><span class="nv nv-Anonymous">%0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="vg">@a</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span><span class="w"></span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv nv-Anonymous">%0</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c">; Function Attrs: noinline nounwind optnone mustprogress</span>
<span class="k">define</span><span class="w"> </span><span class="k">dso_local</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@_Z17test_thread_var_2v</span><span class="p">()</span><span class="w"> </span><span class="vg">#0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="nl">entry:</span><span class="w"></span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="vg">@b</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span><span class="w"></span>
<span class="w">  </span><span class="nv nv-Anonymous">%0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="vg">@b</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span><span class="w"></span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv nv-Anonymous">%0</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llc -march=cpu0 -relocation-model=pic -filetype=asm ch12_thread_var.bc</span>
<span class="go">-o ch12_thread_var.cpu0.pic.s</span>
<span class="gp">JonathantekiiMac:input Jonathan$ </span>cat ch12_thread_var.cpu0.pic.s
</pre></div>
</div>
<p class="rubric">../lbdex/output/ch12_thread_var.cpu0.pic.s</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>...
  .ent  _Z15test_thread_varv            # @_Z15test_thread_varv
_Z15test_thread_varv:
  ...
  ori  $4, $gp, %tlsldm(a)
  ld  $t9, %call16(__tls_get_addr)($gp)
  jalr  $t9
  nop
  ld  $gp, 8($fp)
  lui  $3, %dtp_hi(a)
  addu  $2, $3, $2
  ori  $2, $2, %dtp_lo(a)
  ...
</pre></div>
</div>
<p>In pic mode, the __thread variable access by call function __tls_get_addr with
the address of thread variable.
The c++11 standard thread_local variable is accessed by calling function _ZTW1b
which also call the function __tls_get_addr to get the thread_local variable
address.
In static mode, the thread variable is accessed by getting address of thread
variables “a” and “b” with machine instructions as follows,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llc -march=cpu0 -relocation-model=static -filetype=asm</span>
<span class="go">ch12_thread_var.bc -o ch12_thread_var.cpu0.static.s</span>
<span class="gp">JonathantekiiMac:input Jonathan$ </span>cat ch12_thread_var.cpu0.static.s
</pre></div>
</div>
<p class="rubric">../lbdex/output/ch12_thread_var.cpu0.static.s</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>...
lui  $2, %tp_hi(a)
ori  $2, $2, %tp_lo(a)
...
lui  $2, %tp_hi(b)
ori  $2, $2, %tp_lo(b)
...
</pre></div>
</div>
<p>While Mips uses rdhwr instruction to access thread varaible as below,
Cpu0 access thread varaible without inventing any new instruction.
The thread variables are keeped in thread varaible memory location which
accessed through %tp_hi and %tp_lo, and furthermore, this section of memory is
protected through kernel mode program.
Thus, the user mode program cannot access this area of memory and
no space to breathe for hack program.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llc -march=mips -relocation-model=static -filetype=asm</span>
<span class="go">ch12_thread_var.bc -o -</span>
<span class="go">  ...</span>
<span class="go">  lui $1, %tprel_hi(a)</span>
<span class="go">  ori $1, $1, %tprel_lo(a)</span>
<span class="go">  .set  push</span>
<span class="go">  .set  mips32r2</span>
<span class="go">  rdhwr $3, $29</span>
<span class="go">  .set  pop</span>
<span class="go">  addu  $1, $3, $1</span>
<span class="go">  addiu $2, $zero, 2</span>
<span class="go">  sw  $2, 0($1)</span>
<span class="go">  addiu $2, $zero, 2</span>
<span class="go">  ...</span>
</pre></div>
</div>
<p>In static mode, the thread variable is similar to global variable.
In general, they are same in IRs, DAGs and machine code translation.
List them in the following tables.
You can check them with debug option enabled.</p>
<table class="docutils align-default" id="id19">
<caption><span class="caption-number">Table 37 </span><span class="caption-text">The DAGs of thread varaible of static mode</span><a class="headerlink" href="#id19" title="Permalink to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>stage</p></th>
<th class="head"><p>DAG</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>IR</p></td>
<td><p>load i32* &#64;a, align 4;</p></td>
</tr>
<tr class="row-odd"><td><p>Legalized selection DAG</p></td>
<td><p>(add Cpu0ISD::Hi Cpu0ISD::Lo);</p></td>
</tr>
<tr class="row-even"><td><p>Instruction Selection</p></td>
<td><p>ori $2, $zero, %tp_lo(a);</p></td>
</tr>
<tr class="row-odd"><td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>lui $3, %tp_hi(a);</p></td>
</tr>
<tr class="row-even"><td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>addu  $3, $3, $2;</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="id20">
<caption><span class="caption-number">Table 38 </span><span class="caption-text">The DAGs of local_thread varaible of static mode</span><a class="headerlink" href="#id20" title="Permalink to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>stage</p></th>
<th class="head"><p>DAG</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>IR</p></td>
<td><p>ret i32* &#64;b;</p></td>
</tr>
<tr class="row-odd"><td><p>Legalized selection DAG</p></td>
<td><p>%0=(add Cpu0ISD::Hi Cpu0ISD::Lo);…</p></td>
</tr>
<tr class="row-even"><td><p>Instruction Selection</p></td>
<td><p>ori $2, $zero, %tp_lo(a);</p></td>
</tr>
<tr class="row-odd"><td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>lui $3, %tp_hi(a);</p></td>
</tr>
<tr class="row-even"><td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>addu  $3, $3, $2;</p></td>
</tr>
</tbody>
</table>
</section>
<section id="atomic">
<h2><a class="toc-backref" href="#id27" role="doc-backlink">Atomic</a><a class="headerlink" href="#atomic" title="Permalink to this heading">¶</a></h2>
<p>In tradition, C uses different API which provided by OS or library to support
multi-thread programming. For example, posix thread API on unix/linux, MS
windows API, …, etc. In order to achieve synchronization to solve race
condition between threads, OS provide their own lock or semaphore functions to
programmer. But this solution is OS dependent.
After c++11, programmer can use atomic to program and run the code
on every different platform since the thread and atomic are part of c++ standard.
Beside of portability, the other important benifit is the compiler can generate
high performance code by the target hardware instructions rather than couting on
lock() function only <a class="footnote-reference brackets" href="#atomic-wiki" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#atomic-stackoverflow" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a>
<a class="footnote-reference brackets" href="#atomic-herbsutter" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a>.</p>
<p>Compare-and-swap operation <a class="footnote-reference brackets" href="#cas-wiki" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a> is used to implement synchronization
primitives like semaphores and mutexes, as well as more sophisticated
wait-free and lock-free <a class="footnote-reference brackets" href="#lf-wiki" id="id8" role="doc-noteref"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></a> algorithms.
For atomic variables, Mips lock instructions, ll and sc, to solve the race
condition problem. The semantic as follows,</p>
<ul class="simple">
<li><p>Load-link returns the current value of a memory location, while a subsequent
store-conditional to the same memory location will store a new value only if
no updates have occurred to that location since the load-link.
If any updates have occurred, the store-conditional is guaranteed to fail,
even if the value read by the load-link has since been restored. <a class="footnote-reference brackets" href="#ll-wiki" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></a></p></li>
</ul>
<p>Mips sync and ARM/X86-64 memory-barrier instruction <a class="footnote-reference brackets" href="#mb-wiki" id="id10" role="doc-noteref"><span class="fn-bracket">[</span>11<span class="fn-bracket">]</span></a> provide
synchronization mechanism very efficiently in some scenarios.</p>
<p>Mips sync <a class="footnote-reference brackets" href="#mips-sync" id="id11" role="doc-noteref"><span class="fn-bracket">[</span>12<span class="fn-bracket">]</span></a> is explained simply as follows,</p>
<p>A Simple Description:
SYNC affects only uncached and cached coherent loads and stores. The loads and
stores that occur prior to the SYNC must be completed before the loads and
stores after the SYNC are allowed to start.
Loads are completed when the destination register is written. Stores are completed
when the stored value is visible to every other processor in the system.</p>
<p>In order to support atomic in C++ and java, llvm provides the atomic IRs and
memory ordering here <a class="footnote-reference brackets" href="#atomics-llvm" id="id12" role="doc-noteref"><span class="fn-bracket">[</span>13<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#llvmlang-ordering" id="id13" role="doc-noteref"><span class="fn-bracket">[</span>14<span class="fn-bracket">]</span></a>. C++ memory order
is explained and exampled here <a class="footnote-reference brackets" href="#cpp-mem-order" id="id14" role="doc-noteref"><span class="fn-bracket">[</span>15<span class="fn-bracket">]</span></a>. The chapter 19
of book DPC++ <a class="footnote-reference brackets" href="#dpcpp-memorder" id="id15" role="doc-noteref"><span class="fn-bracket">[</span>16<span class="fn-bracket">]</span></a> explains the memory ordering better and I add
the related code fragment of lbdex/input/atomics.ll to it for explanation as
follows,</p>
<ul class="simple">
<li><p>memory_order::relaxed</p></li>
</ul>
<p>Read and write operations can be re-ordered before or after the operation with
no restrictions. There are no ordering guarantees.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">define i8 @load_i8_unordered(i8* %mem) {</span>
<span class="go">; CHECK-LABEL: load_i8_unordered</span>
<span class="go">; CHECK: ll</span>
<span class="go">; CHECK: sc</span>
<span class="go">; CHECK-NOT: sync</span>
<span class="gp">  %</span><span class="nv">val</span> <span class="o">=</span> load atomic i8, i8* %mem unordered, align <span class="m">1</span>
<span class="go">  ret i8 %val</span>
<span class="go">}</span>
</pre></div>
</div>
<p>No <strong>sync</strong> from CodeGen instructions above.</p>
<ul class="simple">
<li><p>memory_order::acquire</p></li>
</ul>
<p>Read and write operations appearing after the operation in the program must
occur after it (i.e., they cannot be re-ordered before the operation).</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">define i32 @load_i32_acquire(i32* %mem) {</span>
<span class="go">; CHECK-LABEL: load_i32_acquire</span>
<span class="go">; CHECK: ll</span>
<span class="go">; CHECK: sc</span>
<span class="gp">  %</span><span class="nv">val</span> <span class="o">=</span> load atomic i32, i32* %mem acquire, align <span class="m">4</span>
<span class="go">; CHECK: sync</span>
<span class="go">  ret i32 %val</span>
<span class="go">}</span>
</pre></div>
</div>
<p>Sync guarantees “load atomic” complete before the next R/W (Read/Write). All
writes in other threads that release the same atomic variable are visible in the
current thread.</p>
<ul class="simple">
<li><p>memory_order::release</p></li>
</ul>
<p>Read and write operations appearing before the operation in the program must
occur before it (i.e., they cannot be re-ordered after the operation), and
preceding write operations are guaranteed to be visible to other program
instances which have been synchronized by a corresponding acquire operation
(i.e., an atomic operation using the same variable and memory_order::acquire
or a barrier function).</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">define void @store_i32_release(i32* %mem) {</span>
<span class="go">; CHECK-LABEL: store_i32_release</span>
<span class="go">; CHECK: sync</span>
<span class="go">; CHECK: ll</span>
<span class="go">; CHECK: sc</span>
<span class="go">  store atomic i32 42, i32* %mem release, align 4</span>
<span class="go">  ret void</span>
<span class="go">}</span>
</pre></div>
</div>
<p>Sync guarantees preceding R/W complete before “store atomic”. Mips’ ll and sc
guarantee that “store atomic release” is visible to other processors.</p>
<ul class="simple">
<li><p>memory_order::acq_rel</p></li>
</ul>
<p>The operation acts as both an acquire and a release. Read and write operations
cannot be re-ordered around the operation, and preceding writes must be made
visible as previously described for memory_order::release.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">define i32 @cas_strong_i32_acqrel_acquire(i32* %mem) {</span>
<span class="go">; CHECK-LABEL: cas_strong_i32_acqrel_acquire</span>
<span class="go">; CHECK: ll</span>
<span class="go">; CHECK: sc</span>
<span class="gp">  %</span><span class="nv">val</span> <span class="o">=</span> cmpxchg i32* %mem, i32 <span class="m">0</span>, i32 <span class="m">1</span> acq_rel acquire
<span class="go">; CHECK: sync</span>
<span class="gp">  %</span><span class="nv">loaded</span> <span class="o">=</span> extractvalue <span class="o">{</span> i32, i1<span class="o">}</span> %val, <span class="m">0</span>
<span class="go">  ret i32 %loaded</span>
<span class="go">}</span>
</pre></div>
</div>
<p>Sync guarantees preceding R/W complete before “cmpxchg”. Other processors’
preceding write operations are guaranteed to be visible to this
“cmpxchg acquire” (Mips’s ll and sc quarantee it).</p>
<ul class="simple">
<li><p>memory_order::seq_cst</p></li>
</ul>
<p>The operation acts as an acquire, release, or both depending on whether it is
a read, write, or read-modify-write operation, respectively. All operations
with this memory order are observed in a sequentially consistent order.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">define i8 @cas_strong_i8_sc_sc(i8* %mem) {</span>
<span class="go">; CHECK-LABEL: cas_strong_i8_sc_sc</span>
<span class="go">; CHECK: sync</span>
<span class="go">; CHECK: ll</span>
<span class="go">; CHECK: sc</span>
<span class="gp">  %</span><span class="nv">val</span> <span class="o">=</span> cmpxchg i8* %mem, i8 <span class="m">0</span>, i8 <span class="m">1</span> seq_cst seq_cst
<span class="go">; CHECK: sync</span>
<span class="gp">  %</span><span class="nv">loaded</span> <span class="o">=</span> extractvalue <span class="o">{</span> i8, i1<span class="o">}</span> %val, <span class="m">0</span>
<span class="go">  ret i8 %loaded</span>
<span class="go">}</span>
</pre></div>
</div>
<p>First sync guarantees preceding R/W complete before “cmpxchg seq_cst” and
visible to “cmpxchg seq_cst”. For seq_cst, a store performs a release operation.
Which means “cmpxchg seq_cst” are visible to other threads/processors that
acquire the same atomic variable as the memory_order_release definition.
Mips’ ll and sc quarantees this feature of “cmpxchg seq_cst”.
Second Sync guarantees “cmpxchg seq_cst” complete before the next R/W.</p>
<p>There are several restrictions on which memory orders are supported by each
operation. <a class="reference internal" href="#c-f1"><span class="std std-numref">Fig. 49</span></a> (from book Figure 19-10) summarizes which
combinations are valid.</p>
<figure class="align-center" id="id21">
<span id="c-f1"></span><a class="reference internal image-reference" href="_images/Fig-19-10-book-dpc++.png"><img alt="_images/Fig-19-10-book-dpc++.png" src="_images/Fig-19-10-book-dpc++.png" style="width: 633.0px; height: 368.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 49 </span><span class="caption-text">Supporting atomic operations with memory_order</span><a class="headerlink" href="#id21" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>Load operations do not write values to memory and are therefore incompatible
with release semantics. Similarly, store operations do not read values from
memory and are therefore incompatible with acquire semantics. The remaining
read-modify-write atomic operations and fences are compatible with all memory
orderings <a class="footnote-reference brackets" href="#dpcpp-memorder" id="id16" role="doc-noteref"><span class="fn-bracket">[</span>16<span class="fn-bracket">]</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>C++ memory_order_consume</strong></p>
</div>
<figure class="align-center" id="id22">
<span id="c-f2"></span><a class="reference internal image-reference" href="_images/Fig-19-9-book-dpc++.png"><img alt="_images/Fig-19-9-book-dpc++.png" src="_images/Fig-19-9-book-dpc++.png" style="width: 578.0px; height: 594.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 50 </span><span class="caption-text">Comparing standard C++ and SYCL/DPC++ memory models</span><a class="headerlink" href="#id22" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>The C++ memory model additionally includes memory_order::consume, with similar
behavior to memory_order::acquire. however, the C++17 standard discourages its
use, noting that its definition is being revised. its inclusion in dpC++ has
therefore been postponed to a future version.</p>
<p>For a few years now, compilers have treated consume as a synonym for acquire
<a class="footnote-reference brackets" href="#cpp-memorder-consume-as-acquire" id="id17" role="doc-noteref"><span class="fn-bracket">[</span>17<span class="fn-bracket">]</span></a>.</p>
<p>The current expectation is that the replacement facility will rely on core
memory model and atomics definitions very similar to what’s currently there.
Since memory_order_consume does have a profound impact on the memory model,
removing this text would allow drastic simplification, but conversely would
make it very difficult to add anything along the lines of memory_order_consume
back in later, especially if the standard evolves in the meantime, as expected.
Thus we are not proposing to remove the current wording
<a class="footnote-reference brackets" href="#cpp-memorder-consume-remove" id="id18" role="doc-noteref"><span class="fn-bracket">[</span>18<span class="fn-bracket">]</span></a>.</p>
<p>The following test files are extracted from memory_checks() of
clang/test/Sema/atomic-ops.c. The “__c11_atomic_xxx” builtin-functions from
clang defined in clang/include/clang/Basic/Builtins.def. Complie with clang
will get the results same with <a class="reference internal" href="#c-f1"><span class="std std-numref">Fig. 49</span></a>. Clang compile
memory_order_consume to the same result of memory_order_acquire.</p>
<p class="rubric">lbdex/input/ch12_sema_atomic-ops.c</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">clang</span> <span class="o">-</span><span class="n">S</span> <span class="n">ch12_sema_atomic</span><span class="o">-</span><span class="n">ops</span><span class="o">.</span><span class="n">c</span> <span class="o">-</span><span class="n">emit</span><span class="o">-</span><span class="n">llvm</span> <span class="o">-</span><span class="n">o</span> <span class="o">-</span>
<span class="o">//</span> <span class="n">Uses</span> <span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">homebrew</span><span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">llvm</span><span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">clang</span> <span class="ow">in</span> <span class="n">macOS</span><span class="o">.</span>

<span class="c1">#include &lt;stdatomic.h&gt;</span>

<span class="o">//</span> <span class="n">From</span> <span class="n">memory_checks</span><span class="p">()</span> <span class="n">of</span> <span class="n">Sema</span><span class="o">/</span><span class="n">atomic</span><span class="o">-</span><span class="n">ops</span><span class="o">.</span><span class="n">c</span>
<span class="n">void</span> <span class="n">memory_checks</span><span class="p">(</span><span class="n">_Atomic</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span><span class="n">Ap</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="nb">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_load</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_load</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_load</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">memory_order_consume</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_load</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">);</span> <span class="o">//</span> <span class="n">expected</span><span class="o">-</span><span class="n">warning</span> <span class="p">{{</span><span class="n">memory</span> <span class="n">order</span> <span class="n">argument</span> <span class="n">to</span> <span class="n">atomic</span> <span class="n">operation</span> <span class="ow">is</span> <span class="n">invalid</span><span class="p">}}</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_load</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">);</span> <span class="o">//</span> <span class="n">expected</span><span class="o">-</span><span class="n">warning</span> <span class="p">{{</span><span class="n">memory</span> <span class="n">order</span> <span class="n">argument</span> <span class="n">to</span> <span class="n">atomic</span> <span class="n">operation</span> <span class="ow">is</span> <span class="n">invalid</span><span class="p">}}</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_load</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_load</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_load</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="o">//</span> <span class="n">expected</span><span class="o">-</span><span class="n">warning</span> <span class="p">{{</span><span class="n">memory</span> <span class="n">order</span> <span class="n">argument</span> <span class="n">to</span> <span class="n">atomic</span> <span class="n">operation</span> <span class="ow">is</span> <span class="n">invalid</span><span class="p">}}</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_load</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="mi">42</span><span class="p">);</span> <span class="o">//</span> <span class="n">expected</span><span class="o">-</span><span class="n">warning</span> <span class="p">{{</span><span class="n">memory</span> <span class="n">order</span> <span class="n">argument</span> <span class="n">to</span> <span class="n">atomic</span> <span class="n">operation</span> <span class="ow">is</span> <span class="n">invalid</span><span class="p">}}</span>

  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_store</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_store</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">);</span> <span class="o">//</span> <span class="n">expected</span><span class="o">-</span><span class="n">warning</span> <span class="p">{{</span><span class="n">memory</span> <span class="n">order</span> <span class="n">argument</span> <span class="n">to</span> <span class="n">atomic</span> <span class="n">operation</span> <span class="ow">is</span> <span class="n">invalid</span><span class="p">}}</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_store</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_consume</span><span class="p">);</span> <span class="o">//</span> <span class="n">expected</span><span class="o">-</span><span class="n">warning</span> <span class="p">{{</span><span class="n">memory</span> <span class="n">order</span> <span class="n">argument</span> <span class="n">to</span> <span class="n">atomic</span> <span class="n">operation</span> <span class="ow">is</span> <span class="n">invalid</span><span class="p">}}</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_store</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_store</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">);</span> <span class="o">//</span> <span class="n">expected</span><span class="o">-</span><span class="n">warning</span> <span class="p">{{</span><span class="n">memory</span> <span class="n">order</span> <span class="n">argument</span> <span class="n">to</span> <span class="n">atomic</span> <span class="n">operation</span> <span class="ow">is</span> <span class="n">invalid</span><span class="p">}}</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_store</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">);</span>

  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_exchange</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_exchange</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_exchange</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_consume</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_exchange</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_exchange</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_exchange</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">);</span>

  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_compare_exchange_strong</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_compare_exchange_strong</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_compare_exchange_strong</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_consume</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_compare_exchange_strong</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_compare_exchange_strong</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_compare_exchange_strong</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>

  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_compare_exchange_weak</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_compare_exchange_weak</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_compare_exchange_weak</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_consume</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_compare_exchange_weak</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_compare_exchange_weak</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_compare_exchange_weak</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>

  <span class="n">atomic_thread_fence</span><span class="p">(</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="n">atomic_thread_fence</span><span class="p">(</span><span class="n">memory_order_acquire</span><span class="p">);</span>
  <span class="n">atomic_thread_fence</span><span class="p">(</span><span class="n">memory_order_consume</span><span class="p">);</span> <span class="o">//</span> <span class="n">For</span> <span class="n">a</span> <span class="n">few</span> <span class="n">years</span> <span class="n">now</span><span class="p">,</span> <span class="n">compilers</span> <span class="n">have</span> <span class="n">treated</span> <span class="n">consume</span> <span class="k">as</span> <span class="n">a</span> <span class="n">synonym</span> <span class="k">for</span> <span class="n">acquire</span><span class="o">.</span>
  <span class="n">atomic_thread_fence</span><span class="p">(</span><span class="n">memory_order_release</span><span class="p">);</span>
  <span class="n">atomic_thread_fence</span><span class="p">(</span><span class="n">memory_order_acq_rel</span><span class="p">);</span>
  <span class="n">atomic_thread_fence</span><span class="p">(</span><span class="n">memory_order_seq_cst</span><span class="p">);</span>
  <span class="n">atomic_signal_fence</span><span class="p">(</span><span class="n">memory_order_seq_cst</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/input/ch12_sema_atomic-fetch.c</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">clang</span> <span class="o">-</span><span class="n">S</span> <span class="n">ch12_sema_atomic</span><span class="o">-</span><span class="n">fetch</span><span class="o">.</span><span class="n">c</span> <span class="o">-</span><span class="n">emit</span><span class="o">-</span><span class="n">llvm</span> <span class="o">-</span><span class="n">o</span> <span class="o">-</span>
<span class="o">//</span> <span class="n">Uses</span> <span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">homebrew</span><span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">llvm</span><span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">clang</span> <span class="ow">in</span> <span class="n">macOS</span><span class="o">.</span>

<span class="c1">#include &lt;stdatomic.h&gt;</span>

<span class="o">//</span><span class="c1">#define WANT_COMPILE_FAIL</span>

<span class="o">//</span> <span class="n">From</span> <span class="n">__c11_atomic_fetch_xxx</span> <span class="n">of</span> <span class="n">memory_checks</span><span class="p">()</span> <span class="n">of</span> <span class="n">Sema</span><span class="o">/</span><span class="n">atomic</span><span class="o">-</span><span class="n">ops</span><span class="o">.</span><span class="n">c</span>
<span class="n">void</span> <span class="n">memory_checks</span><span class="p">(</span><span class="n">_Atomic</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span><span class="n">Ap</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="nb">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_add</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_add</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_add</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">memory_order_consume</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_add</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_add</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_add</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">);</span>

<span class="c1">#ifdef WANT_COMPILE_FAIL // fail to compile:</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_add</span><span class="p">(</span>
      <span class="p">(</span><span class="n">struct</span> <span class="n">Incomplete</span> <span class="o">*</span> <span class="n">_Atomic</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,</span> <span class="o">//</span> <span class="n">expected</span><span class="o">-</span><span class="n">error</span> <span class="p">{{</span><span class="n">incomplete</span> <span class="nb">type</span> <span class="s1">&#39;struct Incomplete&#39;</span><span class="p">}}</span>
      <span class="mi">1</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">);</span>
<span class="c1">#endif</span>

  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_init</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_init</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_init</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_init</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_init</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_init</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_sub</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_sub</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_sub</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_consume</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_sub</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_sub</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_sub</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">);</span>

  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_and</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_and</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_and</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_consume</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_and</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_and</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_and</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">);</span>

  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_or</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_or</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_or</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_consume</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_or</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_or</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_or</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">);</span>

  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_xor</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_xor</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_xor</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_consume</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_xor</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_xor</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_xor</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">);</span>

  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_nand</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_nand</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_nand</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_consume</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_nand</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_nand</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_nand</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">);</span>

  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_min</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_min</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_min</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_consume</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_min</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_min</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_min</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">);</span>

  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_max</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_max</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_max</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_consume</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_max</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_max</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_max</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<table class="docutils align-default" id="id23">
<caption><span class="caption-number">Table 39 </span><span class="caption-text">Atomic related between clang’s builtin and llvm ir</span><a class="headerlink" href="#id23" title="Permalink to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>clang’s builtin</p></th>
<th class="head"><p>llvm ir</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>__c11_atomic_load</p></td>
<td><p>load atomic</p></td>
</tr>
<tr class="row-odd"><td><p>__c11_atomic_store</p></td>
<td><p>store atomic</p></td>
</tr>
<tr class="row-even"><td><p>__c11_atomic_exchange_xxx</p></td>
<td><p>cmpxchg</p></td>
</tr>
<tr class="row-odd"><td><p>atomic_thread_fence</p></td>
<td><p>fence</p></td>
</tr>
<tr class="row-even"><td><p>__c11_atomic_fetch_xxx</p></td>
<td><p>atomicrmw xxx</p></td>
</tr>
</tbody>
</table>
<p>C++ atomic functions supported by calling implemented functions from C++ libary.
These implemented functions evently call “__c11_atomic_xxx” builtin-functions
for implementation. So,
“__c11_atomic_xxx” listed in above providing lower-level of better performance
functions for C++ programmers. An example as follows,</p>
<p class="rubric">lbdex/input/ch12_c++_atomics.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">clang</span> <span class="o">-</span><span class="n">S</span> <span class="n">ch12_c</span><span class="o">++</span><span class="n">_atomics</span><span class="o">.</span><span class="n">cpp</span> <span class="o">-</span><span class="n">emit</span><span class="o">-</span><span class="n">llvm</span> <span class="o">-</span><span class="n">o</span> <span class="o">-</span>
<span class="o">//</span> <span class="n">Uses</span> <span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">homebrew</span><span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">llvm</span><span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">clang</span> <span class="ow">in</span> <span class="n">macOS</span><span class="o">.</span>

<span class="c1">#include &lt;atomic&gt;</span>

<span class="n">std</span><span class="p">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="nb">bool</span><span class="o">&gt;</span> <span class="n">winner</span> <span class="p">(</span><span class="n">false</span><span class="p">);</span>

<span class="nb">int</span> <span class="n">test_atomics</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nb">bool</span> <span class="n">res</span> <span class="o">=</span> <span class="n">winner</span><span class="o">.</span><span class="n">exchange</span><span class="p">(</span><span class="n">true</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="n">count</span><span class="o">++</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For supporting llvm atomic IRs, the following code added to Chapter12_1.</p>
<p class="rubric">lbdex/chapters/Chapter12_1/Disassembler/Cpu0Disassembler.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">static</span> <span class="n">DecodeStatus</span> <span class="n">DecodeMem</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span>
                              <span class="n">unsigned</span> <span class="n">Insn</span><span class="p">,</span>
                              <span class="n">uint64_t</span> <span class="n">Address</span><span class="p">,</span>
                              <span class="n">const</span> <span class="n">void</span> <span class="o">*</span><span class="n">Decoder</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">if</span><span class="p">(</span><span class="n">Inst</span><span class="o">.</span><span class="n">getOpcode</span><span class="p">()</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">SC</span><span class="p">){</span>
    <span class="n">Inst</span><span class="o">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="p">::</span><span class="n">createReg</span><span class="p">(</span><span class="n">Reg</span><span class="p">));</span>
  <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0InstrInfo.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">SDT_Sync</span>             <span class="p">:</span> <span class="n">SDTypeProfile</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="n">SDTCisVT</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">i32</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">Cpu0Sync</span> <span class="p">:</span> <span class="n">SDNode</span><span class="o">&lt;</span><span class="s2">&quot;Cpu0ISD::Sync&quot;</span><span class="p">,</span> <span class="n">SDT_Sync</span><span class="p">,</span> <span class="p">[</span><span class="n">SDNPHasChain</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">PtrRC</span> <span class="p">:</span> <span class="n">Operand</span><span class="o">&lt;</span><span class="n">iPTR</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">let</span> <span class="n">MIOperandInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">ops</span> <span class="n">ptr_rc</span><span class="p">);</span>
  <span class="n">let</span> <span class="n">DecoderMethod</span> <span class="o">=</span> <span class="s2">&quot;DecodeCPURegsRegisterClass&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// Atomic instructions with 2 source operands (ATOMIC_SWAP &amp; ATOMIC_LOAD_*).
class Atomic2Ops&lt;PatFrag Op, RegisterClass DRC&gt; :
  PseudoSE&lt;(outs DRC:$dst), (ins PtrRC:$ptr, DRC:$incr),
           [(set DRC:$dst, (Op iPTR:$ptr, DRC:$incr))]&gt;;

// Atomic Compare &amp; Swap.
class AtomicCmpSwap&lt;PatFrag Op, RegisterClass DRC&gt; :
  PseudoSE&lt;(outs DRC:$dst), (ins PtrRC:$ptr, DRC:$cmp, DRC:$swap),
           [(set DRC:$dst, (Op iPTR:$ptr, DRC:$cmp, DRC:$swap))]&gt;;
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>class LLBase&lt;bits&lt;8&gt; Opc, string opstring, RegisterClass RC, Operand Mem&gt; :
  FMem&lt;Opc, (outs RC:$ra), (ins Mem:$addr),
       !strconcat(opstring, &quot;\t$ra, $addr&quot;), [], IILoad&gt; {
  let mayLoad = 1;
}

class SCBase&lt;bits&lt;8&gt; Opc, string opstring, RegisterOperand RO, Operand Mem&gt; :
  FMem&lt;Opc, (outs RO:$dst), (ins RO:$ra, Mem:$addr),
       !strconcat(opstring, &quot;\t$ra, $addr&quot;), [], IIStore&gt; {
  let mayStore = 1;
  let Constraints = &quot;$ra = $dst&quot;;
}
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ch12_1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">{</span>
<span class="n">let</span> <span class="n">usesCustomInserter</span> <span class="o">=</span> <span class="mi">1</span> <span class="ow">in</span> <span class="p">{</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_ADD_I8</span>   <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_add_8</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_ADD_I16</span>  <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_add_16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_ADD_I32</span>  <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_add_32</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_SUB_I8</span>   <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_sub_8</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_SUB_I16</span>  <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_sub_16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_SUB_I32</span>  <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_sub_32</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_AND_I8</span>   <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_and_8</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_AND_I16</span>  <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_and_16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_AND_I32</span>  <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_and_32</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_OR_I8</span>    <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_or_8</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_OR_I16</span>   <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_or_16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_OR_I32</span>   <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_or_32</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_XOR_I8</span>   <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_xor_8</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_XOR_I16</span>  <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_xor_16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_XOR_I32</span>  <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_xor_32</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_NAND_I8</span>  <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_nand_8</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_NAND_I16</span> <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_nand_16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_LOAD_NAND_I32</span> <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_nand_32</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>

  <span class="k">def</span> <span class="nf">ATOMIC_SWAP_I8</span>       <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_swap_8</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_SWAP_I16</span>      <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_swap_16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_SWAP_I32</span>      <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_swap_32</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>

  <span class="k">def</span> <span class="nf">ATOMIC_CMP_SWAP_I8</span>   <span class="p">:</span> <span class="n">AtomicCmpSwap</span><span class="o">&lt;</span><span class="n">atomic_cmp_swap_8</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_CMP_SWAP_I16</span>  <span class="p">:</span> <span class="n">AtomicCmpSwap</span><span class="o">&lt;</span><span class="n">atomic_cmp_swap_16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span> <span class="nf">ATOMIC_CMP_SWAP_I32</span>  <span class="p">:</span> <span class="n">AtomicCmpSwap</span><span class="o">&lt;</span><span class="n">atomic_cmp_swap_32</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>let Predicates = [Ch12_1] in {
let hasSideEffects = 1 in
def SYNC : Cpu0Inst&lt;(outs), (ins i32imm:$stype), &quot;sync $stype&quot;,
                    [(Cpu0Sync imm:$stype)], NoItinerary, FrmOther&gt;
{
  bits&lt;5&gt; stype;
  let Opcode = 0x60;
  let Inst{25-11} = 0;
  let Inst{10-6} = stype;
  let Inst{5-0} = 0;
}
}
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">///</span> <span class="n">Load</span><span class="o">-</span><span class="n">linked</span><span class="p">,</span> <span class="n">Store</span><span class="o">-</span><span class="n">conditional</span>
<span class="k">def</span> <span class="nf">LL</span>      <span class="p">:</span> <span class="n">LLBase</span><span class="o">&lt;</span><span class="mh">0x61</span><span class="p">,</span> <span class="s2">&quot;ll&quot;</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="n">mem</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">SC</span>      <span class="p">:</span> <span class="n">SCBase</span><span class="o">&lt;</span><span class="mh">0x62</span><span class="p">,</span> <span class="s2">&quot;sc&quot;</span><span class="p">,</span> <span class="n">RegisterOperand</span><span class="o">&lt;</span><span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">mem</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="p">:</span> <span class="n">Cpu0InstAlias</span><span class="o">&lt;</span><span class="s2">&quot;sync&quot;</span><span class="p">,</span>
                    <span class="p">(</span><span class="n">SYNC</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0ISelLowering.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">MachineBasicBlock</span> <span class="o">*</span>
    <span class="n">EmitInstrWithCustomInserter</span><span class="p">(</span><span class="n">MachineInstr</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">,</span>
                                <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">MBB</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">SDValue</span> <span class="n">lowerATOMIC_FENCE</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span><span class="o">&amp;</span> <span class="n">DAG</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="nb">bool</span> <span class="n">shouldInsertFencesForAtomic</span><span class="p">(</span><span class="n">const</span> <span class="n">Instruction</span> <span class="o">*</span><span class="n">I</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="o">///</span> <span class="n">Emit</span> <span class="n">a</span> <span class="n">sign</span><span class="o">-</span><span class="n">extension</span> <span class="n">using</span> <span class="n">shl</span><span class="o">/</span><span class="n">sra</span> <span class="n">appropriately</span><span class="o">.</span>
    <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">emitSignExtendToI32InReg</span><span class="p">(</span><span class="n">MachineInstr</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">,</span>
                                                <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">BB</span><span class="p">,</span>
                                                <span class="n">unsigned</span> <span class="n">Size</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">DstReg</span><span class="p">,</span>
                                                <span class="n">unsigned</span> <span class="n">SrcRec</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
    <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">emitAtomicBinary</span><span class="p">(</span><span class="n">MachineInstr</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">,</span> <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">BB</span><span class="p">,</span>
                    <span class="n">unsigned</span> <span class="n">Size</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">BinOpcode</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">Nand</span> <span class="o">=</span> <span class="n">false</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
    <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">emitAtomicBinaryPartword</span><span class="p">(</span><span class="n">MachineInstr</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">,</span>
                    <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">BB</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">Size</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">BinOpcode</span><span class="p">,</span>
                    <span class="nb">bool</span> <span class="n">Nand</span> <span class="o">=</span> <span class="n">false</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
    <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">emitAtomicCmpSwap</span><span class="p">(</span><span class="n">MachineInstr</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">,</span>
                                  <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">BB</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">Size</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
    <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">emitAtomicCmpSwapPartword</span><span class="p">(</span><span class="n">MachineInstr</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">,</span>
                                  <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">BB</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">Size</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0SelLowering.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">getTargetNodeName</span><span class="p">(</span><span class="n">unsigned</span> <span class="n">Opcode</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">case</span> <span class="n">Cpu0ISD</span><span class="p">::</span><span class="n">Sync</span><span class="p">:</span>              <span class="k">return</span> <span class="s2">&quot;Cpu0ISD::Sync&quot;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="n">const</span> <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">,</span>
                                       <span class="n">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span>
    <span class="p">:</span> <span class="n">TargetLowering</span><span class="p">(</span><span class="n">TM</span><span class="p">),</span> <span class="n">Subtarget</span><span class="p">(</span><span class="n">STI</span><span class="p">),</span> <span class="n">ABI</span><span class="p">(</span><span class="n">TM</span><span class="o">.</span><span class="n">getABI</span><span class="p">())</span> <span class="p">{</span>

</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">ATOMIC_LOAD</span><span class="p">,</span>       <span class="n">MVT</span><span class="p">::</span><span class="n">i32</span><span class="p">,</span>    <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">ATOMIC_LOAD</span><span class="p">,</span>       <span class="n">MVT</span><span class="p">::</span><span class="n">i64</span><span class="p">,</span>    <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">ATOMIC_STORE</span><span class="p">,</span>      <span class="n">MVT</span><span class="p">::</span><span class="n">i32</span><span class="p">,</span>    <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">ATOMIC_STORE</span><span class="p">,</span>      <span class="n">MVT</span><span class="p">::</span><span class="n">i64</span><span class="p">,</span>    <span class="n">Expand</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="p">::</span>
<span class="n">LowerOperation</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span>
<span class="p">{</span>
  <span class="n">switch</span> <span class="p">(</span><span class="n">Op</span><span class="o">.</span><span class="n">getOpcode</span><span class="p">())</span>
  <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">case</span> <span class="n">ISD</span><span class="p">::</span><span class="n">ATOMIC_FENCE</span><span class="p">:</span>       <span class="k">return</span> <span class="n">lowerATOMIC_FENCE</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>MachineBasicBlock *
Cpu0TargetLowering::EmitInstrWithCustomInserter(MachineInstr &amp;MI,
                                                MachineBasicBlock *BB) const {
  switch (MI.getOpcode()) {
  default:
    llvm_unreachable(&quot;Unexpected instr type to insert&quot;);
  case Cpu0::ATOMIC_LOAD_ADD_I8:
    return emitAtomicBinaryPartword(MI, BB, 1, Cpu0::ADDu);
  case Cpu0::ATOMIC_LOAD_ADD_I16:
    return emitAtomicBinaryPartword(MI, BB, 2, Cpu0::ADDu);
  case Cpu0::ATOMIC_LOAD_ADD_I32:
    return emitAtomicBinary(MI, BB, 4, Cpu0::ADDu);

  case Cpu0::ATOMIC_LOAD_AND_I8:
    return emitAtomicBinaryPartword(MI, BB, 1, Cpu0::AND);
  case Cpu0::ATOMIC_LOAD_AND_I16:
    return emitAtomicBinaryPartword(MI, BB, 2, Cpu0::AND);
  case Cpu0::ATOMIC_LOAD_AND_I32:
    return emitAtomicBinary(MI, BB, 4, Cpu0::AND);

  case Cpu0::ATOMIC_LOAD_OR_I8:
    return emitAtomicBinaryPartword(MI, BB, 1, Cpu0::OR);
  case Cpu0::ATOMIC_LOAD_OR_I16:
    return emitAtomicBinaryPartword(MI, BB, 2, Cpu0::OR);
  case Cpu0::ATOMIC_LOAD_OR_I32:
    return emitAtomicBinary(MI, BB, 4, Cpu0::OR);

  case Cpu0::ATOMIC_LOAD_XOR_I8:
    return emitAtomicBinaryPartword(MI, BB, 1, Cpu0::XOR);
  case Cpu0::ATOMIC_LOAD_XOR_I16:
    return emitAtomicBinaryPartword(MI, BB, 2, Cpu0::XOR);
  case Cpu0::ATOMIC_LOAD_XOR_I32:
    return emitAtomicBinary(MI, BB, 4, Cpu0::XOR);

  case Cpu0::ATOMIC_LOAD_NAND_I8:
    return emitAtomicBinaryPartword(MI, BB, 1, 0, true);
  case Cpu0::ATOMIC_LOAD_NAND_I16:
    return emitAtomicBinaryPartword(MI, BB, 2, 0, true);
  case Cpu0::ATOMIC_LOAD_NAND_I32:
    return emitAtomicBinary(MI, BB, 4, 0, true);

  case Cpu0::ATOMIC_LOAD_SUB_I8:
    return emitAtomicBinaryPartword(MI, BB, 1, Cpu0::SUBu);
  case Cpu0::ATOMIC_LOAD_SUB_I16:
    return emitAtomicBinaryPartword(MI, BB, 2, Cpu0::SUBu);
  case Cpu0::ATOMIC_LOAD_SUB_I32:
    return emitAtomicBinary(MI, BB, 4, Cpu0::SUBu);

  case Cpu0::ATOMIC_SWAP_I8:
    return emitAtomicBinaryPartword(MI, BB, 1, 0);
  case Cpu0::ATOMIC_SWAP_I16:
    return emitAtomicBinaryPartword(MI, BB, 2, 0);
  case Cpu0::ATOMIC_SWAP_I32:
    return emitAtomicBinary(MI, BB, 4, 0);

  case Cpu0::ATOMIC_CMP_SWAP_I8:
    return emitAtomicCmpSwapPartword(MI, BB, 1);
  case Cpu0::ATOMIC_CMP_SWAP_I16:
    return emitAtomicCmpSwapPartword(MI, BB, 2);
  case Cpu0::ATOMIC_CMP_SWAP_I32:
    return emitAtomicCmpSwap(MI, BB, 4);
  }
}

// This function also handles Cpu0::ATOMIC_SWAP_I32 (when BinOpcode == 0), and
// Cpu0::ATOMIC_LOAD_NAND_I32 (when Nand == true)
MachineBasicBlock *Cpu0TargetLowering::emitAtomicBinary(
    MachineInstr &amp;MI, MachineBasicBlock *BB, unsigned Size, unsigned BinOpcode,
    bool Nand) const {
  assert((Size == 4) &amp;&amp; &quot;Unsupported size for EmitAtomicBinary.&quot;);

  MachineFunction *MF = BB-&gt;getParent();
  MachineRegisterInfo &amp;RegInfo = MF-&gt;getRegInfo();
  const TargetRegisterClass *RC = getRegClassFor(MVT::getIntegerVT(Size * 8));
  const TargetInstrInfo *TII = Subtarget.getInstrInfo();
  DebugLoc DL = MI.getDebugLoc();
  unsigned LL, SC, AND, XOR, ZERO, BEQ;

  LL = Cpu0::LL;
  SC = Cpu0::SC;
  AND = Cpu0::AND;
  XOR = Cpu0::XOR;
  ZERO = Cpu0::ZERO;
  BEQ = Cpu0::BEQ;

  unsigned OldVal = MI.getOperand(0).getReg();
  unsigned Ptr = MI.getOperand(1).getReg();
  unsigned Incr = MI.getOperand(2).getReg();

  unsigned StoreVal = RegInfo.createVirtualRegister(RC);
  unsigned AndRes = RegInfo.createVirtualRegister(RC);
  unsigned AndRes2 = RegInfo.createVirtualRegister(RC);
  unsigned Success = RegInfo.createVirtualRegister(RC);

  // insert new blocks after the current block
  const BasicBlock *LLVM_BB = BB-&gt;getBasicBlock();
  MachineBasicBlock *loopMBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineBasicBlock *exitMBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineFunction::iterator It = ++BB-&gt;getIterator();
  MF-&gt;insert(It, loopMBB);
  MF-&gt;insert(It, exitMBB);

  // Transfer the remainder of BB and its successor edges to exitMBB.
  exitMBB-&gt;splice(exitMBB-&gt;begin(), BB,
                  std::next(MachineBasicBlock::iterator(MI)), BB-&gt;end());
  exitMBB-&gt;transferSuccessorsAndUpdatePHIs(BB);

  //  thisMBB:
  //    ...
  //    fallthrough --&gt; loopMBB
  BB-&gt;addSuccessor(loopMBB);
  loopMBB-&gt;addSuccessor(loopMBB);
  loopMBB-&gt;addSuccessor(exitMBB);

  //  loopMBB:
  //    ll oldval, 0(ptr)
  //    &lt;binop&gt; storeval, oldval, incr
  //    sc success, storeval, 0(ptr)
  //    beq success, $0, loopMBB
  BB = loopMBB;
  BuildMI(BB, DL, TII-&gt;get(LL), OldVal).addReg(Ptr).addImm(0);
  if (Nand) {
    //  and andres, oldval, incr
    //  xor storeval, $0, andres
    //  xor storeval2, $0, storeval
    BuildMI(BB, DL, TII-&gt;get(AND), AndRes).addReg(OldVal).addReg(Incr);
    BuildMI(BB, DL, TII-&gt;get(XOR), StoreVal).addReg(ZERO).addReg(AndRes);
    BuildMI(BB, DL, TII-&gt;get(XOR), AndRes2).addReg(ZERO).addReg(AndRes);
  } else if (BinOpcode) {
    //  &lt;binop&gt; storeval, oldval, incr
    BuildMI(BB, DL, TII-&gt;get(BinOpcode), StoreVal).addReg(OldVal).addReg(Incr);
  } else {
    StoreVal = Incr;
  }
  BuildMI(BB, DL, TII-&gt;get(SC), Success).addReg(StoreVal).addReg(Ptr).addImm(0);
  BuildMI(BB, DL, TII-&gt;get(BEQ)).addReg(Success).addReg(ZERO).addMBB(loopMBB);

  MI.eraseFromParent(); // The instruction is gone now.

  return exitMBB;
}

MachineBasicBlock *Cpu0TargetLowering::emitSignExtendToI32InReg(
    MachineInstr &amp;MI, MachineBasicBlock *BB, unsigned Size, unsigned DstReg,
    unsigned SrcReg) const {
  const TargetInstrInfo *TII = Subtarget.getInstrInfo();
  DebugLoc DL = MI.getDebugLoc();

  MachineFunction *MF = BB-&gt;getParent();
  MachineRegisterInfo &amp;RegInfo = MF-&gt;getRegInfo();
  const TargetRegisterClass *RC = getRegClassFor(MVT::i32);
  unsigned ScrReg = RegInfo.createVirtualRegister(RC);

  assert(Size &lt; 32);
  int64_t ShiftImm = 32 - (Size * 8);

  BuildMI(BB, DL, TII-&gt;get(Cpu0::SHL), ScrReg).addReg(SrcReg).addImm(ShiftImm);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::SRA), DstReg).addReg(ScrReg).addImm(ShiftImm);

  return BB;
}

MachineBasicBlock *Cpu0TargetLowering::emitAtomicBinaryPartword(
    MachineInstr &amp;MI, MachineBasicBlock *BB, unsigned Size, unsigned BinOpcode,
    bool Nand) const {
  assert((Size == 1 || Size == 2) &amp;&amp;
         &quot;Unsupported size for EmitAtomicBinaryPartial.&quot;);

  MachineFunction *MF = BB-&gt;getParent();
  MachineRegisterInfo &amp;RegInfo = MF-&gt;getRegInfo();
  const TargetRegisterClass *RC = getRegClassFor(MVT::i32);
  const TargetInstrInfo *TII = Subtarget.getInstrInfo();
  DebugLoc DL = MI.getDebugLoc();

  unsigned Dest = MI.getOperand(0).getReg();
  unsigned Ptr = MI.getOperand(1).getReg();
  unsigned Incr = MI.getOperand(2).getReg();

  unsigned AlignedAddr = RegInfo.createVirtualRegister(RC);
  unsigned ShiftAmt = RegInfo.createVirtualRegister(RC);
  unsigned Mask = RegInfo.createVirtualRegister(RC);
  unsigned Mask2 = RegInfo.createVirtualRegister(RC);
  unsigned Mask3 = RegInfo.createVirtualRegister(RC);
  unsigned NewVal = RegInfo.createVirtualRegister(RC);
  unsigned OldVal = RegInfo.createVirtualRegister(RC);
  unsigned Incr2 = RegInfo.createVirtualRegister(RC);
  unsigned MaskLSB2 = RegInfo.createVirtualRegister(RC);
  unsigned PtrLSB2 = RegInfo.createVirtualRegister(RC);
  unsigned MaskUpper = RegInfo.createVirtualRegister(RC);
  unsigned AndRes = RegInfo.createVirtualRegister(RC);
  unsigned BinOpRes = RegInfo.createVirtualRegister(RC);
  unsigned BinOpRes2 = RegInfo.createVirtualRegister(RC);
  unsigned MaskedOldVal0 = RegInfo.createVirtualRegister(RC);
  unsigned StoreVal = RegInfo.createVirtualRegister(RC);
  unsigned MaskedOldVal1 = RegInfo.createVirtualRegister(RC);
  unsigned SrlRes = RegInfo.createVirtualRegister(RC);
  unsigned Success = RegInfo.createVirtualRegister(RC);

  // insert new blocks after the current block
  const BasicBlock *LLVM_BB = BB-&gt;getBasicBlock();
  MachineBasicBlock *loopMBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineBasicBlock *sinkMBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineBasicBlock *exitMBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineFunction::iterator It = ++BB-&gt;getIterator();

  MF-&gt;insert(It, loopMBB);
  MF-&gt;insert(It, sinkMBB);
  MF-&gt;insert(It, exitMBB);

  // Transfer the remainder of BB and its successor edges to exitMBB.
  exitMBB-&gt;splice(exitMBB-&gt;begin(), BB,
                  std::next(MachineBasicBlock::iterator(MI)), BB-&gt;end());
  exitMBB-&gt;transferSuccessorsAndUpdatePHIs(BB);

  BB-&gt;addSuccessor(loopMBB);
  loopMBB-&gt;addSuccessor(loopMBB);
  loopMBB-&gt;addSuccessor(sinkMBB);
  sinkMBB-&gt;addSuccessor(exitMBB);

  //  thisMBB:
  //    addiu   masklsb2,$0,-4                # 0xfffffffc
  //    and     alignedaddr,ptr,masklsb2
  //    andi    ptrlsb2,ptr,3
  //    sll     shiftamt,ptrlsb2,3
  //    ori     maskupper,$0,255               # 0xff
  //    sll     mask,maskupper,shiftamt
  //    xor     mask2,$0,mask
  //    xor     mask3,$0,mask2
  //    sll     incr2,incr,shiftamt

  int64_t MaskImm = (Size == 1) ? 255 : 65535;
  BuildMI(BB, DL, TII-&gt;get(Cpu0::ADDiu), MaskLSB2)
    .addReg(Cpu0::ZERO).addImm(-4);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::AND), AlignedAddr)
    .addReg(Ptr).addReg(MaskLSB2);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::ANDi), PtrLSB2).addReg(Ptr).addImm(3);
  if (Subtarget.isLittle()) {
    BuildMI(BB, DL, TII-&gt;get(Cpu0::SHL), ShiftAmt).addReg(PtrLSB2).addImm(3);
  } else {
    unsigned Off = RegInfo.createVirtualRegister(RC);
    BuildMI(BB, DL, TII-&gt;get(Cpu0::XORi), Off)
      .addReg(PtrLSB2).addImm((Size == 1) ? 3 : 2);
    BuildMI(BB, DL, TII-&gt;get(Cpu0::SHL), ShiftAmt).addReg(Off).addImm(3);
  }
  BuildMI(BB, DL, TII-&gt;get(Cpu0::ORi), MaskUpper)
    .addReg(Cpu0::ZERO).addImm(MaskImm);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::SHLV), Mask)
    .addReg(MaskUpper).addReg(ShiftAmt);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::XOR), Mask2).addReg(Cpu0::ZERO).addReg(Mask);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::XOR), Mask3).addReg(Cpu0::ZERO).addReg(Mask2);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::SHLV), Incr2).addReg(Incr).addReg(ShiftAmt);

  // atomic.load.binop
  // loopMBB:
  //   ll      oldval,0(alignedaddr)
  //   binop   binopres,oldval,incr2
  //   and     newval,binopres,mask
  //   and     maskedoldval0,oldval,mask3
  //   or      storeval,maskedoldval0,newval
  //   sc      success,storeval,0(alignedaddr)
  //   beq     success,$0,loopMBB

  // atomic.swap
  // loopMBB:
  //   ll      oldval,0(alignedaddr)
  //   and     newval,incr2,mask
  //   and     maskedoldval0,oldval,mask3
  //   or      storeval,maskedoldval0,newval
  //   sc      success,storeval,0(alignedaddr)
  //   beq     success,$0,loopMBB

  BB = loopMBB;
  unsigned LL = Cpu0::LL;
  BuildMI(BB, DL, TII-&gt;get(LL), OldVal).addReg(AlignedAddr).addImm(0);
  if (Nand) {
    //  and andres, oldval, incr2
    //  xor binopres,  $0, andres
    //  xor binopres2, $0, binopres
    //  and newval, binopres, mask
    BuildMI(BB, DL, TII-&gt;get(Cpu0::AND), AndRes).addReg(OldVal).addReg(Incr2);
    BuildMI(BB, DL, TII-&gt;get(Cpu0::XOR), BinOpRes)
      .addReg(Cpu0::ZERO).addReg(AndRes);
    BuildMI(BB, DL, TII-&gt;get(Cpu0::XOR), BinOpRes2)
      .addReg(Cpu0::ZERO).addReg(BinOpRes);
    BuildMI(BB, DL, TII-&gt;get(Cpu0::AND), NewVal).addReg(BinOpRes).addReg(Mask);
  } else if (BinOpcode) {
    //  &lt;binop&gt; binopres, oldval, incr2
    //  and newval, binopres, mask
    BuildMI(BB, DL, TII-&gt;get(BinOpcode), BinOpRes).addReg(OldVal).addReg(Incr2);
    BuildMI(BB, DL, TII-&gt;get(Cpu0::AND), NewVal).addReg(BinOpRes).addReg(Mask);
  } else { // atomic.swap
    //  and newval, incr2, mask
    BuildMI(BB, DL, TII-&gt;get(Cpu0::AND), NewVal).addReg(Incr2).addReg(Mask);
  }

  BuildMI(BB, DL, TII-&gt;get(Cpu0::AND), MaskedOldVal0)
    .addReg(OldVal).addReg(Mask2);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::OR), StoreVal)
    .addReg(MaskedOldVal0).addReg(NewVal);
  unsigned SC = Cpu0::SC;
  BuildMI(BB, DL, TII-&gt;get(SC), Success)
    .addReg(StoreVal).addReg(AlignedAddr).addImm(0);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::BEQ))
    .addReg(Success).addReg(Cpu0::ZERO).addMBB(loopMBB);

  //  sinkMBB:
  //    and     maskedoldval1,oldval,mask
  //    srl     srlres,maskedoldval1,shiftamt
  //    sign_extend dest,srlres
  BB = sinkMBB;

  BuildMI(BB, DL, TII-&gt;get(Cpu0::AND), MaskedOldVal1)
    .addReg(OldVal).addReg(Mask);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::SHRV), SrlRes)
      .addReg(MaskedOldVal1).addReg(ShiftAmt);
  BB = emitSignExtendToI32InReg(MI, BB, Size, Dest, SrlRes);

  MI.eraseFromParent(); // The instruction is gone now.

  return exitMBB;
}

MachineBasicBlock * Cpu0TargetLowering::emitAtomicCmpSwap(MachineInstr &amp;MI,
                                                          MachineBasicBlock *BB,
                                                          unsigned Size) const {
  assert((Size == 4) &amp;&amp; &quot;Unsupported size for EmitAtomicCmpSwap.&quot;);

  MachineFunction *MF = BB-&gt;getParent();
  MachineRegisterInfo &amp;RegInfo = MF-&gt;getRegInfo();
  const TargetRegisterClass *RC = getRegClassFor(MVT::getIntegerVT(Size * 8));
  const TargetInstrInfo *TII = Subtarget.getInstrInfo();
  DebugLoc DL = MI.getDebugLoc();
  unsigned LL, SC, ZERO, BNE, BEQ;

  LL = Cpu0::LL;
  SC = Cpu0::SC;
  ZERO = Cpu0::ZERO;
  BNE = Cpu0::BNE;
  BEQ = Cpu0::BEQ;

  unsigned Dest    = MI.getOperand(0).getReg();
  unsigned Ptr     = MI.getOperand(1).getReg();
  unsigned OldVal  = MI.getOperand(2).getReg();
  unsigned NewVal  = MI.getOperand(3).getReg();

  unsigned Success = RegInfo.createVirtualRegister(RC);

  // insert new blocks after the current block
  const BasicBlock *LLVM_BB = BB-&gt;getBasicBlock();
  MachineBasicBlock *loop1MBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineBasicBlock *loop2MBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineBasicBlock *exitMBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineFunction::iterator It = ++BB-&gt;getIterator();

  MF-&gt;insert(It, loop1MBB);
  MF-&gt;insert(It, loop2MBB);
  MF-&gt;insert(It, exitMBB);

  // Transfer the remainder of BB and its successor edges to exitMBB.
  exitMBB-&gt;splice(exitMBB-&gt;begin(), BB,
                  std::next(MachineBasicBlock::iterator(MI)), BB-&gt;end());
  exitMBB-&gt;transferSuccessorsAndUpdatePHIs(BB);

  //  thisMBB:
  //    ...
  //    fallthrough --&gt; loop1MBB
  BB-&gt;addSuccessor(loop1MBB);
  loop1MBB-&gt;addSuccessor(exitMBB);
  loop1MBB-&gt;addSuccessor(loop2MBB);
  loop2MBB-&gt;addSuccessor(loop1MBB);
  loop2MBB-&gt;addSuccessor(exitMBB);

  // loop1MBB:
  //   ll dest, 0(ptr)
  //   bne dest, oldval, exitMBB
  BB = loop1MBB;
  BuildMI(BB, DL, TII-&gt;get(LL), Dest).addReg(Ptr).addImm(0);
  BuildMI(BB, DL, TII-&gt;get(BNE))
    .addReg(Dest).addReg(OldVal).addMBB(exitMBB);

  // loop2MBB:
  //   sc success, newval, 0(ptr)
  //   beq success, $0, loop1MBB
  BB = loop2MBB;
  BuildMI(BB, DL, TII-&gt;get(SC), Success)
    .addReg(NewVal).addReg(Ptr).addImm(0);
  BuildMI(BB, DL, TII-&gt;get(BEQ))
    .addReg(Success).addReg(ZERO).addMBB(loop1MBB);

  MI.eraseFromParent(); // The instruction is gone now.

  return exitMBB;
}

MachineBasicBlock *
Cpu0TargetLowering::emitAtomicCmpSwapPartword(MachineInstr &amp;MI,
                                              MachineBasicBlock *BB,
                                              unsigned Size) const {
  assert((Size == 1 || Size == 2) &amp;&amp;
      &quot;Unsupported size for EmitAtomicCmpSwapPartial.&quot;);

  MachineFunction *MF = BB-&gt;getParent();
  MachineRegisterInfo &amp;RegInfo = MF-&gt;getRegInfo();
  const TargetRegisterClass *RC = getRegClassFor(MVT::i32);
  const TargetInstrInfo *TII = Subtarget.getInstrInfo();
  DebugLoc DL = MI.getDebugLoc();

  unsigned Dest    = MI.getOperand(0).getReg();
  unsigned Ptr     = MI.getOperand(1).getReg();
  unsigned CmpVal  = MI.getOperand(2).getReg();
  unsigned NewVal  = MI.getOperand(3).getReg();

  unsigned AlignedAddr = RegInfo.createVirtualRegister(RC);
  unsigned ShiftAmt = RegInfo.createVirtualRegister(RC);
  unsigned Mask = RegInfo.createVirtualRegister(RC);
  unsigned Mask2 = RegInfo.createVirtualRegister(RC);
  unsigned Mask3 = RegInfo.createVirtualRegister(RC);
  unsigned ShiftedCmpVal = RegInfo.createVirtualRegister(RC);
  unsigned OldVal = RegInfo.createVirtualRegister(RC);
  unsigned MaskedOldVal0 = RegInfo.createVirtualRegister(RC);
  unsigned ShiftedNewVal = RegInfo.createVirtualRegister(RC);
  unsigned MaskLSB2 = RegInfo.createVirtualRegister(RC);
  unsigned PtrLSB2 = RegInfo.createVirtualRegister(RC);
  unsigned MaskUpper = RegInfo.createVirtualRegister(RC);
  unsigned MaskedCmpVal = RegInfo.createVirtualRegister(RC);
  unsigned MaskedNewVal = RegInfo.createVirtualRegister(RC);
  unsigned MaskedOldVal1 = RegInfo.createVirtualRegister(RC);
  unsigned StoreVal = RegInfo.createVirtualRegister(RC);
  unsigned SrlRes = RegInfo.createVirtualRegister(RC);
  unsigned Success = RegInfo.createVirtualRegister(RC);

  // insert new blocks after the current block
  const BasicBlock *LLVM_BB = BB-&gt;getBasicBlock();
  MachineBasicBlock *loop1MBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineBasicBlock *loop2MBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineBasicBlock *sinkMBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineBasicBlock *exitMBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineFunction::iterator It = ++BB-&gt;getIterator();

  MF-&gt;insert(It, loop1MBB);
  MF-&gt;insert(It, loop2MBB);
  MF-&gt;insert(It, sinkMBB);
  MF-&gt;insert(It, exitMBB);

  // Transfer the remainder of BB and its successor edges to exitMBB.
  exitMBB-&gt;splice(exitMBB-&gt;begin(), BB,
                  std::next(MachineBasicBlock::iterator(MI)), BB-&gt;end());
  exitMBB-&gt;transferSuccessorsAndUpdatePHIs(BB);

  BB-&gt;addSuccessor(loop1MBB);
  loop1MBB-&gt;addSuccessor(sinkMBB);
  loop1MBB-&gt;addSuccessor(loop2MBB);
  loop2MBB-&gt;addSuccessor(loop1MBB);
  loop2MBB-&gt;addSuccessor(sinkMBB);
  sinkMBB-&gt;addSuccessor(exitMBB);

  // FIXME: computation of newval2 can be moved to loop2MBB.
  //  thisMBB:
  //    addiu   masklsb2,$0,-4                # 0xfffffffc
  //    and     alignedaddr,ptr,masklsb2
  //    andi    ptrlsb2,ptr,3
  //    shl     shiftamt,ptrlsb2,3
  //    ori     maskupper,$0,255               # 0xff
  //    shl     mask,maskupper,shiftamt
  //    xor     mask2,$0,mask
  //    xor     mask3,$0,mask2
  //    andi    maskedcmpval,cmpval,255
  //    shl     shiftedcmpval,maskedcmpval,shiftamt
  //    andi    maskednewval,newval,255
  //    shl     shiftednewval,maskednewval,shiftamt
  int64_t MaskImm = (Size == 1) ? 255 : 65535;
  BuildMI(BB, DL, TII-&gt;get(Cpu0::ADDiu), MaskLSB2)
    .addReg(Cpu0::ZERO).addImm(-4);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::AND), AlignedAddr)
    .addReg(Ptr).addReg(MaskLSB2);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::ANDi), PtrLSB2).addReg(Ptr).addImm(3);
  if (Subtarget.isLittle()) {
    BuildMI(BB, DL, TII-&gt;get(Cpu0::SHL), ShiftAmt).addReg(PtrLSB2).addImm(3);
  } else {
    unsigned Off = RegInfo.createVirtualRegister(RC);
    BuildMI(BB, DL, TII-&gt;get(Cpu0::XORi), Off)
      .addReg(PtrLSB2).addImm((Size == 1) ? 3 : 2);
    BuildMI(BB, DL, TII-&gt;get(Cpu0::SHL), ShiftAmt).addReg(Off).addImm(3);
  }
  BuildMI(BB, DL, TII-&gt;get(Cpu0::ORi), MaskUpper)
    .addReg(Cpu0::ZERO).addImm(MaskImm);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::SHLV), Mask)
    .addReg(MaskUpper).addReg(ShiftAmt);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::XOR), Mask2).addReg(Cpu0::ZERO).addReg(Mask);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::XOR), Mask3).addReg(Cpu0::ZERO).addReg(Mask2);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::ANDi), MaskedCmpVal)
    .addReg(CmpVal).addImm(MaskImm);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::SHLV), ShiftedCmpVal)
    .addReg(MaskedCmpVal).addReg(ShiftAmt);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::ANDi), MaskedNewVal)
    .addReg(NewVal).addImm(MaskImm);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::SHLV), ShiftedNewVal)
    .addReg(MaskedNewVal).addReg(ShiftAmt);

  //  loop1MBB:
  //    ll      oldval,0(alginedaddr)
  //    and     maskedoldval0,oldval,mask
  //    bne     maskedoldval0,shiftedcmpval,sinkMBB
  BB = loop1MBB;
  unsigned LL = Cpu0::LL;
  BuildMI(BB, DL, TII-&gt;get(LL), OldVal).addReg(AlignedAddr).addImm(0);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::AND), MaskedOldVal0)
    .addReg(OldVal).addReg(Mask);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::BNE))
    .addReg(MaskedOldVal0).addReg(ShiftedCmpVal).addMBB(sinkMBB);

  //  loop2MBB:
  //    and     maskedoldval1,oldval,mask3
  //    or      storeval,maskedoldval1,shiftednewval
  //    sc      success,storeval,0(alignedaddr)
  //    beq     success,$0,loop1MBB
  BB = loop2MBB;
  BuildMI(BB, DL, TII-&gt;get(Cpu0::AND), MaskedOldVal1)
    .addReg(OldVal).addReg(Mask3);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::OR), StoreVal)
    .addReg(MaskedOldVal1).addReg(ShiftedNewVal);
  unsigned SC = Cpu0::SC;
  BuildMI(BB, DL, TII-&gt;get(SC), Success)
      .addReg(StoreVal).addReg(AlignedAddr).addImm(0);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::BEQ))
      .addReg(Success).addReg(Cpu0::ZERO).addMBB(loop1MBB);

  //  sinkMBB:
  //    srl     srlres,maskedoldval0,shiftamt
  //    sign_extend dest,srlres
  BB = sinkMBB;

  BuildMI(BB, DL, TII-&gt;get(Cpu0::SHRV), SrlRes)
      .addReg(MaskedOldVal0).addReg(ShiftAmt);
  BB = emitSignExtendToI32InReg(MI, BB, Size, Dest, SrlRes);

  MI.eraseFromParent();   // The instruction is gone now.

  return exitMBB;
}
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">lowerATOMIC_FENCE</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span>
                                              <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="o">//</span> <span class="n">FIXME</span><span class="p">:</span> <span class="n">Need</span> <span class="n">pseudo</span><span class="o">-</span><span class="n">fence</span> <span class="k">for</span> <span class="s1">&#39;singlethread&#39;</span> <span class="n">fences</span>
  <span class="o">//</span> <span class="n">FIXME</span><span class="p">:</span> <span class="n">Set</span> <span class="n">SType</span> <span class="k">for</span> <span class="n">weaker</span> <span class="n">fences</span> <span class="n">where</span> <span class="n">supported</span><span class="o">/</span><span class="n">appropriate</span><span class="o">.</span>
  <span class="n">unsigned</span> <span class="n">SType</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">(</span><span class="n">Op</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">Cpu0ISD</span><span class="p">::</span><span class="n">Sync</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">MVT</span><span class="p">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Op</span><span class="o">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                     <span class="n">DAG</span><span class="o">.</span><span class="n">getConstant</span><span class="p">(</span><span class="n">SType</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">MVT</span><span class="p">::</span><span class="n">i32</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0RegisterInfo.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="o">///</span> <span class="n">Code</span> <span class="n">Generation</span> <span class="n">virtual</span> <span class="n">methods</span><span class="o">...</span>
  <span class="n">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span><span class="n">getPointerRegClass</span><span class="p">(</span><span class="n">const</span> <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                                <span class="n">unsigned</span> <span class="n">Kind</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0RegisterInfo.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span>
<span class="n">Cpu0RegisterInfo</span><span class="p">::</span><span class="n">getPointerRegClass</span><span class="p">(</span><span class="n">const</span> <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                     <span class="n">unsigned</span> <span class="n">Kind</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="n">Cpu0</span><span class="p">::</span><span class="n">CPURegsRegClass</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0SEISelLowering.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Cpu0SETargetLowering</span><span class="p">::</span><span class="n">Cpu0SETargetLowering</span><span class="p">(</span><span class="n">const</span> <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">,</span>
                                           <span class="n">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span>
    <span class="p">:</span> <span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="n">TM</span><span class="p">,</span> <span class="n">STI</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">ATOMIC_FENCE</span><span class="p">,</span>       <span class="n">MVT</span><span class="p">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Custom</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0TargetMachine.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">///</span> <span class="n">Cpu0</span> <span class="n">Code</span> <span class="n">Generator</span> <span class="n">Pass</span> <span class="n">Configuration</span> <span class="n">Options</span><span class="o">.</span>
<span class="k">class</span> <span class="nc">Cpu0PassConfig</span> <span class="p">:</span> <span class="n">public</span> <span class="n">TargetPassConfig</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">void</span> <span class="n">addIRPasses</span><span class="p">()</span> <span class="n">override</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">Cpu0PassConfig</span><span class="p">::</span><span class="n">addIRPasses</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">TargetPassConfig</span><span class="p">::</span><span class="n">addIRPasses</span><span class="p">();</span>
  <span class="n">addPass</span><span class="p">(</span><span class="n">createAtomicExpandPass</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Since SC instruction uses RegisterOperand type in Cpu0InstrInfo.td and SC uses
FMem node which DecoderMethod is “DecodeMem”, the DecodeMem() of
Cpu0Disassembler.cpp need to be changed as above.</p>
<p>The atomic node defined in “let usesCustomInserter = 1 in” of Cpu0InstrInfo.td
tells llvm calling EmitInstrWithCustomInserter() of Cpu0ISelLowering.cpp after
Instruction Selection stage at Cpu0TargetLowering::EmitInstrWithCustomInserter()
of ExpandISelPseudos::runOnMachineFunction() stage. For
example, “def ATOMIC_LOAD_ADD_I8 : Atomic2Ops&lt;atomic_load_add_8, CPURegs&gt;;” will
calling EmitInstrWithCustomInserter() with Machine Instruction Opcode
“ATOMIC_LOAD_ADD_I8” when it meets IR “load atomic i8*”.</p>
<p>The “setInsertFencesForAtomic(true);” in Cpu0ISelLowering.cpp will trigger
addIRPasses() of Cpu0TargetMachine.cpp, then the createAtomicExpandPass() of
addIRPasses() will create llvm IR ATOMIC_FENCE. Next, the lowerATOMIC_FENCE()
of Cpu0ISelLowering.cpp will create Cpu0ISD::Sync when it meets IR ATOMIC_FENCE
since “setOperationAction(ISD::ATOMIC_FENCE, MVT::Other, Custom);” of
Cpu0SEISelLowering.cpp. Finally the pattern defined in Cpu0InstrInfo.td translate
it into instruction “sync” by “def SYNC” and alias “SYNC 0”.</p>
<p>This part of Cpu0 backend code is same with Mips except Cpu0 has no instruction
“nor”.</p>
<p>List the atomic IRs, corresponding DAGs and Opcode as the following table.</p>
<table class="docutils align-default" id="id24">
<caption><span class="caption-number">Table 40 </span><span class="caption-text">The atomic related IRs, their corresponding DAGs and Opcode of Cpu0ISelLowering.cpp</span><a class="headerlink" href="#id24" title="Permalink to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>IR</p></th>
<th class="head"><p>DAG</p></th>
<th class="head"><p>Opcode</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>load atomic</p></td>
<td><p>AtomicLoad</p></td>
<td><p>ATOMIC_CMP_SWAP_XXX</p></td>
</tr>
<tr class="row-odd"><td><p>store atomic</p></td>
<td><p>AtomicStore</p></td>
<td><p>ATOMIC_SWAP_XXX</p></td>
</tr>
<tr class="row-even"><td><p>atomicrmw add</p></td>
<td><p>AtomicLoadAdd</p></td>
<td><p>ATOMIC_LOAD_ADD_XXX</p></td>
</tr>
<tr class="row-odd"><td><p>atomicrmw sub</p></td>
<td><p>AtomicLoadSub</p></td>
<td><p>ATOMIC_LOAD_SUB_XXX</p></td>
</tr>
<tr class="row-even"><td><p>atomicrmw xor</p></td>
<td><p>AtomicLoadXor</p></td>
<td><p>ATOMIC_LOAD_XOR_XXX</p></td>
</tr>
<tr class="row-odd"><td><p>atomicrmw and</p></td>
<td><p>AtomicLoadAnd</p></td>
<td><p>ATOMIC_LOAD_AND_XXX</p></td>
</tr>
<tr class="row-even"><td><p>atomicrmw nand</p></td>
<td><p>AtomicLoadNand</p></td>
<td><p>ATOMIC_LOAD_NAND_XXX</p></td>
</tr>
<tr class="row-odd"><td><p>atomicrmw or</p></td>
<td><p>AtomicLoadOr</p></td>
<td><p>ATOMIC_LOAD_OR_XXX</p></td>
</tr>
<tr class="row-even"><td><p>cmpxchg</p></td>
<td><p>AtomicCmpSwapWithSuccess</p></td>
<td><p>ATOMIC_CMP_SWAP_XXX</p></td>
</tr>
<tr class="row-odd"><td><p>atomicrmw xchg</p></td>
<td><p>AtomicLoadSwap</p></td>
<td><p>ATOMIC_SWAP_XXX</p></td>
</tr>
</tbody>
</table>
<p>Input files atomics.ll and atomics-fences.ll include the llvm atomic IRs test.
Input files ch12_atomics.cpp and ch12_atomics-fences.cpp are the C++
files for generating llvm atomic IRs. The C++ files need to run with clang
options “clang++ -pthread -std=c++11”.</p>
<aside class="footnote brackets" id="exception" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">1</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://llvm.org/docs/ExceptionHandling.html">http://llvm.org/docs/ExceptionHandling.html</a></p>
</aside>
<aside class="footnote brackets" id="itanium-exception" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">2</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://itanium-cxx-abi.github.io/cxx-abi/exceptions.pdf">http://itanium-cxx-abi.github.io/cxx-abi/exceptions.pdf</a></p>
</aside>
<aside class="footnote brackets" id="thread-wiki" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">3</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://en.wikipedia.org/wiki/Thread-local_storage">http://en.wikipedia.org/wiki/Thread-local_storage</a></p>
</aside>
<aside class="footnote brackets" id="cpp-atomic" role="note">
<span class="label"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://cplusplus.com/reference/atomic/">https://cplusplus.com/reference/atomic/</a></p>
</aside>
<aside class="footnote brackets" id="atomic-wiki" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">5</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Memory_model_%28programming%29">https://en.wikipedia.org/wiki/Memory_model_%28programming%29</a></p>
</aside>
<aside class="footnote brackets" id="atomic-stackoverflow" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">6</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://stackoverflow.com/questions/6319146/c11-introduced-a-standardized-memory-model-what-does-it-mean-and-how-is-it-g">http://stackoverflow.com/questions/6319146/c11-introduced-a-standardized-memory-model-what-does-it-mean-and-how-is-it-g</a></p>
</aside>
<aside class="footnote brackets" id="atomic-herbsutter" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">7</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://herbsutter.com/2013/02/11/atomic-weapons-the-c-memory-model-and-modern-hardware/">http://herbsutter.com/2013/02/11/atomic-weapons-the-c-memory-model-and-modern-hardware/</a></p>
</aside>
<aside class="footnote brackets" id="lf-wiki" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id8">8</a><span class="fn-bracket">]</span></span>
<p>An algorithm is wait-free if every operation has a bound on the
number of steps the algorithm will take before the operation completes. In
other words, wait-free algorithm has no starvation. Lock-freedom allows
individual threads to starve but guarantees system-wide throughput. An
algorithm is lock-free if, when the program threads are run for a
sufficiently long time, at least one of the threads makes progress (for
some sensible definition of progress). All wait-free algorithms are lock-free.
In particular, if one thread is suspended, then a lock-free algorithm guarantees
that the remaining threads can still make progress. Hence, if two threads can
contend for the same mutex lock or spinlock, then the algorithm is not lock-free.
(If we suspend one thread that holds the lock, then the second thread will block.)
<a class="reference external" href="https://en.wikipedia.org/wiki/Non-blocking_algorithm">https://en.wikipedia.org/wiki/Non-blocking_algorithm</a></p>
</aside>
<aside class="footnote brackets" id="cas-wiki" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">9</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Compare-and-swap">https://en.wikipedia.org/wiki/Compare-and-swap</a></p>
</aside>
<aside class="footnote brackets" id="ll-wiki" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id9">10</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Load-link/store-conditional">https://en.wikipedia.org/wiki/Load-link/store-conditional</a></p>
</aside>
<aside class="footnote brackets" id="mb-wiki" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id10">11</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Memory_barrier">https://en.wikipedia.org/wiki/Memory_barrier</a></p>
</aside>
<aside class="footnote brackets" id="mips-sync" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id11">12</a><span class="fn-bracket">]</span></span>
<p>From page A-158, it is same with ARM’s barrier that all instructions before SYNC are completed before issuing the instructions after SYNC. Page 167 (A-155) of <a class="reference external" href="https://www.cs.cmu.edu/afs/cs/academic/class/15740-f97/public/doc/mips-isa.pdf">https://www.cs.cmu.edu/afs/cs/academic/class/15740-f97/public/doc/mips-isa.pdf</a></p>
</aside>
<aside class="footnote brackets" id="atomics-llvm" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id12">13</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://llvm.org/docs/Atomics.html">http://llvm.org/docs/Atomics.html</a></p>
</aside>
<aside class="footnote brackets" id="llvmlang-ordering" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id13">14</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://llvm.org/docs/LangRef.html#ordering">http://llvm.org/docs/LangRef.html#ordering</a></p>
</aside>
<aside class="footnote brackets" id="cpp-mem-order" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id14">15</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.cppreference.com/w/cpp/atomic/memory_order">https://en.cppreference.com/w/cpp/atomic/memory_order</a></p>
</aside>
<aside class="footnote brackets" id="dpcpp-memorder" role="note">
<span class="label"><span class="fn-bracket">[</span>16<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id15">1</a>,<a role="doc-backlink" href="#id16">2</a>)</span>
<p>Section “The memory_order Enumeration Class” which include figure 19-10 of book <a class="reference external" href="https://link.springer.com/book/10.1007/978-1-4842-5574-2">https://link.springer.com/book/10.1007/978-1-4842-5574-2</a></p>
</aside>
<aside class="footnote brackets" id="cpp-memorder-consume-as-acquire" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id17">17</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://stackoverflow.com/questions/65336409/what-does-memory-order-consume-really-do">https://stackoverflow.com/questions/65336409/what-does-memory-order-consume-really-do</a></p>
</aside>
<aside class="footnote brackets" id="cpp-memorder-consume-remove" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id18">18</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0371r1.html">https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0371r1.html</a></p>
</aside>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="asm.html">Assembler</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="verilog.html">Verify backend on Verilog simulator</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Chen Chung-Shu.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.0.2.
    </div>
  </body>
</html>