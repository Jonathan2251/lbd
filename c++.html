<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>C++ support &#8212; Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css?v=fce32b03" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css?v=4ae1632d" />
    <script src="_static/documentation_options.js?v=70bd5238"></script>
    <script src="_static/doctools.js?v=fd6eb6e6"></script>
    <script src="_static/sphinx_highlight.js?v=6ffebe34"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Verify backend on Verilog simulator" href="verilog.html" />
    <link rel="prev" title="Assembler" href="asm.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</span></a></h1>
        <h2 class="heading"><span>C++ support</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="Top">
      
        <p>
        «&#160;&#160;<a href="asm.html">Assembler</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="verilog.html">Verify backend on Verilog simulator</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="c-support">
<span id="sec-c"></span><h1>C++ support<a class="headerlink" href="#c-support" title="Link to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#exception-handling" id="id24">Exception Handling</a></p></li>
<li><p><a class="reference internal" href="#thread-variable" id="id25">Thread variable</a></p></li>
<li><p><a class="reference internal" href="#c-memory-order" id="id26">C++ Memory Order   </a></p>
<ul>
<li><p><a class="reference internal" href="#source-code-compatibility" id="id27">Source Code Compatibility</a></p></li>
<li><p><a class="reference internal" href="#the-problem-before-c-11" id="id28">The Problem Before C++11</a></p></li>
<li><p><a class="reference internal" href="#c-11-memory-model-solution" id="id29">C++11 Memory Model Solution</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#cpu0-implementation-for-memory-order" id="id30">Cpu0 implementation for memory-order</a></p></li>
</ul>
</nav>
<p>This chapter supports some C++ compiler features.</p>
<section id="exception-handling">
<h2><a class="toc-backref" href="#id24" role="doc-backlink">Exception Handling</a><a class="headerlink" href="#exception-handling" title="Link to this heading">¶</a></h2>
<p>Chapter11_2 can be built and run using the C++ polymorphism example code in
<code class="docutils literal notranslate"><span class="pre">ch12_inherit.cpp</span></code> as follows:</p>
<p class="rubric">lbdex/input/ch12_inherit.cpp</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="k">class</span><span class="w"> </span><span class="nc">CPolygon</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// _ZTVN10__cxxabiv117__class_type_infoE for parent class</span>
<span class="w">  </span><span class="p">...</span>
<span class="cp">#ifdef COUT_TEST</span>
<span class="w"> </span><span class="c1">// generate IR nvoke, landing, resume and unreachable on iMac</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">area</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="cp">#else</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">area</span><span class="p">());</span><span class="w"> </span><span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">};</span>
<span class="p">...</span>
</pre></div>
</div>
<p>If you use <code class="docutils literal notranslate"><span class="pre">cout</span></code> instead of <code class="docutils literal notranslate"><span class="pre">printf</span></code> in <code class="docutils literal notranslate"><span class="pre">ch12_inherit.cpp</span></code>, it will not
generate exception handling IR on Linux. However, it will generate exception
handling IRs such as <code class="docutils literal notranslate"><span class="pre">invoke</span></code>, <code class="docutils literal notranslate"><span class="pre">landingpad</span></code>, <code class="docutils literal notranslate"><span class="pre">resume</span></code>, and
<code class="docutils literal notranslate"><span class="pre">unreachable</span></code> on iMac.</p>
<p>The example code <code class="docutils literal notranslate"><span class="pre">ch12_eh.cpp</span></code>, which includes <strong>try</strong> and <strong>catch</strong>
exception handling, will generate these exception-related IRs on both iMac
and Linux.</p>
<p class="rubric">lbdex/input/ch12_eh.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Ex1</span> <span class="p">{};</span>
<span class="n">void</span> <span class="n">throw_exception</span><span class="p">(</span><span class="nb">int</span> <span class="n">a</span><span class="p">,</span> <span class="nb">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Ex1</span> <span class="n">ex1</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">throw</span> <span class="n">ex1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">test_try_catch</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="n">throw_exception</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">catch</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>clang<span class="w"> </span>-c<span class="w"> </span>ch12_eh.cpp<span class="w"> </span>-emit-llvm
<span class="go">-o ch12_eh.bc</span>
<span class="gp">JonathantekiiMac:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llvm-dis ch12_eh.bc -o -</span>
</pre></div>
</div>
<p class="rubric">../lbdex/output/ch12_eh.ll</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="k">define</span><span class="w"> </span><span class="k">dso_local</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@_Z14test_try_catchv</span><span class="p">()</span><span class="w"> </span><span class="vg">#0</span><span class="w"> </span><span class="k">personality</span><span class="w"> </span><span class="kt">i8</span><span class="p">*</span><span class="w"> </span><span class="k">bitcast</span><span class="w"> </span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="p">(...</span>
<span class="p">)*</span><span class="w"> </span><span class="vg">@__gxx_personality_v0</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="kt">i8</span><span class="p">*)</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">invoke</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@_Z15throw_exceptionii</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="k">signext</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="k">signext</span><span class="w"> </span><span class="m">1</span><span class="p">)</span>
<span class="w">        </span><span class="k">to</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%invoke.cont</span><span class="w"> </span><span class="k">unwind</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%lpad</span>

<span class="nl">invoke.cont:</span><span class="w">                                      </span><span class="c">; preds = %entry</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%try.cont</span>

<span class="nl">lpad:</span><span class="w">                                             </span><span class="c">; preds = %entry</span>
<span class="w">  </span><span class="nv nv-Anonymous">%0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">landingpad</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">i8</span><span class="p">*,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">}</span>
<span class="w">          </span><span class="k">catch</span><span class="w"> </span><span class="kt">i8</span><span class="p">*</span><span class="w"> </span><span class="k">null</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
<span class="p">...</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llc -march=cpu0 -relocation-model=static -filetype=asm ch12_eh.bc -o -</span>
<span class="go">        .section .mdebug.abi32</span>
<span class="go">        .previous</span>
<span class="go">        .file &quot;ch12_eh.bc&quot;</span>
<span class="go">llc: /Users/Jonathan/llvm/test/llvm/lib/CodeGen/LiveVariables.cpp:133: void llvm::</span>
<span class="go">LiveVariables::HandleVirtRegUse(unsigned int, llvm::MachineBasicBlock *, llvm</span>
<span class="go">::MachineInstr *): Assertion `MRI-&gt;getVRegDef(reg) &amp;&amp; &quot;Register use before</span>
<span class="go">def!&quot;&#39; failed.</span>
</pre></div>
</div>
<p>A description of the C++ exception table formats can be found here
<a class="footnote-reference brackets" href="#itanium-exception" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>.</p>
<p>For details about the LLVM IR used in exception handling, please refer to
<a class="footnote-reference brackets" href="#exception" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>.</p>
<p>Chapter12_1 supports the LLVM IRs that correspond to the C++ <strong>try</strong> and
<strong>catch</strong> keywords. It can compile <code class="docutils literal notranslate"><span class="pre">ch12_eh.bc</span></code> as follows:</p>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0ISelLowering.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="o">///</span> <span class="n">If</span> <span class="n">a</span> <span class="n">physical</span> <span class="n">register</span><span class="p">,</span> <span class="n">this</span> <span class="n">returns</span> <span class="n">the</span> <span class="n">register</span> <span class="n">that</span> <span class="n">receives</span> <span class="n">the</span>
    <span class="o">///</span> <span class="n">exception</span> <span class="n">address</span> <span class="n">on</span> <span class="n">entry</span> <span class="n">to</span> <span class="n">an</span> <span class="n">EH</span> <span class="n">pad</span><span class="o">.</span>
    <span class="n">Register</span>
    <span class="n">getExceptionPointerRegister</span><span class="p">(</span><span class="n">const</span> <span class="n">Constant</span> <span class="o">*</span><span class="n">PersonalityFn</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">A0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="o">///</span> <span class="n">If</span> <span class="n">a</span> <span class="n">physical</span> <span class="n">register</span><span class="p">,</span> <span class="n">this</span> <span class="n">returns</span> <span class="n">the</span> <span class="n">register</span> <span class="n">that</span> <span class="n">receives</span> <span class="n">the</span>
    <span class="o">///</span> <span class="n">exception</span> <span class="n">typeid</span> <span class="n">on</span> <span class="n">entry</span> <span class="n">to</span> <span class="n">a</span> <span class="n">landing</span> <span class="n">pad</span><span class="o">.</span>
    <span class="n">Register</span>
    <span class="n">getExceptionSelectorRegister</span><span class="p">(</span><span class="n">const</span> <span class="n">Constant</span> <span class="o">*</span><span class="n">PersonalityFn</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">A1</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llc -march=cpu0 -relocation-model=static -filetype=asm ch12_eh.bc -o -</span>
</pre></div>
</div>
<p class="rubric">../lbdex/output/ch12_eh.cpu0.s</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>  .type  _Z14test_try_catchv,@function
  .ent  _Z14test_try_catchv             # @_Z14test_try_catchv
_Z14test_try_catchv:
  ...
$tmp0:
  addiu  $4, $zero, 2
  addiu  $5, $zero, 1
  jsub  _Z15throw_exceptionii
  nop
$tmp1:
# %bb.1:                                # %invoke.cont
  jmp  $BB1_4
$BB1_2:                                 # %lpad
$tmp2:
  st  $4, 16($fp)
  st  $5, 12($fp)
# %bb.3:                                # %catch
  ld  $4, 16($fp)
  jsub  __cxa_begin_catch
  nop
  addiu  $2, $zero, 1
  st  $2, 20($fp)
  jsub  __cxa_end_catch
  nop
  jmp  $BB1_5
$BB1_4:                                 # %try.cont
  addiu  $2, $zero, 0
  st  $2, 20($fp)
$BB1_5:                                 # %return
  ld  $2, 20($fp)
  ...
</pre></div>
</div>
</section>
<section id="thread-variable">
<h2><a class="toc-backref" href="#id25" role="doc-backlink">Thread variable</a><a class="headerlink" href="#thread-variable" title="Link to this heading">¶</a></h2>
<p>C++ support thread variable as the following file ch12_thread_var.cpp.</p>
<p class="rubric">lbdex/input/ch12_thread_var.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">__thread</span> <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">thread_local</span> <span class="nb">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">//</span> <span class="n">need</span> <span class="n">option</span> <span class="o">-</span><span class="n">std</span><span class="o">=</span><span class="n">c</span><span class="o">++</span><span class="mi">11</span>
<span class="nb">int</span> <span class="n">test_thread_var</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">test_thread_var_2</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

</pre></div>
</div>
<p>While a global variable is a single instance shared by all threads in a process,
a thread-local variable has a separate instance for each thread in the process.
The same thread accesses the same instance of the thread-local variable, while
different threads have their own instances with the same variable name
<a class="footnote-reference brackets" href="#thread-wiki" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>.</p>
<p>To support thread-local variables, symbols such as <strong>tlsgd</strong>, <strong>tlsldm</strong>,
<strong>dtp_hi</strong>, <strong>dtp_lo</strong>, <strong>gottp</strong>, <strong>tp_hi</strong>, and <strong>tp_lo</strong> must be handled in
both <cite>evaluateRelocExpr()</cite> of <cite>Cpu0AsmParser.cpp</cite> and <cite>printImpl()</cite> of
<cite>Cpu0MCExpr.cpp</cite>.</p>
<p>Most of these symbols are used for relocation record handling,
because the actual thread-local storage is created by the OS or language
runtime that supports multi-threaded programming.</p>
<p class="rubric">lbdex/chapters/Chapter12_1/MCTargetDesc/Cpu0AsmBackend.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">MCFixupKindInfo</span> <span class="o">&amp;</span><span class="n">Cpu0AsmBackend</span><span class="p">::</span>
<span class="n">getFixupKindInfo</span><span class="p">(</span><span class="n">MCFixupKind</span> <span class="n">Kind</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="n">unsigned</span> <span class="n">JSUBReloRec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">HasLLD</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">JSUBReloRec</span> <span class="o">=</span> <span class="n">MCFixupKindInfo</span><span class="p">::</span><span class="n">FKF_IsPCRel</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="n">JSUBReloRec</span> <span class="o">=</span> <span class="n">MCFixupKindInfo</span><span class="p">::</span><span class="n">FKF_IsPCRel</span> <span class="o">|</span> <span class="n">MCFixupKindInfo</span><span class="p">::</span><span class="n">FKF_Constant</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">const</span> <span class="n">static</span> <span class="n">MCFixupKindInfo</span> <span class="n">Infos</span><span class="p">[</span><span class="n">Cpu0</span><span class="p">::</span><span class="n">NumTargetFixupKinds</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="o">//</span> <span class="n">This</span> <span class="n">table</span> <span class="o">*</span><span class="n">must</span><span class="o">*</span> <span class="n">be</span> <span class="ow">in</span> <span class="n">same</span> <span class="n">the</span> <span class="n">order</span> <span class="n">of</span> <span class="n">fixup_</span><span class="o">*</span> <span class="n">kinds</span> <span class="ow">in</span>
    <span class="o">//</span> <span class="n">Cpu0FixupKinds</span><span class="o">.</span><span class="n">h</span><span class="o">.</span>
    <span class="o">//</span>
    <span class="o">//</span> <span class="n">name</span>                        <span class="n">offset</span>  <span class="n">bits</span>  <span class="n">flags</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="p">{</span> <span class="s2">&quot;fixup_Cpu0_TLSGD&quot;</span><span class="p">,</span>          <span class="mi">0</span><span class="p">,</span>     <span class="mi">16</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s2">&quot;fixup_Cpu0_GOTTP&quot;</span><span class="p">,</span>          <span class="mi">0</span><span class="p">,</span>     <span class="mi">16</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s2">&quot;fixup_Cpu0_TP_HI&quot;</span><span class="p">,</span>          <span class="mi">0</span><span class="p">,</span>     <span class="mi">16</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s2">&quot;fixup_Cpu0_TP_LO&quot;</span><span class="p">,</span>          <span class="mi">0</span><span class="p">,</span>     <span class="mi">16</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s2">&quot;fixup_Cpu0_TLSLDM&quot;</span><span class="p">,</span>         <span class="mi">0</span><span class="p">,</span>     <span class="mi">16</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s2">&quot;fixup_Cpu0_DTP_HI&quot;</span><span class="p">,</span>         <span class="mi">0</span><span class="p">,</span>     <span class="mi">16</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s2">&quot;fixup_Cpu0_DTP_LO&quot;</span><span class="p">,</span>         <span class="mi">0</span><span class="p">,</span>     <span class="mi">16</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="p">...</span>
<span class="w">  </span><span class="p">};</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/MCTargetDesc/Cpu0BaseInfo.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">namespace</span> <span class="n">Cpu0II</span> <span class="p">{</span>
  <span class="o">///</span> <span class="n">Target</span> <span class="n">Operand</span> <span class="n">Flag</span> <span class="n">enum</span><span class="o">.</span>
  <span class="n">enum</span> <span class="n">TOF</span> <span class="p">{</span>
    <span class="o">//===------------------------------------------------------------------===//</span>
    <span class="o">//</span> <span class="n">Cpu0</span> <span class="n">Specific</span> <span class="n">MachineOperand</span> <span class="n">flags</span><span class="o">.</span>

</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="o">///</span> <span class="n">MO_TLSGD</span> <span class="o">-</span> <span class="n">Represents</span> <span class="n">the</span> <span class="n">offset</span> <span class="n">into</span> <span class="n">the</span> <span class="k">global</span> <span class="n">offset</span> <span class="n">table</span> <span class="n">at</span> <span class="n">which</span>
    <span class="o">//</span> <span class="n">the</span> <span class="n">module</span> <span class="n">ID</span> <span class="ow">and</span> <span class="n">TSL</span> <span class="n">block</span> <span class="n">offset</span> <span class="n">reside</span> <span class="n">during</span> <span class="n">execution</span> <span class="p">(</span><span class="n">General</span>
    <span class="o">//</span> <span class="n">Dynamic</span> <span class="n">TLS</span><span class="p">)</span><span class="o">.</span>
    <span class="n">MO_TLSGD</span><span class="p">,</span>

    <span class="o">///</span> <span class="n">MO_TLSLDM</span> <span class="o">-</span> <span class="n">Represents</span> <span class="n">the</span> <span class="n">offset</span> <span class="n">into</span> <span class="n">the</span> <span class="k">global</span> <span class="n">offset</span> <span class="n">table</span> <span class="n">at</span> <span class="n">which</span>
    <span class="o">//</span> <span class="n">the</span> <span class="n">module</span> <span class="n">ID</span> <span class="ow">and</span> <span class="n">TSL</span> <span class="n">block</span> <span class="n">offset</span> <span class="n">reside</span> <span class="n">during</span> <span class="n">execution</span> <span class="p">(</span><span class="n">Local</span>
    <span class="o">//</span> <span class="n">Dynamic</span> <span class="n">TLS</span><span class="p">)</span><span class="o">.</span>
    <span class="n">MO_TLSLDM</span><span class="p">,</span>
    <span class="n">MO_DTP_HI</span><span class="p">,</span>
    <span class="n">MO_DTP_LO</span><span class="p">,</span>

    <span class="o">///</span> <span class="n">MO_GOTTPREL</span> <span class="o">-</span> <span class="n">Represents</span> <span class="n">the</span> <span class="n">offset</span> <span class="kn">from</span><span class="w"> </span><span class="nn">the</span> <span class="n">thread</span> <span class="n">pointer</span> <span class="p">(</span><span class="n">Initial</span>
    <span class="o">//</span> <span class="n">Exec</span> <span class="n">TLS</span><span class="p">)</span><span class="o">.</span>
    <span class="n">MO_GOTTPREL</span><span class="p">,</span>

    <span class="o">///</span> <span class="n">MO_TPREL_HI</span><span class="o">/</span><span class="n">LO</span> <span class="o">-</span> <span class="n">Represents</span> <span class="n">the</span> <span class="n">hi</span> <span class="ow">and</span> <span class="n">low</span> <span class="n">part</span> <span class="n">of</span> <span class="n">the</span> <span class="n">offset</span> <span class="kn">from</span>
<span class="w">    </span><span class="o">//</span> <span class="n">the</span> <span class="n">thread</span> <span class="n">pointer</span> <span class="p">(</span><span class="n">Local</span> <span class="n">Exec</span> <span class="n">TLS</span><span class="p">)</span><span class="o">.</span>
    <span class="n">MO_TP_HI</span><span class="p">,</span>
    <span class="n">MO_TP_LO</span><span class="p">,</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="p">...</span>
<span class="w">  </span><span class="p">};</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/MCTargetDesc/Cpu0ELFObjectWriter.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">unsigned</span> <span class="n">Cpu0ELFObjectWriter</span><span class="p">::</span><span class="n">getRelocType</span><span class="p">(</span><span class="n">MCContext</span> <span class="o">&amp;</span><span class="n">Ctx</span><span class="p">,</span>
                                           <span class="n">const</span> <span class="n">MCValue</span> <span class="o">&amp;</span><span class="n">Target</span><span class="p">,</span>
                                           <span class="n">const</span> <span class="n">MCFixup</span> <span class="o">&amp;</span><span class="n">Fixup</span><span class="p">,</span>
                                           <span class="nb">bool</span> <span class="n">IsPCRel</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="o">//</span> <span class="n">determine</span> <span class="n">the</span> <span class="nb">type</span> <span class="n">of</span> <span class="n">the</span> <span class="n">relocation</span>
  <span class="n">unsigned</span> <span class="n">Type</span> <span class="o">=</span> <span class="p">(</span><span class="n">unsigned</span><span class="p">)</span><span class="n">ELF</span><span class="p">::</span><span class="n">R_CPU0_NONE</span><span class="p">;</span>
  <span class="n">unsigned</span> <span class="n">Kind</span> <span class="o">=</span> <span class="p">(</span><span class="n">unsigned</span><span class="p">)</span><span class="n">Fixup</span><span class="o">.</span><span class="n">getKind</span><span class="p">();</span>

  <span class="n">switch</span> <span class="p">(</span><span class="n">Kind</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">case</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_TLSGD</span><span class="p">:</span>
    <span class="n">Type</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">::</span><span class="n">R_CPU0_TLS_GD</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_GOTTPREL</span><span class="p">:</span>
    <span class="n">Type</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">::</span><span class="n">R_CPU0_TLS_GOTTPREL</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/MCTargetDesc/Cpu0FixupKinds.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">enum</span> <span class="n">Fixups</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="o">//</span> <span class="n">resulting</span> <span class="ow">in</span> <span class="o">-</span> <span class="n">R_CPU0_TLS_GD</span><span class="o">.</span>
    <span class="n">fixup_Cpu0_TLSGD</span><span class="p">,</span>

    <span class="o">//</span> <span class="n">resulting</span> <span class="ow">in</span> <span class="o">-</span> <span class="n">R_CPU0_TLS_GOTTPREL</span><span class="o">.</span>
    <span class="n">fixup_Cpu0_GOTTPREL</span><span class="p">,</span>

    <span class="o">//</span> <span class="n">resulting</span> <span class="ow">in</span> <span class="o">-</span> <span class="n">R_CPU0_TLS_TPREL_HI16</span><span class="o">.</span>
    <span class="n">fixup_Cpu0_TP_HI</span><span class="p">,</span>

    <span class="o">//</span> <span class="n">resulting</span> <span class="ow">in</span> <span class="o">-</span> <span class="n">R_CPU0_TLS_TPREL_LO16</span><span class="o">.</span>
    <span class="n">fixup_Cpu0_TP_LO</span><span class="p">,</span>

    <span class="o">//</span> <span class="n">resulting</span> <span class="ow">in</span> <span class="o">-</span> <span class="n">R_CPU0_TLS_LDM</span><span class="o">.</span>
    <span class="n">fixup_Cpu0_TLSLDM</span><span class="p">,</span>

    <span class="o">//</span> <span class="n">resulting</span> <span class="ow">in</span> <span class="o">-</span> <span class="n">R_CPU0_TLS_DTP_HI16</span><span class="o">.</span>
    <span class="n">fixup_Cpu0_DTP_HI</span><span class="p">,</span>

    <span class="o">//</span> <span class="n">resulting</span> <span class="ow">in</span> <span class="o">-</span> <span class="n">R_CPU0_TLS_DTP_LO16</span><span class="o">.</span>
    <span class="n">fixup_Cpu0_DTP_LO</span><span class="p">,</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/MCTargetDesc/Cpu0MCCodeEmitter.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">unsigned</span> <span class="n">Cpu0MCCodeEmitter</span><span class="p">::</span>
<span class="n">getExprOpValue</span><span class="p">(</span><span class="n">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">Expr</span><span class="p">,</span><span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCFixup</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Fixups</span><span class="p">,</span>
               <span class="n">const</span> <span class="n">MCSubtargetInfo</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="k">case</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_TLSGD</span><span class="p">:</span>
      <span class="n">FixupKind</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_TLSGD</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_TLSLDM</span><span class="p">:</span>
      <span class="n">FixupKind</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_TLSLDM</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_DTP_HI</span><span class="p">:</span>
      <span class="n">FixupKind</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_DTP_HI</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_DTP_LO</span><span class="p">:</span>
      <span class="n">FixupKind</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_DTP_LO</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_GOTTPREL</span><span class="p">:</span>
      <span class="n">FixupKind</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_GOTTPREL</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_TP_HI</span><span class="p">:</span>
      <span class="n">FixupKind</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_TP_HI</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_TP_LO</span><span class="p">:</span>
      <span class="n">FixupKind</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">fixup_Cpu0_TP_LO</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0InstrInfo.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">TlsGd</span> <span class="n">node</span> <span class="ow">is</span> <span class="n">used</span> <span class="n">to</span> <span class="n">handle</span> <span class="n">General</span> <span class="n">Dynamic</span> <span class="n">TLS</span>
<span class="k">def</span><span class="w"> </span><span class="nf">Cpu0TlsGd</span> <span class="p">:</span> <span class="n">SDNode</span><span class="o">&lt;</span><span class="s2">&quot;Cpu0ISD::TlsGd&quot;</span><span class="p">,</span> <span class="n">SDTIntUnaryOp</span><span class="o">&gt;</span><span class="p">;</span>

<span class="o">//</span> <span class="n">TpHi</span> <span class="ow">and</span> <span class="n">TpLo</span> <span class="n">nodes</span> <span class="n">are</span> <span class="n">used</span> <span class="n">to</span> <span class="n">handle</span> <span class="n">Local</span> <span class="n">Exec</span> <span class="n">TLS</span>
<span class="k">def</span><span class="w"> </span><span class="nf">Cpu0TpHi</span>  <span class="p">:</span> <span class="n">SDNode</span><span class="o">&lt;</span><span class="s2">&quot;Cpu0ISD::TpHi&quot;</span><span class="p">,</span> <span class="n">SDTIntUnaryOp</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span><span class="w"> </span><span class="nf">Cpu0TpLo</span>  <span class="p">:</span> <span class="n">SDNode</span><span class="o">&lt;</span><span class="s2">&quot;Cpu0ISD::TpLo&quot;</span><span class="p">,</span> <span class="n">SDTIntUnaryOp</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>let Predicates = [Ch12_1] in {
def : Pat&lt;(Cpu0Hi tglobaltlsaddr:$in), (LUi tglobaltlsaddr:$in)&gt;;
}
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>let Predicates = [Ch12_1] in {
def : Pat&lt;(Cpu0Lo tglobaltlsaddr:$in), (ORi ZERO, tglobaltlsaddr:$in)&gt;;
}
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>let Predicates = [Ch12_1] in {
def : Pat&lt;(add CPURegs:$hi, (Cpu0Lo tglobaltlsaddr:$lo)),
              (ORi CPURegs:$hi, tglobaltlsaddr:$lo)&gt;;
}
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ch12_1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">{</span>
<span class="k">def</span><span class="w"> </span><span class="p">:</span> <span class="n">WrapperPat</span><span class="o">&lt;</span><span class="n">tglobaltlsaddr</span><span class="p">,</span> <span class="n">ORi</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0SelLowering.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="n">const</span> <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">,</span>
                                       <span class="n">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span>
    <span class="p">:</span> <span class="n">TargetLowering</span><span class="p">(</span><span class="n">TM</span><span class="p">),</span> <span class="n">Subtarget</span><span class="p">(</span><span class="n">STI</span><span class="p">),</span> <span class="n">ABI</span><span class="p">(</span><span class="n">TM</span><span class="o">.</span><span class="n">getABI</span><span class="p">())</span> <span class="p">{</span>

</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">GlobalTLSAddress</span><span class="p">,</span>   <span class="n">MVT</span><span class="p">::</span><span class="n">i32</span><span class="p">,</span>   <span class="n">Custom</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="p">::</span>
<span class="n">LowerOperation</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span>
<span class="p">{</span>
  <span class="n">switch</span> <span class="p">(</span><span class="n">Op</span><span class="o">.</span><span class="n">getOpcode</span><span class="p">())</span>
  <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">case</span> <span class="n">ISD</span><span class="p">::</span><span class="n">GlobalTLSAddress</span><span class="p">:</span>   <span class="k">return</span> <span class="n">lowerGlobalTLSAddress</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="p">...</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>SDValue Cpu0TargetLowering::
lowerGlobalTLSAddress(SDValue Op, SelectionDAG &amp;DAG) const
{
  // If the relocation model is PIC, use the General Dynamic TLS Model or
  // Local Dynamic TLS model, otherwise use the Initial Exec or
  // Local Exec TLS Model.

  GlobalAddressSDNode *GA = cast&lt;GlobalAddressSDNode&gt;(Op);
  if (DAG.getTarget().Options.EmulatedTLS)
    return LowerToTLSEmulatedModel(GA, DAG);

  SDLoc DL(GA);
  const GlobalValue *GV = GA-&gt;getGlobal();
  EVT PtrVT = getPointerTy(DAG.getDataLayout());

  TLSModel::Model model = getTargetMachine().getTLSModel(GV);

  if (model == TLSModel::GeneralDynamic || model == TLSModel::LocalDynamic) {
    // General Dynamic and Local Dynamic TLS Model.
    unsigned Flag = (model == TLSModel::LocalDynamic) ? Cpu0II::MO_TLSLDM
                                                      : Cpu0II::MO_TLSGD;

    SDValue TGA = DAG.getTargetGlobalAddress(GV, DL, PtrVT, 0, Flag);
    SDValue Argument = DAG.getNode(Cpu0ISD::Wrapper, DL, PtrVT,
                                   getGlobalReg(DAG, PtrVT), TGA);
    unsigned PtrSize = PtrVT.getSizeInBits();
    IntegerType *PtrTy = Type::getIntNTy(*DAG.getContext(), PtrSize);

    SDValue TlsGetAddr = DAG.getExternalSymbol(&quot;__tls_get_addr&quot;, PtrVT);

    ArgListTy Args;
    ArgListEntry Entry;
    Entry.Node = Argument;
    Entry.Ty = PtrTy;
    Args.push_back(Entry);

    TargetLowering::CallLoweringInfo CLI(DAG);
    CLI.setDebugLoc(DL).setChain(DAG.getEntryNode())
      .setCallee(CallingConv::C, PtrTy, TlsGetAddr, std::move(Args));
    std::pair&lt;SDValue, SDValue&gt; CallResult = LowerCallTo(CLI);

    SDValue Ret = CallResult.first;

    if (model != TLSModel::LocalDynamic)
      return Ret;

    SDValue TGAHi = DAG.getTargetGlobalAddress(GV, DL, PtrVT, 0,
                                               Cpu0II::MO_DTP_HI);
    SDValue Hi = DAG.getNode(Cpu0ISD::Hi, DL, PtrVT, TGAHi);
    SDValue TGALo = DAG.getTargetGlobalAddress(GV, DL, PtrVT, 0,
                                               Cpu0II::MO_DTP_LO);
    SDValue Lo = DAG.getNode(Cpu0ISD::Lo, DL, PtrVT, TGALo);
    SDValue Add = DAG.getNode(ISD::ADD, DL, PtrVT, Hi, Ret);
    return DAG.getNode(ISD::ADD, DL, PtrVT, Add, Lo);
  }

  SDValue Offset;
  if (model == TLSModel::InitialExec) {
    // Initial Exec TLS Model
    SDValue TGA = DAG.getTargetGlobalAddress(GV, DL, PtrVT, 0,
                                             Cpu0II::MO_GOTTPREL);
    TGA = DAG.getNode(Cpu0ISD::Wrapper, DL, PtrVT, getGlobalReg(DAG, PtrVT),
                      TGA);
    Offset =
        DAG.getLoad(PtrVT, DL, DAG.getEntryNode(), TGA, MachinePointerInfo());
  } else {
    // Local Exec TLS Model
    assert(model == TLSModel::LocalExec);
    SDValue TGAHi = DAG.getTargetGlobalAddress(GV, DL, PtrVT, 0,
                                               Cpu0II::MO_TP_HI);
    SDValue TGALo = DAG.getTargetGlobalAddress(GV, DL, PtrVT, 0,
                                               Cpu0II::MO_TP_LO);
    SDValue Hi = DAG.getNode(Cpu0ISD::Hi, DL, PtrVT, TGAHi);
    SDValue Lo = DAG.getNode(Cpu0ISD::Lo, DL, PtrVT, TGALo);
    Offset = DAG.getNode(ISD::ADD, DL, PtrVT, Hi, Lo);
  }
  return Offset;
}
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0ISelLowering.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">SDValue</span> <span class="n">lowerGlobalTLSAddress</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0MCInstLower.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MCOperand</span> <span class="n">Cpu0MCInstLower</span><span class="p">::</span><span class="n">LowerSymbolOperand</span><span class="p">(</span><span class="n">const</span> <span class="n">MachineOperand</span> <span class="o">&amp;</span><span class="n">MO</span><span class="p">,</span>
                                              <span class="n">MachineOperandType</span> <span class="n">MOTy</span><span class="p">,</span>
                                              <span class="n">unsigned</span> <span class="n">Offset</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VariantKind</span> <span class="n">Kind</span> <span class="o">=</span> <span class="n">MCSymbolRefExpr</span><span class="p">::</span><span class="n">VK_None</span><span class="p">;</span>
  <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">Cpu0ExprKind</span> <span class="n">TargetKind</span> <span class="o">=</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_None</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">MCSymbol</span> <span class="o">*</span><span class="n">Symbol</span><span class="p">;</span>

  <span class="n">switch</span><span class="p">(</span><span class="n">MO</span><span class="o">.</span><span class="n">getTargetFlags</span><span class="p">())</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">case</span> <span class="n">Cpu0II</span><span class="p">::</span><span class="n">MO_TLSGD</span><span class="p">:</span>
    <span class="n">TargetKind</span> <span class="o">=</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_TLSGD</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0II</span><span class="p">::</span><span class="n">MO_TLSLDM</span><span class="p">:</span>
    <span class="n">TargetKind</span> <span class="o">=</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_TLSLDM</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0II</span><span class="p">::</span><span class="n">MO_DTP_HI</span><span class="p">:</span>
    <span class="n">TargetKind</span> <span class="o">=</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_DTP_HI</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0II</span><span class="p">::</span><span class="n">MO_DTP_LO</span><span class="p">:</span>
    <span class="n">TargetKind</span> <span class="o">=</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_DTP_LO</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0II</span><span class="p">::</span><span class="n">MO_GOTTPREL</span><span class="p">:</span>
    <span class="n">TargetKind</span> <span class="o">=</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_GOTTPREL</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0II</span><span class="p">::</span><span class="n">MO_TP_HI</span><span class="p">:</span>
    <span class="n">TargetKind</span> <span class="o">=</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_TP_HI</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0II</span><span class="p">::</span><span class="n">MO_TP_LO</span><span class="p">:</span>
    <span class="n">TargetKind</span> <span class="o">=</span> <span class="n">Cpu0MCExpr</span><span class="p">::</span><span class="n">CEK_TP_LO</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>clang<span class="w"> </span>-target<span class="w"> </span>mips-unknown-linux-gnu<span class="w"> </span>-c
<span class="go">ch12_thread_var.cpp -emit-llvm -std=c++11 -o ch12_thread_var.bc</span>
<span class="gp">JonathantekiiMac:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llvm-dis ch12_thread_var.bc -o -</span>
</pre></div>
</div>
<p class="rubric">../lbdex/output/ch12_thread_var.ll</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="vg">@a</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">dso_local</span><span class="w"> </span><span class="k">thread_local</span><span class="w"> </span><span class="k">global</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span>
<span class="vg">@b</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">dso_local</span><span class="w"> </span><span class="k">thread_local</span><span class="w"> </span><span class="k">global</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span>

<span class="c">; Function Attrs: noinline nounwind optnone mustprogress</span>
<span class="k">define</span><span class="w"> </span><span class="k">dso_local</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@_Z15test_thread_varv</span><span class="p">()</span><span class="w"> </span><span class="vg">#0</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="vg">@a</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span>
<span class="w">  </span><span class="nv nv-Anonymous">%0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="vg">@a</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv nv-Anonymous">%0</span>
<span class="p">}</span>

<span class="c">; Function Attrs: noinline nounwind optnone mustprogress</span>
<span class="k">define</span><span class="w"> </span><span class="k">dso_local</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@_Z17test_thread_var_2v</span><span class="p">()</span><span class="w"> </span><span class="vg">#0</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="vg">@b</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span>
<span class="w">  </span><span class="nv nv-Anonymous">%0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="vg">@b</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv nv-Anonymous">%0</span>
<span class="p">}</span>
<span class="p">...</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llc -march=cpu0 -relocation-model=pic -filetype=asm ch12_thread_var.bc</span>
<span class="go">-o ch12_thread_var.cpu0.pic.s</span>
<span class="gp">JonathantekiiMac:input Jonathan$ </span>cat<span class="w"> </span>ch12_thread_var.cpu0.pic.s
</pre></div>
</div>
<p class="rubric">../lbdex/output/ch12_thread_var.cpu0.pic.s</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>...
  .ent  _Z15test_thread_varv            # @_Z15test_thread_varv
_Z15test_thread_varv:
  ...
  ori  $4, $gp, %tlsldm(a)
  ld  $t9, %call16(__tls_get_addr)($gp)
  jalr  $t9
  nop
  ld  $gp, 8($fp)
  lui  $3, %dtp_hi(a)
  addu  $2, $3, $2
  ori  $2, $2, %dtp_lo(a)
  ...
</pre></div>
</div>
<p>In PIC (Position-Independent Code) mode, the <cite>__thread</cite> variable is accessed by
calling the function <cite>__tls_get_addr</cite> with the address of the thread-local
variable as an argument.</p>
<p>For C++11 <cite>thread_local</cite> variables, the compiler generates a call to the function
<cite>_ZTW1b</cite>, which internally calls <cite>__tls_get_addr</cite> to retrieve the address of the
<cite>thread_local</cite> variable.</p>
<p>In static mode, thread-local variables are accessed directly by loading their
addresses using machine instructions. For example, variables <cite>a</cite> and <cite>b</cite> are
accessed through direct address calculation instructions.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llc -march=cpu0 -relocation-model=static -filetype=asm</span>
<span class="go">ch12_thread_var.bc -o ch12_thread_var.cpu0.static.s</span>
<span class="gp">JonathantekiiMac:input Jonathan$ </span>cat<span class="w"> </span>ch12_thread_var.cpu0.static.s
</pre></div>
</div>
<p class="rubric">../lbdex/output/ch12_thread_var.cpu0.static.s</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>...
lui  $2, %tp_hi(a)
ori  $2, $2, %tp_lo(a)
...
lui  $2, %tp_hi(b)
ori  $2, $2, %tp_lo(b)
...
</pre></div>
</div>
<p>While MIPS uses the <cite>rdhwr</cite> instruction to access thread-local variables, Cpu0
accesses thread-local variables without introducing any new instructions.</p>
<p>Thread-local variables in Cpu0 are stored in a dedicated thread-local memory
region, which is accessed through <cite>%tp_hi</cite> and <cite>%tp_lo</cite>. This memory section is
protected by the kernel, meaning it can only be accessed in kernel mode.</p>
<p>As a result, user-mode programs cannot access this memory region, leaving no room
for potential exploits or malicious programs to interfere with thread-local
storage.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llc -march=mips -relocation-model=static -filetype=asm</span>
<span class="go">ch12_thread_var.bc -o -</span>
<span class="go">  ...</span>
<span class="go">  lui $1, %tprel_hi(a)</span>
<span class="go">  ori $1, $1, %tprel_lo(a)</span>
<span class="go">  .set  push</span>
<span class="go">  .set  mips32r2</span>
<span class="go">  rdhwr $3, $29</span>
<span class="go">  .set  pop</span>
<span class="go">  addu  $1, $3, $1</span>
<span class="go">  addiu $2, $zero, 2</span>
<span class="go">  sw  $2, 0($1)</span>
<span class="go">  addiu $2, $zero, 2</span>
<span class="go">  ...</span>
</pre></div>
</div>
<p>In static mode, the thread variable is similar to global variable.
In general, they are same in IRs, DAGs and machine code translation.
List them in the following tables.
You can check them with debug option enabled.</p>
<p>In static mode, the thread variable behaves similarly to a global variable.
In general, they are the same in terms of LLVM IR, DAG, and machine code
translation.</p>
<p>You can refer to the following tables for a detailed comparison.</p>
<p>To observe this in action, compile and check with debug options enabled.</p>
<table class="docutils align-default" id="id15">
<caption><span class="caption-number">Table 40 </span><span class="caption-text">The DAGs of thread varaible of static mode</span><a class="headerlink" href="#id15" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>stage</p></th>
<th class="head"><p>DAG</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>IR</p></td>
<td><p>load i32* &#64;a, align 4;</p></td>
</tr>
<tr class="row-odd"><td><p>Legalized selection DAG</p></td>
<td><p>(add Cpu0ISD::Hi Cpu0ISD::Lo);</p></td>
</tr>
<tr class="row-even"><td><p>Instruction Selection</p></td>
<td><p>ori $2, $zero, %tp_lo(a);</p></td>
</tr>
<tr class="row-odd"><td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>lui $3, %tp_hi(a);</p></td>
</tr>
<tr class="row-even"><td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>addu  $3, $3, $2;</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="id16">
<caption><span class="caption-number">Table 41 </span><span class="caption-text">The DAGs of local_thread varaible of static mode</span><a class="headerlink" href="#id16" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>stage</p></th>
<th class="head"><p>DAG</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>IR</p></td>
<td><p>ret i32* &#64;b;</p></td>
</tr>
<tr class="row-odd"><td><p>Legalized selection DAG</p></td>
<td><p>%0=(add Cpu0ISD::Hi Cpu0ISD::Lo);…</p></td>
</tr>
<tr class="row-even"><td><p>Instruction Selection</p></td>
<td><p>ori $2, $zero, %tp_lo(a);</p></td>
</tr>
<tr class="row-odd"><td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>lui $3, %tp_hi(a);</p></td>
</tr>
<tr class="row-even"><td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>addu  $3, $3, $2;</p></td>
</tr>
</tbody>
</table>
</section>
<section id="c-memory-order">
<h2><a class="toc-backref" href="#id26" role="doc-backlink">C++ Memory Order <a class="footnote-reference brackets" href="#cpp-mem-order" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#mem-order-wiki" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#atomic-stackoverflow" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a></a><a class="headerlink" href="#c-memory-order" title="Link to this heading">¶</a></h2>
<section id="source-code-compatibility">
<h3><a class="toc-backref" href="#id27" role="doc-backlink">Source Code Compatibility</a><a class="headerlink" href="#source-code-compatibility" title="Link to this heading">¶</a></h3>
<p><strong>Memory Order:</strong></p>
<ul class="simple">
<li><p><strong>Memory Order is the rules that define how operations on shared memory
appear to multiple threads — especially the ordering of reads/writes.</strong></p></li>
<li><p><strong>These rules ensure correct execution in parallel programs.</strong></p></li>
<li><p>C++ Memory Order makes <strong>“source code compatible”</strong> across different platforms
as shown below.</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">volatile</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">ready</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">producer</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Populate data</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">data</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">asm</span><span class="p">(</span><span class="s">&quot;__sync__&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// rely on sync or barrier in CPU instruction.</span>
<span class="w">  </span><span class="c1">// Release store: Ensures all writes to &#39;data&#39; are visible before &#39;ready&#39; is set.</span>
<span class="w">  </span><span class="n">ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"> </span><span class="c1">// Release signal</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">consumer</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Acquire load: Ensures all writes that happened before the release store are visible.</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">ready</span><span class="p">);</span><span class="w"> </span><span class="c1">// Wait for ready signal</span>

<span class="w">  </span><span class="c1">// Ensure that this print sees the correct value of `data`</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<figure class="align-default" id="id17">
<span id="mem-o-hw"></span><div class="graphviz"><img src="_images/graphviz-d1a47bb72182b805f8b7fe7f5f431c71ef946f76.png" alt="digraph MemoryOrderAcquireCache {
    rankdir=TB;
    node [shape=box, fontname=&quot;Helvetica&quot;];

    // Main memory
    MainMemory [label=&quot;Main Memory&quot;, shape=cylinder, style=filled, fillcolor=lightgray];

    // CPU caches
    subgraph cluster_cache1 {
        label=&quot;CPU Core 1 Cache (Thread 1 - Producer)&quot;;
        style=dashed;
        Cache1_Data [label=&quot;data.push_back(i * 10);&quot;];
        Cache1_Ready [label=&quot;ready=true&quot;];
    }

    subgraph cluster_cache2 {
        label=&quot;CPU Core 2 Cache (Thread 2 - Consumer)&quot;;
        style=dashed;
        Cache2_Data [label=&quot;std::cout &lt;&lt; data[i];&quot;];
        Cache2_Ready [label=&quot;ready=false&quot;];
    }

    // Threads
    Thread1 [label=&quot;Thread 1 (Producer)&quot;];
    Thread2 [label=&quot;Thread 2 (Consumer)&quot;];

    // Memory operations in Thread 1 (Producer)
    Thread1 -&gt; Cache1_Data;
    Thread1 -&gt; Cache1_Ready [label=&quot;ready.store(true, release)&quot;];
    
    // Memory propagation
    Cache1_Ready -&gt; MainMemory [label=&quot;ready=true propagated&quot;, color=red];
    MainMemory -&gt; Cache2_Ready [label=&quot;Consumer sees ready=true (Acquire)&quot;, color=red];

    // Memory operations in Thread 2 (Consumer)
    Thread2 -&gt; Cache2_Ready [label=&quot;while (!ready.load(acquire));&quot;];
    Cache2_Ready -&gt; Cache2_Data [label=&quot;data.load(relaxed)&quot;, color=blue];

    // Synchronization path
    Cache1_Ready -&gt; Cache2_Ready [label=&quot;Acquire-Release Sync&quot;, style=dashed, color=purple];
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-number">Fig. 56 </span><span class="caption-text">Diagram for mem-order-ex1.cpp</span><a class="headerlink" href="#id17" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Diagram Explanation:</p>
<ul class="simple">
<li><p><strong>CPU Core 1 (Thread 1 - Producer)</strong></p>
<ul>
<li><p>Writes all elements to ‘data’ (not immediately visible).</p></li>
<li><p>asm(“__sync__”) ensuring prior stores are  visible before writing true to
ready, “ready = true”.</p>
<ul>
<li><p>All memory access instructions (load/store) must be completed after
asm(“__sync__”).</p></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Main Memory</strong></p>
<ul>
<li><p><cite>‘ready=true’</cite> propagates to main memory, making it visible to all cores.</p></li>
</ul>
</li>
<li><p><strong>CPU Core 2 (Thread 2 - Consumer)</strong></p>
<ul>
<li><p>Waits until <cite>‘ready=true’</cite>, ensuring visibility
of all previous writes.</p></li>
<li><p>After acquiring ready, output all elements from ‘data’, which are now
reliably published by the producer thread..</p></li>
</ul>
</li>
</ul>
<p>Above inline assembly asm(“__sync__”) has the following problem:</p>
<p><strong>No standard atomic operations → source code imcompatible.</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>Developers had to use compiler-specific intrinsics (like GCC’s __sync_*,
MSVC’s Interlocked*) or inline assembly, making source code imcompatible.</p></li>
</ul>
</div></blockquote>
<p>The following C++11 example solve the problem of source code imcompatible.</p>
<p class="rubric">References/c++/mem-order-ex1.cpp (C++ code of memory order for
producer-consumer)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
#include &lt;atomic&gt;

std::atomic&lt;int&gt; data(0);
std::atomic&lt;bool&gt; ready(false);

void producer() {
    // Populate data
    for (int i = 0; i &lt; 10; ++i) {
        data.push_back(i * 10);
    }
    // Release store: Ensures all writes to &#39;data&#39; are visible before &#39;ready&#39; is set.
    ready.store(true, std::memory_order_release); // Release signal
}

void consumer() {
    // Acquire load: Ensures all writes that happened before the release store are visible.
    while (!ready.load(std::memory_order_acquire)); // Wait for ready signal

    // Ensure that this print sees the correct value of `data`
    for (int i = 0; i &lt; 10; ++i) {
        std::cout &lt;&lt; data[i];
    }
}

int main() {
    std::thread t1(producer);
    std::thread t2(consumer);

    t1.join();
    t2.join();

    return 0;
}

</pre></div>
</div>
<ul>
<li><p>memory_order::release</p>
<p>Same as asm(“__sync__”), read and write operations appearing before the
operation in the program must occur before it and are completed after
“ready.store(true, std::memory_order_release)”.</p>
</li>
<li><p>memory_order::acquire</p>
<p>Same as load volatile varaible “ready”, read and write operations appearing
after the operation in the program must occur after it (i.e., they cannot be
re-ordered before the operation,
“while (!ready.load(std::memory_order_acquire))”).</p>
</li>
</ul>
<p><strong>Summary:</strong></p>
<p>C++ Memory Order makes <strong>“source code compatible”</strong> across different platforms.</p>
</section>
<section id="the-problem-before-c-11">
<h3><a class="toc-backref" href="#id28" role="doc-backlink">The Problem Before C++11</a><a class="headerlink" href="#the-problem-before-c-11" title="Link to this heading">¶</a></h3>
<p>Before <strong>C++11</strong>, multi-threaded programming relied on <strong>mutexes, volatile
variables, and platform-specific atomic operations (such as atomic_load(&amp;a) and
atomic_store(&amp;a, 42)</strong>, which often led to
inefficiencies and undefined behavior.</p>
<p>For RISC CPUs, <strong>only load/store instructions access memory.</strong> Atomic
instructions ensure memory consistency across multiple cores.</p>
<p>CPUs provide atomic operations such as <strong>compare-and-swap</strong> <a class="footnote-reference brackets" href="#cas-wiki" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a> or
<strong>ll/sc (load-linked/store-conditional)</strong>, along with <strong>BARRIER</strong> or <strong>SYNC</strong>
instructions to enforce memory ordering. However, <strong>C++03 did not have a language
feature to tell the compiler how to control memory order for load/store
instructions.</strong></p>
<p>To address this, <strong>C++11 introduced memory orderings via `std::atomic`</strong>, giving
programmers <strong>fine-grained control</strong> over synchronization and memory consistency.</p>
<ol class="arabic simple">
<li><p><strong>No standard atomic operations → source code imcompatible.</strong></p>
<ul class="simple">
<li><p>Developers had to use compiler-specific intrinsics (like GCC’s __sync_*,
MSVC’s Interlocked*) or inline assembly, making source code imcompatible.</p></li>
</ul>
</li>
<li><p><strong>Unspecified Behavior in Multi-threading</strong></p>
<ul class="simple">
<li><p>The C++98/03 standard had <strong>no formal memory model</strong>.</p></li>
<li><p>Compilers <strong>optimized code aggressively</strong>, leading to race conditions.</p></li>
</ul>
</li>
<li><p><strong>Reliance on Volatile and Platform-specific Primitives</strong></p>
<ul class="simple">
<li><p><cite>volatile</cite> <strong>did not</strong> prevent reordering by the compiler.</p>
<ul>
<li><p>Though some compilers may choose to avoid reordering around volatile
accesses.</p></li>
</ul>
</li>
<li><p>Programmers had to use <strong>OS-specific APIs (e.g., `pthread_mutex`)</strong>.</p></li>
</ul>
</li>
<li><p><strong>Inefficient Synchronization Mechanisms</strong></p>
<ul class="simple">
<li><p>Mutexes ensured correctness but <strong>caused performance overhead</strong>.</p></li>
<li><p><strong>Spin-locks wasted CPU cycles</strong> due to busy-waiting.</p></li>
</ul>
</li>
</ol>
</section>
<section id="c-11-memory-model-solution">
<h3><a class="toc-backref" href="#id29" role="doc-backlink">C++11 Memory Model Solution</a><a class="headerlink" href="#c-11-memory-model-solution" title="Link to this heading">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>Non-blocking algorithm:</strong>
In computer science, an algorithm is called non-blocking if failure or
suspension of any thread cannot cause failure or suspension of another thread.</p>
<p>If a suspended thread can temporarily release its mutex and reacquire it
upon resuming, while always producing correct results, then the algorithm is
non-blocking.</p>
<p><strong>Wait-free: no starvation.</strong></p>
<p>An algorithm is wait-free if every operation has a bound on the
number of steps the algorithm will take before the operation completes. In
other words, wait-free algorithm has no starvation.</p>
<p><strong>Lock-free: progressive, allow starvation.</strong></p>
<p>Lock-freedom allows
individual threads to starve but guarantees system-wide throughput. An
algorithm is lock-free if, when the program threads are run for a
sufficiently long time, at least one of the threads makes progress (for
some sensible definition of progress).</p>
<p>All wait-free algorithms are lock-free.
In particular, if one thread is suspended, then a lock-free algorithm guarantees
that the remaining threads can still make progress. Hence, if two threads can
contend for the same mutex lock or spinlock, then the algorithm is not lock-free.
(If we suspend one thread that holds the lock, then the second thread will block.)
<a class="footnote-reference brackets" href="#lf-wiki" id="id8" role="doc-noteref"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></a>.</p>
<p>Based on this definition, any algorithm that retains a mutex without
allowing temporary release does not qualify as lock-free.</p>
</div>
<p>C++11 introduced <strong>a well-defined memory model</strong> and <strong>atomic operations</strong> with
<strong>memory orderings</strong>, allowing programmers to control hardware-level
optimizations.</p>
<table class="docutils align-default" id="id18">
<caption><span class="caption-number">Table 42 </span><span class="caption-text">C++ memory order A</span><a class="headerlink" href="#id18" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p><strong>Feature</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
<th class="head"><p><strong>Benefit</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><cite>std::atomic</cite></p></td>
<td><p>Provides lock-free atomic variables</p></td>
<td><p>Faster than mutexes</p></td>
</tr>
<tr class="row-odd"><td><p>Memory Orderings (<cite>std::memory_order</cite>)</p></td>
<td><p>Controls instruction reordering</p></td>
<td><p>Fine-grained optimization</p></td>
</tr>
<tr class="row-even"><td><p>Sequential Consistency (<cite>memory_order_seq_cst</cite>)</p></td>
<td><p>Strongest ordering, default behavior</p></td>
<td><p>Prevents race conditions</p></td>
</tr>
<tr class="row-odd"><td><p>Acquire-Release (<cite>memory_order_acquire/release</cite>)</p></td>
<td><p>Synchronization without mutexes</p></td>
<td><p>Efficient producer-consumer</p></td>
</tr>
<tr class="row-even"><td><p>Relaxed Ordering (<cite>memory_order_relaxed</cite>)</p></td>
<td><p>Allows reordering for performance</p></td>
<td><p>Best for atomic counters</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="id19">
<caption><span class="caption-number">Table 43 </span><span class="caption-text">C++ memory order B</span><a class="headerlink" href="#id19" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p><strong>Memory Order</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
<th class="head"><p><strong>Use Cases</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><cite>memory_order_relaxed</cite></p></td>
<td><p>No ordering guarantees; only atomicity.</p></td>
<td><p>Non-dependent atomic counters, statistics.</p></td>
</tr>
<tr class="row-odd"><td><p><cite>memory_order_consume</cite></p></td>
<td><p>Data-dependent ordering (deprecated in practice).</p></td>
<td><p>Rarely used; intended for pointer chains.</p></td>
</tr>
<tr class="row-even"><td><p><cite>memory_order_acquire</cite></p></td>
<td><p>Ensures preceding reads/writes are visible.</p></td>
<td><p>Locks, consumer threads.</p></td>
</tr>
<tr class="row-odd"><td><p><cite>memory_order_release</cite></p></td>
<td><p>Ensures following reads/writes are visible.</p></td>
<td><p>Locks, producer threads.</p></td>
</tr>
<tr class="row-even"><td><p><cite>memory_order_acq_rel</cite></p></td>
<td><p>Combines acquire + release.</p></td>
<td><p>Read-modify-write operations, synchronization.</p></td>
</tr>
<tr class="row-odd"><td><p><cite>memory_order_seq_cst</cite></p></td>
<td><p>Strongest ordering; global sequential consistency.</p></td>
<td><p>Default behavior, safest but can be slow.</p></td>
</tr>
</tbody>
</table>
<p>Explanation:</p>
<ol class="arabic simple">
<li><p><strong>Sequential Consistency (`memory_order_seq_cst`)</strong></p>
<ul class="simple">
<li><p><strong>Prevents reordering globally.</strong></p></li>
<li><p><strong>Ensures</strong> all threads observe operations in the same order.</p></li>
<li><p><strong>Default behavior</strong> of <cite>std::atomic</cite>.</p></li>
<li><p>Provides <strong>global order of operations</strong>, preventing out-of-order execution.</p></li>
<li><p>The safest but can cause <strong>performance overhead</strong>.</p></li>
</ul>
</li>
<li><p><strong>Acquire-Release (`memory_order_acquire/release`)</strong></p>
<ul class="simple">
<li><p><strong>Efficient alternative to mutexes.</strong></p></li>
<li><p><cite>acquire</cite>: Ensures earlier loads are visible.</p></li>
<li><p><cite>release</cite>: Ensures later stores are visible.</p></li>
</ul>
</li>
<li><p><strong>Relaxed Ordering (`memory_order_relaxed`)</strong></p>
<ul class="simple">
<li><p>Allows <strong>maximum performance</strong> without ordering constraints.</p></li>
<li><p>Best for <strong>counters and statistics</strong> that don’t need synchronization.</p></li>
<li><p>Example: <strong>Atomic counters</strong> that don’t require ordering.</p></li>
</ul>
</li>
<li><p><strong>`memory_order_acq_rel`</strong></p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Used in <strong>atomic read-modify-write operations</strong> like <cite>fetch_add</cite>.</p></li>
<li><p>Ensures proper ordering in concurrent updates.</p></li>
</ul>
</div></blockquote>
<p>Summary:</p>
<ul class="simple">
<li><p>Use <strong>`memory_order_relaxed`</strong> for <strong>performance</strong> when ordering is
unnecessary.</p></li>
<li><p>Use <strong>`memory_order_acquire/release`</strong> for <strong>synchronization</strong> between
threads.</p></li>
<li><p>Use <strong>`memory_order_seq_cst`</strong> when you need <strong>global ordering but at a
performance cost</strong>.</p></li>
</ul>
</section>
</section>
<section id="cpu0-implementation-for-memory-order">
<h2><a class="toc-backref" href="#id30" role="doc-backlink">Cpu0 implementation for memory-order</a><a class="headerlink" href="#cpu0-implementation-for-memory-order" title="Link to this heading">¶</a></h2>
<p>In order to support atomic in C++ and java, llvm provides the atomic IRs and
memory ordering here <a class="footnote-reference brackets" href="#atomics-llvm" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#llvmlang-ordering" id="id10" role="doc-noteref"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></a>.</p>
<p>The chapter 19
of book DPC++ <a class="footnote-reference brackets" href="#dpcpp-memorder" id="id11" role="doc-noteref"><span class="fn-bracket">[</span>11<span class="fn-bracket">]</span></a> explains the memory ordering better and I add
the related code fragment of lbdex/input/atomics.ll to it for explanation as
follows,</p>
<ul class="simple">
<li><p>memory_order::relaxed</p></li>
</ul>
<p>Read and write operations can be re-ordered before or after the operation with
no restrictions. There are no ordering guarantees.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">define i8 @load_i8_unordered(i8* %mem) {</span>
<span class="go">; CHECK-LABEL: load_i8_unordered</span>
<span class="go">; CHECK: ll</span>
<span class="go">; CHECK: sc</span>
<span class="go">; CHECK-NOT: sync</span>
<span class="gp">  %</span><span class="nv">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>load<span class="w"> </span>atomic<span class="w"> </span>i8,<span class="w"> </span>i8*<span class="w"> </span>%mem<span class="w"> </span>unordered,<span class="w"> </span>align<span class="w"> </span><span class="m">1</span>
<span class="go">  ret i8 %val</span>
<span class="go">}</span>
</pre></div>
</div>
<p>No <strong>sync</strong> from CodeGen instructions above.</p>
<ul class="simple">
<li><p>memory_order::acquire</p></li>
</ul>
<p>Read and write operations appearing after the operation in the program must
occur after it (i.e., they cannot be re-ordered before the operation).</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">define i32 @load_i32_acquire(i32* %mem) {</span>
<span class="go">; CHECK-LABEL: load_i32_acquire</span>
<span class="go">; CHECK: ll</span>
<span class="go">; CHECK: sc</span>
<span class="gp">  %</span><span class="nv">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>load<span class="w"> </span>atomic<span class="w"> </span>i32,<span class="w"> </span>i32*<span class="w"> </span>%mem<span class="w"> </span>acquire,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="go">; CHECK: sync</span>
<span class="go">  ret i32 %val</span>
<span class="go">}</span>
</pre></div>
</div>
<p>Sync guarantees “load atomic” complete before the next R/W (Read/Write). All
writes in other threads that release the same atomic variable are visible in the
current thread.</p>
<ul class="simple">
<li><p>memory_order::release</p></li>
</ul>
<p>Read and write operations appearing before the operation in the program must
occur before it (i.e., they cannot be re-ordered after the operation), and
preceding write operations are guaranteed to be visible to other program
instances which have been synchronized by a corresponding acquire operation
(i.e., an atomic operation using the same variable and memory_order::acquire
or a barrier function).</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">define void @store_i32_release(i32* %mem) {</span>
<span class="go">; CHECK-LABEL: store_i32_release</span>
<span class="go">; CHECK: sync</span>
<span class="go">; CHECK: ll</span>
<span class="go">; CHECK: sc</span>
<span class="go">  store atomic i32 42, i32* %mem release, align 4</span>
<span class="go">  ret void</span>
<span class="go">}</span>
</pre></div>
</div>
<p>Sync guarantees preceding R/W complete before “store atomic”. Mips’ ll and sc
guarantee that “store atomic release” is visible to other processors.</p>
<ul class="simple">
<li><p>memory_order::acq_rel</p></li>
</ul>
<p>The operation acts as both an acquire and a release. Read and write operations
cannot be re-ordered around the operation, and preceding writes must be made
visible as previously described for memory_order::release.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">define i32 @cas_strong_i32_acqrel_acquire(i32* %mem) {</span>
<span class="go">; CHECK-LABEL: cas_strong_i32_acqrel_acquire</span>
<span class="go">; CHECK: ll</span>
<span class="go">; CHECK: sc</span>
<span class="gp">  %</span><span class="nv">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>cmpxchg<span class="w"> </span>i32*<span class="w"> </span>%mem,<span class="w"> </span>i32<span class="w"> </span><span class="m">0</span>,<span class="w"> </span>i32<span class="w"> </span><span class="m">1</span><span class="w"> </span>acq_rel<span class="w"> </span>acquire
<span class="go">; CHECK: sync</span>
<span class="gp">  %</span><span class="nv">loaded</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>extractvalue<span class="w"> </span><span class="o">{</span><span class="w"> </span>i32,<span class="w"> </span>i1<span class="o">}</span><span class="w"> </span>%val,<span class="w"> </span><span class="m">0</span>
<span class="go">  ret i32 %loaded</span>
<span class="go">}</span>
</pre></div>
</div>
<p>Sync guarantees preceding R/W complete before “cmpxchg”. Other processors’
preceding write operations are guaranteed to be visible to this
“cmpxchg acquire” (Mips’s ll and sc quarantee it).</p>
<ul class="simple">
<li><p>memory_order::seq_cst</p></li>
</ul>
<p>The operation acts as an acquire, release, or both depending on whether it is
a read, write, or read-modify-write operation, respectively. All operations
with this memory order are observed in a sequentially consistent order.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">define i8 @cas_strong_i8_sc_sc(i8* %mem) {</span>
<span class="go">; CHECK-LABEL: cas_strong_i8_sc_sc</span>
<span class="go">; CHECK: sync</span>
<span class="go">; CHECK: ll</span>
<span class="go">; CHECK: sc</span>
<span class="gp">  %</span><span class="nv">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>cmpxchg<span class="w"> </span>i8*<span class="w"> </span>%mem,<span class="w"> </span>i8<span class="w"> </span><span class="m">0</span>,<span class="w"> </span>i8<span class="w"> </span><span class="m">1</span><span class="w"> </span>seq_cst<span class="w"> </span>seq_cst
<span class="go">; CHECK: sync</span>
<span class="gp">  %</span><span class="nv">loaded</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>extractvalue<span class="w"> </span><span class="o">{</span><span class="w"> </span>i8,<span class="w"> </span>i1<span class="o">}</span><span class="w"> </span>%val,<span class="w"> </span><span class="m">0</span>
<span class="go">  ret i8 %loaded</span>
<span class="go">}</span>
</pre></div>
</div>
<p>First sync guarantees preceding R/W complete before “cmpxchg seq_cst” and
visible to “cmpxchg seq_cst”. For seq_cst, a store performs a release operation.
Which means “cmpxchg seq_cst” are visible to other threads/processors that
acquire the same atomic variable as the memory_order_release definition.
Mips’ ll and sc quarantees this feature of “cmpxchg seq_cst”.
Second Sync guarantees “cmpxchg seq_cst” complete before the next R/W.</p>
<p>There are several restrictions on which memory orders are supported by each
operation. <a class="reference internal" href="#c-f1"><span class="std std-numref">Fig. 57</span></a> (from book Figure 19-10) summarizes which
combinations are valid.</p>
<figure class="align-center" id="id20">
<span id="c-f1"></span><a class="reference internal image-reference" href="_images/Fig-19-10-book-dpc++.png"><img alt="_images/Fig-19-10-book-dpc%2B%2B.png" src="_images/Fig-19-10-book-dpc%2B%2B.png" style="width: 633px; height: 368px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 57 </span><span class="caption-text">Supporting atomic operations with memory_order</span><a class="headerlink" href="#id20" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Load operations do not write values to memory and are therefore incompatible
with release semantics. Similarly, store operations do not read values from
memory and are therefore incompatible with acquire semantics. The remaining
read-modify-write atomic operations and fences are compatible with all memory
orderings <a class="footnote-reference brackets" href="#dpcpp-memorder" id="id12" role="doc-noteref"><span class="fn-bracket">[</span>11<span class="fn-bracket">]</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>C++ memory_order_consume</strong></p>
</div>
<figure class="align-center" id="id21">
<span id="c-f2"></span><a class="reference internal image-reference" href="_images/Fig-19-9-book-dpc++.png"><img alt="_images/Fig-19-9-book-dpc%2B%2B.png" src="_images/Fig-19-9-book-dpc%2B%2B.png" style="width: 578px; height: 594px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 58 </span><span class="caption-text">Comparing standard C++ and SYCL/DPC++ memory models</span><a class="headerlink" href="#id21" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The C++ memory model additionally includes memory_order::consume, with similar
behavior to memory_order::acquire. however, the C++17 standard discourages its
use, noting that its definition is being revised. its inclusion in dpC++ has
therefore been postponed to a future version.</p>
<p>For a few years now, compilers have treated consume as a synonym for acquire
<a class="footnote-reference brackets" href="#cpp-memorder-consume-as-acquire" id="id13" role="doc-noteref"><span class="fn-bracket">[</span>12<span class="fn-bracket">]</span></a>.</p>
<p>The current expectation is that the replacement facility will rely on core
memory model and atomics definitions very similar to what’s currently there.
Since memory_order_consume does have a profound impact on the memory model,
removing this text would allow drastic simplification, but conversely would
make it very difficult to add anything along the lines of memory_order_consume
back in later, especially if the standard evolves in the meantime, as expected.
Thus we are not proposing to remove the current wording
<a class="footnote-reference brackets" href="#cpp-memorder-consume-remove" id="id14" role="doc-noteref"><span class="fn-bracket">[</span>13<span class="fn-bracket">]</span></a>.</p>
<p>The following test files are extracted from <cite>memory_checks()</cite> in
<cite>clang/test/Sema/atomic-ops.c</cite>. The <cite>__c11_atomic_xxx</cite> built-in functions used
by Clang are defined in <cite>clang/include/clang/Basic/Builtins.def</cite>. Compiling
these files with Clang produces the same results as shown in <a class="reference internal" href="#c-f1"><span class="std std-numref">Fig. 57</span></a>.</p>
<p>Note: Clang compiles <cite>memory_order_consume</cite> to the same result as
<cite>memory_order_acquire</cite>.</p>
<p class="rubric">lbdex/input/ch12_sema_atomic-ops.c</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">clang</span> <span class="o">-</span><span class="n">S</span> <span class="n">ch12_sema_atomic</span><span class="o">-</span><span class="n">ops</span><span class="o">.</span><span class="n">c</span> <span class="o">-</span><span class="n">emit</span><span class="o">-</span><span class="n">llvm</span> <span class="o">-</span><span class="n">o</span> <span class="o">-</span>
<span class="o">//</span> <span class="n">Uses</span> <span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">homebrew</span><span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">llvm</span><span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">clang</span> <span class="ow">in</span> <span class="n">macOS</span><span class="o">.</span>

<span class="c1">#include &lt;stdatomic.h&gt;</span>

<span class="o">//</span> <span class="n">From</span> <span class="n">memory_checks</span><span class="p">()</span> <span class="n">of</span> <span class="n">Sema</span><span class="o">/</span><span class="n">atomic</span><span class="o">-</span><span class="n">ops</span><span class="o">.</span><span class="n">c</span>
<span class="n">void</span> <span class="n">memory_checks</span><span class="p">(</span><span class="n">_Atomic</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span><span class="n">Ap</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="nb">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_load</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_load</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_load</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">memory_order_consume</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_load</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">);</span> <span class="o">//</span> <span class="n">expected</span><span class="o">-</span><span class="n">warning</span> <span class="p">{{</span><span class="n">memory</span> <span class="n">order</span> <span class="n">argument</span> <span class="n">to</span> <span class="n">atomic</span> <span class="n">operation</span> <span class="ow">is</span> <span class="n">invalid</span><span class="p">}}</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_load</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">);</span> <span class="o">//</span> <span class="n">expected</span><span class="o">-</span><span class="n">warning</span> <span class="p">{{</span><span class="n">memory</span> <span class="n">order</span> <span class="n">argument</span> <span class="n">to</span> <span class="n">atomic</span> <span class="n">operation</span> <span class="ow">is</span> <span class="n">invalid</span><span class="p">}}</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_load</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_load</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_load</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="o">//</span> <span class="n">expected</span><span class="o">-</span><span class="n">warning</span> <span class="p">{{</span><span class="n">memory</span> <span class="n">order</span> <span class="n">argument</span> <span class="n">to</span> <span class="n">atomic</span> <span class="n">operation</span> <span class="ow">is</span> <span class="n">invalid</span><span class="p">}}</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_load</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="mi">42</span><span class="p">);</span> <span class="o">//</span> <span class="n">expected</span><span class="o">-</span><span class="n">warning</span> <span class="p">{{</span><span class="n">memory</span> <span class="n">order</span> <span class="n">argument</span> <span class="n">to</span> <span class="n">atomic</span> <span class="n">operation</span> <span class="ow">is</span> <span class="n">invalid</span><span class="p">}}</span>

  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_store</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_store</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">);</span> <span class="o">//</span> <span class="n">expected</span><span class="o">-</span><span class="n">warning</span> <span class="p">{{</span><span class="n">memory</span> <span class="n">order</span> <span class="n">argument</span> <span class="n">to</span> <span class="n">atomic</span> <span class="n">operation</span> <span class="ow">is</span> <span class="n">invalid</span><span class="p">}}</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_store</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_consume</span><span class="p">);</span> <span class="o">//</span> <span class="n">expected</span><span class="o">-</span><span class="n">warning</span> <span class="p">{{</span><span class="n">memory</span> <span class="n">order</span> <span class="n">argument</span> <span class="n">to</span> <span class="n">atomic</span> <span class="n">operation</span> <span class="ow">is</span> <span class="n">invalid</span><span class="p">}}</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_store</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_store</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">);</span> <span class="o">//</span> <span class="n">expected</span><span class="o">-</span><span class="n">warning</span> <span class="p">{{</span><span class="n">memory</span> <span class="n">order</span> <span class="n">argument</span> <span class="n">to</span> <span class="n">atomic</span> <span class="n">operation</span> <span class="ow">is</span> <span class="n">invalid</span><span class="p">}}</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_store</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">);</span>

  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_exchange</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_exchange</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_exchange</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_consume</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_exchange</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_exchange</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_exchange</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">);</span>

  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_compare_exchange_strong</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_compare_exchange_strong</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_compare_exchange_strong</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_consume</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_compare_exchange_strong</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_compare_exchange_strong</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_compare_exchange_strong</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>

  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_compare_exchange_weak</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_compare_exchange_weak</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_compare_exchange_weak</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_consume</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_compare_exchange_weak</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_compare_exchange_weak</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_compare_exchange_weak</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>

  <span class="n">atomic_thread_fence</span><span class="p">(</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="n">atomic_thread_fence</span><span class="p">(</span><span class="n">memory_order_acquire</span><span class="p">);</span>
  <span class="n">atomic_thread_fence</span><span class="p">(</span><span class="n">memory_order_consume</span><span class="p">);</span> <span class="o">//</span> <span class="n">For</span> <span class="n">a</span> <span class="n">few</span> <span class="n">years</span> <span class="n">now</span><span class="p">,</span> <span class="n">compilers</span> <span class="n">have</span> <span class="n">treated</span> <span class="n">consume</span> <span class="k">as</span> <span class="n">a</span> <span class="n">synonym</span> <span class="k">for</span> <span class="n">acquire</span><span class="o">.</span>
  <span class="n">atomic_thread_fence</span><span class="p">(</span><span class="n">memory_order_release</span><span class="p">);</span>
  <span class="n">atomic_thread_fence</span><span class="p">(</span><span class="n">memory_order_acq_rel</span><span class="p">);</span>
  <span class="n">atomic_thread_fence</span><span class="p">(</span><span class="n">memory_order_seq_cst</span><span class="p">);</span>
  <span class="n">atomic_signal_fence</span><span class="p">(</span><span class="n">memory_order_seq_cst</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/input/ch12_sema_atomic-fetch.c</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">clang</span> <span class="o">-</span><span class="n">S</span> <span class="n">ch12_sema_atomic</span><span class="o">-</span><span class="n">fetch</span><span class="o">.</span><span class="n">c</span> <span class="o">-</span><span class="n">emit</span><span class="o">-</span><span class="n">llvm</span> <span class="o">-</span><span class="n">o</span> <span class="o">-</span>
<span class="o">//</span> <span class="n">Uses</span> <span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">homebrew</span><span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">llvm</span><span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">clang</span> <span class="ow">in</span> <span class="n">macOS</span><span class="o">.</span>

<span class="c1">#include &lt;stdatomic.h&gt;</span>

<span class="o">//</span><span class="c1">#define WANT_COMPILE_FAIL</span>

<span class="o">//</span> <span class="n">From</span> <span class="n">__c11_atomic_fetch_xxx</span> <span class="n">of</span> <span class="n">memory_checks</span><span class="p">()</span> <span class="n">of</span> <span class="n">Sema</span><span class="o">/</span><span class="n">atomic</span><span class="o">-</span><span class="n">ops</span><span class="o">.</span><span class="n">c</span>
<span class="n">void</span> <span class="n">memory_checks</span><span class="p">(</span><span class="n">_Atomic</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span><span class="n">Ap</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="nb">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_add</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_add</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_add</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">memory_order_consume</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_add</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_add</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_add</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">);</span>

<span class="c1">#ifdef WANT_COMPILE_FAIL // fail to compile:</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_add</span><span class="p">(</span>
      <span class="p">(</span><span class="n">struct</span> <span class="n">Incomplete</span> <span class="o">*</span> <span class="n">_Atomic</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,</span> <span class="o">//</span> <span class="n">expected</span><span class="o">-</span><span class="n">error</span> <span class="p">{{</span><span class="n">incomplete</span> <span class="nb">type</span> <span class="s1">&#39;struct Incomplete&#39;</span><span class="p">}}</span>
      <span class="mi">1</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">);</span>
<span class="c1">#endif</span>

  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_init</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_init</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_init</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_init</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_init</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_init</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_sub</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_sub</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_sub</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_consume</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_sub</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_sub</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_sub</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">);</span>

  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_and</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_and</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_and</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_consume</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_and</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_and</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_and</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">);</span>

  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_or</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_or</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_or</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_consume</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_or</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_or</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_or</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">);</span>

  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_xor</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_xor</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_xor</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_consume</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_xor</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_xor</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_xor</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">);</span>

  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_nand</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_nand</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_nand</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_consume</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_nand</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_nand</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_nand</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">);</span>

  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_min</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_min</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_min</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_consume</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_min</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_min</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_min</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">);</span>

  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_max</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_max</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_max</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_consume</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_max</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_max</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">);</span>
  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">__c11_atomic_fetch_max</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">memory_order_seq_cst</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<table class="docutils align-default" id="id22">
<caption><span class="caption-number">Table 44 </span><span class="caption-text">Atomic related between clang’s builtin and llvm ir</span><a class="headerlink" href="#id22" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>clang’s builtin</p></th>
<th class="head"><p>llvm ir</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>__c11_atomic_load</p></td>
<td><p>load atomic</p></td>
</tr>
<tr class="row-odd"><td><p>__c11_atomic_store</p></td>
<td><p>store atomic</p></td>
</tr>
<tr class="row-even"><td><p>__c11_atomic_exchange_xxx</p></td>
<td><p>cmpxchg</p></td>
</tr>
<tr class="row-odd"><td><p>atomic_thread_fence</p></td>
<td><p>fence</p></td>
</tr>
<tr class="row-even"><td><p>__c11_atomic_fetch_xxx</p></td>
<td><p>atomicrmw xxx</p></td>
</tr>
</tbody>
</table>
<p>C++ atomic functions are supported by calling implementation functions from the
C++ standard library. These functions eventually call the <cite>__c11_atomic_xxx</cite>
built-in functions for actual implementation.</p>
<p>Therefore, <cite>__c11_atomic_xxx</cite> functions, listed above, provide a lower-level and
higher-performance interface for C++ programmers. An example is shown below:</p>
<p class="rubric">lbdex/input/ch12_c++_atomics.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="o">~/</span><span class="n">llvm</span><span class="o">/</span><span class="n">debug</span><span class="o">/</span><span class="n">build</span><span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">clang</span> <span class="o">-</span><span class="n">S</span> <span class="n">ch12_c</span><span class="o">++</span><span class="n">_atomics</span><span class="o">.</span><span class="n">cpp</span> <span class="o">-</span><span class="n">emit</span><span class="o">-</span><span class="n">llvm</span> <span class="o">-</span><span class="n">o</span> <span class="o">-</span>
<span class="o">//</span> <span class="n">Uses</span> <span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">homebrew</span><span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">llvm</span><span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">clang</span> <span class="ow">in</span> <span class="n">macOS</span><span class="o">.</span>

<span class="c1">#include &lt;atomic&gt;</span>

<span class="n">std</span><span class="p">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="nb">bool</span><span class="o">&gt;</span> <span class="n">winner</span> <span class="p">(</span><span class="n">false</span><span class="p">);</span>

<span class="nb">int</span> <span class="n">test_atomics</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nb">bool</span> <span class="n">res</span> <span class="o">=</span> <span class="n">winner</span><span class="o">.</span><span class="n">exchange</span><span class="p">(</span><span class="n">true</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="n">count</span><span class="o">++</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To support LLVM atomic IR instructions, the following code is added to
Chapter12_1.</p>
<p class="rubric">lbdex/chapters/Chapter12_1/Disassembler/Cpu0Disassembler.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">static</span> <span class="n">DecodeStatus</span> <span class="n">DecodeMem</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span>
                              <span class="n">unsigned</span> <span class="n">Insn</span><span class="p">,</span>
                              <span class="n">uint64_t</span> <span class="n">Address</span><span class="p">,</span>
                              <span class="n">const</span> <span class="n">void</span> <span class="o">*</span><span class="n">Decoder</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">if</span><span class="p">(</span><span class="n">Inst</span><span class="o">.</span><span class="n">getOpcode</span><span class="p">()</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="p">::</span><span class="n">SC</span><span class="p">){</span>
    <span class="n">Inst</span><span class="o">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="p">::</span><span class="n">createReg</span><span class="p">(</span><span class="n">Reg</span><span class="p">));</span>
  <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0InstrInfo.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">SDT_Sync</span>             <span class="p">:</span> <span class="n">SDTypeProfile</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="n">SDTCisVT</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">i32</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">Cpu0Sync</span> <span class="p">:</span> <span class="n">SDNode</span><span class="o">&lt;</span><span class="s2">&quot;Cpu0ISD::Sync&quot;</span><span class="p">,</span> <span class="n">SDT_Sync</span><span class="p">,</span> <span class="p">[</span><span class="n">SDNPHasChain</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">PtrRC</span> <span class="p">:</span> <span class="n">Operand</span><span class="o">&lt;</span><span class="n">iPTR</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">let</span> <span class="n">MIOperandInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">ops</span> <span class="n">ptr_rc</span><span class="p">);</span>
  <span class="n">let</span> <span class="n">DecoderMethod</span> <span class="o">=</span> <span class="s2">&quot;DecodeCPURegsRegisterClass&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// Atomic instructions with 2 source operands (ATOMIC_SWAP &amp; ATOMIC_LOAD_*).
class Atomic2Ops&lt;PatFrag Op, RegisterClass DRC&gt; :
  PseudoSE&lt;(outs DRC:$dst), (ins PtrRC:$ptr, DRC:$incr),
           [(set DRC:$dst, (Op iPTR:$ptr, DRC:$incr))]&gt;;

// Atomic Compare &amp; Swap.
class AtomicCmpSwap&lt;PatFrag Op, RegisterClass DRC&gt; :
  PseudoSE&lt;(outs DRC:$dst), (ins PtrRC:$ptr, DRC:$cmp, DRC:$swap),
           [(set DRC:$dst, (Op iPTR:$ptr, DRC:$cmp, DRC:$swap))]&gt;;
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>class LLBase&lt;bits&lt;8&gt; Opc, string opstring, RegisterClass RC, Operand Mem&gt; :
  FMem&lt;Opc, (outs RC:$ra), (ins Mem:$addr),
       !strconcat(opstring, &quot;\t$ra, $addr&quot;), [], IILoad&gt; {
  let mayLoad = 1;
}

class SCBase&lt;bits&lt;8&gt; Opc, string opstring, RegisterOperand RO, Operand Mem&gt; :
  FMem&lt;Opc, (outs RO:$dst), (ins RO:$ra, Mem:$addr),
       !strconcat(opstring, &quot;\t$ra, $addr&quot;), [], IIStore&gt; {
  let mayStore = 1;
  let Constraints = &quot;$ra = $dst&quot;;
}
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ch12_1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">{</span>
<span class="n">let</span> <span class="n">usesCustomInserter</span> <span class="o">=</span> <span class="mi">1</span> <span class="ow">in</span> <span class="p">{</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">ATOMIC_LOAD_ADD_I8</span>   <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_add_8</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">ATOMIC_LOAD_ADD_I16</span>  <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_add_16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">ATOMIC_LOAD_ADD_I32</span>  <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_add_32</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">ATOMIC_LOAD_SUB_I8</span>   <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_sub_8</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">ATOMIC_LOAD_SUB_I16</span>  <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_sub_16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">ATOMIC_LOAD_SUB_I32</span>  <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_sub_32</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">ATOMIC_LOAD_AND_I8</span>   <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_and_8</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">ATOMIC_LOAD_AND_I16</span>  <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_and_16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">ATOMIC_LOAD_AND_I32</span>  <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_and_32</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">ATOMIC_LOAD_OR_I8</span>    <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_or_8</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">ATOMIC_LOAD_OR_I16</span>   <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_or_16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">ATOMIC_LOAD_OR_I32</span>   <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_or_32</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">ATOMIC_LOAD_XOR_I8</span>   <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_xor_8</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">ATOMIC_LOAD_XOR_I16</span>  <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_xor_16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">ATOMIC_LOAD_XOR_I32</span>  <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_xor_32</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">ATOMIC_LOAD_NAND_I8</span>  <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_nand_8</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">ATOMIC_LOAD_NAND_I16</span> <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_nand_16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">ATOMIC_LOAD_NAND_I32</span> <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_load_nand_32</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">ATOMIC_SWAP_I8</span>       <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_swap_8</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">ATOMIC_SWAP_I16</span>      <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_swap_16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">ATOMIC_SWAP_I32</span>      <span class="p">:</span> <span class="n">Atomic2Ops</span><span class="o">&lt;</span><span class="n">atomic_swap_32</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">ATOMIC_CMP_SWAP_I8</span>   <span class="p">:</span> <span class="n">AtomicCmpSwap</span><span class="o">&lt;</span><span class="n">atomic_cmp_swap_8</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">ATOMIC_CMP_SWAP_I16</span>  <span class="p">:</span> <span class="n">AtomicCmpSwap</span><span class="o">&lt;</span><span class="n">atomic_cmp_swap_16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">ATOMIC_CMP_SWAP_I32</span>  <span class="p">:</span> <span class="n">AtomicCmpSwap</span><span class="o">&lt;</span><span class="n">atomic_cmp_swap_32</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>let Predicates = [Ch12_1] in {
let hasSideEffects = 1 in
def SYNC : Cpu0Inst&lt;(outs), (ins i32imm:$stype), &quot;sync $stype&quot;,
                    [(Cpu0Sync imm:$stype)], NoItinerary, FrmOther&gt;
{
  bits&lt;5&gt; stype;
  let Opcode = 0x60;
  let Inst{25-11} = 0;
  let Inst{10-6} = stype;
  let Inst{5-0} = 0;
}
}
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">///</span> <span class="n">Load</span><span class="o">-</span><span class="n">linked</span><span class="p">,</span> <span class="n">Store</span><span class="o">-</span><span class="n">conditional</span>
<span class="k">def</span><span class="w"> </span><span class="nf">LL</span>      <span class="p">:</span> <span class="n">LLBase</span><span class="o">&lt;</span><span class="mh">0x61</span><span class="p">,</span> <span class="s2">&quot;ll&quot;</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="n">mem</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">def</span><span class="w"> </span><span class="nf">SC</span>      <span class="p">:</span> <span class="n">SCBase</span><span class="o">&lt;</span><span class="mh">0x62</span><span class="p">,</span> <span class="s2">&quot;sc&quot;</span><span class="p">,</span> <span class="n">RegisterOperand</span><span class="o">&lt;</span><span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">mem</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="p">:</span> <span class="n">Cpu0InstAlias</span><span class="o">&lt;</span><span class="s2">&quot;sync&quot;</span><span class="p">,</span>
                    <span class="p">(</span><span class="n">SYNC</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0ISelLowering.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">MachineBasicBlock</span> <span class="o">*</span>
    <span class="n">EmitInstrWithCustomInserter</span><span class="p">(</span><span class="n">MachineInstr</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">,</span>
                                <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">MBB</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">SDValue</span> <span class="n">lowerATOMIC_FENCE</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span><span class="o">&amp;</span> <span class="n">DAG</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="nb">bool</span> <span class="n">shouldInsertFencesForAtomic</span><span class="p">(</span><span class="n">const</span> <span class="n">Instruction</span> <span class="o">*</span><span class="n">I</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="o">///</span> <span class="n">Emit</span> <span class="n">a</span> <span class="n">sign</span><span class="o">-</span><span class="n">extension</span> <span class="n">using</span> <span class="n">shl</span><span class="o">/</span><span class="n">sra</span> <span class="n">appropriately</span><span class="o">.</span>
    <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">emitSignExtendToI32InReg</span><span class="p">(</span><span class="n">MachineInstr</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">,</span>
                                                <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">BB</span><span class="p">,</span>
                                                <span class="n">unsigned</span> <span class="n">Size</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">DstReg</span><span class="p">,</span>
                                                <span class="n">unsigned</span> <span class="n">SrcRec</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
    <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">emitAtomicBinary</span><span class="p">(</span><span class="n">MachineInstr</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">,</span> <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">BB</span><span class="p">,</span>
                    <span class="n">unsigned</span> <span class="n">Size</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">BinOpcode</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">Nand</span> <span class="o">=</span> <span class="n">false</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
    <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">emitAtomicBinaryPartword</span><span class="p">(</span><span class="n">MachineInstr</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">,</span>
                    <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">BB</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">Size</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">BinOpcode</span><span class="p">,</span>
                    <span class="nb">bool</span> <span class="n">Nand</span> <span class="o">=</span> <span class="n">false</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
    <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">emitAtomicCmpSwap</span><span class="p">(</span><span class="n">MachineInstr</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">,</span>
                                  <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">BB</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">Size</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
    <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">emitAtomicCmpSwapPartword</span><span class="p">(</span><span class="n">MachineInstr</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">,</span>
                                  <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">BB</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">Size</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0SelLowering.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">getTargetNodeName</span><span class="p">(</span><span class="n">unsigned</span> <span class="n">Opcode</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">case</span> <span class="n">Cpu0ISD</span><span class="p">::</span><span class="n">Sync</span><span class="p">:</span>              <span class="k">return</span> <span class="s2">&quot;Cpu0ISD::Sync&quot;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="n">const</span> <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">,</span>
                                       <span class="n">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span>
    <span class="p">:</span> <span class="n">TargetLowering</span><span class="p">(</span><span class="n">TM</span><span class="p">),</span> <span class="n">Subtarget</span><span class="p">(</span><span class="n">STI</span><span class="p">),</span> <span class="n">ABI</span><span class="p">(</span><span class="n">TM</span><span class="o">.</span><span class="n">getABI</span><span class="p">())</span> <span class="p">{</span>

</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">ATOMIC_LOAD</span><span class="p">,</span>       <span class="n">MVT</span><span class="p">::</span><span class="n">i32</span><span class="p">,</span>    <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">ATOMIC_LOAD</span><span class="p">,</span>       <span class="n">MVT</span><span class="p">::</span><span class="n">i64</span><span class="p">,</span>    <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">ATOMIC_STORE</span><span class="p">,</span>      <span class="n">MVT</span><span class="p">::</span><span class="n">i32</span><span class="p">,</span>    <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">ATOMIC_STORE</span><span class="p">,</span>      <span class="n">MVT</span><span class="p">::</span><span class="n">i64</span><span class="p">,</span>    <span class="n">Expand</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="p">::</span>
<span class="n">LowerOperation</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span>
<span class="p">{</span>
  <span class="n">switch</span> <span class="p">(</span><span class="n">Op</span><span class="o">.</span><span class="n">getOpcode</span><span class="p">())</span>
  <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">case</span> <span class="n">ISD</span><span class="p">::</span><span class="n">ATOMIC_FENCE</span><span class="p">:</span>       <span class="k">return</span> <span class="n">lowerATOMIC_FENCE</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>MachineBasicBlock *
Cpu0TargetLowering::EmitInstrWithCustomInserter(MachineInstr &amp;MI,
                                                MachineBasicBlock *BB) const {
  switch (MI.getOpcode()) {
  default:
    llvm_unreachable(&quot;Unexpected instr type to insert&quot;);
  case Cpu0::ATOMIC_LOAD_ADD_I8:
    return emitAtomicBinaryPartword(MI, BB, 1, Cpu0::ADDu);
  case Cpu0::ATOMIC_LOAD_ADD_I16:
    return emitAtomicBinaryPartword(MI, BB, 2, Cpu0::ADDu);
  case Cpu0::ATOMIC_LOAD_ADD_I32:
    return emitAtomicBinary(MI, BB, 4, Cpu0::ADDu);

  case Cpu0::ATOMIC_LOAD_AND_I8:
    return emitAtomicBinaryPartword(MI, BB, 1, Cpu0::AND);
  case Cpu0::ATOMIC_LOAD_AND_I16:
    return emitAtomicBinaryPartword(MI, BB, 2, Cpu0::AND);
  case Cpu0::ATOMIC_LOAD_AND_I32:
    return emitAtomicBinary(MI, BB, 4, Cpu0::AND);

  case Cpu0::ATOMIC_LOAD_OR_I8:
    return emitAtomicBinaryPartword(MI, BB, 1, Cpu0::OR);
  case Cpu0::ATOMIC_LOAD_OR_I16:
    return emitAtomicBinaryPartword(MI, BB, 2, Cpu0::OR);
  case Cpu0::ATOMIC_LOAD_OR_I32:
    return emitAtomicBinary(MI, BB, 4, Cpu0::OR);

  case Cpu0::ATOMIC_LOAD_XOR_I8:
    return emitAtomicBinaryPartword(MI, BB, 1, Cpu0::XOR);
  case Cpu0::ATOMIC_LOAD_XOR_I16:
    return emitAtomicBinaryPartword(MI, BB, 2, Cpu0::XOR);
  case Cpu0::ATOMIC_LOAD_XOR_I32:
    return emitAtomicBinary(MI, BB, 4, Cpu0::XOR);

  case Cpu0::ATOMIC_LOAD_NAND_I8:
    return emitAtomicBinaryPartword(MI, BB, 1, 0, true);
  case Cpu0::ATOMIC_LOAD_NAND_I16:
    return emitAtomicBinaryPartword(MI, BB, 2, 0, true);
  case Cpu0::ATOMIC_LOAD_NAND_I32:
    return emitAtomicBinary(MI, BB, 4, 0, true);

  case Cpu0::ATOMIC_LOAD_SUB_I8:
    return emitAtomicBinaryPartword(MI, BB, 1, Cpu0::SUBu);
  case Cpu0::ATOMIC_LOAD_SUB_I16:
    return emitAtomicBinaryPartword(MI, BB, 2, Cpu0::SUBu);
  case Cpu0::ATOMIC_LOAD_SUB_I32:
    return emitAtomicBinary(MI, BB, 4, Cpu0::SUBu);

  case Cpu0::ATOMIC_SWAP_I8:
    return emitAtomicBinaryPartword(MI, BB, 1, 0);
  case Cpu0::ATOMIC_SWAP_I16:
    return emitAtomicBinaryPartword(MI, BB, 2, 0);
  case Cpu0::ATOMIC_SWAP_I32:
    return emitAtomicBinary(MI, BB, 4, 0);

  case Cpu0::ATOMIC_CMP_SWAP_I8:
    return emitAtomicCmpSwapPartword(MI, BB, 1);
  case Cpu0::ATOMIC_CMP_SWAP_I16:
    return emitAtomicCmpSwapPartword(MI, BB, 2);
  case Cpu0::ATOMIC_CMP_SWAP_I32:
    return emitAtomicCmpSwap(MI, BB, 4);
  }
}

// This function also handles Cpu0::ATOMIC_SWAP_I32 (when BinOpcode == 0), and
// Cpu0::ATOMIC_LOAD_NAND_I32 (when Nand == true)
MachineBasicBlock *Cpu0TargetLowering::emitAtomicBinary(
    MachineInstr &amp;MI, MachineBasicBlock *BB, unsigned Size, unsigned BinOpcode,
    bool Nand) const {
  assert((Size == 4) &amp;&amp; &quot;Unsupported size for EmitAtomicBinary.&quot;);

  MachineFunction *MF = BB-&gt;getParent();
  MachineRegisterInfo &amp;RegInfo = MF-&gt;getRegInfo();
  const TargetRegisterClass *RC = getRegClassFor(MVT::getIntegerVT(Size * 8));
  const TargetInstrInfo *TII = Subtarget.getInstrInfo();
  DebugLoc DL = MI.getDebugLoc();
  unsigned LL, SC, AND, XOR, ZERO, BEQ;

  LL = Cpu0::LL;
  SC = Cpu0::SC;
  AND = Cpu0::AND;
  XOR = Cpu0::XOR;
  ZERO = Cpu0::ZERO;
  BEQ = Cpu0::BEQ;

  unsigned OldVal = MI.getOperand(0).getReg();
  unsigned Ptr = MI.getOperand(1).getReg();
  unsigned Incr = MI.getOperand(2).getReg();

  unsigned StoreVal = RegInfo.createVirtualRegister(RC);
  unsigned AndRes = RegInfo.createVirtualRegister(RC);
  unsigned AndRes2 = RegInfo.createVirtualRegister(RC);
  unsigned Success = RegInfo.createVirtualRegister(RC);

  // insert new blocks after the current block
  const BasicBlock *LLVM_BB = BB-&gt;getBasicBlock();
  MachineBasicBlock *loopMBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineBasicBlock *exitMBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineFunction::iterator It = ++BB-&gt;getIterator();
  MF-&gt;insert(It, loopMBB);
  MF-&gt;insert(It, exitMBB);

  // Transfer the remainder of BB and its successor edges to exitMBB.
  exitMBB-&gt;splice(exitMBB-&gt;begin(), BB,
                  std::next(MachineBasicBlock::iterator(MI)), BB-&gt;end());
  exitMBB-&gt;transferSuccessorsAndUpdatePHIs(BB);

  //  thisMBB:
  //    ...
  //    fallthrough --&gt; loopMBB
  BB-&gt;addSuccessor(loopMBB);
  loopMBB-&gt;addSuccessor(loopMBB);
  loopMBB-&gt;addSuccessor(exitMBB);

  //  loopMBB:
  //    ll oldval, 0(ptr)
  //    &lt;binop&gt; storeval, oldval, incr
  //    sc success, storeval, 0(ptr)
  //    beq success, $0, loopMBB
  BB = loopMBB;
  BuildMI(BB, DL, TII-&gt;get(LL), OldVal).addReg(Ptr).addImm(0);
  if (Nand) {
    //  and andres, oldval, incr
    //  xor storeval, $0, andres
    //  xor storeval2, $0, storeval
    BuildMI(BB, DL, TII-&gt;get(AND), AndRes).addReg(OldVal).addReg(Incr);
    BuildMI(BB, DL, TII-&gt;get(XOR), StoreVal).addReg(ZERO).addReg(AndRes);
    BuildMI(BB, DL, TII-&gt;get(XOR), AndRes2).addReg(ZERO).addReg(AndRes);
  } else if (BinOpcode) {
    //  &lt;binop&gt; storeval, oldval, incr
    BuildMI(BB, DL, TII-&gt;get(BinOpcode), StoreVal).addReg(OldVal).addReg(Incr);
  } else {
    StoreVal = Incr;
  }
  BuildMI(BB, DL, TII-&gt;get(SC), Success).addReg(StoreVal).addReg(Ptr).addImm(0);
  BuildMI(BB, DL, TII-&gt;get(BEQ)).addReg(Success).addReg(ZERO).addMBB(loopMBB);

  MI.eraseFromParent(); // The instruction is gone now.

  return exitMBB;
}

MachineBasicBlock *Cpu0TargetLowering::emitSignExtendToI32InReg(
    MachineInstr &amp;MI, MachineBasicBlock *BB, unsigned Size, unsigned DstReg,
    unsigned SrcReg) const {
  const TargetInstrInfo *TII = Subtarget.getInstrInfo();
  DebugLoc DL = MI.getDebugLoc();

  MachineFunction *MF = BB-&gt;getParent();
  MachineRegisterInfo &amp;RegInfo = MF-&gt;getRegInfo();
  const TargetRegisterClass *RC = getRegClassFor(MVT::i32);
  unsigned ScrReg = RegInfo.createVirtualRegister(RC);

  assert(Size &lt; 32);
  int64_t ShiftImm = 32 - (Size * 8);

  BuildMI(BB, DL, TII-&gt;get(Cpu0::SHL), ScrReg).addReg(SrcReg).addImm(ShiftImm);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::SRA), DstReg).addReg(ScrReg).addImm(ShiftImm);

  return BB;
}

MachineBasicBlock *Cpu0TargetLowering::emitAtomicBinaryPartword(
    MachineInstr &amp;MI, MachineBasicBlock *BB, unsigned Size, unsigned BinOpcode,
    bool Nand) const {
  assert((Size == 1 || Size == 2) &amp;&amp;
         &quot;Unsupported size for EmitAtomicBinaryPartial.&quot;);

  MachineFunction *MF = BB-&gt;getParent();
  MachineRegisterInfo &amp;RegInfo = MF-&gt;getRegInfo();
  const TargetRegisterClass *RC = getRegClassFor(MVT::i32);
  const TargetInstrInfo *TII = Subtarget.getInstrInfo();
  DebugLoc DL = MI.getDebugLoc();

  unsigned Dest = MI.getOperand(0).getReg();
  unsigned Ptr = MI.getOperand(1).getReg();
  unsigned Incr = MI.getOperand(2).getReg();

  unsigned AlignedAddr = RegInfo.createVirtualRegister(RC);
  unsigned ShiftAmt = RegInfo.createVirtualRegister(RC);
  unsigned Mask = RegInfo.createVirtualRegister(RC);
  unsigned Mask2 = RegInfo.createVirtualRegister(RC);
  unsigned Mask3 = RegInfo.createVirtualRegister(RC);
  unsigned NewVal = RegInfo.createVirtualRegister(RC);
  unsigned OldVal = RegInfo.createVirtualRegister(RC);
  unsigned Incr2 = RegInfo.createVirtualRegister(RC);
  unsigned MaskLSB2 = RegInfo.createVirtualRegister(RC);
  unsigned PtrLSB2 = RegInfo.createVirtualRegister(RC);
  unsigned MaskUpper = RegInfo.createVirtualRegister(RC);
  unsigned AndRes = RegInfo.createVirtualRegister(RC);
  unsigned BinOpRes = RegInfo.createVirtualRegister(RC);
  unsigned BinOpRes2 = RegInfo.createVirtualRegister(RC);
  unsigned MaskedOldVal0 = RegInfo.createVirtualRegister(RC);
  unsigned StoreVal = RegInfo.createVirtualRegister(RC);
  unsigned MaskedOldVal1 = RegInfo.createVirtualRegister(RC);
  unsigned SrlRes = RegInfo.createVirtualRegister(RC);
  unsigned Success = RegInfo.createVirtualRegister(RC);

  // insert new blocks after the current block
  const BasicBlock *LLVM_BB = BB-&gt;getBasicBlock();
  MachineBasicBlock *loopMBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineBasicBlock *sinkMBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineBasicBlock *exitMBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineFunction::iterator It = ++BB-&gt;getIterator();

  MF-&gt;insert(It, loopMBB);
  MF-&gt;insert(It, sinkMBB);
  MF-&gt;insert(It, exitMBB);

  // Transfer the remainder of BB and its successor edges to exitMBB.
  exitMBB-&gt;splice(exitMBB-&gt;begin(), BB,
                  std::next(MachineBasicBlock::iterator(MI)), BB-&gt;end());
  exitMBB-&gt;transferSuccessorsAndUpdatePHIs(BB);

  BB-&gt;addSuccessor(loopMBB);
  loopMBB-&gt;addSuccessor(loopMBB);
  loopMBB-&gt;addSuccessor(sinkMBB);
  sinkMBB-&gt;addSuccessor(exitMBB);

  //  thisMBB:
  //    addiu   masklsb2,$0,-4                # 0xfffffffc
  //    and     alignedaddr,ptr,masklsb2
  //    andi    ptrlsb2,ptr,3
  //    sll     shiftamt,ptrlsb2,3
  //    ori     maskupper,$0,255               # 0xff
  //    sll     mask,maskupper,shiftamt
  //    xor     mask2,$0,mask
  //    xor     mask3,$0,mask2
  //    sll     incr2,incr,shiftamt

  int64_t MaskImm = (Size == 1) ? 255 : 65535;
  BuildMI(BB, DL, TII-&gt;get(Cpu0::ADDiu), MaskLSB2)
    .addReg(Cpu0::ZERO).addImm(-4);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::AND), AlignedAddr)
    .addReg(Ptr).addReg(MaskLSB2);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::ANDi), PtrLSB2).addReg(Ptr).addImm(3);
  if (Subtarget.isLittle()) {
    BuildMI(BB, DL, TII-&gt;get(Cpu0::SHL), ShiftAmt).addReg(PtrLSB2).addImm(3);
  } else {
    unsigned Off = RegInfo.createVirtualRegister(RC);
    BuildMI(BB, DL, TII-&gt;get(Cpu0::XORi), Off)
      .addReg(PtrLSB2).addImm((Size == 1) ? 3 : 2);
    BuildMI(BB, DL, TII-&gt;get(Cpu0::SHL), ShiftAmt).addReg(Off).addImm(3);
  }
  BuildMI(BB, DL, TII-&gt;get(Cpu0::ORi), MaskUpper)
    .addReg(Cpu0::ZERO).addImm(MaskImm);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::SHLV), Mask)
    .addReg(MaskUpper).addReg(ShiftAmt);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::XOR), Mask2).addReg(Cpu0::ZERO).addReg(Mask);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::XOR), Mask3).addReg(Cpu0::ZERO).addReg(Mask2);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::SHLV), Incr2).addReg(Incr).addReg(ShiftAmt);

  // atomic.load.binop
  // loopMBB:
  //   ll      oldval,0(alignedaddr)
  //   binop   binopres,oldval,incr2
  //   and     newval,binopres,mask
  //   and     maskedoldval0,oldval,mask3
  //   or      storeval,maskedoldval0,newval
  //   sc      success,storeval,0(alignedaddr)
  //   beq     success,$0,loopMBB

  // atomic.swap
  // loopMBB:
  //   ll      oldval,0(alignedaddr)
  //   and     newval,incr2,mask
  //   and     maskedoldval0,oldval,mask3
  //   or      storeval,maskedoldval0,newval
  //   sc      success,storeval,0(alignedaddr)
  //   beq     success,$0,loopMBB

  BB = loopMBB;
  unsigned LL = Cpu0::LL;
  BuildMI(BB, DL, TII-&gt;get(LL), OldVal).addReg(AlignedAddr).addImm(0);
  if (Nand) {
    //  and andres, oldval, incr2
    //  xor binopres,  $0, andres
    //  xor binopres2, $0, binopres
    //  and newval, binopres, mask
    BuildMI(BB, DL, TII-&gt;get(Cpu0::AND), AndRes).addReg(OldVal).addReg(Incr2);
    BuildMI(BB, DL, TII-&gt;get(Cpu0::XOR), BinOpRes)
      .addReg(Cpu0::ZERO).addReg(AndRes);
    BuildMI(BB, DL, TII-&gt;get(Cpu0::XOR), BinOpRes2)
      .addReg(Cpu0::ZERO).addReg(BinOpRes);
    BuildMI(BB, DL, TII-&gt;get(Cpu0::AND), NewVal).addReg(BinOpRes).addReg(Mask);
  } else if (BinOpcode) {
    //  &lt;binop&gt; binopres, oldval, incr2
    //  and newval, binopres, mask
    BuildMI(BB, DL, TII-&gt;get(BinOpcode), BinOpRes).addReg(OldVal).addReg(Incr2);
    BuildMI(BB, DL, TII-&gt;get(Cpu0::AND), NewVal).addReg(BinOpRes).addReg(Mask);
  } else { // atomic.swap
    //  and newval, incr2, mask
    BuildMI(BB, DL, TII-&gt;get(Cpu0::AND), NewVal).addReg(Incr2).addReg(Mask);
  }

  BuildMI(BB, DL, TII-&gt;get(Cpu0::AND), MaskedOldVal0)
    .addReg(OldVal).addReg(Mask2);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::OR), StoreVal)
    .addReg(MaskedOldVal0).addReg(NewVal);
  unsigned SC = Cpu0::SC;
  BuildMI(BB, DL, TII-&gt;get(SC), Success)
    .addReg(StoreVal).addReg(AlignedAddr).addImm(0);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::BEQ))
    .addReg(Success).addReg(Cpu0::ZERO).addMBB(loopMBB);

  //  sinkMBB:
  //    and     maskedoldval1,oldval,mask
  //    srl     srlres,maskedoldval1,shiftamt
  //    sign_extend dest,srlres
  BB = sinkMBB;

  BuildMI(BB, DL, TII-&gt;get(Cpu0::AND), MaskedOldVal1)
    .addReg(OldVal).addReg(Mask);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::SHRV), SrlRes)
      .addReg(MaskedOldVal1).addReg(ShiftAmt);
  BB = emitSignExtendToI32InReg(MI, BB, Size, Dest, SrlRes);

  MI.eraseFromParent(); // The instruction is gone now.

  return exitMBB;
}

MachineBasicBlock * Cpu0TargetLowering::emitAtomicCmpSwap(MachineInstr &amp;MI,
                                                          MachineBasicBlock *BB,
                                                          unsigned Size) const {
  assert((Size == 4) &amp;&amp; &quot;Unsupported size for EmitAtomicCmpSwap.&quot;);

  MachineFunction *MF = BB-&gt;getParent();
  MachineRegisterInfo &amp;RegInfo = MF-&gt;getRegInfo();
  const TargetRegisterClass *RC = getRegClassFor(MVT::getIntegerVT(Size * 8));
  const TargetInstrInfo *TII = Subtarget.getInstrInfo();
  DebugLoc DL = MI.getDebugLoc();
  unsigned LL, SC, ZERO, BNE, BEQ;

  LL = Cpu0::LL;
  SC = Cpu0::SC;
  ZERO = Cpu0::ZERO;
  BNE = Cpu0::BNE;
  BEQ = Cpu0::BEQ;

  unsigned Dest    = MI.getOperand(0).getReg();
  unsigned Ptr     = MI.getOperand(1).getReg();
  unsigned OldVal  = MI.getOperand(2).getReg();
  unsigned NewVal  = MI.getOperand(3).getReg();

  unsigned Success = RegInfo.createVirtualRegister(RC);

  // insert new blocks after the current block
  const BasicBlock *LLVM_BB = BB-&gt;getBasicBlock();
  MachineBasicBlock *loop1MBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineBasicBlock *loop2MBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineBasicBlock *exitMBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineFunction::iterator It = ++BB-&gt;getIterator();

  MF-&gt;insert(It, loop1MBB);
  MF-&gt;insert(It, loop2MBB);
  MF-&gt;insert(It, exitMBB);

  // Transfer the remainder of BB and its successor edges to exitMBB.
  exitMBB-&gt;splice(exitMBB-&gt;begin(), BB,
                  std::next(MachineBasicBlock::iterator(MI)), BB-&gt;end());
  exitMBB-&gt;transferSuccessorsAndUpdatePHIs(BB);

  //  thisMBB:
  //    ...
  //    fallthrough --&gt; loop1MBB
  BB-&gt;addSuccessor(loop1MBB);
  loop1MBB-&gt;addSuccessor(exitMBB);
  loop1MBB-&gt;addSuccessor(loop2MBB);
  loop2MBB-&gt;addSuccessor(loop1MBB);
  loop2MBB-&gt;addSuccessor(exitMBB);

  // loop1MBB:
  //   ll dest, 0(ptr)
  //   bne dest, oldval, exitMBB
  BB = loop1MBB;
  BuildMI(BB, DL, TII-&gt;get(LL), Dest).addReg(Ptr).addImm(0);
  BuildMI(BB, DL, TII-&gt;get(BNE))
    .addReg(Dest).addReg(OldVal).addMBB(exitMBB);

  // loop2MBB:
  //   sc success, newval, 0(ptr)
  //   beq success, $0, loop1MBB
  BB = loop2MBB;
  BuildMI(BB, DL, TII-&gt;get(SC), Success)
    .addReg(NewVal).addReg(Ptr).addImm(0);
  BuildMI(BB, DL, TII-&gt;get(BEQ))
    .addReg(Success).addReg(ZERO).addMBB(loop1MBB);

  MI.eraseFromParent(); // The instruction is gone now.

  return exitMBB;
}

MachineBasicBlock *
Cpu0TargetLowering::emitAtomicCmpSwapPartword(MachineInstr &amp;MI,
                                              MachineBasicBlock *BB,
                                              unsigned Size) const {
  assert((Size == 1 || Size == 2) &amp;&amp;
      &quot;Unsupported size for EmitAtomicCmpSwapPartial.&quot;);

  MachineFunction *MF = BB-&gt;getParent();
  MachineRegisterInfo &amp;RegInfo = MF-&gt;getRegInfo();
  const TargetRegisterClass *RC = getRegClassFor(MVT::i32);
  const TargetInstrInfo *TII = Subtarget.getInstrInfo();
  DebugLoc DL = MI.getDebugLoc();

  unsigned Dest    = MI.getOperand(0).getReg();
  unsigned Ptr     = MI.getOperand(1).getReg();
  unsigned CmpVal  = MI.getOperand(2).getReg();
  unsigned NewVal  = MI.getOperand(3).getReg();

  unsigned AlignedAddr = RegInfo.createVirtualRegister(RC);
  unsigned ShiftAmt = RegInfo.createVirtualRegister(RC);
  unsigned Mask = RegInfo.createVirtualRegister(RC);
  unsigned Mask2 = RegInfo.createVirtualRegister(RC);
  unsigned Mask3 = RegInfo.createVirtualRegister(RC);
  unsigned ShiftedCmpVal = RegInfo.createVirtualRegister(RC);
  unsigned OldVal = RegInfo.createVirtualRegister(RC);
  unsigned MaskedOldVal0 = RegInfo.createVirtualRegister(RC);
  unsigned ShiftedNewVal = RegInfo.createVirtualRegister(RC);
  unsigned MaskLSB2 = RegInfo.createVirtualRegister(RC);
  unsigned PtrLSB2 = RegInfo.createVirtualRegister(RC);
  unsigned MaskUpper = RegInfo.createVirtualRegister(RC);
  unsigned MaskedCmpVal = RegInfo.createVirtualRegister(RC);
  unsigned MaskedNewVal = RegInfo.createVirtualRegister(RC);
  unsigned MaskedOldVal1 = RegInfo.createVirtualRegister(RC);
  unsigned StoreVal = RegInfo.createVirtualRegister(RC);
  unsigned SrlRes = RegInfo.createVirtualRegister(RC);
  unsigned Success = RegInfo.createVirtualRegister(RC);

  // insert new blocks after the current block
  const BasicBlock *LLVM_BB = BB-&gt;getBasicBlock();
  MachineBasicBlock *loop1MBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineBasicBlock *loop2MBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineBasicBlock *sinkMBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineBasicBlock *exitMBB = MF-&gt;CreateMachineBasicBlock(LLVM_BB);
  MachineFunction::iterator It = ++BB-&gt;getIterator();

  MF-&gt;insert(It, loop1MBB);
  MF-&gt;insert(It, loop2MBB);
  MF-&gt;insert(It, sinkMBB);
  MF-&gt;insert(It, exitMBB);

  // Transfer the remainder of BB and its successor edges to exitMBB.
  exitMBB-&gt;splice(exitMBB-&gt;begin(), BB,
                  std::next(MachineBasicBlock::iterator(MI)), BB-&gt;end());
  exitMBB-&gt;transferSuccessorsAndUpdatePHIs(BB);

  BB-&gt;addSuccessor(loop1MBB);
  loop1MBB-&gt;addSuccessor(sinkMBB);
  loop1MBB-&gt;addSuccessor(loop2MBB);
  loop2MBB-&gt;addSuccessor(loop1MBB);
  loop2MBB-&gt;addSuccessor(sinkMBB);
  sinkMBB-&gt;addSuccessor(exitMBB);

  // FIXME: computation of newval2 can be moved to loop2MBB.
  //  thisMBB:
  //    addiu   masklsb2,$0,-4                # 0xfffffffc
  //    and     alignedaddr,ptr,masklsb2
  //    andi    ptrlsb2,ptr,3
  //    shl     shiftamt,ptrlsb2,3
  //    ori     maskupper,$0,255               # 0xff
  //    shl     mask,maskupper,shiftamt
  //    xor     mask2,$0,mask
  //    xor     mask3,$0,mask2
  //    andi    maskedcmpval,cmpval,255
  //    shl     shiftedcmpval,maskedcmpval,shiftamt
  //    andi    maskednewval,newval,255
  //    shl     shiftednewval,maskednewval,shiftamt
  int64_t MaskImm = (Size == 1) ? 255 : 65535;
  BuildMI(BB, DL, TII-&gt;get(Cpu0::ADDiu), MaskLSB2)
    .addReg(Cpu0::ZERO).addImm(-4);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::AND), AlignedAddr)
    .addReg(Ptr).addReg(MaskLSB2);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::ANDi), PtrLSB2).addReg(Ptr).addImm(3);
  if (Subtarget.isLittle()) {
    BuildMI(BB, DL, TII-&gt;get(Cpu0::SHL), ShiftAmt).addReg(PtrLSB2).addImm(3);
  } else {
    unsigned Off = RegInfo.createVirtualRegister(RC);
    BuildMI(BB, DL, TII-&gt;get(Cpu0::XORi), Off)
      .addReg(PtrLSB2).addImm((Size == 1) ? 3 : 2);
    BuildMI(BB, DL, TII-&gt;get(Cpu0::SHL), ShiftAmt).addReg(Off).addImm(3);
  }
  BuildMI(BB, DL, TII-&gt;get(Cpu0::ORi), MaskUpper)
    .addReg(Cpu0::ZERO).addImm(MaskImm);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::SHLV), Mask)
    .addReg(MaskUpper).addReg(ShiftAmt);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::XOR), Mask2).addReg(Cpu0::ZERO).addReg(Mask);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::XOR), Mask3).addReg(Cpu0::ZERO).addReg(Mask2);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::ANDi), MaskedCmpVal)
    .addReg(CmpVal).addImm(MaskImm);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::SHLV), ShiftedCmpVal)
    .addReg(MaskedCmpVal).addReg(ShiftAmt);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::ANDi), MaskedNewVal)
    .addReg(NewVal).addImm(MaskImm);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::SHLV), ShiftedNewVal)
    .addReg(MaskedNewVal).addReg(ShiftAmt);

  //  loop1MBB:
  //    ll      oldval,0(alginedaddr)
  //    and     maskedoldval0,oldval,mask
  //    bne     maskedoldval0,shiftedcmpval,sinkMBB
  BB = loop1MBB;
  unsigned LL = Cpu0::LL;
  BuildMI(BB, DL, TII-&gt;get(LL), OldVal).addReg(AlignedAddr).addImm(0);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::AND), MaskedOldVal0)
    .addReg(OldVal).addReg(Mask);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::BNE))
    .addReg(MaskedOldVal0).addReg(ShiftedCmpVal).addMBB(sinkMBB);

  //  loop2MBB:
  //    and     maskedoldval1,oldval,mask3
  //    or      storeval,maskedoldval1,shiftednewval
  //    sc      success,storeval,0(alignedaddr)
  //    beq     success,$0,loop1MBB
  BB = loop2MBB;
  BuildMI(BB, DL, TII-&gt;get(Cpu0::AND), MaskedOldVal1)
    .addReg(OldVal).addReg(Mask3);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::OR), StoreVal)
    .addReg(MaskedOldVal1).addReg(ShiftedNewVal);
  unsigned SC = Cpu0::SC;
  BuildMI(BB, DL, TII-&gt;get(SC), Success)
      .addReg(StoreVal).addReg(AlignedAddr).addImm(0);
  BuildMI(BB, DL, TII-&gt;get(Cpu0::BEQ))
      .addReg(Success).addReg(Cpu0::ZERO).addMBB(loop1MBB);

  //  sinkMBB:
  //    srl     srlres,maskedoldval0,shiftamt
  //    sign_extend dest,srlres
  BB = sinkMBB;

  BuildMI(BB, DL, TII-&gt;get(Cpu0::SHRV), SrlRes)
      .addReg(MaskedOldVal0).addReg(ShiftAmt);
  BB = emitSignExtendToI32InReg(MI, BB, Size, Dest, SrlRes);

  MI.eraseFromParent();   // The instruction is gone now.

  return exitMBB;
}
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="p">::</span><span class="n">lowerATOMIC_FENCE</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span>
                                              <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="o">//</span> <span class="n">FIXME</span><span class="p">:</span> <span class="n">Need</span> <span class="n">pseudo</span><span class="o">-</span><span class="n">fence</span> <span class="k">for</span> <span class="s1">&#39;singlethread&#39;</span> <span class="n">fences</span>
  <span class="o">//</span> <span class="n">FIXME</span><span class="p">:</span> <span class="n">Set</span> <span class="n">SType</span> <span class="k">for</span> <span class="n">weaker</span> <span class="n">fences</span> <span class="n">where</span> <span class="n">supported</span><span class="o">/</span><span class="n">appropriate</span><span class="o">.</span>
  <span class="n">unsigned</span> <span class="n">SType</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">(</span><span class="n">Op</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">DAG</span><span class="o">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">Cpu0ISD</span><span class="p">::</span><span class="n">Sync</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">MVT</span><span class="p">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Op</span><span class="o">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                     <span class="n">DAG</span><span class="o">.</span><span class="n">getConstant</span><span class="p">(</span><span class="n">SType</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">MVT</span><span class="p">::</span><span class="n">i32</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0RegisterInfo.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="o">///</span> <span class="n">Code</span> <span class="n">Generation</span> <span class="n">virtual</span> <span class="n">methods</span><span class="o">...</span>
  <span class="n">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span><span class="n">getPointerRegClass</span><span class="p">(</span><span class="n">const</span> <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                                <span class="n">unsigned</span> <span class="n">Kind</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0RegisterInfo.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span>
<span class="n">Cpu0RegisterInfo</span><span class="p">::</span><span class="n">getPointerRegClass</span><span class="p">(</span><span class="n">const</span> <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                     <span class="n">unsigned</span> <span class="n">Kind</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="n">Cpu0</span><span class="p">::</span><span class="n">CPURegsRegClass</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0SEISelLowering.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Cpu0SETargetLowering</span><span class="p">::</span><span class="n">Cpu0SETargetLowering</span><span class="p">(</span><span class="n">const</span> <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">,</span>
                                           <span class="n">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span>
    <span class="p">:</span> <span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="n">TM</span><span class="p">,</span> <span class="n">STI</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="p">::</span><span class="n">ATOMIC_FENCE</span><span class="p">,</span>       <span class="n">MVT</span><span class="p">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Custom</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0TargetMachine.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">///</span> <span class="n">Cpu0</span> <span class="n">Code</span> <span class="n">Generator</span> <span class="n">Pass</span> <span class="n">Configuration</span> <span class="n">Options</span><span class="o">.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Cpu0PassConfig</span> <span class="p">:</span> <span class="n">public</span> <span class="n">TargetPassConfig</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">void</span> <span class="n">addIRPasses</span><span class="p">()</span> <span class="n">override</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">Cpu0PassConfig</span><span class="p">::</span><span class="n">addIRPasses</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">TargetPassConfig</span><span class="p">::</span><span class="n">addIRPasses</span><span class="p">();</span>
  <span class="n">addPass</span><span class="p">(</span><span class="n">createAtomicExpandPass</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Since the <cite>SC</cite> instruction uses <cite>RegisterOperand</cite> type in <cite>Cpu0InstrInfo.td</cite> and
<cite>SC</cite> uses the <cite>FMem</cite> node whose <cite>DecoderMethod</cite> is <cite>DecodeMem</cite>, the
<cite>DecodeMem()</cite> function in <cite>Cpu0Disassembler.cpp</cite> needs to be modified
accordingly.</p>
<p>The atomic node defined in <cite>let usesCustomInserter = 1 in</cite> within
<cite>Cpu0InstrInfo.td</cite> tells LLVM to call <cite>EmitInstrWithCustomInserter()</cite> in
<cite>Cpu0ISelLowering.cpp</cite> after the Instruction Selection stage, specifically in
the <cite>Cpu0TargetLowering::EmitInstrWithCustomInserter()</cite> function invoked during
the <cite>ExpandISelPseudos::runOnMachineFunction()</cite> phase.</p>
<p>For example, the declaration
<cite>def ATOMIC_LOAD_ADD_I8 : Atomic2Ops&lt;atomic_load_add_8, CPURegs&gt;;</cite>
will trigger a call to <cite>EmitInstrWithCustomInserter()</cite> with the machine
instruction opcode <cite>ATOMIC_LOAD_ADD_I8</cite> when the IR <cite>load atomic i8*</cite> is
encountered.</p>
<p>The call to <cite>setInsertFencesForAtomic(true);</cite> in <cite>Cpu0ISelLowering.cpp</cite> will
trigger the <cite>addIRPasses()</cite> function in <cite>Cpu0TargetMachine.cpp</cite>, which in turn
invokes <cite>createAtomicExpandPass()</cite> to create the LLVM IR <cite>ATOMIC_FENCE</cite>.</p>
<p>Later, <cite>lowerATOMIC_FENCE()</cite> in <cite>Cpu0ISelLowering.cpp</cite> will emit a
<cite>Cpu0ISD::Sync</cite> when it sees an <cite>ATOMIC_FENCE</cite> IR, because of the statement
<cite>setOperationAction(ISD::ATOMIC_FENCE, MVT::Other, Custom);</cite> in
<cite>Cpu0SEISelLowering.cpp</cite>.</p>
<p>Finally, the pattern defined in <cite>Cpu0InstrInfo.td</cite> will translate the DAG node
into the actual <cite>sync</cite> instruction via <cite>def SYNC</cite> and its alias <cite>SYNC 0</cite>.</p>
<p>This part of the Cpu0 backend code is similar to Mips, except that Cpu0 does
not include the <cite>nor</cite> instruction.</p>
<p>Below is a table listing the atomic IRs, their corresponding DAG nodes, and
machine opcodes.</p>
<table class="docutils align-default" id="id23">
<caption><span class="caption-number">Table 45 </span><span class="caption-text">The atomic related IRs, their corresponding DAGs and Opcode of Cpu0ISelLowering.cpp</span><a class="headerlink" href="#id23" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>IR</p></th>
<th class="head"><p>DAG</p></th>
<th class="head"><p>Opcode</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>load atomic</p></td>
<td><p>AtomicLoad</p></td>
<td><p>ATOMIC_CMP_SWAP_XXX</p></td>
</tr>
<tr class="row-odd"><td><p>store atomic</p></td>
<td><p>AtomicStore</p></td>
<td><p>ATOMIC_SWAP_XXX</p></td>
</tr>
<tr class="row-even"><td><p>atomicrmw add</p></td>
<td><p>AtomicLoadAdd</p></td>
<td><p>ATOMIC_LOAD_ADD_XXX</p></td>
</tr>
<tr class="row-odd"><td><p>atomicrmw sub</p></td>
<td><p>AtomicLoadSub</p></td>
<td><p>ATOMIC_LOAD_SUB_XXX</p></td>
</tr>
<tr class="row-even"><td><p>atomicrmw xor</p></td>
<td><p>AtomicLoadXor</p></td>
<td><p>ATOMIC_LOAD_XOR_XXX</p></td>
</tr>
<tr class="row-odd"><td><p>atomicrmw and</p></td>
<td><p>AtomicLoadAnd</p></td>
<td><p>ATOMIC_LOAD_AND_XXX</p></td>
</tr>
<tr class="row-even"><td><p>atomicrmw nand</p></td>
<td><p>AtomicLoadNand</p></td>
<td><p>ATOMIC_LOAD_NAND_XXX</p></td>
</tr>
<tr class="row-odd"><td><p>atomicrmw or</p></td>
<td><p>AtomicLoadOr</p></td>
<td><p>ATOMIC_LOAD_OR_XXX</p></td>
</tr>
<tr class="row-even"><td><p>cmpxchg</p></td>
<td><p>AtomicCmpSwapWithSuccess</p></td>
<td><p>ATOMIC_CMP_SWAP_XXX</p></td>
</tr>
<tr class="row-odd"><td><p>atomicrmw xchg</p></td>
<td><p>AtomicLoadSwap</p></td>
<td><p>ATOMIC_SWAP_XXX</p></td>
</tr>
</tbody>
</table>
<p>The input files <cite>atomics.ll</cite> and <cite>atomics-fences.ll</cite> include tests for LLVM
atomic IRs.</p>
<p>The C++ source files <cite>ch12_atomics.cpp</cite> and <cite>ch12_atomics-fences.cpp</cite> are used
to generate the corresponding LLVM atomic IRs. To compile these files, use the
following <cite>clang++</cite> options:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">clang</span><span class="o">++</span> <span class="o">-</span><span class="n">pthread</span> <span class="o">-</span><span class="n">std</span><span class="o">=</span><span class="n">c</span><span class="o">++</span><span class="mi">11</span>
</pre></div>
</div>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="exception" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">1</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://llvm.org/docs/ExceptionHandling.html">http://llvm.org/docs/ExceptionHandling.html</a></p>
</aside>
<aside class="footnote brackets" id="itanium-exception" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">2</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://itanium-cxx-abi.github.io/cxx-abi/exceptions.pdf">http://itanium-cxx-abi.github.io/cxx-abi/exceptions.pdf</a></p>
</aside>
<aside class="footnote brackets" id="thread-wiki" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">3</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://en.wikipedia.org/wiki/Thread-local_storage">http://en.wikipedia.org/wiki/Thread-local_storage</a></p>
</aside>
<aside class="footnote brackets" id="cpp-mem-order" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">4</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.cppreference.com/w/cpp/atomic/memory_order">https://en.cppreference.com/w/cpp/atomic/memory_order</a></p>
</aside>
<aside class="footnote brackets" id="mem-order-wiki" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">5</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Memory_model_%28programming%29">https://en.wikipedia.org/wiki/Memory_model_%28programming%29</a></p>
</aside>
<aside class="footnote brackets" id="atomic-stackoverflow" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">6</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://stackoverflow.com/questions/6319146/c11-introduced-a-standardized-memory-model-what-does-it-mean-and-how-is-it-g">http://stackoverflow.com/questions/6319146/c11-introduced-a-standardized-memory-model-what-does-it-mean-and-how-is-it-g</a></p>
</aside>
<aside class="footnote brackets" id="cas-wiki" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">7</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Compare-and-swap">https://en.wikipedia.org/wiki/Compare-and-swap</a></p>
</aside>
<aside class="footnote brackets" id="lf-wiki" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id8">8</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Non-blocking_algorithm">https://en.wikipedia.org/wiki/Non-blocking_algorithm</a></p>
</aside>
<aside class="footnote brackets" id="atomics-llvm" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id9">9</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://llvm.org/docs/Atomics.html">http://llvm.org/docs/Atomics.html</a></p>
</aside>
<aside class="footnote brackets" id="llvmlang-ordering" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id10">10</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://llvm.org/docs/LangRef.html#ordering">http://llvm.org/docs/LangRef.html#ordering</a></p>
</aside>
<aside class="footnote brackets" id="dpcpp-memorder" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>11<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id11">1</a>,<a role="doc-backlink" href="#id12">2</a>)</span>
<p>Section “The memory_order Enumeration Class” which include figure 19-10 of book <a class="reference external" href="https://link.springer.com/book/10.1007/978-1-4842-5574-2">https://link.springer.com/book/10.1007/978-1-4842-5574-2</a></p>
</aside>
<aside class="footnote brackets" id="cpp-memorder-consume-as-acquire" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id13">12</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://stackoverflow.com/questions/65336409/what-does-memory-order-consume-really-do">https://stackoverflow.com/questions/65336409/what-does-memory-order-consume-really-do</a></p>
</aside>
<aside class="footnote brackets" id="cpp-memorder-consume-remove" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id14">13</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0371r1.html">https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0371r1.html</a></p>
</aside>
</aside>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="Bottom">
      
        <p>
        «&#160;&#160;<a href="asm.html">Assembler</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="verilog.html">Verify backend on Verilog simulator</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
    &#169; Copyright 2016, Chen Chung-Shu.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 9.1.0.
    </div>
  </body>
</html>